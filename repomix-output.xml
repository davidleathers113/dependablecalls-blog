This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.github/
  workflows/
    ci.yml
    CLAUDE.md
    database-backup.yml
    deploy-production.yml
    deploy-staging.yml
    emergency-rollback.yml
    pr-validation.yml
    security-scan.yml
    uptime-monitoring.yml
  CLAUDE.md
  README.md
.husky/
  pre-commit
docs/
  DEVOPS.md
  ERROR_BOUNDARIES_USAGE.md
  FEATURE_ERROR_BOUNDARIES_SUMMARY.md
netlify/
  functions/
    auth-login.ts
    auth-logout.ts
    auth-refresh.ts
    auth-reset-password.ts
    auth-signup.ts
    auth-verify-email.ts
    campaigns-create.ts
    campaigns-get.ts
    campaigns-list.ts
    campaigns-update.ts
    realtime-calls.ts
    realtime-campaigns.ts
    realtime-stats.ts
    webhook-call-events.ts
performance/
  load-test.yml
  stress-test.yml
public/
  vite.svg
scripts/
  backup/
    supabase-backup.sh
    supabase-restore.sh
  rollback.sh
src/
  assets/
    CLAUDE.md
    react.svg
  components/
    __tests__/
      FeatureErrorBoundaries.test.tsx
    auth/
      CLAUDE.md
      Login.tsx
      LoginForm.tsx
      ProtectedRoute.tsx
      withProtectedRoute.tsx
    campaigns/
      CLAUDE.md
    common/
      Badge.tsx
      Button.tsx
      Card.tsx
      CLAUDE.md
      ErrorBoundary.tsx
      ErrorBoundaryExample.tsx
      FallbackUI.examples.tsx
      FallbackUI.tsx
      index.ts
      Input.tsx
      Loading.tsx
      withErrorBoundary.tsx
    dashboard/
      admin/
        AdminDashboard.tsx
      buyer/
        BuyerDashboard.tsx
      supplier/
        ActiveCampaignsTable.tsx
        CallVolumeChart.tsx
        index.ts
        QuickStatsBar.tsx
        RecentCallsList.tsx
        SupplierDashboard.tsx
      CLAUDE.md
      RealTimeDashboard.tsx
    demo/
      ErrorBoundaryDemo.tsx
    dev/
      LogViewer.tsx
    forms/
      FormErrorBoundary.tsx
      withFormErrorBoundary.tsx
    layout/
      AppLayout.tsx
      CLAUDE.md
      PublicLayout.tsx
    monitoring/
      StatusPage.tsx
    payments/
      index.ts
      PaymentDashboard.tsx
      PaymentErrorBoundary.tsx
      PaymentForm.tsx
      PaymentModal.tsx
      PayoutDashboard.tsx
      QuickTopUpForm.tsx
      StripeConnectOnboarding.tsx
      WebhookHandler.tsx
      withPaymentErrorBoundary.tsx
    realtime/
      RealtimeErrorBoundary.tsx
      withRealtimeErrorBoundary.tsx
    reports/
      CLAUDE.md
    ui/
      AppErrorFallback.tsx
      ErrorFallback.tsx
      QueryErrorFallback.tsx
    CLAUDE.md
  data/
    blogPosts.ts
  hooks/
    CLAUDE.md
    index.ts
    useAuth.ts
    useDebounce.ts
    useFormSubmission.ts
    useLoadingState.ts
    useLocalStorage.ts
    useRealTimeCallUpdates.ts
    useRealTimeStats.ts
    useRealtimeSubscription.ts
    useStripe.ts
    useSupabase.ts
  integrations/
    fraud/
      blocking.ts
      CLAUDE.md
      config.ts
      fraudlabs.ts
      index.ts
      ipquality.ts
      maxmind.ts
      scoring.ts
      sift.ts
      truecaller.ts
      types.ts
    stripe/
      billing.ts
      CLAUDE.md
      client.ts
      connected-accounts.ts
      customers.ts
      index.ts
      payments.ts
      payouts.ts
      README.md
      subscriptions.ts
      types.ts
      webhooks.ts
    CLAUDE.md
  lib/
    apm.ts
    auth-middleware.ts
    CLAUDE.md
    database.ts
    error-utils.ts
    health-check.ts
    logger.ts
    monitoring.ts
    queryClient.ts
    scroll.ts
    supabase.ts
  pages/
    auth/
      CLAUDE.md
      ForgotPasswordPage.tsx
      LoginPage.tsx
      RegisterPage.tsx
      ResetPasswordPage.tsx
    billing/
      BillingPage.tsx
      CLAUDE.md
    calls/
      CallsPage.tsx
      CLAUDE.md
    campaigns/
      CampaignsPage.tsx
      CLAUDE.md
      CreateCampaignPage.tsx
      EditCampaignPage.tsx
    dashboard/
      CLAUDE.md
      DashboardPage.tsx
    legal/
      CompliancePage.tsx
      PrivacyPage.tsx
      TermsPage.tsx
    public/
      AboutPage.tsx
      BlogPage.tsx
      BlogPostPage.tsx
      CareersPage.tsx
      CLAUDE.md
      ContactPage.tsx
      HomePage.tsx
    reports/
      CLAUDE.md
      ReportsPage.tsx
    settings/
      CLAUDE.md
      SettingsPage.tsx
    CLAUDE.md
    ErrorDemo.tsx
  services/
    CLAUDE.md
  store/
    authStore.ts
    buyerStore.ts
    CLAUDE.md
  test/
    providers.tsx
    setup.ts
    test-utils.tsx
  types/
    auth.ts
    CLAUDE.md
    database.ts
  utils/
    CLAUDE.md
    environment.ts
    format.ts
    navigation.ts
  App.tsx
  CLAUDE.md
  index.css
  main.tsx
  vite-env.d.ts
supabase/
  functions/
    create-payment-intent/
      index.ts
    process-payouts/
      index.ts
    setup-connected-account/
      index.ts
    stripe-webhook/
      index.ts
  migrations/
    001_initial_schema.sql
    002_security_policies.sql
    003_functions.sql
    004_triggers.sql
    005_indexes.sql
    CLAUDE.md
  .gitignore
  CLAUDE.md
  config.toml
  README.md
  seed.sql
tests/
  e2e/
    auth/
      example.spec.ts
    CLAUDE.md
  fixtures/
    calls.ts
    campaigns.ts
    CLAUDE.md
    index.ts
    users.ts
  integration/
    CLAUDE.md
  performance/
    CLAUDE.md
  unit/
    components/
      payments/
        PaymentModal.test.tsx
        QuickTopUpForm.test.tsx
      ErrorBoundary.test.tsx
      example.test.tsx
      FallbackUI.test.tsx
    integrations/
      stripe/
        billing.test.ts
        client.test.ts
        customers.test.ts
        payments.test.ts
        webhooks.test.ts
      stripe-client.test.ts
      stripe-integration.test.ts
    pages/
      auth/
        ForgotPasswordPage.test.tsx
        LoginPage.test.tsx
        RegisterPage.test.tsx
    store/
      buyerStore.test.ts
    CLAUDE.md
  CLAUDE.md
.dockerignore
.env.example
.gitignore
.mcp.json
.nvmrc
.prettierignore
.prettierrc.json
app.css
BACKEND_SETUP.md
CLAUDE.md
docker-compose.yml
Dockerfile
Dockerfile.dev
eslint.config.js
index.html
lighthouserc.json
netlify.toml
package.json
playwright.config.ts
postcss.config.js
README.md
tsconfig.app.json
tsconfig.json
tsconfig.node.json
ui-testing-baseline-report.md
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/types/auth.ts">
import type { User as SupabaseUser } from '@supabase/supabase-js'
import type { Database } from './database'

// Base User type from Supabase
export type BaseUser = SupabaseUser

// Extended User type with additional properties from our database
export interface User extends BaseUser {
  // Properties from suppliers table (if user is a supplier)
  stripe_account_id?: string | null
  stripe_onboarding_completed?: boolean
  stripe_charges_enabled?: boolean
  stripe_payouts_enabled?: boolean
  company_name?: string
  
  // Properties from buyers table (if user is a buyer)
  stripe_customer_id?: string | null
  stripe_payment_method_id?: string | null
  current_balance?: number
  credit_limit?: number
  auto_recharge_enabled?: boolean
  auto_recharge_threshold?: number
  auto_recharge_amount?: number
  
  // User type for role-based access
  userType?: 'supplier' | 'buyer' | 'admin' | null
}

// Database types for convenience
export type DbUser = Database['public']['Tables']['users']['Row']
export type DbSupplier = Database['public']['Tables']['suppliers']['Row']
export type DbBuyer = Database['public']['Tables']['buyers']['Row']
export type DbAdmin = Database['public']['Tables']['admins']['Row']

// Helper function to create extended user from Supabase user and database records
export function createExtendedUser(
  baseUser: SupabaseUser,
  supplier?: DbSupplier | null,
  buyer?: DbBuyer | null,
  admin?: DbAdmin | null
): User {
  const user: User = {
    ...baseUser,
    userType: admin ? 'admin' : buyer ? 'buyer' : supplier ? 'supplier' : null,
  }

  // Add supplier-specific properties
  if (supplier) {
    user.stripe_account_id = supplier.stripe_account_id
    user.stripe_onboarding_completed = supplier.stripe_onboarding_completed
    user.stripe_charges_enabled = supplier.stripe_charges_enabled
    user.stripe_payouts_enabled = supplier.stripe_payouts_enabled
    user.company_name = supplier.company_name
  }

  // Add buyer-specific properties
  if (buyer) {
    user.stripe_customer_id = buyer.stripe_customer_id
    user.stripe_payment_method_id = buyer.stripe_payment_method_id
    user.current_balance = buyer.current_balance
    user.credit_limit = buyer.credit_limit
    user.auto_recharge_enabled = buyer.auto_recharge_enabled
    user.auto_recharge_threshold = buyer.auto_recharge_threshold
    user.auto_recharge_amount = buyer.auto_recharge_amount
    user.company_name = buyer.company_name
  }

  return user
}

// Type guards
export function isSupplier(user: User): boolean {
  return user.userType === 'supplier'
}

export function isBuyer(user: User): boolean {
  return user.userType === 'buyer'
}

export function isAdmin(user: User): boolean {
  return user.userType === 'admin'
}

export type UserRole = 'supplier' | 'buyer' | 'admin'
</file>

<file path=".github/workflows/ci.yml">
name: DCE Platform CI/CD

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

env:
  NODE_VERSION: '22.15.0'

jobs:
  test:
    runs-on: ubuntu-latest
    name: ðŸ§ª Test

    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ðŸš€ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: ðŸ“¦ Install dependencies
        run: npm ci

      - name: ðŸ” Lint code
        run: npm run lint

      - name: ðŸ—ï¸ Type check
        run: npm run type-check

      - name: ðŸ§ª Run unit tests
        run: npm run test:ci

      - name: ðŸ“Š Upload coverage reports
        uses: codecov/codecov-action@v4
        if: success()
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          file: ./coverage/lcov.info

  e2e:
    runs-on: ubuntu-latest
    name: ðŸŽ­ E2E Tests

    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ðŸš€ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: ðŸ“¦ Install dependencies
        run: npm ci

      - name: ðŸŽ­ Install Playwright
        run: npx playwright install --with-deps

      - name: ðŸ—ï¸ Build application
        run: npm run build

      - name: ðŸŽ­ Run E2E tests
        run: npm run test:e2e
        env:
          CI: true

      - name: ðŸ“¸ Upload test results
        uses: actions/upload-artifact@v4
        if: failure()
        with:
          name: e2e-test-results
          path: test-results/
          retention-days: 7

  build:
    runs-on: ubuntu-latest
    name: ðŸ—ï¸ Build
    needs: [test]

    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ðŸš€ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: ðŸ“¦ Install dependencies
        run: npm ci

      - name: ðŸ—ï¸ Build application
        run: npm run build
        env:
          VITE_SUPABASE_URL: ${{ secrets.VITE_SUPABASE_URL }}
          VITE_SUPABASE_ANON_KEY: ${{ secrets.VITE_SUPABASE_ANON_KEY }}
          VITE_STRIPE_PUBLIC_KEY: ${{ secrets.VITE_STRIPE_PUBLIC_KEY }}

      - name: ðŸ“¦ Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-files
          path: dist/
          retention-days: 7

  security:
    runs-on: ubuntu-latest
    name: ðŸ”’ Security Scan

    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ðŸš€ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: ðŸ“¦ Install dependencies
        run: npm ci

      - name: ðŸ” Run security audit
        run: npm audit --audit-level=high

      - name: ðŸ”’ Run CodeQL analysis
        uses: github/codeql-action/init@v3
        with:
          languages: javascript,typescript

      - name: ðŸ”’ Perform CodeQL analysis
        uses: github/codeql-action/analyze@v3

  deploy-staging:
    runs-on: ubuntu-latest
    name: ðŸš€ Deploy to Staging
    needs: [test, e2e, build, security]
    if: github.ref == 'refs/heads/develop'

    environment:
      name: staging
      url: https://staging.dependablecalls.com

    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ðŸ“¦ Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-files
          path: dist/

      - name: ðŸš€ Deploy to Netlify Staging
        uses: nwtgck/actions-netlify@v3
        with:
          publish-dir: './dist'
          production-branch: main
          github-token: ${{ secrets.GITHUB_TOKEN }}
          deploy-message: 'Deploy from GitHub Actions - ${{ github.sha }}'
          enable-pull-request-comment: true
          enable-commit-comment: true
          overwrites-pull-request-comment: true
        env:
          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
          NETLIFY_SITE_ID: ${{ secrets.NETLIFY_STAGING_SITE_ID }}

  deploy-production:
    runs-on: ubuntu-latest
    name: ðŸš€ Deploy to Production
    needs: [test, e2e, build, security]
    if: github.ref == 'refs/heads/main'

    environment:
      name: production
      url: https://dependablecalls.com

    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ðŸ“¦ Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-files
          path: dist/

      - name: ðŸš€ Deploy to Netlify Production
        uses: nwtgck/actions-netlify@v3
        with:
          publish-dir: './dist'
          production-deploy: true
          github-token: ${{ secrets.GITHUB_TOKEN }}
          deploy-message: 'Production deployment - ${{ github.sha }}'
        env:
          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
          NETLIFY_SITE_ID: ${{ secrets.NETLIFY_PRODUCTION_SITE_ID }}

      - name: ðŸ“Š Notify Sentry of release
        uses: getsentry/action-release@v1
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
          SENTRY_ORG: ${{ secrets.SENTRY_ORG }}
          SENTRY_PROJECT: dce-platform
        with:
          environment: production
          version: ${{ github.sha }}

  lighthouse:
    runs-on: ubuntu-latest
    name: ðŸ” Lighthouse Audit
    needs: [deploy-staging]
    if: github.ref == 'refs/heads/develop'

    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ðŸ” Run Lighthouse audit
        uses: treosh/lighthouse-ci-action@v10
        with:
          configPath: './lighthouserc.json'
          uploadArtifacts: true
          temporaryPublicStorage: true
        env:
          LHCI_GITHUB_APP_TOKEN: ${{ secrets.LHCI_GITHUB_APP_TOKEN }}

  database-migrations:
    runs-on: ubuntu-latest
    name: ðŸ—„ï¸ Database Migrations
    if: github.ref == 'refs/heads/main'

    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ðŸš€ Setup Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: latest

      - name: ðŸ—„ï¸ Run database migrations
        run: supabase db push
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
          SUPABASE_DB_PASSWORD: ${{ secrets.SUPABASE_DB_PASSWORD }}

      - name: ðŸ”„ Generate database types
        run: |
          supabase gen types typescript --project-id ${{ secrets.SUPABASE_PROJECT_ID }} > src/types/database.ts
          git config --global user.email "actions@github.com"
          git config --global user.name "GitHub Actions"
          git add src/types/database.ts
          git diff --staged --quiet || git commit -m "Update database types [skip ci]"
          git push
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}

  performance:
    runs-on: ubuntu-latest
    name: âš¡ Performance Tests
    needs: [deploy-staging]
    if: github.ref == 'refs/heads/develop'

    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: âš¡ Run performance tests
        run: |
          npx artillery run performance/load-test.yml --target https://staging.dependablecalls.com
          npx artillery run performance/stress-test.yml --target https://staging.dependablecalls.com

  notification:
    runs-on: ubuntu-latest
    name: ðŸ“¢ Notifications
    needs: [deploy-production]
    if: always() && github.ref == 'refs/heads/main'

    steps:
      - name: ðŸ“¢ Slack notification
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          channel: '#deployments'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
          fields: repo,message,commit,author,action,eventName,ref,workflow
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}
</file>

<file path=".github/workflows/CLAUDE.md">
# GitHub Actions Workflows

# Workflow Structure
- `.github/workflows/ci.yml` - Continuous Integration
- `.github/workflows/deploy-staging.yml` - Staging deployment
- `.github/workflows/deploy-production.yml` - Production deployment
- `.github/workflows/security-scan.yml` - Security scanning
- `.github/workflows/database-migrations.yml` - Database management

# Continuous Integration
```yaml
# .github/workflows/ci.yml
name: Continuous Integration

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

env:
  NODE_VERSION: '22.15.0'
  PNPM_VERSION: '9.15.0'

jobs:
  lint-and-typecheck:
    name: Lint and Type Check
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Install pnpm
        run: npm install -g pnpm@${{ env.PNPM_VERSION }}

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Run ESLint
        run: pnpm lint

      - name: Run TypeScript check
        run: pnpm type-check

      - name: Check formatting
        run: pnpm format:check

  test:
    name: Run Tests
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: dce_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Install pnpm
        run: npm install -g pnpm@${{ env.PNPM_VERSION }}

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Run unit tests
        run: pnpm test:unit
        env:
          NODE_ENV: test
          DATABASE_TEST_URL: postgresql://postgres:postgres@localhost:5432/dce_test

      - name: Run integration tests
        run: pnpm test:integration
        env:
          NODE_ENV: test

      - name: Upload coverage reports
        uses: codecov/codecov-action@v4
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: ./coverage/lcov.info
          fail_ci_if_error: true

  build:
    name: Build Application
    runs-on: ubuntu-latest
    needs: [lint-and-typecheck, test]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Install pnpm
        run: npm install -g pnpm@${{ env.PNPM_VERSION }}

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build application
        run: pnpm build
        env:
          NODE_ENV: production
          VITE_SUPABASE_URL: ${{ secrets.VITE_SUPABASE_URL }}
          VITE_SUPABASE_ANON_KEY: ${{ secrets.VITE_SUPABASE_ANON_KEY }}

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-files
          path: dist/
          retention-days: 7

  e2e-tests:
    name: End-to-End Tests
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Install pnpm
        run: npm install -g pnpm@${{ env.PNPM_VERSION }}

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Install Playwright browsers
        run: pnpm exec playwright install --with-deps

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-files
          path: dist/

      - name: Start preview server
        run: pnpm preview &
        env:
          CI: true

      - name: Wait for server
        run: npx wait-on http://localhost:4173

      - name: Run Playwright tests
        run: pnpm test:e2e
        env:
          CI: true

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: failure()
        with:
          name: playwright-report
          path: playwright-report/
          retention-days: 7
```

# Staging Deployment
```yaml
# .github/workflows/deploy-staging.yml
name: Deploy to Staging

on:
  push:
    branches: [develop]
  workflow_dispatch:

env:
  NODE_VERSION: '22.15.0'
  PNPM_VERSION: '9.15.0'

jobs:
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    environment: staging
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Install pnpm
        run: npm install -g pnpm@${{ env.PNPM_VERSION }}

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Run database migrations
        run: |
          echo "$SUPABASE_SERVICE_ROLE_KEY" | base64 -d > service-role-key.json
          pnpm supabase db push --db-url $STAGING_DATABASE_URL
        env:
          STAGING_DATABASE_URL: ${{ secrets.STAGING_DATABASE_URL }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}

      - name: Build application
        run: pnpm build
        env:
          NODE_ENV: production
          VITE_SUPABASE_URL: ${{ secrets.STAGING_SUPABASE_URL }}
          VITE_SUPABASE_ANON_KEY: ${{ secrets.STAGING_SUPABASE_ANON_KEY }}
          VITE_STRIPE_PUBLIC_KEY: ${{ secrets.STAGING_STRIPE_PUBLIC_KEY }}

      - name: Deploy to Netlify
        uses: nwtgck/actions-netlify@v3.0
        with:
          publish-dir: './dist'
          production-branch: develop
          github-token: ${{ secrets.GITHUB_TOKEN }}
          deploy-message: "Deploy from GitHub Actions"
          enable-pull-request-comment: false
          enable-commit-comment: true
        env:
          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
          NETLIFY_SITE_ID: ${{ secrets.STAGING_NETLIFY_SITE_ID }}

      - name: Run smoke tests
        run: pnpm test:smoke
        env:
          BASE_URL: ${{ steps.deploy.outputs.deploy-url }}

      - name: Notify deployment
        if: always()
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          text: 'Staging deployment ${{ job.status }}'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
```

# Production Deployment
```yaml
# .github/workflows/deploy-production.yml
name: Deploy to Production

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      confirm_production:
        description: 'Type "DEPLOY" to confirm production deployment'
        required: true
        default: ''

env:
  NODE_VERSION: '22.15.0'
  PNPM_VERSION: '9.15.0'

jobs:
  security-check:
    name: Security Check
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run security audit
        run: |
          npm audit --audit-level=high
          pnpm audit --audit-level=high

      - name: Check for secrets
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          base: main
          head: HEAD

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: security-check
    environment: production
    if: github.event.inputs.confirm_production == 'DEPLOY' || github.ref == 'refs/heads/main'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Verify production confirmation
        if: github.event_name == 'workflow_dispatch'
        run: |
          if [ "${{ github.event.inputs.confirm_production }}" != "DEPLOY" ]; then
            echo "Production deployment not confirmed. Exiting."
            exit 1
          fi

      - name: Install pnpm
        run: npm install -g pnpm@${{ env.PNPM_VERSION }}

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Run full test suite
        run: pnpm test:all
        env:
          NODE_ENV: test

      - name: Backup production database
        run: |
          pg_dump $PRODUCTION_DATABASE_URL > backup-$(date +%Y%m%d-%H%M%S).sql
        env:
          PRODUCTION_DATABASE_URL: ${{ secrets.PRODUCTION_DATABASE_URL }}

      - name: Run database migrations
        run: |
          pnpm supabase db push --db-url $PRODUCTION_DATABASE_URL
        env:
          PRODUCTION_DATABASE_URL: ${{ secrets.PRODUCTION_DATABASE_URL }}

      - name: Build application
        run: pnpm build
        env:
          NODE_ENV: production
          VITE_SUPABASE_URL: ${{ secrets.PRODUCTION_SUPABASE_URL }}
          VITE_SUPABASE_ANON_KEY: ${{ secrets.PRODUCTION_SUPABASE_ANON_KEY }}
          VITE_STRIPE_PUBLIC_KEY: ${{ secrets.PRODUCTION_STRIPE_PUBLIC_KEY }}

      - name: Deploy to Netlify
        uses: nwtgck/actions-netlify@v3.0
        with:
          publish-dir: './dist'
          production-branch: main
          github-token: ${{ secrets.GITHUB_TOKEN }}
          deploy-message: "Production deploy from GitHub Actions"
        env:
          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
          NETLIFY_SITE_ID: ${{ secrets.PRODUCTION_NETLIFY_SITE_ID }}

      - name: Run production health checks
        run: pnpm test:health
        env:
          BASE_URL: https://dependablecalls.com

      - name: Create GitHub release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ github.run_number }}
          release_name: Release v${{ github.run_number }}
          body: |
            Production deployment completed successfully.
            
            Changes in this release:
            ${{ github.event.head_commit.message }}
          draft: false
          prerelease: false

      - name: Notify production deployment
        if: always()
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          text: 'Production deployment ${{ job.status }}'
          channel: '#deployments'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
```

# Security Scanning
```yaml
# .github/workflows/security-scan.yml
name: Security Scan

on:
  schedule:
    - cron: '0 2 * * *' # Daily at 2 AM
  workflow_dispatch:

jobs:
  dependency-scan:
    name: Dependency Security Scan
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run npm audit
        run: npm audit --audit-level=moderate

      - name: Run Snyk security scan
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          args: --severity-threshold=high

  code-scan:
    name: Code Security Scan
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Initialize CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: javascript, typescript

      - name: Autobuild
        uses: github/codeql-action/autobuild@v3

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3

  secret-scan:
    name: Secret Scan
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run TruffleHog
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          base: main
          head: HEAD
          extra_args: --debug --only-verified

  container-scan:
    name: Container Security Scan
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Build Docker image
        run: docker build -t dce-app:latest .

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'dce-app:latest'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'trivy-results.sarif'
```

# Database Migration Workflow
```yaml
# .github/workflows/database-migrations.yml
name: Database Migrations

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      migration_direction:
        description: 'Migration direction'
        required: true
        default: 'up'
        type: choice
        options:
          - up
          - down
      confirm_production:
        description: 'Type "MIGRATE" to confirm production migration'
        required: false
        default: ''

jobs:
  migrate-database:
    name: Run Database Migration
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Verify production confirmation
        if: github.event.inputs.environment == 'production'
        run: |
          if [ "${{ github.event.inputs.confirm_production }}" != "MIGRATE" ]; then
            echo "Production migration not confirmed. Exiting."
            exit 1
          fi

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22.15.0'

      - name: Install pnpm
        run: npm install -g pnpm@9.15.0

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Setup Supabase CLI
        uses: supabase/setup-cli@v1

      - name: Create database backup
        if: github.event.inputs.environment == 'production'
        run: |
          TIMESTAMP=$(date +%Y%m%d_%H%M%S)
          pg_dump $DATABASE_URL > "backup_${TIMESTAMP}.sql"
          echo "Backup created: backup_${TIMESTAMP}.sql"
        env:
          DATABASE_URL: ${{ secrets.PRODUCTION_DATABASE_URL }}

      - name: Run migrations (up)
        if: github.event.inputs.migration_direction == 'up'
        run: supabase db push
        env:
          SUPABASE_DB_URL: ${{ github.event.inputs.environment == 'production' && secrets.PRODUCTION_DATABASE_URL || secrets.STAGING_DATABASE_URL }}

      - name: Run migrations (down)
        if: github.event.inputs.migration_direction == 'down'
        run: |
          echo "Rolling back last migration..."
          # Custom rollback logic would go here
          supabase migration repair --status reverted
        env:
          SUPABASE_DB_URL: ${{ github.event.inputs.environment == 'production' && secrets.PRODUCTION_DATABASE_URL || secrets.STAGING_DATABASE_URL }}

      - name: Verify migration
        run: |
          supabase migration list
          pnpm test:migration
        env:
          DATABASE_URL: ${{ github.event.inputs.environment == 'production' && secrets.PRODUCTION_DATABASE_URL || secrets.STAGING_DATABASE_URL }}

      - name: Notify migration result
        if: always()
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          text: 'Database migration (${{ github.event.inputs.migration_direction }}) on ${{ github.event.inputs.environment }}: ${{ job.status }}'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
```

# Performance Testing
```yaml
# .github/workflows/performance.yml
name: Performance Testing

on:
  schedule:
    - cron: '0 4 * * 1' # Weekly on Monday at 4 AM
  workflow_dispatch:

jobs:
  lighthouse-audit:
    name: Lighthouse Audit
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22.15.0'

      - name: Install dependencies
        run: npm install -g @lhci/cli

      - name: Run Lighthouse CI
        run: lhci autorun
        env:
          LHCI_GITHUB_APP_TOKEN: ${{ secrets.LHCI_GITHUB_APP_TOKEN }}

  load-testing:
    name: Load Testing
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Artillery load test
        run: |
          npm install -g artillery
          artillery run tests/load/api-load-test.yml

      - name: Upload load test results
        uses: actions/upload-artifact@v4
        with:
          name: load-test-results
          path: load-test-report.json
```

# Workflow Best Practices
- Use environment-specific secrets
- Implement manual approvals for production
- Create comprehensive test coverage
- Monitor deployment health
- Maintain rollback capabilities
- Log all deployment activities

# Security Considerations
- Scan for vulnerabilities before deployment
- Use least-privilege access tokens
- Encrypt sensitive data in transit
- Implement secret scanning
- Regular security audits

# Monitoring and Alerting
- Real-time deployment notifications
- Health check monitoring
- Performance regression alerts
- Security vulnerability notifications
- Database migration status updates

# CRITICAL RULES
- NO regex in workflow files
- NO hardcoded secrets in workflows
- ALWAYS require manual approval for production
- ALWAYS run security scans before deployment
- IMPLEMENT proper error handling
- TEST all workflow changes thoroughly
- ENSURE proper access controls
- MAINTAIN deployment rollback capability
- DOCUMENT all workflow processes
- MONITOR deployment metrics
</file>

<file path=".github/workflows/database-backup.yml">
name: Database Backup

on:
  schedule:
    # Run daily at 2 AM UTC
    - cron: '0 2 * * *'
  workflow_dispatch:
    inputs:
      retention_days:
        description: 'Backup retention in days'
        required: false
        default: '7'

jobs:
  backup:
    name: Backup Supabase Database
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
          
      - name: Install PostgreSQL client
        run: |
          sudo sh -c 'echo "deb http://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main" > /etc/apt/sources.list.d/pgdg.list'
          wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add -
          sudo apt-get update
          sudo apt-get -y install postgresql-client-16
          
      - name: Run backup script
        env:
          SUPABASE_DB_URL: ${{ secrets.SUPABASE_DB_URL_PROD }}
          AWS_S3_BUCKET: ${{ secrets.BACKUP_S3_BUCKET }}
          RETENTION_DAYS: ${{ github.event.inputs.retention_days || '7' }}
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          PAGERDUTY_INTEGRATION_KEY: ${{ secrets.PAGERDUTY_INTEGRATION_KEY }}
        run: |
          bash scripts/backup/supabase-backup.sh
          
      - name: Verify backup
        run: |
          # Check if backup was created in S3
          LATEST_BACKUP=$(aws s3 ls s3://${{ secrets.BACKUP_S3_BUCKET }}/database-backups/ | grep dump.gz | sort | tail -1 | awk '{print $4}')
          if [[ -z "$LATEST_BACKUP" ]]; then
            echo "ERROR: No backup found in S3"
            exit 1
          fi
          echo "Latest backup: $LATEST_BACKUP"
          
      - name: Test restore (dry run)
        if: github.event_name == 'workflow_dispatch'
        run: |
          echo "Backup restore test would be performed here in a test environment"
          # In production, this would restore to a test database to verify backup integrity

  backup-staging:
    name: Backup Staging Database
    runs-on: ubuntu-latest
    timeout-minutes: 30
    if: github.event_name == 'schedule'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
          
      - name: Install PostgreSQL client
        run: |
          sudo sh -c 'echo "deb http://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main" > /etc/apt/sources.list.d/pgdg.list'
          wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add -
          sudo apt-get update
          sudo apt-get -y install postgresql-client-16
          
      - name: Run staging backup
        env:
          SUPABASE_DB_URL: ${{ secrets.SUPABASE_DB_URL_STAGING }}
          AWS_S3_BUCKET: ${{ secrets.BACKUP_S3_BUCKET }}
          RETENTION_DAYS: '3'  # Shorter retention for staging
          BACKUP_DIR: /tmp/backups/staging
        run: |
          # Modify backup path for staging
          export AWS_S3_BUCKET="${AWS_S3_BUCKET}/staging"
          bash scripts/backup/supabase-backup.sh
</file>

<file path=".github/workflows/deploy-production.yml">
name: Deploy to Production

on:
  push:
    branches: [main]
  workflow_dispatch:

jobs:
  test-and-build:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Run linting
        run: npm run lint
        
      - name: Run type checking
        run: npm run type-check
        
      - name: Run tests
        run: npm run test:ci
        
      - name: Build for production
        run: npm run build
        env:
          VITE_SUPABASE_URL: ${{ secrets.VITE_SUPABASE_URL }}
          VITE_SUPABASE_ANON_KEY: ${{ secrets.VITE_SUPABASE_ANON_KEY }}
          VITE_STRIPE_PUBLISHABLE_KEY: ${{ secrets.VITE_STRIPE_PUBLISHABLE_KEY }}
          VITE_SENTRY_DSN: ${{ secrets.VITE_SENTRY_DSN }}
        
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: production-build
          path: dist/
          retention-days: 30

  deploy:
    needs: test-and-build
    runs-on: ubuntu-latest
    environment: production
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: production-build
          path: dist/
          
      - name: Deploy to Netlify
        uses: nwtgck/actions-netlify@v3.0
        with:
          publish-dir: './dist'
          production-branch: main
          github-token: ${{ secrets.GITHUB_TOKEN }}
          deploy-message: "Production deployment from commit ${{ github.sha }}"
          enable-pull-request-comment: false
          enable-commit-comment: true
          overwrites-pull-request-comment: false
        env:
          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
          NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID }}
          
      - name: Notify Sentry of release
        uses: getsentry/action-release@v1
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
          SENTRY_ORG: ${{ secrets.SENTRY_ORG }}
          SENTRY_PROJECT: ${{ secrets.SENTRY_PROJECT }}
        with:
          environment: production
          version: ${{ github.sha }}
          
      - name: Health check
        run: |
          echo "Waiting for deployment to be ready..."
          sleep 30
          curl -f https://dependablecalls.com/health || exit 1
</file>

<file path=".github/workflows/deploy-staging.yml">
name: Deploy to Staging

on:
  push:
    branches: [develop]
  workflow_dispatch:

jobs:
  test-and-build:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Run linting
        run: npm run lint
        
      - name: Run type checking
        run: npm run type-check
        
      - name: Run tests
        run: npm run test:ci
        
      - name: Build for staging
        run: npm run build
        env:
          VITE_SUPABASE_URL: ${{ secrets.VITE_STAGING_SUPABASE_URL }}
          VITE_SUPABASE_ANON_KEY: ${{ secrets.VITE_STAGING_SUPABASE_ANON_KEY }}
          VITE_STRIPE_PUBLISHABLE_KEY: ${{ secrets.VITE_STAGING_STRIPE_PUBLISHABLE_KEY }}
          VITE_SENTRY_DSN: ${{ secrets.VITE_STAGING_SENTRY_DSN }}
        
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: staging-build
          path: dist/
          retention-days: 7

  deploy:
    needs: test-and-build
    runs-on: ubuntu-latest
    environment: staging
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: staging-build
          path: dist/
          
      - name: Deploy to Netlify Staging
        uses: nwtgck/actions-netlify@v3.0
        with:
          publish-dir: './dist'
          production-branch: develop
          github-token: ${{ secrets.GITHUB_TOKEN }}
          deploy-message: "Staging deployment from commit ${{ github.sha }}"
          enable-pull-request-comment: false
          enable-commit-comment: true
        env:
          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
          NETLIFY_SITE_ID: ${{ secrets.NETLIFY_STAGING_SITE_ID }}
          
      - name: Notify Sentry of staging release
        uses: getsentry/action-release@v1
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
          SENTRY_ORG: ${{ secrets.SENTRY_ORG }}
          SENTRY_PROJECT: ${{ secrets.SENTRY_PROJECT }}
        with:
          environment: staging
          version: ${{ github.sha }}
          
      - name: Run smoke tests
        run: |
          echo "Running smoke tests against staging..."
          sleep 15
          # Add actual smoke test commands here when available
          echo "Smoke tests completed"
</file>

<file path=".github/workflows/emergency-rollback.yml">
name: Emergency Rollback

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to rollback'
        required: true
        type: choice
        options:
          - production
          - staging
      deployment_id:
        description: 'Deployment ID to rollback to (leave empty to select interactively)'
        required: false
      reason:
        description: 'Reason for rollback'
        required: true
        default: 'Performance degradation'

jobs:
  rollback:
    name: Rollback ${{ github.event.inputs.environment }}
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup environment
        run: |
          if [[ "${{ github.event.inputs.environment }}" == "production" ]]; then
            echo "NETLIFY_SITE_ID=${{ secrets.NETLIFY_SITE_ID }}" >> $GITHUB_ENV
          else
            echo "NETLIFY_SITE_ID=${{ secrets.NETLIFY_STAGING_SITE_ID }}" >> $GITHUB_ENV
          fi
          
      - name: Get deployment history
        env:
          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
        run: |
          echo "Recent deployments for ${{ github.event.inputs.environment }}:"
          curl -s -H "Authorization: Bearer $NETLIFY_AUTH_TOKEN" \
            "https://api.netlify.com/api/v1/sites/$NETLIFY_SITE_ID/deploys?per_page=10" | \
            jq -r '.[] | select(.state == "ready") | "\(.id) - \(.created_at) - \(.branch) - \(.context)"' | \
            head -5
            
      - name: Perform rollback
        env:
          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
          NETLIFY_SITE_ID: ${{ env.NETLIFY_SITE_ID }}
          ENVIRONMENT: ${{ github.event.inputs.environment }}
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          if [[ -n "${{ github.event.inputs.deployment_id }}" ]]; then
            echo "${{ github.event.inputs.deployment_id }}" | ./scripts/rollback.sh
          else
            # Interactive mode not supported in GitHub Actions
            echo "ERROR: Deployment ID is required for automated rollback"
            exit 1
          fi
          
      - name: Create rollback issue
        uses: actions/github-script@v7
        with:
          script: |
            const issue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `ðŸ”„ Emergency Rollback: ${context.payload.inputs.environment}`,
              body: `## Emergency Rollback Performed
              
              **Environment:** ${context.payload.inputs.environment}
              **Initiated by:** @${context.actor}
              **Timestamp:** ${new Date().toISOString()}
              **Reason:** ${context.payload.inputs.reason}
              **Deployment ID:** ${context.payload.inputs.deployment_id || 'Interactive selection'}
              
              ### Action Items
              - [ ] Investigate root cause
              - [ ] Fix identified issues
              - [ ] Test fixes in staging
              - [ ] Plan forward deployment
              
              ### Related Information
              - Workflow run: ${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}
              `,
              labels: ['emergency', 'rollback', context.payload.inputs.environment],
              assignees: [context.actor]
            });
            
            console.log(`Created issue #${issue.data.number}`);
            
      - name: Notify team
        if: always()
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          text: |
            Emergency Rollback ${{ job.status }}
            Environment: ${{ github.event.inputs.environment }}
            Reason: ${{ github.event.inputs.reason }}
            Initiated by: ${{ github.actor }}
          webhook_url: ${{ secrets.SLACK_WEBHOOK_URL }}

  post-rollback-validation:
    name: Validate Rollback
    needs: rollback
    runs-on: ubuntu-latest
    
    steps:
      - name: Wait for deployment
        run: sleep 30
        
      - name: Health check
        run: |
          SITE_URL="${{ github.event.inputs.environment == 'production' && 'https://dependablecalls.com' || 'https://staging.dependablecalls.com' }}"
          
          for i in {1..5}; do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$SITE_URL/health" || echo "000")
            echo "Health check attempt $i: HTTP $HTTP_CODE"
            
            if [[ "$HTTP_CODE" == "200" ]]; then
              echo "âœ… Health check passed"
              exit 0
            fi
            
            sleep 10
          done
          
          echo "âŒ Health check failed after rollback"
          exit 1
          
      - name: Run smoke tests
        run: |
          # Basic smoke tests
          SITE_URL="${{ github.event.inputs.environment == 'production' && 'https://dependablecalls.com' || 'https://staging.dependablecalls.com' }}"
          
          # Check critical pages
          for page in "/" "/login" "/api/health"; do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$SITE_URL$page" || echo "000")
            echo "Page $page: HTTP $HTTP_CODE"
            
            if [[ "$HTTP_CODE" != "200" && "$HTTP_CODE" != "301" && "$HTTP_CODE" != "302" ]]; then
              echo "âŒ Page $page returned unexpected status: $HTTP_CODE"
              exit 1
            fi
          done
          
          echo "âœ… Smoke tests passed"
</file>

<file path=".github/workflows/pr-validation.yml">
name: PR Validation

on:
  pull_request:
    branches: [main, develop]

jobs:
  validate:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Lint code
        run: npm run lint
        
      - name: Type check
        run: npm run type-check
        
      - name: Run tests
        run: npm run test:ci
        
      - name: Build application
        run: npm run build
        
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-files
          path: dist/
          retention-days: 7
          
      - name: Security audit
        run: npm audit --audit-level=high
        
      - name: Dependency vulnerability scan
        uses: snyk/actions/node@master
        continue-on-error: true
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          args: --severity-threshold=high
</file>

<file path=".github/workflows/security-scan.yml">
name: Security Scanning

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]
  schedule:
    # Run daily at 2 AM UTC
    - cron: '0 2 * * *'
  workflow_dispatch:

jobs:
  dependency-scan:
    name: Dependency Vulnerability Scan
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Run npm audit
        run: npm audit --audit-level=moderate
        continue-on-error: true
        
      - name: Snyk vulnerability scan
        uses: snyk/actions/node@master
        continue-on-error: true
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          args: --severity-threshold=medium --file=package.json
          
      - name: Upload Snyk results to GitHub Code Scanning
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: snyk.sarif

  sast-scan:
    name: Static Application Security Testing
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Initialize CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: javascript-typescript
          queries: security-extended,security-and-quality
          
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Build application
        run: npm run build
        
      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3
        
      - name: ESLint security scan
        run: npm run lint
        continue-on-error: true

  secret-scan:
    name: Secret Detection
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: TruffleHog OSS
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          base: main
          head: HEAD
          extra_args: --debug --only-verified

  license-scan:
    name: License Compliance
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: License check
        run: npx license-checker --summary --excludePrivatePackages
        continue-on-error: true
</file>

<file path=".github/workflows/uptime-monitoring.yml">
name: Uptime Monitoring

on:
  schedule:
    # Run every 5 minutes
    - cron: '*/5 * * * *'
  workflow_dispatch:

jobs:
  check-production:
    name: Check Production Health
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Health check - Main site
        id: health_main
        run: |
          response=$(curl -s -o response.txt -w "%{http_code}" https://dependablecalls.com/health || echo "000")
          echo "status_code=$response" >> $GITHUB_OUTPUT
          
          if [[ "$response" == "200" ]]; then
            echo "âœ… Main site is healthy"
            jq . response.txt || cat response.txt
          else
            echo "âŒ Main site is unhealthy (HTTP $response)"
            cat response.txt || echo "No response body"
            exit 1
          fi
          
      - name: Check critical endpoints
        run: |
          endpoints=(
            "https://dependablecalls.com"
            "https://dependablecalls.com/login"
            "https://dependablecalls.com/api/health"
          )
          
          for endpoint in "${endpoints[@]}"; do
            echo "Checking $endpoint..."
            status=$(curl -s -o /dev/null -w "%{http_code}" "$endpoint" || echo "000")
            
            if [[ "$status" == "200" || "$status" == "301" || "$status" == "302" ]]; then
              echo "âœ… $endpoint - HTTP $status"
            else
              echo "âŒ $endpoint - HTTP $status"
              exit 1
            fi
          done
          
      - name: Performance check
        run: |
          echo "Measuring response times..."
          
          # Measure homepage load time
          time_total=$(curl -s -o /dev/null -w "%{time_total}" https://dependablecalls.com)
          echo "Homepage load time: ${time_total}s"
          
          # Check if response time is acceptable (under 3 seconds)
          if (( $(echo "$time_total > 3" | bc -l) )); then
            echo "âš ï¸ Homepage load time is slow (${time_total}s > 3s)"
          fi
          
      - name: Create incident if unhealthy
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            const labels = ['incident', 'production', 'automated'];
            const title = `ðŸš¨ Production Health Check Failed`;
            const body = `## Production Health Check Failed
            
            **Time:** ${new Date().toISOString()}
            **Status Code:** ${{ steps.health_main.outputs.status_code }}
            **Workflow:** ${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}
            
            ### Immediate Actions Required:
            1. Check production logs
            2. Verify database connectivity
            3. Check for deployment issues
            4. Review error tracking in Sentry
            
            ### Escalation:
            - [ ] Notify on-call engineer
            - [ ] Check monitoring dashboards
            - [ ] Review recent deployments
            `;
            
            // Check if there's already an open incident
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: labels.join(','),
              state: 'open'
            });
            
            if (issues.data.length === 0) {
              // Create new incident
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title,
                body,
                labels
              });
            } else {
              // Add comment to existing incident
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issues.data[0].number,
                body: `Health check failed again at ${new Date().toISOString()}`
              });
            }
            
      - name: Send alerts
        if: failure()
        run: |
          # Send Slack notification
          if [[ -n "${{ secrets.SLACK_WEBHOOK_URL }}" ]]; then
            curl -X POST -H 'Content-type: application/json' \
              --data '{
                "text": "ðŸš¨ Production health check failed!",
                "attachments": [{
                  "color": "danger",
                  "fields": [
                    {"title": "Environment", "value": "Production", "short": true},
                    {"title": "Status", "value": "${{ steps.health_main.outputs.status_code }}", "short": true},
                    {"title": "Time", "value": "'"$(date -u +%Y-%m-%dT%H:%M:%SZ)"'", "short": true}
                  ]
                }]
              }' \
              ${{ secrets.SLACK_WEBHOOK_URL }}
          fi
          
          # Send PagerDuty alert
          if [[ -n "${{ secrets.PAGERDUTY_INTEGRATION_KEY }}" ]]; then
            curl -X POST https://events.pagerduty.com/v2/enqueue \
              -H 'Content-Type: application/json' \
              -d '{
                "routing_key": "${{ secrets.PAGERDUTY_INTEGRATION_KEY }}",
                "event_action": "trigger",
                "payload": {
                  "summary": "Production health check failed",
                  "severity": "critical",
                  "source": "github-actions",
                  "custom_details": {
                    "status_code": "${{ steps.health_main.outputs.status_code }}",
                    "workflow_url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                  }
                }
              }'
          fi

  check-staging:
    name: Check Staging Health
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule' && github.run_number % 3 == 0  # Run every 15 minutes
    
    steps:
      - name: Health check - Staging
        run: |
          response=$(curl -s -o /dev/null -w "%{http_code}" https://staging.dependablecalls.com/health || echo "000")
          
          if [[ "$response" == "200" ]]; then
            echo "âœ… Staging is healthy"
          else
            echo "âš ï¸ Staging is unhealthy (HTTP $response)"
            # Don't fail the job for staging
          fi

  metrics:
    name: Store Uptime Metrics
    needs: [check-production]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: Calculate uptime
        run: |
          # This would typically store metrics in a time-series database
          if [[ "${{ needs.check-production.result }}" == "success" ]]; then
            echo "UPTIME_STATUS=up" >> $GITHUB_ENV
            echo "âœ… Recording successful health check"
          else
            echo "UPTIME_STATUS=down" >> $GITHUB_ENV
            echo "âŒ Recording failed health check"
          fi
          
      - name: Update status page
        run: |
          # This would update a public status page
          echo "Status: $UPTIME_STATUS"
          echo "Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
</file>

<file path=".github/CLAUDE.md">
# CI/CD & GitHub Workflows

# Workflow Structure
```
.github/
â”œâ”€â”€ workflows/        # GitHub Actions workflows
â”œâ”€â”€ templates/        # Issue and PR templates
â”œâ”€â”€ CODEOWNERS       # Code review assignments
â””â”€â”€ dependabot.yml   # Dependency updates
```

# Core Workflows

## Main Workflow (`ci.yml`)
```yaml
name: CI/CD Pipeline
on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'
      
      - run: npm ci
      - run: npm run lint
      - run: npm run type-check
      - run: npm run test:ci
      - run: npm run test:e2e
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
```

## Deployment Workflow (`deploy.yml`)
```yaml
name: Deploy
on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'
      
      - run: npm ci
      - run: npm run build
      
      - name: Deploy to Netlify
        uses: nwtgck/actions-netlify@v2
        with:
          publish-dir: './dist'
          production-branch: main
          github-token: ${{ secrets.GITHUB_TOKEN }}
          deploy-message: 'Deploy from GitHub Actions'
        env:
          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
          NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID }}
```

# Quality Gates
- All tests must pass (unit, integration, E2E)
- Code coverage must be â‰¥90%
- TypeScript compilation must succeed
- ESLint checks must pass
- No security vulnerabilities allowed

# Environment Variables
Store secrets in GitHub repository settings:
- `NETLIFY_AUTH_TOKEN`
- `NETLIFY_SITE_ID`
- `SUPABASE_SERVICE_ROLE_KEY`
- `STRIPE_WEBHOOK_SECRET`

# Branch Protection Rules
```yaml
main:
  required_status_checks:
    - ci/test
    - ci/build
    - ci/security-scan
  require_pull_request_reviews: true
  required_reviewers: 2
  dismiss_stale_reviews: true
  require_code_owner_reviews: true
```

# Pull Request Template
```markdown
## Description
Brief description of the changes

## Type of Change
- [ ] Bug fix
- [ ] New feature
- [ ] Breaking change
- [ ] Documentation update

## Testing
- [ ] Unit tests added/updated
- [ ] Integration tests added/updated
- [ ] E2E tests added/updated
- [ ] Manual testing completed

## Checklist
- [ ] Code follows style guidelines
- [ ] Self-review completed
- [ ] Comments added for complex code
- [ ] Documentation updated
- [ ] No secrets in code
```

# Security Scanning
```yaml
name: Security Scan
on: [push, pull_request]

jobs:
  security:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Run Snyk to check for vulnerabilities
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
```

# Performance Monitoring
```yaml
- name: Lighthouse CI
  uses: treosh/lighthouse-ci-action@v10
  with:
    configPath: './lighthouserc.js'
    uploadArtifacts: true
    temporaryPublicStorage: true
```

# Database Migration Workflow
```yaml
name: Database Migration
on:
  push:
    branches: [main]
    paths: ['supabase/migrations/**']

jobs:
  migrate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: supabase/setup-cli@v1
        with:
          version: latest
      
      - name: Apply migrations
        run: supabase db push
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
          SUPABASE_PROJECT_ID: ${{ secrets.SUPABASE_PROJECT_ID }}
```

# Code Quality Workflow
```yaml
name: Code Quality
on: [push, pull_request]

jobs:
  quality:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: SonarCloud Scan
        uses: SonarSource/sonarcloud-github-action@master
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
```

# Dependency Updates
```yaml
# dependabot.yml
version: 2
updates:
  - package-ecosystem: "npm"
    directory: "/"
    schedule:
      interval: "weekly"
    open-pull-requests-limit: 5
    reviewers:
      - "tech-team"
```

# CODEOWNERS File
```
# Global owners
* @tech-team

# Frontend specific
/src/components/ @frontend-team
/src/pages/ @frontend-team

# Backend specific
/supabase/ @backend-team
/src/integrations/ @backend-team

# DevOps specific
/.github/ @devops-team
/netlify.toml @devops-team
```

# Release Workflow
```yaml
name: Release
on:
  push:
    tags: ['v*']

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Create Release
        uses: actions/create-release@v1
        with:
          tag_name: ${{ github.ref }}
          release_name: Release ${{ github.ref }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

# Monitoring & Alerting
```yaml
- name: Slack Notification
  uses: 8398a7/action-slack@v3
  if: failure()
  with:
    status: ${{ job.status }}
    channel: '#deployments'
    webhook_url: ${{ secrets.SLACK_WEBHOOK }}
```

# DCE-Specific Workflows

## Call Volume Monitoring
```yaml
name: Monitor Call Volume
on:
  schedule:
    - cron: '*/15 * * * *'  # Every 15 minutes

jobs:
  monitor:
    runs-on: ubuntu-latest
    steps:
      - name: Check Call Volume
        run: |
          # Script to check call volume and alert if anomalies
```

## Fraud Detection Updates
```yaml
name: Update Fraud Models
on:
  schedule:
    - cron: '0 2 * * *'  # Daily at 2 AM

jobs:
  update-models:
    runs-on: ubuntu-latest
    steps:
      - name: Retrain fraud detection model
        run: |
          # Update fraud detection algorithms
```

# Environment Management
- **Development**: Auto-deploy on develop branch
- **Staging**: Auto-deploy on release branches
- **Production**: Manual deployment approval required

# Rollback Strategy
```yaml
- name: Rollback on Failure
  if: failure()
  run: |
    # Rollback to previous stable version
    netlify deploy --dir=dist --prod --alias=rollback
```

# Secrets Management
- Use GitHub Secrets for sensitive data
- Rotate secrets regularly
- Use different secrets per environment
- Never log secret values

# CRITICAL RULES
- NO secrets in workflow files or code
- ALL deployments must pass quality gates
- ALWAYS require code reviews for main branch
- NEVER deploy without testing
- ALWAYS use environment-specific configurations
- MONITOR deployment success/failure
- IMPLEMENT automated rollback on critical failures
- USE semantic versioning for releases
- SCAN for security vulnerabilities automatically
</file>

<file path=".github/README.md">
# GitHub Actions CI/CD Pipeline

This directory contains the CI/CD pipeline configuration for the DCE platform.

## Workflows

### PR Validation (`pr-validation.yml`)

- Runs on every pull request
- Executes: linting, type checking, tests, build, and security scans
- Must pass before merging

### Production Deployment (`deploy-production.yml`)

- Triggered on push to `main` branch
- Deploys to production environment
- Includes health checks and Sentry release tracking

### Staging Deployment (`deploy-staging.yml`)

- Triggered on push to `develop` branch
- Deploys to staging environment
- Runs smoke tests after deployment

### Security Scanning (`security-scan.yml`)

- Runs on push, PR, and daily schedule
- Includes:
  - Dependency vulnerability scanning (npm audit, Snyk)
  - Static Application Security Testing (CodeQL)
  - Secret detection (TruffleHog)
  - License compliance checks

## Required Secrets

Configure these in GitHub repository settings:

### Netlify

- `NETLIFY_AUTH_TOKEN`: Netlify authentication token
- `NETLIFY_SITE_ID`: Production site ID
- `NETLIFY_STAGING_SITE_ID`: Staging site ID

### Supabase

- `VITE_SUPABASE_URL`: Production Supabase URL
- `VITE_SUPABASE_ANON_KEY`: Production anonymous key
- `VITE_STAGING_SUPABASE_URL`: Staging Supabase URL
- `VITE_STAGING_SUPABASE_ANON_KEY`: Staging anonymous key

### Stripe

- `VITE_STRIPE_PUBLISHABLE_KEY`: Production publishable key
- `VITE_STAGING_STRIPE_PUBLISHABLE_KEY`: Staging publishable key

### Monitoring

- `VITE_SENTRY_DSN`: Production Sentry DSN
- `VITE_STAGING_SENTRY_DSN`: Staging Sentry DSN
- `SENTRY_AUTH_TOKEN`: Sentry authentication token
- `SENTRY_ORG`: Sentry organization slug
- `SENTRY_PROJECT`: Sentry project slug

### Security

- `SNYK_TOKEN`: Snyk authentication token
- `GITHUB_TOKEN`: Automatically provided by GitHub Actions

## Local Development

### Pre-commit Hooks

The project uses husky and lint-staged for pre-commit validation:

- ESLint fixes and formatting
- Prettier formatting
- TypeScript type checking

To skip pre-commit hooks (not recommended):

```bash
git commit --no-verify
```

### Running Workflows Locally

Test workflows locally using [act](https://github.com/nektos/act):

```bash
act pull_request  # Test PR validation
act push         # Test deployment workflows
```
</file>

<file path="docs/DEVOPS.md">
# DevOps & Infrastructure Guide

## Overview

This guide covers the complete DevOps infrastructure for the DCE platform, including CI/CD, monitoring, deployment, and incident response procedures.

## Table of Contents

1. [CI/CD Pipeline](#cicd-pipeline)
2. [Deployment](#deployment)
3. [Monitoring & Alerting](#monitoring--alerting)
4. [Database Operations](#database-operations)
5. [Incident Response](#incident-response)
6. [Performance Optimization](#performance-optimization)
7. [Security](#security)
8. [Disaster Recovery](#disaster-recovery)

## CI/CD Pipeline

### GitHub Actions Workflows

#### PR Validation (`pr-validation.yml`)
- **Triggers**: Pull requests to main/develop
- **Jobs**: Lint, type check, test, build, security scan
- **Required to pass before merge**

#### Deployment Workflows
- **Production** (`deploy-production.yml`): Auto-deploys main branch
- **Staging** (`deploy-staging.yml`): Auto-deploys develop branch
- **Emergency Rollback** (`emergency-rollback.yml`): Manual trigger for quick rollback

#### Automated Tasks
- **Database Backup** (`database-backup.yml`): Daily at 2 AM UTC
- **Security Scanning** (`security-scan.yml`): Daily vulnerability checks
- **Uptime Monitoring** (`uptime-monitoring.yml`): Every 5 minutes

### Pre-commit Hooks

```bash
# Automatically runs on git commit:
- ESLint with auto-fix
- Prettier formatting
- TypeScript type checking

# Skip hooks (emergency only):
git commit --no-verify
```

## Deployment

### Docker Deployment

```bash
# Build production image
docker build -t dce-website:latest .

# Run with Docker Compose
docker-compose up -d

# Development with hot reload
docker-compose up app-dev
```

### Manual Deployment

```bash
# Deploy to production
npm run build
netlify deploy --prod

# Deploy to staging
npm run build
netlify deploy --alias staging
```

### Rollback Procedures

```bash
# Emergency rollback
./scripts/rollback.sh

# Rollback with specific deployment ID
ENVIRONMENT=production ./scripts/rollback.sh <deployment-id>
```

## Monitoring & Alerting

### Application Performance Monitoring (APM)

The platform includes comprehensive APM tracking:

- **Web Vitals**: LCP, FID, CLS, INP
- **Resource Timing**: Track slow-loading resources
- **API Performance**: Automatic tracking of all API calls
- **Component Performance**: Measure render times
- **Memory Usage**: Track JS heap usage

Access metrics:
- Development: Open DevTools console
- Production: Check Sentry Performance dashboard

### Health Checks

Health endpoints:
- `/health` - Overall system health
- `/api/health` - API health check

Health check includes:
- Supabase connectivity
- Stripe.js loading
- Sentry initialization
- API responsiveness

### Log Aggregation

```typescript
// Application logging
import { logger } from '@/lib/logger'

// Log levels
logger.debug('Debug message')
logger.info('Info message')
logger.warn('Warning message')
logger.error('Error message', error)
logger.fatal('Fatal error', error)

// Structured logging
logger.logApiCall(endpoint, method, status, duration)
logger.logUserAction(action, metadata)
logger.logPerformance(metric, value)
logger.logSecurityEvent(event, severity)
```

### Uptime Monitoring

- **Production**: Checked every 5 minutes
- **Staging**: Checked every 15 minutes
- **Alerts**: Slack, PagerDuty, GitHub Issues
- **SLA Target**: 99.9% uptime

### Status Page

Access the status page at `/status` to view:
- Current system health
- Service status
- Response times
- Recent incidents
- Uptime metrics

## Database Operations

### Automated Backups

```bash
# Manual backup
./scripts/backup/supabase-backup.sh

# Restore from backup
./scripts/backup/supabase-restore.sh [backup-name]

# List available backups
aws s3 ls s3://${BACKUP_S3_BUCKET}/database-backups/
```

### Backup Schedule
- **Production**: Daily at 2 AM UTC, 7-day retention
- **Staging**: Daily at 2 AM UTC, 3-day retention
- **Storage**: AWS S3 with lifecycle policies

### Database Migrations

```bash
# Create migration
supabase migration new <migration-name>

# Apply migrations
supabase db push

# Reset database (development only)
supabase db reset
```

## Incident Response

### Severity Levels

1. **P1 (Critical)**: Complete outage, data loss risk
   - Response time: < 15 minutes
   - Escalation: Immediate
   
2. **P2 (High)**: Major functionality broken
   - Response time: < 1 hour
   - Escalation: Within 30 minutes
   
3. **P3 (Medium)**: Minor functionality affected
   - Response time: < 4 hours
   - Escalation: Next business day
   
4. **P4 (Low)**: Cosmetic issues
   - Response time: Next business day
   - Escalation: As needed

### Response Procedures

1. **Identify**: Check monitoring dashboards
2. **Assess**: Determine severity and impact
3. **Communicate**: Update status page and notify team
4. **Mitigate**: Apply temporary fixes if needed
5. **Resolve**: Implement permanent solution
6. **Review**: Post-mortem within 48 hours

### Emergency Contacts

- **On-call Engineer**: Check PagerDuty
- **Escalation**: Team lead â†’ CTO â†’ CEO
- **External**: Supabase support, Stripe support

## Performance Optimization

### Frontend Optimization

- **Code Splitting**: Automatic with Vite
- **Lazy Loading**: Components and routes
- **Image Optimization**: WebP with fallbacks
- **Caching**: Service worker + CDN

### Backend Optimization

- **Database Indexes**: See `migrations/005_indexes.sql`
- **Query Optimization**: Use Supabase query planner
- **Connection Pooling**: Automatic with Supabase
- **Rate Limiting**: Implemented at edge

### Monitoring Performance

```bash
# Check bundle size
npm run build -- --report

# Analyze performance
lighthouse https://dependablecalls.com

# Load testing
k6 run scripts/load-test.js
```

## Security

### Security Scanning

- **Dependencies**: Daily npm audit + Snyk
- **Code**: CodeQL static analysis
- **Secrets**: TruffleHog scanning
- **Infrastructure**: SSL/TLS checks

### Security Headers

Configured in `netlify.toml`:
- Content-Security-Policy
- X-Frame-Options: DENY
- X-Content-Type-Options: nosniff
- Strict-Transport-Security

### Access Control

- **GitHub**: Branch protection + required reviews
- **Netlify**: Environment-specific deploy keys
- **Supabase**: Row-level security policies
- **Monitoring**: Read-only dashboard access

## Disaster Recovery

### Backup Strategy

- **Database**: Daily automated backups to S3
- **Code**: Git repository (GitHub)
- **Configurations**: Stored in repository
- **Secrets**: Backed up in password manager

### Recovery Procedures

1. **Data Loss**: Restore from latest backup
2. **Service Outage**: Failover to backup region
3. **Security Breach**: Rotate all credentials
4. **Complete Failure**: Rebuild from infrastructure code

### RTO/RPO Targets

- **RTO** (Recovery Time Objective): < 4 hours
- **RPO** (Recovery Point Objective): < 24 hours

## Runbooks

### Common Issues

#### High Memory Usage
```bash
# Check memory usage
docker stats

# Restart container
docker-compose restart app

# Clear caches
redis-cli FLUSHALL
```

#### Slow API Response
```bash
# Check database connections
SELECT count(*) FROM pg_stat_activity;

# Check slow queries
SELECT * FROM pg_stat_statements ORDER BY total_time DESC LIMIT 10;

# Restart services
docker-compose restart
```

#### Failed Deployments
```bash
# Check deployment logs
netlify deploy --list

# Rollback to previous
./scripts/rollback.sh

# Clear build cache
netlify build --clear-cache
```

## Monitoring Dashboards

### Sentry
- Errors: https://sentry.io/organizations/[org]/issues/
- Performance: https://sentry.io/organizations/[org]/performance/
- Releases: https://sentry.io/organizations/[org]/releases/

### Netlify
- Deployments: https://app.netlify.com/sites/[site]/deploys
- Analytics: https://app.netlify.com/sites/[site]/analytics
- Functions: https://app.netlify.com/sites/[site]/functions

### Supabase
- Database: https://app.supabase.com/project/[id]/database
- Auth: https://app.supabase.com/project/[id]/auth
- Logs: https://app.supabase.com/project/[id]/logs

## Maintenance Windows

- **Scheduled**: Sundays 2-4 AM UTC
- **Notification**: 48 hours in advance
- **Emergency**: As needed with immediate notification

## Contact Information

- **DevOps Team**: devops@dependablecalls.com
- **Emergency**: +1-XXX-XXX-XXXX
- **Slack**: #devops-alerts
- **PagerDuty**: https://dependablecalls.pagerduty.com
</file>

<file path="docs/ERROR_BOUNDARIES_USAGE.md">
# Feature-Level Error Boundaries Usage Guide

This guide explains how to use the feature-level error boundaries in the DCE Platform.

## Overview

The DCE Platform implements specialized error boundaries for three critical feature types:

1. **Payment Processing** - Stripe integration errors
2. **Form Handling** - Validation and submission errors
3. **Real-time Features** - WebSocket and connection errors

## Payment Error Boundaries

### When to Use

Use `PaymentErrorBoundary` for any component that:

- Processes payments through Stripe
- Handles payment forms
- Manages payment methods
- Shows payment history

### Example Usage

```tsx
import { PaymentErrorBoundary } from '@/components/payments/PaymentErrorBoundary'
import PaymentForm from '@/components/payments/PaymentForm'

// Option 1: Using the pre-wrapped component
export default function CheckoutPage() {
  return (
    <PaymentForm // This already includes PaymentErrorBoundary
      amount={5000}
      currency="usd"
      description="Campaign budget top-up"
      metadata={{
        invoiceId: 'inv_123',
        buyerId: 'buyer_456',
        billingPeriod: '2024-01',
      }}
      onSuccess={(paymentIntentId) => {
        console.log('Payment successful:', paymentIntentId)
      }}
      onError={(error) => {
        console.error('Payment error:', error)
      }}
    />
  )
}

// Option 2: Wrapping your own payment component
import { PaymentErrorBoundary } from '@/components/payments/PaymentErrorBoundary'

function CustomPaymentFlow() {
  // Your payment logic here
}

export default function PaymentPage() {
  return (
    <PaymentErrorBoundary
      onRetry={() => window.location.reload()}
      onUpdatePaymentMethod={() => navigate('/settings/payment-methods')}
      onContactSupport={() => navigate('/support')}
      preserveFormData={true}
    >
      <CustomPaymentFlow />
    </PaymentErrorBoundary>
  )
}
```

### Error Types Handled

- Card declined
- Insufficient funds
- Invalid card information
- Network/connection errors
- Generic payment failures

## Form Error Boundaries

### When to Use

Use `FormErrorBoundary` for:

- Multi-step forms (campaign creation, onboarding)
- Complex forms with validation
- Forms that need draft saving
- Forms with network submission

### Example Usage

```tsx
import { FormErrorBoundary } from '@/components/forms/FormErrorBoundary'
import { z } from 'zod'

const campaignSchema = z.object({
  name: z.string().min(3),
  budget: z.number().positive(),
  // ... other fields
})

export default function CreateCampaignPage() {
  const [retryKey, setRetryKey] = useState(0)

  const handleSaveDraft = (data: Record<string, unknown>) => {
    localStorage.setItem('campaignDraft', JSON.stringify(data))
    toast.success('Draft saved!')
  }

  return (
    <FormErrorBoundary
      formName="createCampaign"
      enableDraftSaving={true}
      validationSchema={campaignSchema}
      onRetry={() => setRetryKey((prev) => prev + 1)}
      onSaveDraft={handleSaveDraft}
      onReset={() => {
        localStorage.removeItem('campaignDraft')
        setRetryKey((prev) => prev + 1)
      }}
    >
      <CampaignForm key={retryKey} />
    </FormErrorBoundary>
  )
}
```

### Features

- Automatic form data preservation
- Draft saving with 24-hour expiration
- Validation error display
- Retry with data restoration
- Network error handling

## Real-time Error Boundaries

### When to Use

Use `RealtimeErrorBoundary` for:

- WebSocket connections
- Real-time dashboards
- Live data feeds
- Webhook processors
- Call tracking features

### Example Usage

```tsx
import { RealtimeErrorBoundary } from '@/components/realtime/RealtimeErrorBoundary'
import { WebhookHandler } from '@/components/payments/WebhookHandler'

// Option 1: Using pre-wrapped components
export default function PaymentDashboard() {
  return (
    <>
      <WebhookHandler /> {/* Already includes RealtimeErrorBoundary */}
      <RealTimeDashboard userId={user.id} userType="buyer" />
    </>
  )
}

// Option 2: Wrapping custom real-time components
function LiveCallTracker() {
  // Your real-time logic here
}

export default function CallCenter() {
  return (
    <RealtimeErrorBoundary
      featureName="Call Tracking"
      enableAutoReconnect={true}
      maxReconnectAttempts={5}
      reconnectDelay={2000}
      onReconnect={async () => {
        // Custom reconnection logic
      }}
      onFallbackToPolling={() => {
        // Switch to polling mode
      }}
    >
      <LiveCallTracker />
    </RealtimeErrorBoundary>
  )
}
```

### Features

- Automatic reconnection with exponential backoff
- Connection status indicator
- Fallback to polling mode
- Preserves functionality during disconnections
- Shows real-time connection status

## Best Practices

### 1. Choose the Right Boundary

- Payment forms â†’ `PaymentErrorBoundary`
- Complex forms â†’ `FormErrorBoundary`
- Real-time features â†’ `RealtimeErrorBoundary`
- Generic errors â†’ Base `ErrorBoundary`

### 2. Provide Recovery Options

Always implement recovery handlers:

```tsx
<PaymentErrorBoundary
  onRetry={handleRetry}
  onUpdatePaymentMethod={handleUpdatePayment}
  onContactSupport={handleSupport}
/>
```

### 3. Preserve User Data

Enable data preservation for forms:

```tsx
<FormErrorBoundary enableDraftSaving={true} preserveFormData={true} />
```

### 4. Test Error Scenarios

Test each error boundary by simulating failures:

```tsx
// Simulate payment error
throw new Error('Your card was declined')

// Simulate network error
throw new Error('Network request failed')

// Simulate WebSocket disconnection
throw new Error('WebSocket connection lost')
```

### 5. Monitor Errors

All error boundaries integrate with Sentry:

```tsx
<PaymentErrorBoundary
  onError={(error, errorInfo) => {
    // Custom error tracking
    analytics.track('payment_error', {
      error: error.message,
      component: errorInfo.componentStack,
    })
  }}
/>
```

## Error Recovery Flows

### Payment Recovery

1. Error occurs â†’ Show specific error message
2. User can: Retry, Update payment method, Contact support
3. Form data is preserved
4. Successful retry â†’ Continue flow

### Form Recovery

1. Error occurs â†’ Preserve form data
2. User can: Retry submission, Save as draft, Reset form
3. Draft saved â†’ Can be restored within 24 hours
4. Successful retry â†’ Form submitted

### Real-time Recovery

1. Connection lost â†’ Show status indicator
2. Auto-reconnect attempts (5 times by default)
3. If reconnection fails â†’ Offer fallback to polling
4. Connection restored â†’ Resume real-time updates

## Testing Error Boundaries

### Manual Testing

1. Disconnect network to test connection errors
2. Submit invalid data to test validation errors
3. Use test card numbers to simulate payment failures
4. Kill WebSocket connections to test real-time errors

### Automated Testing

```tsx
import { render, screen } from '@testing-library/react'
import { PaymentErrorBoundary } from '@/components/payments/PaymentErrorBoundary'

test('handles payment errors gracefully', () => {
  const ThrowError = () => {
    throw new Error('Your card was declined')
  }

  render(
    <PaymentErrorBoundary>
      <ThrowError />
    </PaymentErrorBoundary>
  )

  expect(screen.getByText('Card Declined')).toBeInTheDocument()
  expect(screen.getByText('Update Payment Method')).toBeInTheDocument()
})
```

## Troubleshooting

### Payment Errors Not Caught

- Ensure error is thrown within the boundary
- Check that Stripe errors are properly propagated
- Verify error boundary is not nested incorrectly

### Form Data Not Preserved

- Enable `preserveFormData` prop
- Ensure forms have proper name attributes
- Check localStorage permissions

### Real-time Reconnection Failing

- Verify WebSocket URL is correct
- Check authentication tokens
- Monitor console for connection errors
- Ensure fallback mechanisms are implemented

## Migration Guide

### Updating Existing Components

Before:

```tsx
function PaymentForm() {
  try {
    // Payment logic
  } catch (error) {
    // Basic error handling
  }
}
```

After:

```tsx
import { withPaymentErrorBoundary } from '@/components/payments/PaymentErrorBoundary'

const PaymentForm = withPaymentErrorBoundary(
  function PaymentForm() {
    // Payment logic (no try/catch needed)
  },
  {
    preserveFormData: true,
    onRetry: () => window.location.reload(),
  }
)
```

This approach provides better error handling, user experience, and recovery options.
</file>

<file path="docs/FEATURE_ERROR_BOUNDARIES_SUMMARY.md">
# Feature-Level Error Boundaries Implementation Summary

## Overview

Successfully implemented specialized error boundaries for the DCE Platform to protect critical user flows from errors. The implementation focuses on three key areas: payment processing, form handling, and real-time features.

## Components Created

### 1. Payment Error Boundary (`/src/components/payments/PaymentErrorBoundary.tsx`)

- **Purpose**: Protects Stripe payment flows from failures
- **Features**:
  - Categorizes payment errors (card declined, insufficient funds, network issues)
  - Preserves form data during errors
  - Provides payment-specific recovery options
  - Integrates with Sentry for error tracking
- **Recovery Options**:
  - Retry payment
  - Update payment method
  - Contact support

### 2. Form Error Boundary (`/src/components/forms/FormErrorBoundary.tsx`)

- **Purpose**: Handles complex form validation and submission errors
- **Features**:
  - Distinguishes between validation and submission errors
  - Auto-saves form data every 5 seconds
  - Draft functionality with 24-hour expiration
  - Retry mechanism with max attempt limits
- **Recovery Options**:
  - Retry submission
  - Save as draft
  - Reset form

### 3. Real-time Error Boundary (`/src/components/realtime/RealtimeErrorBoundary.tsx`)

- **Purpose**: Manages WebSocket and real-time connection failures
- **Features**:
  - Automatic reconnection with exponential backoff
  - Connection status indicator
  - Fallback to polling mode
  - Preserves app functionality during disconnections
- **Recovery Options**:
  - Reconnect now
  - Continue with limited features
  - Refresh page

## Component Integrations

### Payment Components

- **PaymentForm**: Wrapped with PaymentErrorBoundary
- **PaymentDashboard**: Protected payment displays
- **StripeConnectOnboarding**: Error handling for onboarding flows

### Form Components

- **CreateCampaignPage**: Multi-step form with draft saving
- **Onboarding forms**: Protected with validation error handling
- **Settings forms**: Error recovery for configuration changes

### Real-time Components

- **WebhookHandler**: Wrapped for Stripe webhook processing
- **RealTimeDashboard**: Protected live data displays
- **Call tracking**: Error handling for real-time call data

## Higher-Order Components (HOCs)

Created separate HOC files to avoid fast refresh warnings:

- `withPaymentErrorBoundary`
- `withFormErrorBoundary`
- `withRealtimeErrorBoundary`
- `withProtectedRoute`

## Testing

- Created comprehensive test suite (`FeatureErrorBoundaries.test.tsx`)
- Tests cover all error scenarios and recovery mechanisms
- Validates proper error categorization
- Ensures data preservation works correctly

## Error Recovery Flows

### Payment Recovery Flow

1. Payment error occurs
2. Error is categorized (declined, network, etc.)
3. Form data is preserved
4. User sees specific error message
5. Recovery options: Retry, Update payment, Contact support

### Form Recovery Flow

1. Form error occurs (validation or submission)
2. Form data is automatically captured
3. Draft is saved to localStorage
4. User can retry, save draft, or reset
5. Drafts expire after 24 hours

### Real-time Recovery Flow

1. Connection lost
2. Status indicator appears
3. Auto-reconnect attempts (5 times)
4. Exponential backoff between attempts
5. Fallback to polling if reconnection fails

## Best Practices Implemented

1. **Error Categorization**: Each boundary intelligently categorizes errors for appropriate handling
2. **Data Preservation**: User data is never lost during errors
3. **User Communication**: Clear error messages with actionable recovery options
4. **Progressive Enhancement**: Features degrade gracefully during failures
5. **Monitoring Integration**: All errors are tracked in Sentry with context

## Usage Examples

### Payment Form Protection

```tsx
import PaymentForm from '@/components/payments/PaymentForm'

// Already includes error boundary
;<PaymentForm amount={5000} onSuccess={handleSuccess} onError={handleError} />
```

### Campaign Creation Protection

```tsx
import CreateCampaignPage from '@/pages/campaigns/CreateCampaignPage'

// Already wrapped with FormErrorBoundary
;<CreateCampaignPage />
```

### Real-time Dashboard Protection

```tsx
import RealTimeDashboard from '@/components/dashboard/RealTimeDashboard'

// Includes RealtimeErrorBoundary
;<RealTimeDashboard userId={user.id} userType="buyer" />
```

## Documentation

- **Usage Guide**: `/docs/ERROR_BOUNDARIES_USAGE.md`
- **Implementation Details**: Component source files
- **Testing Guide**: Test files demonstrate all scenarios

## Success Metrics

âœ… Payment errors don't crash the application
âœ… Form data is preserved during failures
âœ… Real-time features continue working offline
âœ… Users have clear recovery paths
âœ… All components maintain TypeScript type safety
âœ… ESLint compliance with no errors
âœ… Comprehensive test coverage

## Next Steps

1. Monitor error rates in production
2. Gather user feedback on recovery flows
3. Optimize reconnection strategies based on usage patterns
4. Add analytics to track recovery success rates
</file>

<file path="netlify/functions/auth-login.ts">
import type { Handler } from '@netlify/functions'
import { withoutAuth, ApiError } from '../../src/lib/auth-middleware'
import { z } from 'zod'

const loginSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z.string().min(1, 'Password is required'),
})

type LoginRequest = z.infer<typeof loginSchema>

export const handler: Handler = async (event) => {
  if (event.httpMethod === 'OPTIONS') {
    return {
      statusCode: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization',
        'Access-Control-Allow-Methods': 'POST, OPTIONS',
      },
      body: '',
    }
  }

  if (event.httpMethod !== 'POST') {
    return {
      statusCode: 405,
      body: JSON.stringify({ error: 'Method not allowed' }),
    }
  }

  return withoutAuth(event, async (supabase, request) => {
    if (!request.body) {
      throw new ApiError('Request body is required', 400)
    }

    const requestData: LoginRequest = loginSchema.parse(JSON.parse(request.body))

    // Authenticate with Supabase
    const { data: authData, error: authError } = await supabase.auth.signInWithPassword({
      email: requestData.email,
      password: requestData.password,
    })

    if (authError) {
      console.error('Login error:', authError)
      throw new ApiError('Invalid email or password', 401, 'INVALID_CREDENTIALS')
    }

    if (!authData.user) {
      throw new ApiError('Login failed', 500, 'LOGIN_FAILED')
    }

    // Get user profile and role information
    const { data: userData, error: userError } = await supabase
      .from('users')
      .select('id, email, first_name, last_name, status, is_active')
      .eq('id', authData.user.id)
      .single()

    if (userError) {
      console.error('Error fetching user data:', userError)
      throw new ApiError('User not found', 404, 'USER_NOT_FOUND')
    }

    if (!userData.is_active || userData.status !== 'active') {
      throw new ApiError('Account is not active', 403, 'ACCOUNT_INACTIVE')
    }

    // Determine user role
    let userType: 'supplier' | 'buyer' | 'admin' | undefined

    const [supplierCheck, buyerCheck, adminCheck] = await Promise.all([
      supabase.from('suppliers').select('id, status').eq('user_id', authData.user.id).single(),
      supabase.from('buyers').select('id, status').eq('user_id', authData.user.id).single(),
      supabase.from('admins').select('id, role').eq('user_id', authData.user.id).single(),
    ])

    if (adminCheck.data) {
      userType = 'admin'
    } else if (buyerCheck.data) {
      userType = 'buyer'
      if (buyerCheck.data.status !== 'active') {
        throw new ApiError('Buyer account is not active', 403, 'ACCOUNT_INACTIVE')
      }
    } else if (supplierCheck.data) {
      userType = 'supplier'
      if (supplierCheck.data.status !== 'active') {
        throw new ApiError('Supplier account is not active', 403, 'ACCOUNT_INACTIVE')
      }
    }

    return {
      success: true,
      message: 'Login successful',
      user: {
        id: authData.user.id,
        email: authData.user.email,
        firstName: userData.first_name,
        lastName: userData.last_name,
        userType,
        needsEmailVerification: !authData.user.email_confirmed_at,
      },
      session: {
        access_token: authData.session?.access_token,
        refresh_token: authData.session?.refresh_token,
        expires_at: authData.session?.expires_at,
      },
    }
  })
}
</file>

<file path="netlify/functions/auth-logout.ts">
import type { Handler } from '@netlify/functions'
import { withAuth } from '../../src/lib/auth-middleware'

export const handler: Handler = async (event) => {
  if (event.httpMethod === 'OPTIONS') {
    return {
      statusCode: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization',
        'Access-Control-Allow-Methods': 'POST, OPTIONS',
      },
      body: '',
    }
  }

  if (event.httpMethod !== 'POST') {
    return {
      statusCode: 405,
      body: JSON.stringify({ error: 'Method not allowed' }),
    }
  }

  return withAuth(event, async (context) => {
    // Sign out the user from Supabase
    const { error } = await context.supabase.auth.signOut()

    if (error) {
      console.error('Logout error:', error)
      // Don't throw error, logout should always succeed from client perspective
    }

    return {
      success: true,
      message: 'Logged out successfully',
    }
  })
}
</file>

<file path="netlify/functions/auth-refresh.ts">
import type { Handler } from '@netlify/functions'
import { withoutAuth, ApiError } from '../../src/lib/auth-middleware'
import { z } from 'zod'

const refreshTokenSchema = z.object({
  refresh_token: z.string().min(1, 'Refresh token is required'),
})

type RefreshTokenRequest = z.infer<typeof refreshTokenSchema>

export const handler: Handler = async (event) => {
  if (event.httpMethod === 'OPTIONS') {
    return {
      statusCode: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization',
        'Access-Control-Allow-Methods': 'POST, OPTIONS',
      },
      body: '',
    }
  }

  if (event.httpMethod !== 'POST') {
    return {
      statusCode: 405,
      body: JSON.stringify({ error: 'Method not allowed' }),
    }
  }

  return withoutAuth(event, async (supabase, request) => {
    if (!request.body) {
      throw new ApiError('Request body is required', 400)
    }

    const requestData: RefreshTokenRequest = refreshTokenSchema.parse(JSON.parse(request.body))

    // Refresh the session
    const { data, error } = await supabase.auth.refreshSession({
      refresh_token: requestData.refresh_token,
    })

    if (error) {
      console.error('Token refresh error:', error)
      throw new ApiError('Invalid or expired refresh token', 401, 'INVALID_REFRESH_TOKEN')
    }

    if (!data.session || !data.user) {
      throw new ApiError('Failed to refresh session', 500, 'REFRESH_FAILED')
    }

    // Get updated user information
    const { data: userData, error: userError } = await supabase
      .from('users')
      .select('id, email, first_name, last_name, status, is_active')
      .eq('id', data.user.id)
      .single()

    if (userError) {
      console.error('Error fetching user data:', userError)
      throw new ApiError('User not found', 404, 'USER_NOT_FOUND')
    }

    if (!userData.is_active || userData.status !== 'active') {
      throw new ApiError('Account is not active', 403, 'ACCOUNT_INACTIVE')
    }

    // Determine user role
    let userType: 'supplier' | 'buyer' | 'admin' | undefined

    const [supplierCheck, buyerCheck, adminCheck] = await Promise.all([
      supabase.from('suppliers').select('id, status').eq('user_id', data.user.id).single(),
      supabase.from('buyers').select('id, status').eq('user_id', data.user.id).single(),
      supabase.from('admins').select('id, role').eq('user_id', data.user.id).single(),
    ])

    if (adminCheck.data) {
      userType = 'admin'
    } else if (buyerCheck.data && buyerCheck.data.status === 'active') {
      userType = 'buyer'
    } else if (supplierCheck.data && supplierCheck.data.status === 'active') {
      userType = 'supplier'
    }

    return {
      success: true,
      message: 'Session refreshed successfully',
      user: {
        id: data.user.id,
        email: data.user.email,
        firstName: userData.first_name,
        lastName: userData.last_name,
        userType,
        needsEmailVerification: !data.user.email_confirmed_at,
      },
      session: {
        access_token: data.session.access_token,
        refresh_token: data.session.refresh_token,
        expires_at: data.session.expires_at,
      },
    }
  })
}
</file>

<file path="netlify/functions/auth-reset-password.ts">
import type { Handler } from '@netlify/functions'
import { withoutAuth, ApiError } from '../../src/lib/auth-middleware'
import { z } from 'zod'

const resetPasswordSchema = z.object({
  email: z.string().email('Invalid email address'),
})

type ResetPasswordRequest = z.infer<typeof resetPasswordSchema>

export const handler: Handler = async (event) => {
  if (event.httpMethod === 'OPTIONS') {
    return {
      statusCode: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization',
        'Access-Control-Allow-Methods': 'POST, OPTIONS',
      },
      body: '',
    }
  }

  if (event.httpMethod !== 'POST') {
    return {
      statusCode: 405,
      body: JSON.stringify({ error: 'Method not allowed' }),
    }
  }

  return withoutAuth(event, async (supabase, request) => {
    if (!request.body) {
      throw new ApiError('Request body is required', 400)
    }

    const requestData: ResetPasswordRequest = resetPasswordSchema.parse(JSON.parse(request.body))

    // Check if user exists first
    const { data: existingUser } = await supabase
      .from('users')
      .select('id, is_active, status')
      .eq('email', requestData.email)
      .single()

    if (!existingUser) {
      // Don't reveal if user exists or not for security
      return {
        success: true,
        message: 'If an account with that email exists, a password reset link has been sent.',
      }
    }

    if (!existingUser.is_active || existingUser.status !== 'active') {
      throw new ApiError('Account is not active', 403, 'ACCOUNT_INACTIVE')
    }

    // Send password reset email
    const { error } = await supabase.auth.resetPasswordForEmail(requestData.email, {
      redirectTo: `${process.env.VITE_APP_URL || 'http://localhost:5173'}/reset-password`,
    })

    if (error) {
      console.error('Password reset error:', error)
      throw new ApiError('Failed to send password reset email', 500, 'RESET_FAILED')
    }

    return {
      success: true,
      message: 'If an account with that email exists, a password reset link has been sent.',
    }
  })
}
</file>

<file path="netlify/functions/auth-signup.ts">
import type { Handler } from '@netlify/functions'
import { withoutAuth, ApiError } from '../../src/lib/auth-middleware'
import { z } from 'zod'

const signupSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z.string().min(8, 'Password must be at least 8 characters'),
  firstName: z.string().min(1, 'First name is required'),
  lastName: z.string().min(1, 'Last name is required'),
  userType: z.enum(['supplier', 'buyer'], {
    errorMap: () => ({ message: 'User type must be either supplier or buyer' }),
  }),
  companyName: z.string().min(1, 'Company name is required'),
  phone: z.string().optional(),
  website: z.string().url().optional().or(z.literal('')),
})

type SignupRequest = z.infer<typeof signupSchema>

export const handler: Handler = async (event) => {
  if (event.httpMethod === 'OPTIONS') {
    return {
      statusCode: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization',
        'Access-Control-Allow-Methods': 'POST, OPTIONS',
      },
      body: '',
    }
  }

  if (event.httpMethod !== 'POST') {
    return {
      statusCode: 405,
      body: JSON.stringify({ error: 'Method not allowed' }),
    }
  }

  return withoutAuth(event, async (supabase, request) => {
    if (!request.body) {
      throw new ApiError('Request body is required', 400)
    }

    const requestData: SignupRequest = signupSchema.parse(JSON.parse(request.body))

    // Check if user already exists
    const { data: existingUser } = await supabase
      .from('users')
      .select('id')
      .eq('email', requestData.email)
      .single()

    if (existingUser) {
      throw new ApiError('User with this email already exists', 409, 'USER_EXISTS')
    }

    // Create auth user
    const { data: authData, error: authError } = await supabase.auth.signUp({
      email: requestData.email,
      password: requestData.password,
      options: {
        data: {
          first_name: requestData.firstName,
          last_name: requestData.lastName,
          user_type: requestData.userType,
        },
      },
    })

    if (authError) {
      console.error('Auth signup error:', authError)
      throw new ApiError(authError.message, 400, 'SIGNUP_FAILED')
    }

    if (!authData.user) {
      throw new ApiError('Failed to create user account', 500, 'SIGNUP_FAILED')
    }

    // Create user profile
    const { error: userError } = await supabase.from('users').insert({
      id: authData.user.id,
      email: requestData.email,
      first_name: requestData.firstName,
      last_name: requestData.lastName,
      phone: requestData.phone,
      status: 'pending',
    })

    if (userError) {
      console.error('User profile creation error:', userError)
      // Clean up auth user if profile creation fails
      await supabase.auth.admin.deleteUser(authData.user.id)
      throw new ApiError('Failed to create user profile', 500, 'PROFILE_CREATION_FAILED')
    }

    // Create role-specific record
    if (requestData.userType === 'supplier') {
      const { error: supplierError } = await supabase.from('suppliers').insert({
        user_id: authData.user.id,
        company_name: requestData.companyName,
        website_url: requestData.website || null,
        status: 'pending',
      })

      if (supplierError) {
        console.error('Supplier creation error:', supplierError)
        throw new ApiError('Failed to create supplier profile', 500, 'SUPPLIER_CREATION_FAILED')
      }
    } else {
      const { error: buyerError } = await supabase.from('buyers').insert({
        user_id: authData.user.id,
        company_name: requestData.companyName,
        website_url: requestData.website || null,
        status: 'pending',
      })

      if (buyerError) {
        console.error('Buyer creation error:', buyerError)
        throw new ApiError('Failed to create buyer profile', 500, 'BUYER_CREATION_FAILED')
      }
    }

    return {
      success: true,
      message: 'Account created successfully. Please check your email to verify your account.',
      user: {
        id: authData.user.id,
        email: authData.user.email,
        userType: requestData.userType,
        needsEmailVerification: !authData.user.email_confirmed_at,
      },
    }
  })
}
</file>

<file path="netlify/functions/auth-verify-email.ts">
import type { Handler } from '@netlify/functions'
import { withoutAuth, ApiError } from '../../src/lib/auth-middleware'
import { z } from 'zod'

const verifyEmailSchema = z.object({
  token: z.string().min(1, 'Verification token is required'),
  type: z.enum(['signup', 'email_change', 'recovery'], {
    errorMap: () => ({ message: 'Invalid verification type' }),
  }),
})

type VerifyEmailRequest = z.infer<typeof verifyEmailSchema>

export const handler: Handler = async (event) => {
  if (event.httpMethod === 'OPTIONS') {
    return {
      statusCode: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization',
        'Access-Control-Allow-Methods': 'POST, OPTIONS',
      },
      body: '',
    }
  }

  if (event.httpMethod !== 'POST') {
    return {
      statusCode: 405,
      body: JSON.stringify({ error: 'Method not allowed' }),
    }
  }

  return withoutAuth(event, async (supabase, request) => {
    if (!request.body) {
      throw new ApiError('Request body is required', 400)
    }

    const requestData: VerifyEmailRequest = verifyEmailSchema.parse(JSON.parse(request.body))

    // Verify the email token
    const { data, error } = await supabase.auth.verifyOtp({
      token_hash: requestData.token,
      type: requestData.type,
    })

    if (error) {
      console.error('Email verification error:', error)
      throw new ApiError('Invalid or expired verification token', 400, 'INVALID_TOKEN')
    }

    if (!data.user) {
      throw new ApiError('Verification failed', 500, 'VERIFICATION_FAILED')
    }

    // Update user status if this is a signup verification
    if (requestData.type === 'signup') {
      const { error: updateError } = await supabase
        .from('users')
        .update({
          status: 'active',
          is_active: true,
        })
        .eq('id', data.user.id)

      if (updateError) {
        console.error('Error updating user status:', updateError)
        // Don't throw error here - verification was successful
      }

      // Also update supplier/buyer status if applicable
      const [supplierUpdate, buyerUpdate] = await Promise.all([
        supabase.from('suppliers').update({ status: 'pending' }).eq('user_id', data.user.id),
        supabase.from('buyers').update({ status: 'pending' }).eq('user_id', data.user.id),
      ])

      if (supplierUpdate.error) {
        console.error('Error updating supplier status:', supplierUpdate.error)
      }
      if (buyerUpdate.error) {
        console.error('Error updating buyer status:', buyerUpdate.error)
      }
    }

    return {
      success: true,
      message:
        requestData.type === 'signup'
          ? 'Email verified successfully. Your account is now active.'
          : 'Email verification successful.',
      user: {
        id: data.user.id,
        email: data.user.email,
        emailVerified: true,
      },
    }
  })
}
</file>

<file path="netlify/functions/campaigns-create.ts">
import type { Handler } from '@netlify/functions'
import { requireRole, ApiError } from '../../src/lib/auth-middleware'
import { z } from 'zod'

const createCampaignSchema = z.object({
  name: z
    .string()
    .min(1, 'Campaign name is required')
    .max(100, 'Name must be less than 100 characters'),
  description: z.string().max(500, 'Description must be less than 500 characters').optional(),
  category: z.string().min(1, 'Category is required'),
  vertical: z.string().min(1, 'Vertical is required'),
  bidFloor: z.number().min(0, 'Bid floor must be positive').max(1000, 'Bid floor too high'),
  maxConcurrentCalls: z
    .number()
    .int()
    .min(1, 'Must allow at least 1 concurrent call')
    .max(50, 'Too many concurrent calls'),
  qualityThreshold: z
    .number()
    .int()
    .min(1, 'Quality threshold too low')
    .max(100, 'Quality threshold too high'),
  recordingEnabled: z.boolean().default(true),
  targeting: z
    .object({
      geographic: z
        .object({
          states: z.array(z.string()).optional(),
          cities: z.array(z.string()).optional(),
          metro_areas: z.array(z.string()).optional(),
        })
        .optional(),
      demographic: z
        .object({
          age_range: z.string().optional(),
          income_level: z.string().optional(),
        })
        .optional(),
      schedule: z
        .object({
          enabled: z.boolean().default(true),
          timezone: z.string().default('UTC'),
          hours: z
            .record(
              z.string(),
              z.object({
                start: z.number().min(0).max(23),
                end: z.number().min(0).max(23),
              })
            )
            .optional(),
        })
        .optional(),
    })
    .optional(),
})

type CreateCampaignRequest = z.infer<typeof createCampaignSchema>

export const handler: Handler = async (event) => {
  if (event.httpMethod === 'OPTIONS') {
    return {
      statusCode: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization',
        'Access-Control-Allow-Methods': 'POST, OPTIONS',
      },
      body: '',
    }
  }

  if (event.httpMethod !== 'POST') {
    return {
      statusCode: 405,
      body: JSON.stringify({ error: 'Method not allowed' }),
    }
  }

  return requireRole(['supplier'])(event, async (context) => {
    if (!event.body) {
      throw new ApiError('Request body is required', 400)
    }

    const requestData: CreateCampaignRequest = createCampaignSchema.parse(JSON.parse(event.body))

    // Get supplier ID
    const { data: supplierData, error: supplierError } = await context.supabase
      .from('suppliers')
      .select('id, status, credit_balance')
      .eq('user_id', context.user!.id)
      .single()

    if (supplierError || !supplierData) {
      throw new ApiError('Supplier profile not found', 404, 'SUPPLIER_NOT_FOUND')
    }

    if (supplierData.status !== 'active') {
      throw new ApiError('Supplier account is not active', 403, 'SUPPLIER_INACTIVE')
    }

    // Check if supplier has sufficient balance for minimum bid
    const minimumBalance = requestData.bidFloor * 10 // Require 10x bid floor as minimum balance
    if (supplierData.credit_balance < minimumBalance) {
      throw new ApiError(
        `Insufficient balance. Minimum ${minimumBalance.toFixed(2)} required for this bid floor.`,
        400,
        'INSUFFICIENT_BALANCE'
      )
    }

    // Create campaign
    const { data: campaign, error: campaignError } = await context.supabase
      .from('campaigns')
      .insert({
        supplier_id: supplierData.id,
        name: requestData.name,
        description: requestData.description || null,
        category: requestData.category,
        vertical: requestData.vertical,
        bid_floor: requestData.bidFloor,
        max_concurrent_calls: requestData.maxConcurrentCalls,
        quality_threshold: requestData.qualityThreshold,
        recording_enabled: requestData.recordingEnabled,
        targeting: requestData.targeting || {},
        status: 'draft',
      })
      .select(
        `
        id,
        name,
        description,
        category,
        vertical,
        status,
        bid_floor,
        max_concurrent_calls,
        quality_threshold,
        recording_enabled,
        targeting,
        created_at,
        updated_at
      `
      )
      .single()

    if (campaignError) {
      console.error('Error creating campaign:', campaignError)
      throw new ApiError('Failed to create campaign', 500, 'CREATION_FAILED')
    }

    return {
      success: true,
      message: 'Campaign created successfully',
      data: campaign,
    }
  })
}
</file>

<file path="netlify/functions/campaigns-get.ts">
import type { Handler } from '@netlify/functions'
import { withAuth, ApiError } from '../../src/lib/auth-middleware'

export const handler: Handler = async (event) => {
  if (event.httpMethod === 'OPTIONS') {
    return {
      statusCode: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization',
        'Access-Control-Allow-Methods': 'GET, OPTIONS',
      },
      body: '',
    }
  }

  if (event.httpMethod !== 'GET') {
    return {
      statusCode: 405,
      body: JSON.stringify({ error: 'Method not allowed' }),
    }
  }

  return withAuth(event, async (context) => {
    const campaignId = event.path.split('/').pop()

    if (!campaignId) {
      throw new ApiError('Campaign ID is required', 400, 'MISSING_CAMPAIGN_ID')
    }

    // Get campaign with related data
    const { data: campaign, error: campaignError } = await context.supabase
      .from('campaigns')
      .select(
        `
        id,
        name,
        description,
        category,
        vertical,
        status,
        bid_floor,
        max_concurrent_calls,
        quality_threshold,
        recording_enabled,
        targeting,
        created_at,
        updated_at,
        suppliers!campaigns_supplier_id_fkey (
          id,
          company_name,
          business_type,
          users!suppliers_user_id_fkey (
            first_name,
            last_name,
            email
          )
        )
      `
      )
      .eq('id', campaignId)
      .single()

    if (campaignError) {
      console.error('Error fetching campaign:', campaignError)
      throw new ApiError('Campaign not found', 404, 'CAMPAIGN_NOT_FOUND')
    }

    // Check access permissions
    if (context.user?.role === 'supplier') {
      const { data: supplierData } = await context.supabase
        .from('suppliers')
        .select('id')
        .eq('user_id', context.user.id)
        .single()

      if (!supplierData || campaign.suppliers?.id !== supplierData.id) {
        throw new ApiError('Access denied', 403, 'ACCESS_DENIED')
      }
    }
    // Buyers can view active campaigns, admins can view all campaigns

    // Get campaign statistics
    const { data: stats } = await context.supabase
      .from('campaign_stats')
      .select('*')
      .eq('campaign_id', campaignId)
      .order('date', { ascending: false })
      .limit(30) // Last 30 days

    // Get recent calls for this campaign
    const { data: recentCalls } = await context.supabase
      .from('calls')
      .select(
        `
        id,
        tracking_number,
        caller_number,
        duration_seconds,
        status,
        quality_score,
        payout_amount,
        charge_amount,
        started_at,
        ended_at,
        caller_location,
        metadata
      `
      )
      .eq('campaign_id', campaignId)
      .order('started_at', { ascending: false })
      .limit(10)

    // Get tracking numbers for this campaign
    const { data: trackingNumbers } = await context.supabase
      .from('tracking_numbers')
      .select('*')
      .eq('campaign_id', campaignId)
      .eq('is_active', true)

    return {
      success: true,
      data: {
        campaign,
        stats: stats || [],
        recentCalls: recentCalls || [],
        trackingNumbers: trackingNumbers || [],
      },
    }
  })
}
</file>

<file path="netlify/functions/campaigns-list.ts">
import type { Handler } from '@netlify/functions'
import { requireRole, ApiError } from '../../src/lib/auth-middleware'
import { z } from 'zod'

const querySchema = z.object({
  page: z.coerce.number().min(1).default(1),
  limit: z.coerce.number().min(1).max(100).default(20),
  status: z.enum(['draft', 'active', 'paused', 'completed']).optional(),
  vertical: z.string().optional(),
  search: z.string().optional(),
})

export const handler: Handler = async (event) => {
  if (event.httpMethod === 'OPTIONS') {
    return {
      statusCode: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization',
        'Access-Control-Allow-Methods': 'GET, OPTIONS',
      },
      body: '',
    }
  }

  if (event.httpMethod !== 'GET') {
    return {
      statusCode: 405,
      body: JSON.stringify({ error: 'Method not allowed' }),
    }
  }

  return requireRole(['supplier', 'buyer', 'admin'])(event, async (context) => {
    const queryParams = querySchema.parse(event.queryStringParameters || {})
    const { page, limit, status, vertical, search } = queryParams
    const offset = (page - 1) * limit

    let query = context.supabase.from('campaigns').select(
      `
        id,
        name,
        description,
        category,
        vertical,
        status,
        bid_floor,
        max_concurrent_calls,
        quality_threshold,
        targeting,
        created_at,
        updated_at,
        suppliers!campaigns_supplier_id_fkey (
          id,
          company_name,
          users!suppliers_user_id_fkey (
            first_name,
            last_name,
            email
          )
        )
      `,
      { count: 'exact' }
    )

    // Role-based filtering
    if (context.user?.role === 'supplier') {
      // Suppliers can only see campaigns they created
      const { data: supplierData } = await context.supabase
        .from('suppliers')
        .select('id')
        .eq('user_id', context.user.id)
        .single()

      if (!supplierData) {
        throw new ApiError('Supplier profile not found', 404, 'SUPPLIER_NOT_FOUND')
      }

      query = query.eq('supplier_id', supplierData.id)
    } else if (context.user?.role === 'buyer') {
      // Buyers can see all active campaigns or their own buyer campaigns
      // For this endpoint, show active campaigns they can bid on
      query = query.eq('status', 'active')
    }
    // Admins can see all campaigns (no additional filtering)

    // Apply filters
    if (status) {
      query = query.eq('status', status)
    }

    if (vertical) {
      query = query.eq('vertical', vertical)
    }

    if (search) {
      query = query.or(
        `name.ilike.%${search}%,description.ilike.%${search}%,category.ilike.%${search}%`
      )
    }

    // Apply pagination and ordering
    const {
      data: campaigns,
      error,
      count,
    } = await query.order('created_at', { ascending: false }).range(offset, offset + limit - 1)

    if (error) {
      console.error('Error fetching campaigns:', error)
      throw new ApiError('Failed to fetch campaigns', 500, 'FETCH_FAILED')
    }

    // Calculate pagination metadata
    const totalPages = Math.ceil((count || 0) / limit)
    const hasNext = page < totalPages
    const hasPrev = page > 1

    return {
      success: true,
      data: campaigns || [],
      pagination: {
        page,
        limit,
        total: count || 0,
        totalPages,
        hasNext,
        hasPrev,
      },
    }
  })
}
</file>

<file path="netlify/functions/campaigns-update.ts">
import type { Handler } from '@netlify/functions'
import { requireRole, ApiError } from '../../src/lib/auth-middleware'
import { z } from 'zod'

const updateCampaignSchema = z.object({
  name: z
    .string()
    .min(1, 'Campaign name is required')
    .max(100, 'Name must be less than 100 characters')
    .optional(),
  description: z.string().max(500, 'Description must be less than 500 characters').optional(),
  status: z.enum(['draft', 'active', 'paused', 'completed']).optional(),
  bidFloor: z
    .number()
    .min(0, 'Bid floor must be positive')
    .max(1000, 'Bid floor too high')
    .optional(),
  maxConcurrentCalls: z
    .number()
    .int()
    .min(1, 'Must allow at least 1 concurrent call')
    .max(50, 'Too many concurrent calls')
    .optional(),
  qualityThreshold: z
    .number()
    .int()
    .min(1, 'Quality threshold too low')
    .max(100, 'Quality threshold too high')
    .optional(),
  recordingEnabled: z.boolean().optional(),
  targeting: z
    .object({
      geographic: z
        .object({
          states: z.array(z.string()).optional(),
          cities: z.array(z.string()).optional(),
          metro_areas: z.array(z.string()).optional(),
        })
        .optional(),
      demographic: z
        .object({
          age_range: z.string().optional(),
          income_level: z.string().optional(),
        })
        .optional(),
      schedule: z
        .object({
          enabled: z.boolean().default(true),
          timezone: z.string().default('UTC'),
          hours: z
            .record(
              z.string(),
              z.object({
                start: z.number().min(0).max(23),
                end: z.number().min(0).max(23),
              })
            )
            .optional(),
        })
        .optional(),
    })
    .optional(),
})

type UpdateCampaignRequest = z.infer<typeof updateCampaignSchema>

export const handler: Handler = async (event) => {
  if (event.httpMethod === 'OPTIONS') {
    return {
      statusCode: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization',
        'Access-Control-Allow-Methods': 'PUT, OPTIONS',
      },
      body: '',
    }
  }

  if (event.httpMethod !== 'PUT') {
    return {
      statusCode: 405,
      body: JSON.stringify({ error: 'Method not allowed' }),
    }
  }

  return requireRole(['supplier', 'admin'])(event, async (context) => {
    const campaignId = event.path.split('/').pop()

    if (!campaignId) {
      throw new ApiError('Campaign ID is required', 400, 'MISSING_CAMPAIGN_ID')
    }

    if (!event.body) {
      throw new ApiError('Request body is required', 400)
    }

    const requestData: UpdateCampaignRequest = updateCampaignSchema.parse(JSON.parse(event.body))

    // Get existing campaign
    const { data: existingCampaign, error: fetchError } = await context.supabase
      .from('campaigns')
      .select(
        `
        id,
        supplier_id,
        status,
        bid_floor,
        suppliers!campaigns_supplier_id_fkey (
          id,
          user_id,
          credit_balance
        )
      `
      )
      .eq('id', campaignId)
      .single()

    if (fetchError || !existingCampaign) {
      throw new ApiError('Campaign not found', 404, 'CAMPAIGN_NOT_FOUND')
    }

    // Check access permissions
    if (context.user?.role === 'supplier') {
      const { data: supplierData } = await context.supabase
        .from('suppliers')
        .select('id')
        .eq('user_id', context.user.id)
        .single()

      if (!supplierData || existingCampaign.supplier_id !== supplierData.id) {
        throw new ApiError('Access denied', 403, 'ACCESS_DENIED')
      }
    }

    // If updating bid floor, check supplier balance
    if (requestData.bidFloor && requestData.bidFloor !== existingCampaign.bid_floor) {
      const minimumBalance = requestData.bidFloor * 10
      if (existingCampaign.suppliers?.credit_balance < minimumBalance) {
        throw new ApiError(
          `Insufficient balance. Minimum ${minimumBalance.toFixed(2)} required for this bid floor.`,
          400,
          'INSUFFICIENT_BALANCE'
        )
      }
    }

    // Validate status transitions
    if (requestData.status && requestData.status !== existingCampaign.status) {
      const validTransitions: Record<string, string[]> = {
        draft: ['active', 'completed'],
        active: ['paused', 'completed'],
        paused: ['active', 'completed'],
        completed: [], // Cannot transition from completed
      }

      const allowedStatuses = validTransitions[existingCampaign.status] || []
      if (!allowedStatuses.includes(requestData.status)) {
        throw new ApiError(
          `Cannot transition from ${existingCampaign.status} to ${requestData.status}`,
          400,
          'INVALID_STATUS_TRANSITION'
        )
      }
    }

    // Build update object
    const updateData: Record<string, unknown> = {}

    if (requestData.name !== undefined) updateData.name = requestData.name
    if (requestData.description !== undefined) updateData.description = requestData.description
    if (requestData.status !== undefined) updateData.status = requestData.status
    if (requestData.bidFloor !== undefined) updateData.bid_floor = requestData.bidFloor
    if (requestData.maxConcurrentCalls !== undefined)
      updateData.max_concurrent_calls = requestData.maxConcurrentCalls
    if (requestData.qualityThreshold !== undefined)
      updateData.quality_threshold = requestData.qualityThreshold
    if (requestData.recordingEnabled !== undefined)
      updateData.recording_enabled = requestData.recordingEnabled
    if (requestData.targeting !== undefined) updateData.targeting = requestData.targeting

    // Update campaign
    const { data: campaign, error: updateError } = await context.supabase
      .from('campaigns')
      .update(updateData)
      .eq('id', campaignId)
      .select(
        `
        id,
        name,
        description,
        category,
        vertical,
        status,
        bid_floor,
        max_concurrent_calls,
        quality_threshold,
        recording_enabled,
        targeting,
        created_at,
        updated_at
      `
      )
      .single()

    if (updateError) {
      console.error('Error updating campaign:', updateError)
      throw new ApiError('Failed to update campaign', 500, 'UPDATE_FAILED')
    }

    return {
      success: true,
      message: 'Campaign updated successfully',
      data: campaign,
    }
  })
}
</file>

<file path="netlify/functions/realtime-calls.ts">
import type { Handler } from '@netlify/functions'
import { withAuth, ApiError } from '../../src/lib/auth-middleware'
import { z } from 'zod'

const callSubscriptionSchema = z.object({
  action: z.enum(['subscribe', 'unsubscribe']),
  callId: z.string().uuid('Invalid call ID').optional(),
  campaignId: z.string().uuid('Invalid campaign ID').optional(),
  filters: z
    .object({
      status: z
        .array(z.enum(['initiated', 'ringing', 'connected', 'completed', 'failed', 'rejected']))
        .optional(),
      qualityScoreMin: z.number().min(0).max(100).optional(),
      dateRange: z
        .object({
          start: z.string().datetime(),
          end: z.string().datetime(),
        })
        .optional(),
    })
    .optional(),
})

type CallSubscriptionRequest = z.infer<typeof callSubscriptionSchema>

export const handler: Handler = async (event) => {
  if (event.httpMethod === 'OPTIONS') {
    return {
      statusCode: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization',
        'Access-Control-Allow-Methods': 'POST, OPTIONS',
      },
      body: '',
    }
  }

  if (event.httpMethod !== 'POST') {
    return {
      statusCode: 405,
      body: JSON.stringify({ error: 'Method not allowed' }),
    }
  }

  return withAuth(event, async (context, request) => {
    if (!request.body) {
      throw new ApiError('Request body is required', 400)
    }

    const requestData: CallSubscriptionRequest = callSubscriptionSchema.parse(
      JSON.parse(request.body)
    )

    // Generate channel name and filters based on user role
    let channelName = 'calls'
    const channelFilters: string[] = []

    // Role-based filtering
    if (context.user?.role === 'supplier') {
      // Suppliers only see calls from their campaigns
      const { data: supplierData } = await context.supabase
        .from('suppliers')
        .select('id')
        .eq('user_id', context.user.id)
        .single()

      if (supplierData) {
        // Get all campaigns for this supplier
        const { data: campaigns } = await context.supabase
          .from('campaigns')
          .select('id')
          .eq('supplier_id', supplierData.id)

        if (campaigns && campaigns.length > 0) {
          const campaignIds = campaigns.map((c) => c.id)
          channelFilters.push(`campaign_id=in.(${campaignIds.join(',')})`)
        } else {
          // No campaigns, no calls to see
          throw new ApiError('No campaigns found for supplier', 404, 'NO_CAMPAIGNS')
        }
      }
    } else if (context.user?.role === 'buyer') {
      // Buyers see calls from their buyer campaigns
      const { data: buyerData } = await context.supabase
        .from('buyers')
        .select('id')
        .eq('user_id', context.user.id)
        .single()

      if (buyerData) {
        // Get all buyer campaigns
        const { data: buyerCampaigns } = await context.supabase
          .from('buyer_campaigns')
          .select('id')
          .eq('buyer_id', buyerData.id)

        if (buyerCampaigns && buyerCampaigns.length > 0) {
          const campaignIds = buyerCampaigns.map((bc) => bc.id)
          channelFilters.push(`buyer_campaign_id=in.(${campaignIds.join(',')})`)
        }
      }
    }
    // Admins see all calls (no filtering)

    // Specific campaign filter
    if (requestData.campaignId) {
      // Verify access to the campaign
      const { data: campaign } = await context.supabase
        .from('campaigns')
        .select('id, supplier_id')
        .eq('id', requestData.campaignId)
        .single()

      if (!campaign) {
        throw new ApiError('Campaign not found', 404, 'CAMPAIGN_NOT_FOUND')
      }

      // Check access permissions for suppliers
      if (context.user?.role === 'supplier') {
        const { data: supplierData } = await context.supabase
          .from('suppliers')
          .select('id')
          .eq('user_id', context.user.id)
          .single()

        if (!supplierData || campaign.supplier_id !== supplierData.id) {
          throw new ApiError('Access denied', 403, 'ACCESS_DENIED')
        }
      }

      channelFilters.push(`campaign_id=eq.${requestData.campaignId}`)
    }

    // Specific call subscription
    if (requestData.callId) {
      // Verify access to the call
      const { data: call } = await context.supabase
        .from('calls')
        .select('id, campaign_id, buyer_campaign_id')
        .eq('id', requestData.callId)
        .single()

      if (!call) {
        throw new ApiError('Call not found', 404, 'CALL_NOT_FOUND')
      }

      // Verify user has access to this call based on campaign ownership
      // (Access check logic would go here based on role)

      channelName = `calls:id=eq.${requestData.callId}`
    }

    // Apply additional filters
    if (requestData.filters) {
      if (requestData.filters.status && requestData.filters.status.length > 0) {
        const statusFilter = requestData.filters.status.map((s) => `status=eq.${s}`).join(',')
        channelFilters.push(`(${statusFilter})`)
      }

      if (requestData.filters.qualityScoreMin !== undefined) {
        channelFilters.push(`quality_score=gte.${requestData.filters.qualityScoreMin}`)
      }

      if (requestData.filters.dateRange) {
        channelFilters.push(`started_at=gte.${requestData.filters.dateRange.start}`)
        channelFilters.push(`started_at=lte.${requestData.filters.dateRange.end}`)
      }
    }

    // Build final channel name
    if (channelFilters.length > 0 && !requestData.callId) {
      channelName = `calls:${channelFilters.join(':')}`
    }

    // Create subscription configuration
    const subscriptionConfig = {
      event: '*', // Listen to all events
      schema: 'public',
      table: 'calls',
      filter: channelFilters.length > 0 ? channelFilters.join(' AND ') : undefined,
    }

    // Generate JWT token for real-time subscription
    const realtimeToken = await context.supabase.auth.getSession()

    if (!realtimeToken.data.session) {
      throw new ApiError('Failed to generate realtime token', 500, 'TOKEN_GENERATION_FAILED')
    }

    // Get call quality subscription config if needed
    const qualitySubscriptionConfig = requestData.callId
      ? {
          event: '*',
          schema: 'public',
          table: 'call_quality_scores',
          filter: `call_id=eq.${requestData.callId}`,
        }
      : null

    return {
      success: true,
      action: requestData.action,
      subscription: {
        channel: channelName,
        config: subscriptionConfig,
        qualityConfig: qualitySubscriptionConfig,
        token: realtimeToken.data.session.access_token,
        url: process.env.VITE_SUPABASE_URL || '',
        anonKey: process.env.VITE_SUPABASE_ANON_KEY || '',
      },
      instructions: {
        subscribe: `Use the Supabase client to subscribe to channel: ${channelName}`,
        events: ['INSERT', 'UPDATE', 'DELETE'],
        example: `
          const channel = supabase
            .channel('${channelName}')
            .on('postgres_changes', ${JSON.stringify(subscriptionConfig, null, 2)}, 
              (payload) => {
                console.log('Call change:', payload)
                // Handle different event types
                switch(payload.eventType) {
                  case 'INSERT':
                    // New call started
                    break;
                  case 'UPDATE':
                    // Call status updated
                    break;
                  case 'DELETE':
                    // Call removed (rare)
                    break;
                }
              }
            )
            ${
              qualitySubscriptionConfig
                ? `.on('postgres_changes', ${JSON.stringify(
                    qualitySubscriptionConfig,
                    null,
                    2
                  )}, (payload) => console.log('Quality score update:', payload))`
                : ''
            }
            .subscribe()
        `,
      },
    }
  })
}
</file>

<file path="netlify/functions/realtime-campaigns.ts">
import type { Handler } from '@netlify/functions'
import { withAuth, ApiError } from '../../src/lib/auth-middleware'
import { z } from 'zod'

const subscriptionSchema = z.object({
  action: z.enum(['subscribe', 'unsubscribe']),
  campaignId: z.string().uuid('Invalid campaign ID').optional(),
  filters: z
    .object({
      status: z.array(z.enum(['draft', 'active', 'paused', 'completed'])).optional(),
      vertical: z.array(z.string()).optional(),
      ownCampaignsOnly: z.boolean().optional(),
    })
    .optional(),
})

type SubscriptionRequest = z.infer<typeof subscriptionSchema>

export const handler: Handler = async (event) => {
  if (event.httpMethod === 'OPTIONS') {
    return {
      statusCode: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization',
        'Access-Control-Allow-Methods': 'POST, OPTIONS',
      },
      body: '',
    }
  }

  if (event.httpMethod !== 'POST') {
    return {
      statusCode: 405,
      body: JSON.stringify({ error: 'Method not allowed' }),
    }
  }

  return withAuth(event, async (context, request) => {
    if (!request.body) {
      throw new ApiError('Request body is required', 400)
    }

    const requestData: SubscriptionRequest = subscriptionSchema.parse(JSON.parse(request.body))

    // Generate channel name based on user role and filters
    let channelName = 'campaigns'
    const channelFilters: string[] = []

    // Role-based channel filtering
    if (context.user?.role === 'supplier') {
      // Get supplier ID
      const { data: supplierData } = await context.supabase
        .from('suppliers')
        .select('id')
        .eq('user_id', context.user.id)
        .single()

      if (supplierData) {
        channelFilters.push(`supplier_id=eq.${supplierData.id}`)
      }
    } else if (context.user?.role === 'buyer') {
      // Buyers see all active campaigns by default
      if (!requestData.filters?.status || requestData.filters.status.includes('active')) {
        channelFilters.push(`status=eq.active`)
      }
    }
    // Admins see all campaigns (no filtering)

    // Apply custom filters
    if (requestData.filters) {
      if (requestData.filters.status && requestData.filters.status.length > 0) {
        const statusFilter = requestData.filters.status.map((s) => `status=eq.${s}`).join(',')
        channelFilters.push(`(${statusFilter})`)
      }

      if (requestData.filters.vertical && requestData.filters.vertical.length > 0) {
        const verticalFilter = requestData.filters.vertical.map((v) => `vertical=eq.${v}`).join(',')
        channelFilters.push(`(${verticalFilter})`)
      }
    }

    // Specific campaign subscription
    if (requestData.campaignId) {
      // Verify access to the campaign
      const { data: campaign } = await context.supabase
        .from('campaigns')
        .select('id, supplier_id')
        .eq('id', requestData.campaignId)
        .single()

      if (!campaign) {
        throw new ApiError('Campaign not found', 404, 'CAMPAIGN_NOT_FOUND')
      }

      // Check access permissions
      if (context.user?.role === 'supplier') {
        const { data: supplierData } = await context.supabase
          .from('suppliers')
          .select('id')
          .eq('user_id', context.user.id)
          .single()

        if (!supplierData || campaign.supplier_id !== supplierData.id) {
          throw new ApiError('Access denied', 403, 'ACCESS_DENIED')
        }
      }

      channelName = `campaigns:id=eq.${requestData.campaignId}`
    } else if (channelFilters.length > 0) {
      // Build filter string for channel name
      channelName = `campaigns:${channelFilters.join(':')}`
    }

    // Create subscription configuration
    const subscriptionConfig = {
      event: '*', // Listen to all events (INSERT, UPDATE, DELETE)
      schema: 'public',
      table: 'campaigns',
      filter: channelFilters.length > 0 ? channelFilters.join(' AND ') : undefined,
    }

    // Generate JWT token for real-time subscription
    // This token will be used by the client to connect to Supabase Realtime
    const realtimeToken = await context.supabase.auth.getSession()

    if (!realtimeToken.data.session) {
      throw new ApiError('Failed to generate realtime token', 500, 'TOKEN_GENERATION_FAILED')
    }

    return {
      success: true,
      action: requestData.action,
      subscription: {
        channel: channelName,
        config: subscriptionConfig,
        token: realtimeToken.data.session.access_token,
        url: process.env.VITE_SUPABASE_URL || '',
        anonKey: process.env.VITE_SUPABASE_ANON_KEY || '',
      },
      instructions: {
        subscribe: `Use the Supabase client to subscribe to channel: ${channelName}`,
        events: ['INSERT', 'UPDATE', 'DELETE'],
        example: `
          const channel = supabase
            .channel('${channelName}')
            .on('postgres_changes', ${JSON.stringify(subscriptionConfig, null, 2)}, 
              (payload) => console.log('Campaign change:', payload)
            )
            .subscribe()
        `,
      },
    }
  })
}
</file>

<file path="netlify/functions/realtime-stats.ts">
import type { Handler } from '@netlify/functions'
import { withAuth, ApiError } from '../../src/lib/auth-middleware'
import { z } from 'zod'

const statsSubscriptionSchema = z.object({
  action: z.enum(['subscribe', 'unsubscribe']),
  statsType: z.enum(['campaign', 'supplier', 'buyer', 'platform']),
  entityId: z.string().uuid('Invalid entity ID').optional(),
  metrics: z
    .array(
      z.enum([
        'calls_count',
        'active_calls',
        'total_duration',
        'total_revenue',
        'conversion_rate',
        'quality_score_avg',
        'fraud_detection_alerts',
      ])
    )
    .optional(),
  interval: z.enum(['realtime', '1min', '5min', '15min']).default('realtime'),
})

type StatsSubscriptionRequest = z.infer<typeof statsSubscriptionSchema>

export const handler: Handler = async (event) => {
  if (event.httpMethod === 'OPTIONS') {
    return {
      statusCode: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization',
        'Access-Control-Allow-Methods': 'POST, OPTIONS',
      },
      body: '',
    }
  }

  if (event.httpMethod !== 'POST') {
    return {
      statusCode: 405,
      body: JSON.stringify({ error: 'Method not allowed' }),
    }
  }

  return withAuth(event, async (context, request) => {
    if (!request.body) {
      throw new ApiError('Request body is required', 400)
    }

    const requestData: StatsSubscriptionRequest = statsSubscriptionSchema.parse(
      JSON.parse(request.body)
    )

    // Verify access based on stats type and user role
    let channelName = ''
    const subscriptions: Array<{
      channel: string
      table: string
      filter?: string
    }> = []

    switch (requestData.statsType) {
      case 'campaign': {
        if (!requestData.entityId) {
          throw new ApiError('Campaign ID is required', 400, 'MISSING_CAMPAIGN_ID')
        }

        // Verify access to campaign
        const { data: campaign } = await context.supabase
          .from('campaigns')
          .select('id, supplier_id')
          .eq('id', requestData.entityId)
          .single()

        if (!campaign) {
          throw new ApiError('Campaign not found', 404, 'CAMPAIGN_NOT_FOUND')
        }

        // Check access for suppliers
        if (context.user?.role === 'supplier') {
          const { data: supplierData } = await context.supabase
            .from('suppliers')
            .select('id')
            .eq('user_id', context.user.id)
            .single()

          if (!supplierData || campaign.supplier_id !== supplierData.id) {
            throw new ApiError('Access denied', 403, 'ACCESS_DENIED')
          }
        }

        channelName = `stats:campaign:${requestData.entityId}`

        // Subscribe to campaign stats updates
        subscriptions.push({
          channel: channelName,
          table: 'campaign_stats',
          filter: `campaign_id=eq.${requestData.entityId}`,
        })

        // Also subscribe to live call updates for this campaign
        subscriptions.push({
          channel: `${channelName}:calls`,
          table: 'calls',
          filter: `campaign_id=eq.${requestData.entityId}`,
        })

        break
      }

      case 'supplier': {
        // Suppliers can only see their own stats
        if (context.user?.role !== 'supplier' && context.user?.role !== 'admin') {
          throw new ApiError('Access denied', 403, 'ACCESS_DENIED')
        }

        const { data: supplierData } = await context.supabase
          .from('suppliers')
          .select('id')
          .eq('user_id', context.user.id)
          .single()

        if (!supplierData) {
          throw new ApiError('Supplier not found', 404, 'SUPPLIER_NOT_FOUND')
        }

        const supplierId = requestData.entityId || supplierData.id

        // Verify access to requested supplier stats
        if (context.user?.role === 'supplier' && supplierId !== supplierData.id) {
          throw new ApiError('Access denied', 403, 'ACCESS_DENIED')
        }

        channelName = `stats:supplier:${supplierId}`

        // Subscribe to supplier stats view
        subscriptions.push({
          channel: channelName,
          table: 'supplier_stats_view',
          filter: `supplier_id=eq.${supplierId}`,
        })

        // Subscribe to campaigns for this supplier
        subscriptions.push({
          channel: `${channelName}:campaigns`,
          table: 'campaigns',
          filter: `supplier_id=eq.${supplierId}`,
        })

        break
      }

      case 'buyer': {
        // Buyers can only see their own stats
        if (context.user?.role !== 'buyer' && context.user?.role !== 'admin') {
          throw new ApiError('Access denied', 403, 'ACCESS_DENIED')
        }

        const { data: buyerData } = await context.supabase
          .from('buyers')
          .select('id')
          .eq('user_id', context.user.id)
          .single()

        if (!buyerData) {
          throw new ApiError('Buyer not found', 404, 'BUYER_NOT_FOUND')
        }

        const buyerId = requestData.entityId || buyerData.id

        // Verify access to requested buyer stats
        if (context.user?.role === 'buyer' && buyerId !== buyerData.id) {
          throw new ApiError('Access denied', 403, 'ACCESS_DENIED')
        }

        channelName = `stats:buyer:${buyerId}`

        // Subscribe to buyer stats view
        subscriptions.push({
          channel: channelName,
          table: 'buyer_stats_view',
          filter: `buyer_id=eq.${buyerId}`,
        })

        // Subscribe to buyer campaigns
        subscriptions.push({
          channel: `${channelName}:campaigns`,
          table: 'buyer_campaigns',
          filter: `buyer_id=eq.${buyerId}`,
        })

        break
      }

      case 'platform': {
        // Only admins can see platform-wide stats
        if (context.user?.role !== 'admin') {
          throw new ApiError('Admin access required', 403, 'ADMIN_ONLY')
        }

        channelName = 'stats:platform'

        // Subscribe to platform-wide metrics
        subscriptions.push({
          channel: channelName,
          table: 'platform_stats',
        })

        // Subscribe to fraud detection alerts
        if (requestData.metrics?.includes('fraud_detection_alerts')) {
          subscriptions.push({
            channel: `${channelName}:fraud`,
            table: 'fraud_alerts',
            filter: 'resolved=eq.false',
          })
        }

        break
      }
    }

    // Generate JWT token for real-time subscription
    const realtimeToken = await context.supabase.auth.getSession()

    if (!realtimeToken.data.session) {
      throw new ApiError('Failed to generate realtime token', 500, 'TOKEN_GENERATION_FAILED')
    }

    // Create aggregation configuration based on interval
    const aggregationConfig = {
      realtime: {
        enabled: true,
        window: 0, // No aggregation
      },
      '1min': {
        enabled: true,
        window: 60000, // 1 minute in milliseconds
      },
      '5min': {
        enabled: true,
        window: 300000, // 5 minutes
      },
      '15min': {
        enabled: true,
        window: 900000, // 15 minutes
      },
    }[requestData.interval]

    return {
      success: true,
      action: requestData.action,
      subscription: {
        channels: subscriptions.map((sub) => sub.channel),
        configs: subscriptions,
        aggregation: aggregationConfig,
        token: realtimeToken.data.session.access_token,
        url: process.env.VITE_SUPABASE_URL || '',
        anonKey: process.env.VITE_SUPABASE_ANON_KEY || '',
      },
      instructions: {
        subscribe: `Subscribe to stats channels for ${requestData.statsType}`,
        metrics: requestData.metrics || 'all',
        example: `
          // Create multiple subscriptions for comprehensive stats
          const statsChannel = supabase
            .channel('${channelName}')
            ${subscriptions
              .map(
                (sub) => `
            .on('postgres_changes', {
              event: '*',
              schema: 'public',
              table: '${sub.table}'${sub.filter ? `,\n              filter: '${sub.filter}'` : ''}
            }, (payload) => {
              // Update stats based on change
              updateStats(payload)
            })`
              )
              .join('')}
            .subscribe()

          // Aggregation function for interval-based updates
          ${
            requestData.interval !== 'realtime'
              ? `
          const aggregateStats = debounce(() => {
            // Aggregate accumulated changes
            processAggregatedStats()
          }, ${aggregationConfig?.window})`
              : ''
          }
        `,
      },
    }
  })
}
</file>

<file path="netlify/functions/webhook-call-events.ts">
import type { Handler } from '@netlify/functions'
import { createClient } from '@supabase/supabase-js'
import type { Database } from '../../src/types/database'
import { z } from 'zod'
import crypto from 'crypto'

// Initialize Supabase client with service role for webhook operations
const supabase = createClient<Database>(
  process.env.VITE_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!, // Service role key for admin operations
  {
    auth: {
      autoRefreshToken: false,
      persistSession: false,
    },
  }
)

// Call event schema from telephony provider
const callEventSchema = z.object({
  eventType: z.enum([
    'call.initiated',
    'call.ringing',
    'call.connected',
    'call.completed',
    'call.failed',
    'call.recording.ready',
    'call.transcription.ready',
  ]),
  callSid: z.string(),
  trackingNumber: z.string(),
  callerNumber: z.string(),
  destinationNumber: z.string().optional(),
  timestamp: z.string().datetime(),
  duration: z.number().optional(),
  recordingUrl: z.string().url().optional(),
  transcriptionText: z.string().optional(),
  metadata: z.record(z.unknown()).optional(),
})

type CallEvent = z.infer<typeof callEventSchema>

// Verify webhook signature
function verifyWebhookSignature(
  payload: string,
  signature: string,
  secret: string
): boolean {
  const expectedSignature = crypto
    .createHmac('sha256', secret)
    .update(payload)
    .digest('hex')
  
  return crypto.timingSafeEqual(
    Buffer.from(signature),
    Buffer.from(expectedSignature)
  )
}

export const handler: Handler = async (event) => {
  if (event.httpMethod !== 'POST') {
    return {
      statusCode: 405,
      body: JSON.stringify({ error: 'Method not allowed' }),
    }
  }

  try {
    // Verify webhook signature
    const signature = event.headers['x-webhook-signature']
    const webhookSecret = process.env.TELEPHONY_WEBHOOK_SECRET

    if (!signature || !webhookSecret) {
      return {
        statusCode: 401,
        body: JSON.stringify({ error: 'Missing signature or webhook secret' }),
      }
    }

    if (!verifyWebhookSignature(event.body!, signature, webhookSecret)) {
      return {
        statusCode: 401,
        body: JSON.stringify({ error: 'Invalid signature' }),
      }
    }

    // Parse and validate event data
    const eventData: CallEvent = callEventSchema.parse(JSON.parse(event.body!))

    // Find the call record by call SID
    const { data: existingCall, error: findError } = await supabase
      .from('calls')
      .select('*')
      .eq('call_sid', eventData.callSid)
      .single()

    if (findError && findError.code !== 'PGRST116') {
      // PGRST116 means no rows found, which is OK for initiated events
      console.error('Error finding call:', findError)
      return {
        statusCode: 500,
        body: JSON.stringify({ error: 'Database error' }),
      }
    }

    // Handle different event types
    switch (eventData.eventType) {
      case 'call.initiated': {
        if (existingCall) {
          return {
            statusCode: 200,
            body: JSON.stringify({ message: 'Call already exists' }),
          }
        }

        // Find campaign by tracking number
        const { data: trackingNumber } = await supabase
          .from('tracking_numbers')
          .select('campaign_id')
          .eq('number', eventData.trackingNumber)
          .eq('is_active', true)
          .single()

        if (!trackingNumber) {
          console.error('No active campaign found for tracking number:', eventData.trackingNumber)
          return {
            statusCode: 404,
            body: JSON.stringify({ error: 'Tracking number not found' }),
          }
        }

        // Get campaign details
        const { data: campaign } = await supabase
          .from('campaigns')
          .select('id, supplier_id, bid_floor')
          .eq('id', trackingNumber.campaign_id)
          .eq('status', 'active')
          .single()

        if (!campaign) {
          return {
            statusCode: 404,
            body: JSON.stringify({ error: 'Campaign not active' }),
          }
        }

        // Create new call record
        const { error: insertError } = await supabase.from('calls').insert({
          call_sid: eventData.callSid,
          campaign_id: campaign.id,
          supplier_id: campaign.supplier_id,
          tracking_number: eventData.trackingNumber,
          caller_number: eventData.callerNumber,
          destination_number: eventData.destinationNumber || null,
          status: 'initiated',
          started_at: eventData.timestamp,
          metadata: eventData.metadata || {},
        })

        if (insertError) {
          console.error('Error creating call:', insertError)
          return {
            statusCode: 500,
            body: JSON.stringify({ error: 'Failed to create call record' }),
          }
        }

        break
      }

      case 'call.ringing': {
        if (!existingCall) {
          return {
            statusCode: 404,
            body: JSON.stringify({ error: 'Call not found' }),
          }
        }

        await supabase
          .from('calls')
          .update({
            status: 'ringing',
            updated_at: new Date().toISOString(),
          })
          .eq('id', existingCall.id)

        break
      }

      case 'call.connected': {
        if (!existingCall) {
          return {
            statusCode: 404,
            body: JSON.stringify({ error: 'Call not found' }),
          }
        }

        await supabase
          .from('calls')
          .update({
            status: 'connected',
            connected_at: eventData.timestamp,
            updated_at: new Date().toISOString(),
          })
          .eq('id', existingCall.id)

        break
      }

      case 'call.completed': {
        if (!existingCall) {
          return {
            statusCode: 404,
            body: JSON.stringify({ error: 'Call not found' }),
          }
        }

        // Calculate payout based on duration and campaign settings
        const duration = eventData.duration || 0
        const { data: campaign } = await supabase
          .from('campaigns')
          .select('bid_floor, quality_threshold')
          .eq('id', existingCall.campaign_id!)
          .single()

        let payoutAmount = 0
        if (campaign && duration >= 30) {
          // Basic payout calculation (can be enhanced with quality scoring)
          payoutAmount = campaign.bid_floor
        }

        await supabase
          .from('calls')
          .update({
            status: 'completed',
            ended_at: eventData.timestamp,
            duration_seconds: duration,
            payout_amount: payoutAmount,
            updated_at: new Date().toISOString(),
          })
          .eq('id', existingCall.id)

        // Update supplier balance if payout is due
        if (payoutAmount > 0 && existingCall.supplier_id) {
          await supabase.rpc('add_supplier_credit', {
            supplier_id: existingCall.supplier_id,
            amount: payoutAmount,
            call_id: existingCall.id,
          })
        }

        break
      }

      case 'call.failed': {
        if (!existingCall) {
          return {
            statusCode: 404,
            body: JSON.stringify({ error: 'Call not found' }),
          }
        }

        await supabase
          .from('calls')
          .update({
            status: 'failed',
            ended_at: eventData.timestamp,
            metadata: {
              ...((existingCall.metadata as object) || {}),
              failure_reason: eventData.metadata?.reason || 'Unknown',
            },
            updated_at: new Date().toISOString(),
          })
          .eq('id', existingCall.id)

        break
      }

      case 'call.recording.ready': {
        if (!existingCall) {
          return {
            statusCode: 404,
            body: JSON.stringify({ error: 'Call not found' }),
          }
        }

        await supabase
          .from('calls')
          .update({
            recording_url: eventData.recordingUrl,
            updated_at: new Date().toISOString(),
          })
          .eq('id', existingCall.id)

        // Trigger quality scoring if enabled
        // This could call another function or queue a job

        break
      }

      case 'call.transcription.ready': {
        if (!existingCall) {
          return {
            statusCode: 404,
            body: JSON.stringify({ error: 'Call not found' }),
          }
        }

        await supabase
          .from('calls')
          .update({
            transcription: eventData.transcriptionText,
            updated_at: new Date().toISOString(),
          })
          .eq('id', existingCall.id)

        // Trigger quality scoring based on transcription
        // This could analyze keywords, intent, etc.

        break
      }
    }

    return {
      statusCode: 200,
      body: JSON.stringify({ 
        success: true, 
        eventType: eventData.eventType,
        callSid: eventData.callSid 
      }),
    }
  } catch (error) {
    console.error('Webhook error:', error)

    if (error instanceof z.ZodError) {
      return {
        statusCode: 400,
        body: JSON.stringify({ 
          error: 'Invalid event data', 
          details: error.errors 
        }),
      }
    }

    return {
      statusCode: 500,
      body: JSON.stringify({ error: 'Internal server error' }),
    }
  }
}
</file>

<file path="performance/load-test.yml">
config:
  target: 'https://staging.dependablecalls.com'
  phases:
    - duration: 60
      arrivalRate: 5
      name: 'Warm up'
    - duration: 120
      arrivalRate: 10
      name: 'Ramp up load'
    - duration: 300
      arrivalRate: 20
      name: 'Sustained load'
  plugins:
    metrics-by-endpoint:
      useOnlyRequestNames: true

scenarios:
  - name: 'Homepage load test'
    weight: 30
    flow:
      - get:
          url: '/'
          name: 'homepage'
      - think: 3
      - get:
          url: '/features'
          name: 'features'
      - think: 2
      - get:
          url: '/pricing'
          name: 'pricing'

  - name: 'Authentication flow'
    weight: 20
    flow:
      - get:
          url: '/login'
          name: 'login_page'
      - think: 5
      - post:
          url: '/auth/signin'
          name: 'login_attempt'
          json:
            email: 'test-user-{{ $randomString() }}@example.com'
            password: 'testpassword123'

  - name: 'Contact form'
    weight: 15
    flow:
      - get:
          url: '/contact'
          name: 'contact_page'
      - think: 10
      - post:
          url: '/api/contact'
          name: 'contact_form_submit'
          json:
            firstName: 'Test'
            lastName: 'User'
            email: 'test@example.com'
            message: 'Performance test message'

  - name: 'API endpoints'
    weight: 35
    flow:
      - get:
          url: '/api/health'
          name: 'health_check'
      - get:
          url: '/api/campaigns/public'
          name: 'public_campaigns'
      - get:
          url: '/api/stats/public'
          name: 'public_stats'
</file>

<file path="performance/stress-test.yml">
config:
  target: 'https://staging.dependablecalls.com'
  phases:
    - duration: 60
      arrivalRate: 10
      name: 'Baseline'
    - duration: 120
      arrivalRate: 50
      name: 'Stress ramp'
    - duration: 180
      arrivalRate: 100
      name: 'High stress'
    - duration: 60
      arrivalRate: 200
      name: 'Peak stress'
    - duration: 120
      arrivalRate: 50
      name: 'Cool down'
  plugins:
    metrics-by-endpoint:
      useOnlyRequestNames: true

scenarios:
  - name: 'Homepage stress test'
    weight: 40
    flow:
      - get:
          url: '/'
          name: 'homepage_stress'
      - think: 1
      - get:
          url: '/features'
          name: 'features_stress'

  - name: 'API stress test'
    weight: 30
    flow:
      - get:
          url: '/api/health'
          name: 'health_stress'
      - get:
          url: '/api/campaigns/public'
          name: 'campaigns_stress'

  - name: 'Static assets stress'
    weight: 30
    flow:
      - get:
          url: '/assets/logo.png'
          name: 'logo_stress'
      - get:
          url: '/favicon.ico'
          name: 'favicon_stress'
</file>

<file path="public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="scripts/backup/supabase-backup.sh">
#!/bin/bash

# Supabase Database Backup Script
# This script creates automated backups of the Supabase PostgreSQL database

set -euo pipefail

# Configuration
BACKUP_DIR="${BACKUP_DIR:-/backups/supabase}"
RETENTION_DAYS="${RETENTION_DAYS:-7}"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
BACKUP_NAME="dce_backup_${TIMESTAMP}"

# Required environment variables
: "${SUPABASE_DB_URL:?SUPABASE_DB_URL is required}"
: "${AWS_S3_BUCKET:?AWS_S3_BUCKET is required for backup storage}"
: "${AWS_ACCESS_KEY_ID:?AWS_ACCESS_KEY_ID is required}"
: "${AWS_SECRET_ACCESS_KEY:?AWS_SECRET_ACCESS_KEY is required}"

# Optional notifications
SLACK_WEBHOOK_URL="${SLACK_WEBHOOK_URL:-}"
PAGERDUTY_INTEGRATION_KEY="${PAGERDUTY_INTEGRATION_KEY:-}"

# Functions
log() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] $*"
}

notify_slack() {
    local message="$1"
    local color="${2:-good}"
    
    if [[ -n "$SLACK_WEBHOOK_URL" ]]; then
        curl -X POST -H 'Content-type: application/json' \
            --data "{\"attachments\":[{\"color\":\"$color\",\"text\":\"$message\"}]}" \
            "$SLACK_WEBHOOK_URL" 2>/dev/null || true
    fi
}

notify_error() {
    local error_message="$1"
    
    # Slack notification
    notify_slack "âš ï¸ Database backup failed: $error_message" "danger"
    
    # PagerDuty alert
    if [[ -n "$PAGERDUTY_INTEGRATION_KEY" ]]; then
        curl -X POST https://events.pagerduty.com/v2/enqueue \
            -H 'Content-Type: application/json' \
            -d "{
                \"routing_key\": \"$PAGERDUTY_INTEGRATION_KEY\",
                \"event_action\": \"trigger\",
                \"payload\": {
                    \"summary\": \"Database backup failed\",
                    \"severity\": \"error\",
                    \"source\": \"supabase-backup\",
                    \"custom_details\": {
                        \"error\": \"$error_message\",
                        \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"
                    }
                }
            }" 2>/dev/null || true
    fi
}

# Create backup directory
mkdir -p "$BACKUP_DIR"

# Start backup process
log "Starting database backup: $BACKUP_NAME"
notify_slack "ðŸ”„ Starting database backup: $BACKUP_NAME" "warning"

# Perform database dump
if pg_dump "$SUPABASE_DB_URL" \
    --format=custom \
    --verbose \
    --no-owner \
    --no-privileges \
    --exclude-table-data='storage.objects' \
    --exclude-table-data='auth.refresh_tokens' \
    --exclude-table-data='auth.sessions' \
    -f "${BACKUP_DIR}/${BACKUP_NAME}.dump" 2>&1 | tee -a "${BACKUP_DIR}/backup.log"; then
    
    log "Database dump completed successfully"
    
    # Compress backup
    if gzip -9 "${BACKUP_DIR}/${BACKUP_NAME}.dump"; then
        log "Backup compressed successfully"
        
        # Calculate backup size
        BACKUP_SIZE=$(du -h "${BACKUP_DIR}/${BACKUP_NAME}.dump.gz" | cut -f1)
        
        # Upload to S3
        if aws s3 cp "${BACKUP_DIR}/${BACKUP_NAME}.dump.gz" \
            "s3://${AWS_S3_BUCKET}/database-backups/${BACKUP_NAME}.dump.gz" \
            --storage-class STANDARD_IA; then
            
            log "Backup uploaded to S3 successfully"
            
            # Create backup metadata
            cat > "${BACKUP_DIR}/${BACKUP_NAME}.metadata.json" <<EOF
{
    "backup_name": "${BACKUP_NAME}",
    "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
    "size": "${BACKUP_SIZE}",
    "database_url": "REDACTED",
    "retention_days": ${RETENTION_DAYS},
    "checksum": "$(sha256sum "${BACKUP_DIR}/${BACKUP_NAME}.dump.gz" | cut -d' ' -f1)"
}
EOF
            
            # Upload metadata
            aws s3 cp "${BACKUP_DIR}/${BACKUP_NAME}.metadata.json" \
                "s3://${AWS_S3_BUCKET}/database-backups/${BACKUP_NAME}.metadata.json"
            
            # Clean up local files
            rm -f "${BACKUP_DIR}/${BACKUP_NAME}.dump.gz"
            rm -f "${BACKUP_DIR}/${BACKUP_NAME}.metadata.json"
            
            # Success notification
            notify_slack "âœ… Database backup completed successfully\nðŸ“¦ Size: ${BACKUP_SIZE}\nðŸ“ Location: s3://${AWS_S3_BUCKET}/database-backups/${BACKUP_NAME}.dump.gz" "good"
            
            # Clean up old backups
            log "Cleaning up old backups (retention: ${RETENTION_DAYS} days)"
            aws s3 ls "s3://${AWS_S3_BUCKET}/database-backups/" | \
                grep "dump.gz" | \
                while read -r line; do
                    backup_date=$(echo "$line" | awk '{print $1}')
                    backup_file=$(echo "$line" | awk '{print $4}')
                    
                    if [[ $(date -d "$backup_date" +%s 2>/dev/null || date -j -f "%Y-%m-%d" "$backup_date" +%s) -lt $(date -d "${RETENTION_DAYS} days ago" +%s) ]]; then
                        log "Deleting old backup: $backup_file"
                        aws s3 rm "s3://${AWS_S3_BUCKET}/database-backups/$backup_file"
                        aws s3 rm "s3://${AWS_S3_BUCKET}/database-backups/${backup_file%.dump.gz}.metadata.json" 2>/dev/null || true
                    fi
                done
            
            log "Backup process completed successfully"
            exit 0
        else
            notify_error "Failed to upload backup to S3"
            exit 1
        fi
    else
        notify_error "Failed to compress backup"
        exit 1
    fi
else
    notify_error "Failed to create database dump"
    exit 1
fi
</file>

<file path="scripts/backup/supabase-restore.sh">
#!/bin/bash

# Supabase Database Restore Script
# This script restores a Supabase PostgreSQL database from backup

set -euo pipefail

# Configuration
RESTORE_DIR="${RESTORE_DIR:-/tmp/restore}"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)

# Required environment variables
: "${SUPABASE_DB_URL:?SUPABASE_DB_URL is required}"
: "${AWS_S3_BUCKET:?AWS_S3_BUCKET is required}"
: "${AWS_ACCESS_KEY_ID:?AWS_ACCESS_KEY_ID is required}"
: "${AWS_SECRET_ACCESS_KEY:?AWS_SECRET_ACCESS_KEY is required}"

# Optional: Specific backup to restore (defaults to latest)
BACKUP_NAME="${1:-}"

# Functions
log() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] $*"
}

error_exit() {
    echo "ERROR: $1" >&2
    exit 1
}

confirm_restore() {
    echo "âš ï¸  WARNING: This will restore the database from backup."
    echo "   This operation will:"
    echo "   - Stop all active connections"
    echo "   - Drop and recreate the database"
    echo "   - Restore all data from the backup"
    echo ""
    read -p "Are you ABSOLUTELY sure you want to continue? Type 'yes' to confirm: " confirmation
    
    if [[ "$confirmation" != "yes" ]]; then
        log "Restore cancelled by user"
        exit 0
    fi
}

# Create restore directory
mkdir -p "$RESTORE_DIR"

# Confirm restore operation
if [[ -z "${FORCE_RESTORE:-}" ]]; then
    confirm_restore
fi

log "Starting database restore process"

# Find backup to restore
if [[ -z "$BACKUP_NAME" ]]; then
    log "Finding latest backup..."
    BACKUP_NAME=$(aws s3 ls "s3://${AWS_S3_BUCKET}/database-backups/" | \
        grep "dump.gz" | \
        sort -r | \
        head -1 | \
        awk '{print $4}' | \
        sed 's/.dump.gz$//')
    
    if [[ -z "$BACKUP_NAME" ]]; then
        error_exit "No backups found in S3"
    fi
    
    log "Latest backup found: $BACKUP_NAME"
fi

# Download backup
log "Downloading backup: ${BACKUP_NAME}.dump.gz"
if ! aws s3 cp "s3://${AWS_S3_BUCKET}/database-backups/${BACKUP_NAME}.dump.gz" \
    "${RESTORE_DIR}/${BACKUP_NAME}.dump.gz"; then
    error_exit "Failed to download backup from S3"
fi

# Download metadata
log "Downloading backup metadata"
if aws s3 cp "s3://${AWS_S3_BUCKET}/database-backups/${BACKUP_NAME}.metadata.json" \
    "${RESTORE_DIR}/${BACKUP_NAME}.metadata.json" 2>/dev/null; then
    
    # Verify checksum
    if command -v jq &> /dev/null; then
        EXPECTED_CHECKSUM=$(jq -r '.checksum' "${RESTORE_DIR}/${BACKUP_NAME}.metadata.json")
        ACTUAL_CHECKSUM=$(sha256sum "${RESTORE_DIR}/${BACKUP_NAME}.dump.gz" | cut -d' ' -f1)
        
        if [[ "$EXPECTED_CHECKSUM" != "$ACTUAL_CHECKSUM" ]]; then
            error_exit "Checksum verification failed! Backup may be corrupted."
        fi
        
        log "Checksum verified successfully"
    fi
fi

# Decompress backup
log "Decompressing backup"
if ! gunzip "${RESTORE_DIR}/${BACKUP_NAME}.dump.gz"; then
    error_exit "Failed to decompress backup"
fi

# Create restore log
RESTORE_LOG="${RESTORE_DIR}/restore_${TIMESTAMP}.log"

# Parse database connection details
DB_HOST=$(echo "$SUPABASE_DB_URL" | sed -n 's/.*@\([^:]*\):.*/\1/p')
DB_PORT=$(echo "$SUPABASE_DB_URL" | sed -n 's/.*:\([0-9]*\)\/.*/\1/p')
DB_NAME=$(echo "$SUPABASE_DB_URL" | sed -n 's/.*\/\([^?]*\).*/\1/p')
DB_USER=$(echo "$SUPABASE_DB_URL" | sed -n 's/.*:\/\/\([^:]*\):.*/\1/p')

# Terminate existing connections
log "Terminating existing database connections"
psql "$SUPABASE_DB_URL" -c "
    SELECT pg_terminate_backend(pg_stat_activity.pid)
    FROM pg_stat_activity
    WHERE pg_stat_activity.datname = '$DB_NAME'
      AND pid <> pg_backend_pid();" || true

# Create pre-restore backup
log "Creating pre-restore safety backup"
PRE_RESTORE_BACKUP="pre_restore_${DB_NAME}_${TIMESTAMP}"
pg_dump "$SUPABASE_DB_URL" \
    --format=custom \
    --no-owner \
    --no-privileges \
    -f "${RESTORE_DIR}/${PRE_RESTORE_BACKUP}.dump" 2>&1 | tee -a "$RESTORE_LOG" || true

# Perform restore
log "Starting database restore"
if pg_restore \
    --verbose \
    --no-owner \
    --no-privileges \
    --no-acl \
    --clean \
    --if-exists \
    -d "$SUPABASE_DB_URL" \
    "${RESTORE_DIR}/${BACKUP_NAME}.dump" 2>&1 | tee -a "$RESTORE_LOG"; then
    
    log "Database restore completed successfully"
    
    # Run post-restore tasks
    log "Running post-restore tasks"
    
    # Update sequences
    psql "$SUPABASE_DB_URL" <<EOF
-- Reset all sequences to max value
DO \$\$
DECLARE
    seq RECORD;
    max_val BIGINT;
    sql_query TEXT;
BEGIN
    FOR seq IN 
        SELECT sequence_schema, sequence_name, 
               REPLACE(REPLACE(sequence_name, '_id_seq', ''), '_seq', '') as table_name
        FROM information_schema.sequences
        WHERE sequence_schema NOT IN ('pg_catalog', 'information_schema')
    LOOP
        sql_query := format('SELECT COALESCE(MAX(id), 0) FROM %I.%I', 
                           seq.sequence_schema, seq.table_name);
        BEGIN
            EXECUTE sql_query INTO max_val;
            EXECUTE format('SELECT setval(''%I.%I'', %s)', 
                          seq.sequence_schema, seq.sequence_name, max_val + 1);
        EXCEPTION WHEN OTHERS THEN
            -- Skip if table doesn't exist or has no id column
            NULL;
        END;
    END LOOP;
END\$\$;

-- Analyze tables for query optimization
ANALYZE;
EOF
    
    # Verify restore
    log "Verifying restore"
    TABLE_COUNT=$(psql "$SUPABASE_DB_URL" -t -c "
        SELECT COUNT(*) 
        FROM information_schema.tables 
        WHERE table_schema NOT IN ('pg_catalog', 'information_schema');")
    
    log "Restore verification: $TABLE_COUNT tables found"
    
    # Clean up
    log "Cleaning up temporary files"
    rm -f "${RESTORE_DIR}/${BACKUP_NAME}.dump"
    rm -f "${RESTORE_DIR}/${BACKUP_NAME}.metadata.json"
    
    # Compress pre-restore backup
    if [[ -f "${RESTORE_DIR}/${PRE_RESTORE_BACKUP}.dump" ]]; then
        gzip -9 "${RESTORE_DIR}/${PRE_RESTORE_BACKUP}.dump"
        log "Pre-restore backup saved: ${RESTORE_DIR}/${PRE_RESTORE_BACKUP}.dump.gz"
    fi
    
    log "Database restore completed successfully!"
    log "Restore log: $RESTORE_LOG"
    
    # Notification
    if [[ -n "${SLACK_WEBHOOK_URL:-}" ]]; then
        curl -X POST -H 'Content-type: application/json' \
            --data "{\"text\":\"âœ… Database restore completed successfully\nðŸ“¦ Backup: ${BACKUP_NAME}\nðŸ“Š Tables: ${TABLE_COUNT}\"}" \
            "$SLACK_WEBHOOK_URL" 2>/dev/null || true
    fi
    
else
    error_exit "Database restore failed! Check log: $RESTORE_LOG"
fi
</file>

<file path="scripts/rollback.sh">
#!/bin/bash

# Deployment Rollback Script
# Enables quick rollback to previous version in case of issues

set -euo pipefail

# Configuration
DEPLOYMENT_HISTORY_FILE="${DEPLOYMENT_HISTORY_FILE:-/var/log/deployments.json}"
MAX_ROLLBACK_VERSIONS="${MAX_ROLLBACK_VERSIONS:-5}"

# Required environment variables
: "${NETLIFY_AUTH_TOKEN:?NETLIFY_AUTH_TOKEN is required}"
: "${NETLIFY_SITE_ID:?NETLIFY_SITE_ID is required}"
: "${ENVIRONMENT:?ENVIRONMENT is required (production/staging)}"

# Optional
SLACK_WEBHOOK_URL="${SLACK_WEBHOOK_URL:-}"
ROLLBACK_TO_VERSION="${1:-}"

# Functions
log() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] $*"
}

error_exit() {
    echo "ERROR: $1" >&2
    notify_slack "âŒ Rollback failed: $1" "danger"
    exit 1
}

notify_slack() {
    local message="$1"
    local color="${2:-good}"
    
    if [[ -n "$SLACK_WEBHOOK_URL" ]]; then
        curl -X POST -H 'Content-type: application/json' \
            --data "{\"attachments\":[{\"color\":\"$color\",\"text\":\"$message\"}]}" \
            "$SLACK_WEBHOOK_URL" 2>/dev/null || true
    fi
}

get_current_deployment() {
    curl -s -H "Authorization: Bearer $NETLIFY_AUTH_TOKEN" \
        "https://api.netlify.com/api/v1/sites/$NETLIFY_SITE_ID" | \
        jq -r '.published_deploy.id'
}

get_deployment_list() {
    curl -s -H "Authorization: Bearer $NETLIFY_AUTH_TOKEN" \
        "https://api.netlify.com/api/v1/sites/$NETLIFY_SITE_ID/deploys?per_page=$MAX_ROLLBACK_VERSIONS" | \
        jq -r '.[] | select(.state == "ready") | {id: .id, created_at: .created_at, branch: .branch, commit_ref: .commit_ref, title: .title}'
}

perform_rollback() {
    local deploy_id="$1"
    
    log "Initiating rollback to deployment: $deploy_id"
    
    # Restore deployment
    local response=$(curl -s -X POST \
        -H "Authorization: Bearer $NETLIFY_AUTH_TOKEN" \
        -H "Content-Type: application/json" \
        "https://api.netlify.com/api/v1/sites/$NETLIFY_SITE_ID/deploys/$deploy_id/restore")
    
    local state=$(echo "$response" | jq -r '.state')
    
    if [[ "$state" == "ready" ]]; then
        log "Rollback completed successfully"
        return 0
    else
        error_exit "Rollback failed with state: $state"
    fi
}

create_rollback_record() {
    local from_deploy="$1"
    local to_deploy="$2"
    local reason="${3:-Manual rollback}"
    
    local record=$(jq -n \
        --arg from "$from_deploy" \
        --arg to "$to_deploy" \
        --arg reason "$reason" \
        --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
        --arg user "${USER:-unknown}" \
        --arg environment "$ENVIRONMENT" \
        '{
            from_deployment: $from,
            to_deployment: $to,
            reason: $reason,
            timestamp: $timestamp,
            initiated_by: $user,
            environment: $environment
        }')
    
    # Append to deployment history
    if [[ -f "$DEPLOYMENT_HISTORY_FILE" ]]; then
        jq ". += [$record]" "$DEPLOYMENT_HISTORY_FILE" > "${DEPLOYMENT_HISTORY_FILE}.tmp" && \
        mv "${DEPLOYMENT_HISTORY_FILE}.tmp" "$DEPLOYMENT_HISTORY_FILE"
    else
        echo "[$record]" > "$DEPLOYMENT_HISTORY_FILE"
    fi
}

# Main rollback process
log "Starting rollback process for $ENVIRONMENT environment"
notify_slack "ðŸ”„ Initiating rollback for $ENVIRONMENT environment" "warning"

# Get current deployment
CURRENT_DEPLOY=$(get_current_deployment)
log "Current deployment: $CURRENT_DEPLOY"

# If specific version not provided, show available options
if [[ -z "$ROLLBACK_TO_VERSION" ]]; then
    log "Available deployments for rollback:"
    echo ""
    
    get_deployment_list | jq -r '. | "\(.id) - \(.created_at) - Branch: \(.branch) - \(.title // "No title")"'
    
    echo ""
    read -p "Enter deployment ID to rollback to: " ROLLBACK_TO_VERSION
    
    if [[ -z "$ROLLBACK_TO_VERSION" ]]; then
        error_exit "No deployment ID provided"
    fi
fi

# Validate deployment exists
if ! get_deployment_list | jq -e ".id == \"$ROLLBACK_TO_VERSION\"" > /dev/null; then
    error_exit "Deployment $ROLLBACK_TO_VERSION not found or not available for rollback"
fi

# Confirm rollback
echo ""
echo "âš ï¸  WARNING: This will rollback the $ENVIRONMENT environment"
echo "   From: $CURRENT_DEPLOY"
echo "   To:   $ROLLBACK_TO_VERSION"
echo ""
read -p "Are you sure you want to continue? (yes/no): " confirmation

if [[ "$confirmation" != "yes" ]]; then
    log "Rollback cancelled by user"
    exit 0
fi

# Read rollback reason
read -p "Reason for rollback (press Enter for default): " ROLLBACK_REASON
ROLLBACK_REASON="${ROLLBACK_REASON:-Manual rollback}"

# Create pre-rollback snapshot
log "Creating pre-rollback health check"
HEALTH_CHECK=$(curl -s -o /dev/null -w "%{http_code}" "https://${NETLIFY_SITE_ID}.netlify.app/health" || echo "000")
log "Current health status: $HEALTH_CHECK"

# Perform rollback
if perform_rollback "$ROLLBACK_TO_VERSION"; then
    # Wait for deployment to be ready
    log "Waiting for deployment to be ready..."
    sleep 10
    
    # Verify rollback
    NEW_DEPLOY=$(get_current_deployment)
    
    if [[ "$NEW_DEPLOY" == "$ROLLBACK_TO_VERSION" ]]; then
        log "Rollback verified successfully"
        
        # Record rollback
        create_rollback_record "$CURRENT_DEPLOY" "$ROLLBACK_TO_VERSION" "$ROLLBACK_REASON"
        
        # Post-rollback health check
        sleep 5
        POST_HEALTH=$(curl -s -o /dev/null -w "%{http_code}" "https://${NETLIFY_SITE_ID}.netlify.app/health" || echo "000")
        log "Post-rollback health status: $POST_HEALTH"
        
        if [[ "$POST_HEALTH" == "200" ]]; then
            notify_slack "âœ… Rollback completed successfully\nðŸ“¦ From: $CURRENT_DEPLOY\nðŸ“¦ To: $ROLLBACK_TO_VERSION\nðŸ’¬ Reason: $ROLLBACK_REASON\nâ¤ï¸ Health: OK" "good"
        else
            notify_slack "âš ï¸ Rollback completed but health check failed\nðŸ“¦ From: $CURRENT_DEPLOY\nðŸ“¦ To: $ROLLBACK_TO_VERSION\nâŒ Health: $POST_HEALTH" "warning"
        fi
        
        log "Rollback completed successfully!"
    else
        error_exit "Rollback verification failed. Expected $ROLLBACK_TO_VERSION but got $NEW_DEPLOY"
    fi
else
    error_exit "Rollback operation failed"
fi

# Generate rollback report
cat > "/tmp/rollback_report_$(date +%Y%m%d_%H%M%S).txt" <<EOF
Rollback Report
===============
Environment: $ENVIRONMENT
Timestamp: $(date)
Initiated by: ${USER:-unknown}

From Deployment: $CURRENT_DEPLOY
To Deployment: $ROLLBACK_TO_VERSION
Reason: $ROLLBACK_REASON

Pre-rollback Health: $HEALTH_CHECK
Post-rollback Health: $POST_HEALTH

Status: SUCCESS
EOF

log "Rollback report generated: /tmp/rollback_report_$(date +%Y%m%d_%H%M%S).txt"
</file>

<file path="src/assets/CLAUDE.md">
# Asset Management

# Asset Structure

```
assets/
â”œâ”€â”€ images/        # Static images
â”œâ”€â”€ icons/         # SVG icons
â”œâ”€â”€ fonts/         # Custom fonts
â”œâ”€â”€ videos/        # Video files
â””â”€â”€ data/          # Static JSON data
```

# Image Guidelines

- Use WebP format for photos (fallback to JPG)
- Use SVG for logos and icons
- Use PNG for images requiring transparency
- Optimize all images before committing

# Image Optimization

```bash
# Use these tools before adding images:
# - imageoptim (Mac)
# - squoosh.app (Web)
# - sharp-cli (Node.js)
```

# SVG Best Practices

- Remove unnecessary metadata
- Use currentColor for dynamic colors
- Optimize with SVGO
- Inline critical SVGs

```tsx
// Using SVG as React component
import { ReactComponent as Logo } from '@/assets/icons/logo.svg'

export function Header() {
  return <Logo className="h-8 w-8 text-primary" />
}
```

# Image Imports

```tsx
// Static imports for build optimization
import heroImage from '@/assets/images/hero.webp'
import heroImageFallback from '@/assets/images/hero.jpg'

// Use in component
;<picture>
  <source srcSet={heroImage} type="image/webp" />
  <img src={heroImageFallback} alt="Hero" />
</picture>
```

# Responsive Images

```tsx
// Define srcset for different screen sizes
const imageSizes = {
  small: '/assets/images/hero-400w.webp',
  medium: '/assets/images/hero-800w.webp',
  large: '/assets/images/hero-1200w.webp',
}

;<img
  srcSet={`
    ${imageSizes.small} 400w,
    ${imageSizes.medium} 800w,
    ${imageSizes.large} 1200w
  `}
  sizes="(max-width: 640px) 100vw, (max-width: 1024px) 50vw, 33vw"
  src={imageSizes.medium}
  alt="Responsive image"
/>
```

# Icon System

- Use Heroicons for UI icons
- Custom icons as SVG components
- Consistent 24x24 viewBox
- Support dark mode

```tsx
// Icon wrapper component
export function Icon({ name, className = 'h-6 w-6' }: IconProps) {
  const IconComponent = iconMap[name]
  return <IconComponent className={className} />
}
```

# Font Loading

```css
/* Use font-display: swap for performance */
@font-face {
  font-family: 'CustomFont';
  src: url('/assets/fonts/custom.woff2') format('woff2');
  font-weight: 400;
  font-display: swap;
}
```

# Static Data Files

```tsx
// Import JSON data
import campaignTypes from '@/assets/data/campaign-types.json'
import statesList from '@/assets/data/states.json'

// Type-safe imports
interface CampaignType {
  id: string
  name: string
  category: string
}

const typedCampaignTypes: CampaignType[] = campaignTypes
```

# Asset Loading Strategies

```tsx
// Lazy load non-critical images
const LazyImage = ({ src, alt }: ImageProps) => {
  return <img loading="lazy" src={src} alt={alt} decoding="async" />
}

// Preload critical assets
;<link rel="preload" as="image" href="/assets/images/hero.webp" />
```

# File Naming Conventions

- Lowercase with hyphens: `user-avatar.svg`
- Include dimensions: `hero-1920x1080.jpg`
- Version large files: `video-v2.mp4`
- Descriptive names: `call-tracking-dashboard.png`

# Asset Size Limits

- Images: Max 500KB (optimize larger)
- Icons: Max 5KB per SVG
- Videos: Use external CDN
- Total bundle: Monitor with build tools

# CDN Integration

```tsx
// Use CDN for large assets
const CDN_URL = import.meta.env.VITE_CDN_URL

export function getAssetUrl(path: string): string {
  if (import.meta.env.PROD) {
    return `${CDN_URL}${path}`
  }
  return path
}
```

# Dark Mode Assets

```tsx
// Provide dark mode variants
const logo = {
  light: '/assets/images/logo-light.svg',
  dark: '/assets/images/logo-dark.svg',
}

export function Logo() {
  const { theme } = useTheme()
  return <img src={logo[theme]} alt="Logo" />
}
```

# Performance Monitoring

```tsx
// Track asset loading performance
export function trackAssetPerformance() {
  window.addEventListener('load', () => {
    const resources = performance.getEntriesByType('resource')
    const images = resources.filter((r) => r.name.includes('/assets/images/'))

    images.forEach((img) => {
      if (img.duration > 1000) {
        console.warn(`Slow asset: ${img.name} (${img.duration}ms)`)
      }
    })
  })
}
```

# Build Optimization

- Vite automatically optimizes assets
- Use dynamic imports for large assets
- Enable compression in production
- Monitor bundle analyzer output

# DCE-Specific Assets

- Call tracking flow diagrams
- Campaign category icons
- User role badges
- Quality score indicators
- Fraud alert icons
- Payment method logos

# Asset Security

- Sanitize SVG uploads
- Validate file types
- Limit file sizes
- Use CSP headers for assets
- No sensitive data in filenames

# Testing Assets

```tsx
// Test asset loading
describe('Asset Loading', () => {
  it('should load critical images', async () => {
    const img = screen.getByAltText('Hero')
    await waitFor(() => {
      expect(img).toHaveAttribute('src')
      expect(img.complete).toBe(true)
    })
  })
})
```

# CRITICAL RULES

- NO unoptimized images in repository
- NO assets over 1MB without approval
- ALWAYS provide alt text for images
- ALWAYS optimize SVGs before use
- ALWAYS use appropriate format
- NEVER commit sensitive data in assets
- USE lazy loading for non-critical images
- MONITOR asset performance impact
- PROVIDE dark mode variants when needed
</file>

<file path="src/assets/react.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
</file>

<file path="src/components/__tests__/FeatureErrorBoundaries.test.tsx">
import React from 'react'
import { render, screen, fireEvent, waitFor } from '@testing-library/react'
import { vi } from 'vitest'
import { PaymentErrorBoundary } from '../payments/PaymentErrorBoundary'
import { FormErrorBoundary } from '../forms/FormErrorBoundary'
import { RealtimeErrorBoundary } from '../realtime/RealtimeErrorBoundary'
import { z } from 'zod'

// Mock Sentry
vi.mock('@sentry/react', () => ({
  captureException: vi.fn(),
}))

describe('PaymentErrorBoundary', () => {
  const ThrowPaymentError = ({ errorType }: { errorType: string }) => {
    if (errorType === 'card_declined') {
      throw new Error('Your card was declined')
    }
    if (errorType === 'network') {
      throw new Error('Network connection failed')
    }
    return <div>Payment form content</div>
  }

  it('should catch and display card declined errors', () => {
    const onRetry = vi.fn()
    const onUpdatePaymentMethod = vi.fn()

    render(
      <PaymentErrorBoundary onRetry={onRetry} onUpdatePaymentMethod={onUpdatePaymentMethod}>
        <ThrowPaymentError errorType="card_declined" />
      </PaymentErrorBoundary>
    )

    expect(screen.getByText('Card Declined')).toBeInTheDocument()
    expect(screen.getByText(/Your card was declined/)).toBeInTheDocument()
    expect(screen.getByRole('button', { name: /Update Payment Method/i })).toBeInTheDocument()
  })

  it('should handle retry action', () => {
    const onRetry = vi.fn()

    render(
      <PaymentErrorBoundary onRetry={onRetry}>
        <ThrowPaymentError errorType="network" />
      </PaymentErrorBoundary>
    )

    const retryButton = screen.getByRole('button', { name: /Try Again/i })
    fireEvent.click(retryButton)

    expect(onRetry).toHaveBeenCalled()
  })

  it('should preserve form data on error', () => {
    const FormWithError = () => {
      const [shouldError, setShouldError] = React.useState(false)

      if (shouldError) {
        throw new Error('Payment failed')
      }

      return (
        <form>
          <input name="cardNumber" defaultValue="4242424242424242" />
          <button type="button" onClick={() => setShouldError(true)}>
            Trigger Error
          </button>
        </form>
      )
    }

    render(
      <PaymentErrorBoundary preserveFormData={true}>
        <FormWithError />
      </PaymentErrorBoundary>
    )

    // Trigger error
    fireEvent.click(screen.getByText('Trigger Error'))

    // Check that sessionStorage was called (in a real test, you'd mock this)
    expect(screen.getByText(/Payment Failed/)).toBeInTheDocument()
  })
})

describe('FormErrorBoundary', () => {
  const testSchema = z.object({
    name: z.string().min(3),
    email: z.string().email(),
  })

  const ThrowFormError = ({ errorType }: { errorType: string }) => {
    if (errorType === 'validation') {
      const error = new z.ZodError([
        {
          code: 'too_small',
          minimum: 3,
          type: 'string',
          inclusive: true,
          message: 'Name must be at least 3 characters',
          path: ['name'],
        },
      ])
      throw error
    }
    if (errorType === 'network') {
      throw new Error('Network timeout')
    }
    return <div>Form content</div>
  }

  it('should display validation errors', () => {
    render(
      <FormErrorBoundary validationSchema={testSchema}>
        <ThrowFormError errorType="validation" />
      </FormErrorBoundary>
    )

    expect(screen.getByText('Form Validation Error')).toBeInTheDocument()
    expect(screen.getByText(/Name must be at least 3 characters/)).toBeInTheDocument()
  })

  it('should handle network errors', () => {
    const onRetry = vi.fn()

    render(
      <FormErrorBoundary onRetry={onRetry}>
        <ThrowFormError errorType="network" />
      </FormErrorBoundary>
    )

    expect(screen.getByText(/Network error occurred/)).toBeInTheDocument()

    const retryButton = screen.getByRole('button', { name: /Retry/i })
    fireEvent.click(retryButton)

    expect(onRetry).toHaveBeenCalled()
  })

  it('should save draft when requested', () => {
    const onSaveDraft = vi.fn()

    const FormWithDraft = () => {
      throw new Error('Form submission failed')
    }

    render(
      <FormErrorBoundary enableDraftSaving={true} onSaveDraft={onSaveDraft} formName="testForm">
        <FormWithDraft />
      </FormErrorBoundary>
    )

    const saveDraftButton = screen.getByRole('button', { name: /Save as Draft/i })
    fireEvent.click(saveDraftButton)

    expect(onSaveDraft).toHaveBeenCalled()
  })
})

describe('RealtimeErrorBoundary', () => {
  const ThrowRealtimeError = ({ errorType }: { errorType: string }) => {
    if (errorType === 'websocket') {
      throw new Error('WebSocket connection failed')
    }
    if (errorType === 'timeout') {
      throw new Error('Request timed out')
    }
    return <div>Real-time content</div>
  }

  it('should handle WebSocket errors', () => {
    const onReconnect = vi.fn()

    render(
      <RealtimeErrorBoundary featureName="Test Feature" onReconnect={onReconnect}>
        <ThrowRealtimeError errorType="websocket" />
      </RealtimeErrorBoundary>
    )

    expect(screen.getByText('Real-time Connection Error')).toBeInTheDocument()
    expect(screen.getByText(/Test Feature feature is temporarily unavailable/)).toBeInTheDocument()

    const reconnectButton = screen.getByRole('button', { name: /Reconnect Now/i })
    fireEvent.click(reconnectButton)

    expect(onReconnect).toHaveBeenCalled()
  })

  it('should show timeout error with retry', () => {
    const onRetry = vi.fn()

    render(
      <RealtimeErrorBoundary onReconnect={onRetry}>
        <ThrowRealtimeError errorType="timeout" />
      </RealtimeErrorBoundary>
    )

    expect(screen.getByText('Request Timeout')).toBeInTheDocument()

    const retryButton = screen.getByRole('button', { name: /Try Again/i })
    fireEvent.click(retryButton)

    expect(onRetry).toHaveBeenCalled()
  })

  it('should offer fallback to polling', () => {
    const onFallbackToPolling = vi.fn()

    render(
      <RealtimeErrorBoundary onFallbackToPolling={onFallbackToPolling} featureName="Live Updates">
        <ThrowRealtimeError errorType="websocket" />
      </RealtimeErrorBoundary>
    )

    const fallbackButton = screen.getByRole('button', { name: /Continue with Limited Features/i })
    fireEvent.click(fallbackButton)

    expect(onFallbackToPolling).toHaveBeenCalled()
  })

  it('should show connection status indicator', async () => {
    const RealtimeComponent = () => {
      const [isConnected, setIsConnected] = React.useState(true)

      React.useEffect(() => {
        const timer = setTimeout(() => setIsConnected(false), 100)
        return () => clearTimeout(timer)
      }, [])

      if (!isConnected) {
        throw new Error('Connection lost')
      }

      return <div>Connected</div>
    }

    render(
      <RealtimeErrorBoundary enableAutoReconnect={false} featureName="Dashboard">
        <RealtimeComponent />
      </RealtimeErrorBoundary>
    )

    // Initially connected
    expect(screen.getByText('Connected')).toBeInTheDocument()

    // Wait for disconnection
    await waitFor(() => {
      expect(screen.getByText(/Real-time Connection Error/)).toBeInTheDocument()
    })
  })
})

describe('Error Boundary Integration', () => {
  it('should not interfere with normal component operation', () => {
    const NormalComponent = () => <div>Normal operation</div>

    const { rerender } = render(
      <PaymentErrorBoundary>
        <NormalComponent />
      </PaymentErrorBoundary>
    )

    expect(screen.getByText('Normal operation')).toBeInTheDocument()

    // Re-render should work normally
    rerender(
      <PaymentErrorBoundary>
        <NormalComponent />
      </PaymentErrorBoundary>
    )

    expect(screen.getByText('Normal operation')).toBeInTheDocument()
  })

  it('should reset error state when children change', () => {
    const ErrorComponent = () => {
      throw new Error('Test error')
    }
    const NormalComponent = () => <div>Normal component</div>

    const { rerender } = render(
      <PaymentErrorBoundary>
        <ErrorComponent />
      </PaymentErrorBoundary>
    )

    expect(screen.getByText(/Payment Failed/)).toBeInTheDocument()

    // Change to normal component
    rerender(
      <PaymentErrorBoundary>
        <NormalComponent />
      </PaymentErrorBoundary>
    )

    expect(screen.getByText('Normal component')).toBeInTheDocument()
    expect(screen.queryByText(/Payment Failed/)).not.toBeInTheDocument()
  })
})
</file>

<file path="src/components/auth/CLAUDE.md">
# Authentication Components

# Component Structure
- `LoginForm.tsx` - User login form
- `RegisterForm.tsx` - User registration form  
- `ForgotPasswordForm.tsx` - Password reset form
- `AuthGuard.tsx` - Route protection component
- `RoleGuard.tsx` - Role-based access control

# Authentication Flow Components
```tsx
// LoginForm.tsx
interface LoginFormProps {
  onSuccess?: (user: User) => void;
  redirectTo?: string;
}

export function LoginForm({ onSuccess, redirectTo = '/dashboard' }: LoginFormProps) {
  const form = useLoginForm();
  const navigate = useNavigate();
  
  const handleSubmit = async (data: LoginFormData) => {
    const user = await authService.login(data);
    onSuccess?.(user);
    navigate(redirectTo);
  };
  
  return (
    <form onSubmit={form.handleSubmit(handleSubmit)}>
      <Input {...form.register('email')} type="email" />
      <Input {...form.register('password')} type="password" />
      <Button type="submit" loading={form.formState.isSubmitting}>
        Sign In
      </Button>
    </form>
  );
}
```

# Form Validation
- Use React Hook Form + Zod schemas
- Real-time validation feedback
- Password strength indicators
- Email format validation (NO regex - use Zod)

# Role-Based Components
```tsx
// RoleGuard.tsx
interface RoleGuardProps {
  allowedRoles: UserRole[];
  children: React.ReactNode;
  fallback?: React.ReactNode;
}

export function RoleGuard({ allowedRoles, children, fallback }: RoleGuardProps) {
  const { user } = useAuth();
  
  if (!user || !allowedRoles.includes(user.role)) {
    return fallback || <Navigate to="/unauthorized" />;
  }
  
  return <>{children}</>;
}
```

# Supabase Auth Integration
- Use Supabase Auth hooks
- Handle session management
- Email verification flows
- Password reset with magic links

# Authentication States
```tsx
// AuthProvider context
interface AuthContextValue {
  user: User | null;
  loading: boolean;
  login: (email: string, password: string) => Promise<void>;
  logout: () => Promise<void>;
  register: (data: RegisterData) => Promise<void>;
  resetPassword: (email: string) => Promise<void>;
}
```

# Error Handling
- Network error recovery
- Invalid credential messages
- Rate limiting feedback
- Session expiry handling

# DCE-Specific Auth Features
- Supplier vs Buyer registration flows
- Company information collection
- Identity verification status
- Terms of service acceptance

# Security Patterns
- Password complexity requirements
- Session timeout handling
- CSRF protection
- Secure token storage

# Mobile Responsiveness
- Touch-friendly form inputs
- Responsive layout design
- Keyboard navigation support
- Accessibility compliance

# Testing Patterns
```tsx
// Test authentication components
describe('LoginForm', () => {
  it('should submit valid credentials', async () => {
    render(<LoginForm />);
    
    fireEvent.change(screen.getByLabelText('Email'), {
      target: { value: 'test@example.com' }
    });
    fireEvent.change(screen.getByLabelText('Password'), {
      target: { value: 'password123' }
    });
    
    fireEvent.click(screen.getByRole('button', { name: 'Sign In' }));
    
    await waitFor(() => {
      expect(mockAuthService.login).toHaveBeenCalled();
    });
  });
});
```

# CRITICAL RULES
- NO regex for email validation - use Zod
- NO any types in auth interfaces
- ALWAYS validate on both client and server
- ALWAYS handle loading states
- ALWAYS provide clear error messages
- SECURE password handling (no plain text)
- IMPLEMENT proper session management
- TEST all authentication flows
</file>

<file path="src/components/auth/Login.tsx">
import { useState } from 'react'
import { Link, useNavigate, useLocation } from 'react-router-dom'
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { z } from 'zod'
import { useAuthStore } from '../../store/authStore'
import { EyeIcon, EyeSlashIcon } from '@heroicons/react/24/outline'

// Validation schema
const loginSchema = z.object({
  email: z.string().min(1, 'Email is required').email('Please enter a valid email address'),
  password: z
    .string()
    .min(1, 'Password is required')
    .min(8, 'Password must be at least 8 characters'),
})

type LoginFormData = z.infer<typeof loginSchema>

interface LoginProps {
  onSuccess?: () => void
  redirectTo?: string
  className?: string
}

interface LocationState {
  from?: { pathname: string }
  message?: string
}

export default function Login({ onSuccess, redirectTo, className = '' }: LoginProps) {
  const [showPassword, setShowPassword] = useState(false)
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  const navigate = useNavigate()
  const location = useLocation()
  const { signIn } = useAuthStore()

  const locationState = location.state as LocationState | null
  const from = locationState?.from?.pathname || redirectTo || '/app/dashboard'
  const message = locationState?.message

  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
    setError: setFormError,
  } = useForm<LoginFormData>({
    resolver: zodResolver(loginSchema),
    defaultValues: {
      email: '',
      password: '',
    },
  })

  const onSubmit = async (data: LoginFormData) => {
    try {
      setIsLoading(true)
      setError(null)

      await signIn(data.email, data.password)

      if (onSuccess) {
        onSuccess()
      } else {
        navigate(from, { replace: true })
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Login failed. Please try again.'

      // Handle specific Supabase auth errors
      if (errorMessage.includes('Invalid login credentials')) {
        setFormError('email', { message: 'Invalid email or password' })
        setFormError('password', { message: 'Invalid email or password' })
      } else if (errorMessage.includes('Email not confirmed')) {
        setError('Please check your email and click the confirmation link before logging in.')
      } else if (errorMessage.includes('Too many requests')) {
        setError('Too many login attempts. Please wait a few minutes and try again.')
      } else {
        setError(errorMessage)
      }
    } finally {
      setIsLoading(false)
    }
  }

  const togglePasswordVisibility = () => {
    setShowPassword(!showPassword)
  }

  return (
    <div className={`w-full max-w-md mx-auto ${className}`}>
      <div className="bg-white shadow-lg rounded-lg px-8 py-6">
        <div className="mb-6 text-center">
          <h2 className="text-2xl font-bold text-gray-900">Sign In</h2>
          <p className="mt-2 text-sm text-gray-600">Access your DCE Platform account</p>
        </div>

        {message && (
          <div className="mb-4 p-3 bg-blue-50 border border-blue-200 rounded-md">
            <p className="text-sm text-blue-800">{message}</p>
          </div>
        )}

        {error && (
          <div className="mb-4 p-3 bg-red-50 border border-red-200 rounded-md">
            <p className="text-sm text-red-800">{error}</p>
          </div>
        )}

        <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
          <div>
            <label htmlFor="email" className="block text-sm font-medium text-gray-700 mb-1">
              Email Address
            </label>
            <input
              {...register('email')}
              type="email"
              id="email"
              autoComplete="email"
              className={`w-full px-3 py-2 border rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 ${
                errors.email ? 'border-red-300' : 'border-gray-300'
              }`}
              placeholder="Enter your email"
              disabled={isSubmitting || isLoading}
            />
            {errors.email && <p className="mt-1 text-sm text-red-600">{errors.email.message}</p>}
          </div>

          <div>
            <label htmlFor="password" className="block text-sm font-medium text-gray-700 mb-1">
              Password
            </label>
            <div className="relative">
              <input
                {...register('password')}
                type={showPassword ? 'text' : 'password'}
                id="password"
                autoComplete="current-password"
                className={`w-full px-3 py-2 pr-10 border rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 ${
                  errors.password ? 'border-red-300' : 'border-gray-300'
                }`}
                placeholder="Enter your password"
                disabled={isSubmitting || isLoading}
              />
              <button
                type="button"
                onClick={togglePasswordVisibility}
                className="absolute inset-y-0 right-0 pr-3 flex items-center"
                disabled={isSubmitting || isLoading}
              >
                {showPassword ? (
                  <EyeSlashIcon className="h-5 w-5 text-gray-400 hover:text-gray-600" />
                ) : (
                  <EyeIcon className="h-5 w-5 text-gray-400 hover:text-gray-600" />
                )}
              </button>
            </div>
            {errors.password && (
              <p className="mt-1 text-sm text-red-600">{errors.password.message}</p>
            )}
          </div>

          <div className="flex items-center justify-between">
            <div className="flex items-center">
              <input
                id="remember-me"
                name="remember-me"
                type="checkbox"
                className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
              />
              <label htmlFor="remember-me" className="ml-2 block text-sm text-gray-700">
                Remember me
              </label>
            </div>

            <Link
              to="/forgot-password"
              className="text-sm text-blue-600 hover:text-blue-500 hover:underline"
            >
              Forgot password?
            </Link>
          </div>

          <button
            type="submit"
            disabled={isSubmitting || isLoading}
            className="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {isSubmitting || isLoading ? (
              <div className="flex items-center">
                <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white mr-2" />
                Signing in...
              </div>
            ) : (
              'Sign In'
            )}
          </button>
        </form>

        <div className="mt-6">
          <div className="relative">
            <div className="absolute inset-0 flex items-center">
              <div className="w-full border-t border-gray-300" />
            </div>
            <div className="relative flex justify-center text-sm">
              <span className="px-2 bg-white text-gray-500">Don't have an account?</span>
            </div>
          </div>

          <div className="mt-4">
            <Link
              to="/register"
              className="w-full flex justify-center py-2 px-4 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
            >
              Create Account
            </Link>
          </div>
        </div>
      </div>

      {/* Demo credentials for development */}
      {process.env.NODE_ENV === 'development' && (
        <div className="mt-4 p-3 bg-yellow-50 border border-yellow-200 rounded-md">
          <p className="text-xs text-yellow-800 font-medium mb-1">Demo Credentials:</p>
          <p className="text-xs text-yellow-700">
            Supplier: supplier@demo.com / password123
            <br />
            Buyer: buyer@demo.com / password123
            <br />
            Admin: admin@demo.com / password123
          </p>
        </div>
      )}
    </div>
  )
}
</file>

<file path="src/components/auth/LoginForm.tsx">
import { useState } from 'react'
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { z } from 'zod'
import { EyeIcon, EyeSlashIcon } from '@heroicons/react/24/outline'
import { useAuthStore } from '../../store/authStore'

// Validation schema using Zod (NO REGEX)
const loginFormSchema = z.object({
  email: z
    .string({ required_error: 'Email is required' })
    .min(1, 'Email is required')
    .email('Please enter a valid email address'),
  password: z
    .string({ required_error: 'Password is required' })
    .min(1, 'Password is required')
    .min(8, 'Password must be at least 8 characters'),
  rememberMe: z.boolean().optional().default(false),
})

type LoginFormData = z.infer<typeof loginFormSchema>

interface LoginFormProps {
  onSuccess?: (user: unknown) => void
  onError?: (error: string) => void
  showRememberMe?: boolean
  showForgotPassword?: boolean
  className?: string
  disabled?: boolean
}

export function LoginForm({
  onSuccess,
  onError,
  showRememberMe = true,
  showForgotPassword = true,
  className = '',
  disabled = false,
}: LoginFormProps) {
  const [showPassword, setShowPassword] = useState(false)
  const [isSubmitting, setIsSubmitting] = useState(false)
  const { signIn } = useAuthStore()

  const {
    register,
    handleSubmit,
    formState: { errors, isValid },
    setError: setFormError,
    reset,
  } = useForm<LoginFormData>({
    resolver: zodResolver(loginFormSchema),
    mode: 'onChange',
    defaultValues: {
      email: '',
      password: '',
      rememberMe: false,
    },
  })

  const togglePasswordVisibility = () => {
    setShowPassword(!showPassword)
  }

  const onSubmit = async (data: LoginFormData) => {
    if (disabled || isSubmitting) return

    try {
      setIsSubmitting(true)

      // Use the auth store to sign in
      const user = await signIn(data.email, data.password)

      // Handle remember me functionality
      if (data.rememberMe) {
        localStorage.setItem('dce_remember_me', 'true')
      } else {
        localStorage.removeItem('dce_remember_me')
      }

      // Call success callback if provided
      if (onSuccess) {
        onSuccess(user)
      }

      // Reset form on success
      reset()
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Login failed. Please try again.'

      // Handle specific authentication errors
      if (errorMessage.includes('Invalid login credentials')) {
        setFormError('email', {
          type: 'manual',
          message: 'Invalid email or password',
        })
        setFormError('password', {
          type: 'manual',
          message: 'Invalid email or password',
        })
      } else if (errorMessage.includes('Email not confirmed')) {
        setFormError('email', {
          type: 'manual',
          message: 'Please check your email and confirm your account',
        })
      } else if (errorMessage.includes('Too many requests')) {
        setFormError('email', {
          type: 'manual',
          message: 'Too many attempts. Please wait and try again',
        })
      } else {
        // General error handling
        if (onError) {
          onError(errorMessage)
        } else {
          setFormError('email', {
            type: 'manual',
            message: errorMessage,
          })
        }
      }
    } finally {
      setIsSubmitting(false)
    }
  }

  const isFormDisabled = disabled || isSubmitting

  return (
    <form onSubmit={handleSubmit(onSubmit)} className={`space-y-6 ${className}`} noValidate>
      {/* Email Field */}
      <div>
        <label htmlFor="email" className="block text-sm font-medium text-gray-700 mb-2">
          Email Address
        </label>
        <input
          {...register('email')}
          type="email"
          id="email"
          autoComplete="email"
          spellCheck="false"
          className={`
            w-full px-4 py-3 border rounded-lg shadow-sm 
            transition-colors duration-200
            focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500
            disabled:bg-gray-50 disabled:cursor-not-allowed
            ${
              errors.email
                ? 'border-red-300 bg-red-50 focus:ring-red-500 focus:border-red-500'
                : 'border-gray-300 bg-white hover:border-gray-400'
            }
          `}
          placeholder="Enter your email address"
          disabled={isFormDisabled}
          aria-invalid={errors.email ? 'true' : 'false'}
          aria-describedby={errors.email ? 'email-error' : undefined}
        />
        {errors.email && (
          <p id="email-error" className="mt-2 text-sm text-red-600" role="alert">
            {errors.email.message}
          </p>
        )}
      </div>

      {/* Password Field */}
      <div>
        <label htmlFor="password" className="block text-sm font-medium text-gray-700 mb-2">
          Password
        </label>
        <div className="relative">
          <input
            {...register('password')}
            type={showPassword ? 'text' : 'password'}
            id="password"
            autoComplete="current-password"
            className={`
              w-full px-4 py-3 pr-12 border rounded-lg shadow-sm 
              transition-colors duration-200
              focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500
              disabled:bg-gray-50 disabled:cursor-not-allowed
              ${
                errors.password
                  ? 'border-red-300 bg-red-50 focus:ring-red-500 focus:border-red-500'
                  : 'border-gray-300 bg-white hover:border-gray-400'
              }
            `}
            placeholder="Enter your password"
            disabled={isFormDisabled}
            aria-invalid={errors.password ? 'true' : 'false'}
            aria-describedby={errors.password ? 'password-error' : undefined}
          />
          <button
            type="button"
            onClick={togglePasswordVisibility}
            className={`
              absolute inset-y-0 right-0 pr-4 flex items-center
              transition-colors duration-200
              ${
                isFormDisabled
                  ? 'cursor-not-allowed text-gray-300'
                  : 'cursor-pointer text-gray-400 hover:text-gray-600'
              }
            `}
            disabled={isFormDisabled}
            aria-label={showPassword ? 'Hide password' : 'Show password'}
          >
            {showPassword ? <EyeSlashIcon className="h-5 w-5" /> : <EyeIcon className="h-5 w-5" />}
          </button>
        </div>
        {errors.password && (
          <p id="password-error" className="mt-2 text-sm text-red-600" role="alert">
            {errors.password.message}
          </p>
        )}
      </div>

      {/* Remember Me & Forgot Password */}
      {(showRememberMe || showForgotPassword) && (
        <div className="flex items-center justify-between">
          {showRememberMe && (
            <div className="flex items-center">
              <input
                {...register('rememberMe')}
                id="remember-me"
                type="checkbox"
                className={`
                  h-4 w-4 text-blue-600 border-gray-300 rounded
                  focus:ring-blue-500 focus:ring-2
                  disabled:cursor-not-allowed disabled:opacity-50
                `}
                disabled={isFormDisabled}
              />
              <label
                htmlFor="remember-me"
                className={`
                  ml-2 block text-sm 
                  ${isFormDisabled ? 'text-gray-400' : 'text-gray-700'}
                `}
              >
                Remember me
              </label>
            </div>
          )}

          {showForgotPassword && (
            <div className={showRememberMe ? '' : 'ml-auto'}>
              <button
                type="button"
                className={`
                  text-sm font-medium transition-colors duration-200
                  ${
                    isFormDisabled
                      ? 'text-gray-400 cursor-not-allowed'
                      : 'text-blue-600 hover:text-blue-500 hover:underline'
                  }
                `}
                disabled={isFormDisabled}
                onClick={() => {
                  // This would typically navigate to forgot password page
                  // For now, we'll just log it
                  console.log('Navigate to forgot password')
                }}
              >
                Forgot your password?
              </button>
            </div>
          )}
        </div>
      )}

      {/* Submit Button */}
      <button
        type="submit"
        disabled={isFormDisabled || !isValid}
        className={`
          w-full flex justify-center items-center py-3 px-4 
          border border-transparent rounded-lg shadow-sm 
          text-sm font-medium text-white
          transition-all duration-200
          focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500
          ${
            isFormDisabled || !isValid
              ? 'bg-gray-400 cursor-not-allowed opacity-60'
              : 'bg-blue-600 hover:bg-blue-700 active:bg-blue-800'
          }
        `}
        aria-describedby={isSubmitting ? 'submitting-status' : undefined}
      >
        {isSubmitting ? (
          <>
            <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white mr-2" />
            <span id="submitting-status">Signing in...</span>
          </>
        ) : (
          'Sign In'
        )}
      </button>

      {/* Development Demo Credentials */}
      {process.env.NODE_ENV === 'development' && (
        <div className="mt-6 p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
          <p className="text-xs font-medium text-yellow-800 mb-2">
            Demo Credentials (Development Only):
          </p>
          <div className="space-y-1 text-xs text-yellow-700">
            <p>
              <strong>Supplier:</strong> supplier@demo.com / password123
            </p>
            <p>
              <strong>Buyer:</strong> buyer@demo.com / password123
            </p>
            <p>
              <strong>Admin:</strong> admin@demo.com / password123
            </p>
          </div>
        </div>
      )}
    </form>
  )
}

export default LoginForm
</file>

<file path="src/components/campaigns/CLAUDE.md">
# Campaign Components

# Component Structure
- `CampaignCard.tsx` - Campaign display card
- `CampaignForm.tsx` - Campaign creation/editing form
- `CampaignFilters.tsx` - Filtering and search
- `CampaignStats.tsx` - Performance metrics
- `CampaignList.tsx` - Paginated campaign list

# Campaign Management
```tsx
interface CampaignCardProps {
  campaign: Campaign;
  onEdit?: (id: string) => void;
  onDelete?: (id: string) => void;
  showActions?: boolean;
}

export function CampaignCard({ campaign, onEdit, onDelete, showActions }: CampaignCardProps) {
  return (
    <div className="campaign-card">
      <h3>{campaign.name}</h3>
      <div className="campaign-stats">
        <StatItem label="Target CPA" value={formatCurrency(campaign.target_cpa)} />
        <StatItem label="Daily Budget" value={formatCurrency(campaign.daily_budget)} />
        <StatItem label="Status" value={campaign.status} />
      </div>
      {showActions && (
        <div className="campaign-actions">
          <Button onClick={() => onEdit?.(campaign.id)}>Edit</Button>
          <Button onClick={() => onDelete?.(campaign.id)} variant="danger">Delete</Button>
        </div>
      )}
    </div>
  );
}
```

# Real-time Updates
- Live call volume indicators
- Performance metrics updates
- Budget consumption tracking
- Quality score changes

# Campaign Filters
```tsx
interface CampaignFiltersProps {
  onFiltersChange: (filters: CampaignFilters) => void;
  initialFilters?: CampaignFilters;
}

export function CampaignFilters({ onFiltersChange, initialFilters }: CampaignFiltersProps) {
  const [filters, setFilters] = useState(initialFilters || {});
  
  const handleFilterChange = (key: keyof CampaignFilters, value: unknown) => {
    const newFilters = { ...filters, [key]: value };
    setFilters(newFilters);
    onFiltersChange(newFilters);
  };
  
  return (
    <div className="campaign-filters">
      <Select
        value={filters.vertical}
        onChange={(value) => handleFilterChange('vertical', value)}
        options={CAMPAIGN_VERTICALS}
      />
      <Select
        value={filters.status}
        onChange={(value) => handleFilterChange('status', value)}
        options={CAMPAIGN_STATUSES}
      />
    </div>
  );
}
```

# Form Components
- Geographic targeting selectors
- Budget and CPA inputs
- Time restriction settings
- Quality requirements

# Performance Visualization
- Chart components for metrics
- Real-time data updates
- Export functionality
- Comparative analysis

# DCE-Specific Features
- Vertical-specific settings
- Fraud protection toggles
- Payout calculation displays
- Lead quality thresholds

# Integration Patterns
- Supabase real-time subscriptions
- Stripe billing integration
- Analytics data fetching
- Campaign optimization suggestions

# CRITICAL RULES
- NO regex in campaign validation
- NO any types in component props
- ALWAYS handle real-time updates
- ALWAYS validate budget constraints
- IMPLEMENT proper error boundaries
- TEST all campaign operations
</file>

<file path="src/components/common/CLAUDE.md">
# Common Shared Components

# UI Components
- `Button.tsx` - Consistent button styles
- `Input.tsx` - Form input fields
- `Modal.tsx` - Modal dialogs
- `LoadingSpinner.tsx` - Loading indicators
- `ErrorBoundary.tsx` - Error handling

# Layout Components
- `Card.tsx` - Content containers
- `Table.tsx` - Data tables
- `Pagination.tsx` - Page navigation
- `Breadcrumbs.tsx` - Navigation trail
- `Sidebar.tsx` - Navigation sidebar

# Form Components
```tsx
interface InputProps extends React.InputHTMLAttributes<HTMLInputElement> {
  label?: string;
  error?: string;
  helperText?: string;
  required?: boolean;
}

export function Input({ label, error, helperText, required, className, ...props }: InputProps) {
  return (
    <div className="input-group">
      {label && (
        <label className="input-label">
          {label}
          {required && <span className="required">*</span>}
        </label>
      )}
      <input
        className={`input ${error ? 'input-error' : ''} ${className || ''}`}
        aria-invalid={!!error}
        {...props}
      />
      {error && <div className="input-error-text">{error}</div>}
      {helperText && <div className="input-helper-text">{helperText}</div>}
    </div>
  );
}
```

# Data Display Components
```tsx
interface TableProps<T> {
  data: T[];
  columns: TableColumn<T>[];
  loading?: boolean;
  onSort?: (key: keyof T, direction: 'asc' | 'desc') => void;
  onRowClick?: (item: T) => void;
}

export function Table<T>({ data, columns, loading, onSort, onRowClick }: TableProps<T>) {
  if (loading) return <LoadingSpinner />;
  
  return (
    <table className="data-table">
      <thead>
        <tr>
          {columns.map(column => (
            <th key={String(column.key)} onClick={() => onSort?.(column.key, 'asc')}>
              {column.title}
            </th>
          ))}
        </tr>
      </thead>
      <tbody>
        {data.map((item, index) => (
          <tr key={index} onClick={() => onRowClick?.(item)}>
            {columns.map(column => (
              <td key={String(column.key)}>
                {column.render ? column.render(item) : String(item[column.key])}
              </td>
            ))}
          </tr>
        ))}
      </tbody>
    </table>
  );
}
```

# Modal Components
- Confirmation dialogs
- Form modals
- Image/media viewers
- Help and tutorial overlays

# Notification System
```tsx
interface ToastProps {
  type: 'success' | 'error' | 'warning' | 'info';
  message: string;
  onDismiss: () => void;
  autoClose?: boolean;
}

export function Toast({ type, message, onDismiss, autoClose = true }: ToastProps) {
  useEffect(() => {
    if (autoClose) {
      const timer = setTimeout(onDismiss, 5000);
      return () => clearTimeout(timer);
    }
  }, [autoClose, onDismiss]);
  
  return (
    <div className={`toast toast-${type}`}>
      <span>{message}</span>
      <button onClick={onDismiss} className="toast-close">Ã—</button>
    </div>
  );
}
```

# Loading States
- Skeleton loaders
- Progress indicators
- Shimmer effects
- Empty state placeholders

# Error Handling
```tsx
interface ErrorBoundaryState {
  hasError: boolean;
  error?: Error;
}

export class ErrorBoundary extends Component<PropsWithChildren, ErrorBoundaryState> {
  constructor(props: PropsWithChildren) {
    super(props);
    this.state = { hasError: false };
  }
  
  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error };
  }
  
  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('Error boundary caught error:', error, errorInfo);
    // Send to error reporting service
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <div className="error-fallback">
          <h2>Oops! Something went wrong</h2>
          <p>We've been notified of this error. Please try refreshing the page.</p>
          <Button onClick={() => window.location.reload()}>Refresh Page</Button>
        </div>
      );
    }
    
    return this.props.children;
  }
}
```

# Accessibility Features
- ARIA labels and roles
- Keyboard navigation
- Screen reader support
- Focus management
- Color contrast compliance

# Design System Integration
- Consistent spacing tokens
- Typography scale
- Color palette
- Icon library usage
- Animation standards

# Performance Optimization
- Memoized components
- Lazy loading
- Virtual scrolling for large lists
- Image optimization

# CRITICAL RULES
- NO regex in component logic
- NO any types in props interfaces
- ALWAYS implement accessibility
- ALWAYS handle loading/error states
- USE consistent design tokens
- TEST all interactive elements
- OPTIMIZE for performance
- MAINTAIN design system consistency
</file>

<file path="src/components/common/withErrorBoundary.tsx">
import React from 'react'
import type { ReactNode, ErrorInfo } from 'react'
import { ErrorBoundary } from './ErrorBoundary'
import type { ErrorFallbackProps } from './ErrorBoundary'

// Higher-Order Component for wrapping components with ErrorBoundary
export interface WithErrorBoundaryOptions {
  level?: 'page' | 'section' | 'component'
  onError?: (error: Error, errorInfo: ErrorInfo) => void
  fallback?: ReactNode | React.ComponentType<ErrorFallbackProps>
  context?: string
  showTechnicalDetails?: boolean
}

export function withErrorBoundary<T extends Record<string, unknown>>(
  Component: React.ComponentType<T>,
  options: WithErrorBoundaryOptions = {}
): React.ComponentType<T> {
  const WrappedComponent = (props: T) => (
    <ErrorBoundary
      level={options.level || 'component'}
      onError={options.onError}
      fallback={options.fallback}
      context={options.context || Component.displayName || Component.name}
      showTechnicalDetails={options.showTechnicalDetails}
    >
      <Component {...props} />
    </ErrorBoundary>
  )

  WrappedComponent.displayName = `withErrorBoundary(${Component.displayName || Component.name})`

  return WrappedComponent
}
</file>

<file path="src/components/dashboard/admin/AdminDashboard.tsx">
import { useState } from 'react'
import { useAuth } from '../../../hooks/useAuth'
import { 
  CurrencyDollarIcon, 
  PhoneIcon, 
  ChartBarIcon,
  UserGroupIcon,
  ShieldCheckIcon,
  ExclamationTriangleIcon,
  ServerIcon,
  ClockIcon
} from '@heroicons/react/24/outline'

interface AdminStats {
  totalRevenue: number
  revenueTrend: number
  totalCalls: number
  callsTrend: number
  activeSuppliers: number
  suppliersTrend: number
  activeBuyers: number
  buyersTrend: number
  fraudBlocked: number
  fraudTrend: number
  systemUptime: number
  uptimeTrend: number
}

function StatCard({
  title,
  value,
  trend,
  icon: Icon,
  format = 'number',
  color = 'primary',
}: {
  title: string
  value: number | string
  trend: number
  icon: React.ComponentType<{ className?: string }>
  format?: 'number' | 'currency' | 'percentage' | 'uptime'
  color?: 'primary' | 'warning' | 'success'
}) {
  const formatValue = (val: number | string) => {
    if (typeof val === 'string') return val
    switch (format) {
      case 'currency':
        return new Intl.NumberFormat('en-US', {
          style: 'currency',
          currency: 'USD',
        }).format(val)
      case 'percentage':
        return `${val.toFixed(1)}%`
      case 'uptime':
        return `${val.toFixed(2)}%`
      default:
        return val.toLocaleString()
    }
  }

  const getTrendColor = (trend: number) => {
    if (trend > 0) return 'text-green-600'
    if (trend < 0) return 'text-red-600'
    return 'text-gray-500'
  }

  const getTrendIcon = (trend: number) => {
    if (trend > 0) return 'â†—'
    if (trend < 0) return 'â†˜'
    return 'â†’'
  }

  const iconColorClass = {
    primary: 'text-primary-600',
    warning: 'text-yellow-600',
    success: 'text-green-600',
  }[color]

  return (
    <div className="bg-white rounded-lg shadow p-6">
      <div className="flex items-center justify-between">
        <div className="flex items-center">
          <Icon className={`h-8 w-8 ${iconColorClass}`} />
          <div className="ml-3">
            <p className="text-sm font-medium text-gray-600">{title}</p>
            <p className="text-2xl font-bold text-gray-900">{formatValue(value)}</p>
          </div>
        </div>
        <div className={`text-sm font-medium ${getTrendColor(trend)}`}>
          <span className="inline-flex items-center">
            {getTrendIcon(trend)} {Math.abs(trend).toFixed(1)}%
          </span>
        </div>
      </div>
    </div>
  )
}

export function AdminDashboard() {
  const { user } = useAuth()
  const [selectedTimeRange, setSelectedTimeRange] = useState<'24h' | '7d' | '30d'>('7d')

  if (!user || user.user_metadata?.userType !== 'admin') {
    return (
      <div className="flex items-center justify-center h-64">
        <p className="text-gray-500">Access denied. Admin account required.</p>
      </div>
    )
  }

  // Mock data - in real app, this would come from API
  const stats: AdminStats = {
    totalRevenue: 156789,
    revenueTrend: 15.3,
    totalCalls: 4567,
    callsTrend: 12.8,
    activeSuppliers: 45,
    suppliersTrend: 5.2,
    activeBuyers: 28,
    buyersTrend: 8.7,
    fraudBlocked: 234,
    fraudTrend: -12.5,
    systemUptime: 99.98,
    uptimeTrend: 0.1,
  }

  return (
    <div data-testid="admin-dashboard" className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold text-gray-900">Admin Dashboard</h1>
          <p className="text-gray-600">Platform overview and system health</p>
        </div>
        <div className="flex items-center space-x-2">
          <label htmlFor="timeRange" className="text-sm text-gray-700">
            Time Range:
          </label>
          <select
            id="timeRange"
            value={selectedTimeRange}
            onChange={(e) => setSelectedTimeRange(e.target.value as '24h' | '7d' | '30d')}
            className="rounded-md border-gray-300 text-sm focus:border-primary-500 focus:ring-primary-500"
          >
            <option value="24h">Last 24 Hours</option>
            <option value="7d">Last 7 Days</option>
            <option value="30d">Last 30 Days</option>
          </select>
        </div>
      </div>

      {/* Stats Grid */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        <StatCard
          title="Platform Revenue"
          value={stats.totalRevenue}
          trend={stats.revenueTrend}
          icon={CurrencyDollarIcon}
          format="currency"
        />
        <StatCard
          title="Total Calls"
          value={stats.totalCalls}
          trend={stats.callsTrend}
          icon={PhoneIcon}
        />
        <StatCard
          title="Active Suppliers"
          value={stats.activeSuppliers}
          trend={stats.suppliersTrend}
          icon={UserGroupIcon}
        />
        <StatCard
          title="Active Buyers"
          value={stats.activeBuyers}
          trend={stats.buyersTrend}
          icon={ChartBarIcon}
        />
        <StatCard
          title="Fraud Blocked"
          value={stats.fraudBlocked}
          trend={stats.fraudTrend}
          icon={ShieldCheckIcon}
          color="warning"
        />
        <StatCard
          title="System Uptime"
          value={stats.systemUptime}
          trend={stats.uptimeTrend}
          icon={ServerIcon}
          format="uptime"
          color="success"
        />
      </div>

      {/* System Alerts */}
      <div className="bg-white shadow rounded-lg">
        <div className="px-6 py-4 border-b border-gray-200">
          <h2 className="text-lg font-medium text-gray-900">System Alerts</h2>
        </div>
        <ul className="divide-y divide-gray-200">
          <li className="px-6 py-4">
            <div className="flex items-center">
              <ExclamationTriangleIcon className="h-6 w-6 text-yellow-500 flex-shrink-0" />
              <div className="ml-3 flex-1">
                <p className="text-sm font-medium text-gray-900">High fraud activity detected</p>
                <p className="text-sm text-gray-500">
                  15 suspicious calls blocked from IP range 192.168.x.x
                </p>
              </div>
              <span className="text-sm text-gray-500">10 minutes ago</span>
            </div>
          </li>
          <li className="px-6 py-4">
            <div className="flex items-center">
              <ShieldCheckIcon className="h-6 w-6 text-green-500 flex-shrink-0" />
              <div className="ml-3 flex-1">
                <p className="text-sm font-medium text-gray-900">Security update completed</p>
                <p className="text-sm text-gray-500">
                  All systems patched and secured
                </p>
              </div>
              <span className="text-sm text-gray-500">2 hours ago</span>
            </div>
          </li>
        </ul>
      </div>

      {/* Top Performers Table */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        {/* Top Suppliers */}
        <div className="bg-white shadow rounded-lg">
          <div className="px-6 py-4 border-b border-gray-200">
            <h2 className="text-lg font-medium text-gray-900">Top Suppliers</h2>
          </div>
          <div className="overflow-x-auto">
            <table className="min-w-full divide-y divide-gray-200">
              <thead className="bg-gray-50">
                <tr>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Supplier
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Calls
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Quality
                  </th>
                </tr>
              </thead>
              <tbody className="bg-white divide-y divide-gray-200">
                <tr>
                  <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                    LeadGen Pro
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">847</td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">96%</td>
                </tr>
                <tr>
                  <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                    CallMaster Inc
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">652</td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">94%</td>
                </tr>
                <tr>
                  <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                    Premium Leads Co
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">523</td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">92%</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>

        {/* Top Buyers */}
        <div className="bg-white shadow rounded-lg">
          <div className="px-6 py-4 border-b border-gray-200">
            <h2 className="text-lg font-medium text-gray-900">Top Buyers</h2>
          </div>
          <div className="overflow-x-auto">
            <table className="min-w-full divide-y divide-gray-200">
              <thead className="bg-gray-50">
                <tr>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Buyer
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Spent
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Campaigns
                  </th>
                </tr>
              </thead>
              <tbody className="bg-white divide-y divide-gray-200">
                <tr>
                  <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                    Insurance Direct
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">$24,580</td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">8</td>
                </tr>
                <tr>
                  <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                    Solar Solutions
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">$18,920</td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">5</td>
                </tr>
                <tr>
                  <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                    Home Services Hub
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">$15,340</td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">6</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>

      {/* System Status */}
      <div className="bg-white shadow rounded-lg">
        <div className="px-6 py-4 border-b border-gray-200">
          <h2 className="text-lg font-medium text-gray-900">System Status</h2>
        </div>
        <div className="px-6 py-4">
          <div className="space-y-4">
            <div className="flex items-center justify-between">
              <div className="flex items-center">
                <ServerIcon className="h-5 w-5 text-gray-400 mr-3" />
                <span className="text-sm font-medium text-gray-900">API Server</span>
              </div>
              <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800">
                Operational
              </span>
            </div>
            <div className="flex items-center justify-between">
              <div className="flex items-center">
                <ServerIcon className="h-5 w-5 text-gray-400 mr-3" />
                <span className="text-sm font-medium text-gray-900">Database</span>
              </div>
              <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800">
                Operational
              </span>
            </div>
            <div className="flex items-center justify-between">
              <div className="flex items-center">
                <ClockIcon className="h-5 w-5 text-gray-400 mr-3" />
                <span className="text-sm font-medium text-gray-900">Real-time Processing</span>
              </div>
              <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800">
                Operational
              </span>
            </div>
            <div className="flex items-center justify-between">
              <div className="flex items-center">
                <ShieldCheckIcon className="h-5 w-5 text-gray-400 mr-3" />
                <span className="text-sm font-medium text-gray-900">Fraud Detection</span>
              </div>
              <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800">
                Active
              </span>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/components/dashboard/supplier/ActiveCampaignsTable.tsx">
import { useQuery } from '@tanstack/react-query'
import { PlayIcon, PauseIcon, EyeIcon, ChartBarIcon } from '@heroicons/react/24/outline'
import { supabase } from '../../../lib/supabase'

interface ActiveCampaignsTableProps {
  supplierId: string
}

interface Campaign {
  id: string
  name: string
  buyer_name: string
  status: 'active' | 'paused' | 'completed'
  bid_amount: number
  daily_cap: number
  calls_today: number
  revenue_today: number
  conversion_rate: number
  quality_score: number
  created_at: string
}

async function fetchActiveCampaigns(supplierId: string): Promise<Campaign[]> {
  const { data, error } = await supabase
    .from('supplier_campaigns_view')
    .select('*')
    .eq('supplier_id', supplierId)
    .in('status', ['active', 'paused'])
    .order('created_at', { ascending: false })

  if (error) {
    console.error('Error fetching campaigns:', error)
    return []
  }

  return data || []
}

function CampaignStatusBadge({ status }: { status: Campaign['status'] }) {
  const getStatusConfig = (status: string) => {
    switch (status) {
      case 'active':
        return {
          className: 'bg-green-100 text-green-800',
          text: 'Active',
          icon: 'ðŸŸ¢',
        }
      case 'paused':
        return {
          className: 'bg-yellow-100 text-yellow-800',
          text: 'Paused',
          icon: 'â¸ï¸',
        }
      case 'completed':
        return {
          className: 'bg-gray-100 text-gray-800',
          text: 'Completed',
          icon: 'âœ…',
        }
      default:
        return {
          className: 'bg-gray-100 text-gray-800',
          text: 'Unknown',
          icon: 'â“',
        }
    }
  }

  const config = getStatusConfig(status)

  return (
    <span
      className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${config.className}`}
    >
      <span className="mr-1">{config.icon}</span>
      {config.text}
    </span>
  )
}

function ProgressBar({ current, max, label }: { current: number; max: number; label: string }) {
  const percentage = max > 0 ? Math.min((current / max) * 100, 100) : 0
  const isNearLimit = percentage >= 90

  return (
    <div className="w-full">
      <div className="flex justify-between text-xs text-gray-600 mb-1">
        <span>{label}</span>
        <span>
          {current}/{max}
        </span>
      </div>
      <div className="w-full bg-gray-200 rounded-full h-2">
        <div
          className={`h-2 rounded-full transition-all duration-300 ${
            isNearLimit ? 'bg-red-500' : 'bg-primary-500'
          }`}
          style={{ width: `${percentage}%` }}
        />
      </div>
    </div>
  )
}

export function ActiveCampaignsTable({ supplierId }: ActiveCampaignsTableProps) {
  const {
    data: campaigns,
    isLoading,
    error,
  } = useQuery({
    queryKey: ['active-campaigns', supplierId],
    queryFn: () => fetchActiveCampaigns(supplierId),
    refetchInterval: 60000, // Refresh every minute
  })

  const handleToggleCampaign = async (campaignId: string, currentStatus: string) => {
    const newStatus = currentStatus === 'active' ? 'paused' : 'active'

    try {
      const { error } = await supabase
        .from('campaigns')
        .update({ status: newStatus })
        .eq('id', campaignId)

      if (error) {
        console.error('Error updating campaign status:', error)
        // In a real app, you'd show a toast notification here
      }
    } catch (err) {
      console.error('Error toggling campaign:', err)
    }
  }

  const handleViewDetails = (campaignId: string) => {
    // In a real implementation, this would navigate to campaign details
    console.log('Viewing campaign details:', campaignId)
  }

  if (error) {
    return (
      <div className="bg-white rounded-lg shadow">
        <div className="p-6">
          <h3 className="text-lg font-semibold text-gray-900 mb-4">Active Campaigns</h3>
          <div className="text-center py-8 text-red-500">
            <p>Error loading campaigns. Please try again.</p>
          </div>
        </div>
      </div>
    )
  }

  return (
    <div className="bg-white rounded-lg shadow">
      {/* Header */}
      <div className="p-6 border-b border-gray-200">
        <div className="flex items-center justify-between">
          <h3 className="text-lg font-semibold text-gray-900">Active Campaigns</h3>
          {isLoading && (
            <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-primary-600"></div>
          )}
        </div>
      </div>

      {/* Table */}
      <div className="overflow-x-auto">
        {isLoading ? (
          // Loading skeleton
          <div className="p-6">
            <div className="animate-pulse space-y-4">
              {[...Array(3)].map((_, i) => (
                <div key={i} className="flex items-center space-x-4">
                  <div className="h-4 bg-gray-200 rounded w-1/4"></div>
                  <div className="h-4 bg-gray-200 rounded w-1/6"></div>
                  <div className="h-4 bg-gray-200 rounded w-1/6"></div>
                  <div className="h-4 bg-gray-200 rounded w-1/6"></div>
                  <div className="h-4 bg-gray-200 rounded w-1/6"></div>
                </div>
              ))}
            </div>
          </div>
        ) : campaigns?.length === 0 ? (
          <div className="p-8 text-center text-gray-500">
            <ChartBarIcon className="h-12 w-12 mx-auto mb-4 text-gray-300" />
            <p>No active campaigns found.</p>
            <p className="text-sm mt-1">Join campaigns to start receiving calls.</p>
          </div>
        ) : (
          <table className="min-w-full divide-y divide-gray-200">
            <thead className="bg-gray-50">
              <tr>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Campaign
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Status
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Bid
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Today's Progress
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Performance
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Actions
                </th>
              </tr>
            </thead>
            <tbody className="bg-white divide-y divide-gray-200">
              {campaigns?.map((campaign) => (
                <tr key={campaign.id} className="hover:bg-gray-50">
                  <td className="px-6 py-4 whitespace-nowrap">
                    <div>
                      <div className="text-sm font-medium text-gray-900">{campaign.name}</div>
                      <div className="text-sm text-gray-500">{campaign.buyer_name}</div>
                    </div>
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap">
                    <CampaignStatusBadge status={campaign.status} />
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                    ${campaign.bid_amount.toFixed(2)}
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap">
                    <div className="w-32">
                      <ProgressBar
                        current={campaign.calls_today}
                        max={campaign.daily_cap}
                        label="Calls"
                      />
                    </div>
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap">
                    <div className="text-sm text-gray-900">
                      <div className="flex items-center justify-between mb-1">
                        <span>Revenue:</span>
                        <span className="font-medium text-green-600">
                          ${campaign.revenue_today.toFixed(2)}
                        </span>
                      </div>
                      <div className="flex items-center justify-between mb-1">
                        <span>Conv. Rate:</span>
                        <span className="font-medium">{campaign.conversion_rate.toFixed(1)}%</span>
                      </div>
                      <div className="flex items-center justify-between">
                        <span>Quality:</span>
                        <span className="font-medium">{campaign.quality_score}/100</span>
                      </div>
                    </div>
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm font-medium space-x-2">
                    <button
                      onClick={() => handleToggleCampaign(campaign.id, campaign.status)}
                      className={`inline-flex items-center px-3 py-1 rounded-md text-xs font-medium ${
                        campaign.status === 'active'
                          ? 'bg-yellow-100 text-yellow-800 hover:bg-yellow-200'
                          : 'bg-green-100 text-green-800 hover:bg-green-200'
                      }`}
                    >
                      {campaign.status === 'active' ? (
                        <>
                          <PauseIcon className="h-3 w-3 mr-1" />
                          Pause
                        </>
                      ) : (
                        <>
                          <PlayIcon className="h-3 w-3 mr-1" />
                          Resume
                        </>
                      )}
                    </button>
                    <button
                      onClick={() => handleViewDetails(campaign.id)}
                      className="inline-flex items-center px-3 py-1 rounded-md text-xs font-medium bg-primary-100 text-primary-800 hover:bg-primary-200"
                    >
                      <EyeIcon className="h-3 w-3 mr-1" />
                      Details
                    </button>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        )}
      </div>
    </div>
  )
}
</file>

<file path="src/components/dashboard/supplier/CallVolumeChart.tsx">
import { useState } from 'react'
import { useQuery } from '@tanstack/react-query'
import { ChartBarIcon, ArrowDownTrayIcon } from '@heroicons/react/24/outline'
import { supabase } from '../../../lib/supabase'

interface CallVolumeChartProps {
  timeRange: '24h' | '7d' | '30d'
  supplierId: string
}

interface ChartDataPoint {
  timestamp: string
  calls: number
  revenue: number
  conversions: number
}

type ChartMetric = 'calls' | 'revenue' | 'conversions'

async function fetchChartData(supplierId: string, timeRange: string): Promise<ChartDataPoint[]> {
  const hoursBack = timeRange === '24h' ? 24 : timeRange === '7d' ? 168 : 720
  const now = new Date()
  const startTime = new Date(now.getTime() - hoursBack * 60 * 60 * 1000)

  // Note: interval would be used for database query grouping in real implementation

  const { data, error } = await supabase
    .from('call_volume_chart_data')
    .select('*')
    .eq('supplier_id', supplierId)
    .gte('timestamp', startTime.toISOString())
    .order('timestamp', { ascending: true })

  if (error) {
    console.error('Error fetching chart data:', error)
    return []
  }

  return data || []
}

function formatChartData(data: ChartDataPoint[], timeRange: string) {
  return data.map((point) => ({
    ...point,
    formattedTime: formatTimestamp(point.timestamp, timeRange),
  }))
}

function formatTimestamp(timestamp: string, timeRange: string): string {
  const date = new Date(timestamp)

  if (timeRange === '24h') {
    return date.toLocaleTimeString('en-US', {
      hour: 'numeric',
      minute: '2-digit',
    })
  } else if (timeRange === '7d') {
    return date.toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric',
      hour: 'numeric',
    })
  } else {
    return date.toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric',
    })
  }
}

function SimpleBarChart({
  data,
  metric,
  height = 200,
}: {
  data: (ChartDataPoint & { formattedTime: string })[]
  metric: ChartMetric
  height?: number
}) {
  const maxValue = Math.max(...data.map((d) => d[metric]))
  const minValue = Math.min(...data.map((d) => d[metric]))
  const range = maxValue - minValue || 1

  const getBarHeight = (value: number) => {
    return ((value - minValue) / range) * (height - 40) + 20
  }

  const formatValue = (value: number) => {
    switch (metric) {
      case 'revenue':
        return `$${value.toFixed(0)}`
      case 'calls':
        return value.toString()
      case 'conversions':
        return value.toString()
      default:
        return value.toString()
    }
  }

  const getBarColor = () => {
    switch (metric) {
      case 'revenue':
        return 'fill-green-500'
      case 'calls':
        return 'fill-primary-500'
      case 'conversions':
        return 'fill-blue-500'
      default:
        return 'fill-gray-500'
    }
  }

  if (data.length === 0) {
    return (
      <div className="flex items-center justify-center h-48 text-gray-500">
        No data available for this time period
      </div>
    )
  }

  return (
    <div className="w-full">
      <svg width="100%" height={height + 60} className="overflow-visible">
        {/* Bars */}
        {data.map((point, index) => {
          const barWidth = 100 / data.length - 2 // 2% gap between bars
          const xPosition = (index * 100) / data.length + 1 // 1% offset
          const barHeight = getBarHeight(point[metric])

          return (
            <g key={point.timestamp}>
              {/* Bar */}
              <rect
                x={`${xPosition}%`}
                y={height - barHeight + 20}
                width={`${barWidth}%`}
                height={barHeight}
                className={`${getBarColor()} hover:opacity-80 transition-opacity cursor-pointer`}
              >
                <title>{`${point.formattedTime}: ${formatValue(point[metric])}`}</title>
              </rect>

              {/* X-axis label */}
              <text
                x={`${xPosition + barWidth / 2}%`}
                y={height + 35}
                textAnchor="middle"
                className="text-xs fill-gray-600"
                style={{ fontSize: '10px' }}
              >
                {point.formattedTime}
              </text>
            </g>
          )
        })}

        {/* Y-axis labels */}
        <text x="10" y="15" className="text-xs fill-gray-600" style={{ fontSize: '10px' }}>
          {formatValue(maxValue)}
        </text>
        <text x="10" y={height + 15} className="text-xs fill-gray-600" style={{ fontSize: '10px' }}>
          {formatValue(minValue)}
        </text>
      </svg>
    </div>
  )
}

export function CallVolumeChart({ timeRange, supplierId }: CallVolumeChartProps) {
  const [selectedMetric, setSelectedMetric] = useState<ChartMetric>('calls')

  const {
    data: rawData,
    isLoading,
    error,
  } = useQuery({
    queryKey: ['call-volume-chart', supplierId, timeRange],
    queryFn: () => fetchChartData(supplierId, timeRange),
    refetchInterval: 60000, // Refresh every minute
  })

  const chartData = rawData ? formatChartData(rawData, timeRange) : []

  const handleExport = () => {
    if (!chartData.length) return

    const headers = ['Time', 'Calls', 'Revenue', 'Conversions']
    const csvContent = [
      headers.join(','),
      ...chartData.map((row) =>
        [row.formattedTime, row.calls, row.revenue, row.conversions].join(',')
      ),
    ].join('\n')

    const blob = new Blob([csvContent], { type: 'text/csv' })
    const url = window.URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = `call-volume-${timeRange}-${new Date().toISOString().split('T')[0]}.csv`
    document.body.appendChild(a)
    a.click()
    document.body.removeChild(a)
    window.URL.revokeObjectURL(url)
  }

  const getMetricLabel = (metric: ChartMetric) => {
    switch (metric) {
      case 'calls':
        return 'Calls'
      case 'revenue':
        return 'Revenue'
      case 'conversions':
        return 'Conversions'
    }
  }

  if (error) {
    return (
      <div className="bg-white rounded-lg shadow p-6">
        <div className="flex items-center justify-center h-48 text-red-500">
          <p>Error loading chart data. Please try again.</p>
        </div>
      </div>
    )
  }

  return (
    <div className="bg-white rounded-lg shadow">
      {/* Header */}
      <div className="p-6 border-b border-gray-200">
        <div className="flex items-center justify-between">
          <div className="flex items-center">
            <ChartBarIcon className="h-6 w-6 text-primary-600 mr-2" />
            <h3 className="text-lg font-semibold text-gray-900">Performance Chart</h3>
          </div>
          <div className="flex items-center space-x-3">
            {/* Metric Toggle */}
            <div className="flex rounded-md shadow-sm">
              {(['calls', 'revenue', 'conversions'] as ChartMetric[]).map((metric) => (
                <button
                  key={metric}
                  onClick={() => setSelectedMetric(metric)}
                  className={`px-3 py-2 text-sm font-medium border first:rounded-l-md last:rounded-r-md ${
                    selectedMetric === metric
                      ? 'bg-primary-600 text-white border-primary-600'
                      : 'bg-white text-gray-700 border-gray-300 hover:bg-gray-50'
                  }`}
                >
                  {getMetricLabel(metric)}
                </button>
              ))}
            </div>

            {/* Export Button */}
            <button
              onClick={handleExport}
              disabled={!chartData.length}
              className="inline-flex items-center px-3 py-2 border border-gray-300 shadow-sm text-sm leading-4 font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              <ArrowDownTrayIcon className="h-4 w-4 mr-1" />
              Export
            </button>
          </div>
        </div>
      </div>

      {/* Chart Content */}
      <div className="p-6">
        {isLoading ? (
          <div className="flex items-center justify-center h-48">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary-600"></div>
          </div>
        ) : (
          <SimpleBarChart data={chartData} metric={selectedMetric} />
        )}
      </div>
    </div>
  )
}
</file>

<file path="src/components/dashboard/supplier/index.ts">
export { SupplierDashboard } from './SupplierDashboard'
export { QuickStatsBar } from './QuickStatsBar'
export { CallVolumeChart } from './CallVolumeChart'
export { RecentCallsList } from './RecentCallsList'
export { ActiveCampaignsTable } from './ActiveCampaignsTable'
</file>

<file path="src/components/dashboard/supplier/QuickStatsBar.tsx">
import { useQuery } from '@tanstack/react-query'
import { PhoneIcon, CurrencyDollarIcon, ChartBarIcon, StarIcon } from '@heroicons/react/24/outline'
import { supabase } from '../../../lib/supabase'
import { useRealTimeStats } from '../../../hooks/useRealTimeStats'

interface QuickStatsBarProps {
  timeRange: '24h' | '7d' | '30d'
  supplierId: string
}

interface DashboardStats {
  totalCalls: number
  callsTrend: number
  revenue: number
  revenueTrend: number
  conversionRate: number
  conversionTrend: number
  qualityScore: number
  qualityTrend: number
}

async function fetchSupplierStats(supplierId: string, timeRange: string): Promise<DashboardStats> {
  const hoursBack = timeRange === '24h' ? 24 : timeRange === '7d' ? 168 : 720
  const now = new Date()
  const startTime = new Date(now.getTime() - hoursBack * 60 * 60 * 1000)

  // Fetch current period stats
  const { data: currentStats, error } = await supabase
    .from('supplier_stats_view')
    .select('*')
    .eq('supplier_id', supplierId)
    .gte('created_at', startTime.toISOString())
    .single()

  if (error) {
    console.error('Error fetching supplier stats:', error)
    // Return default stats if query fails
    return {
      totalCalls: 0,
      callsTrend: 0,
      revenue: 0,
      revenueTrend: 0,
      conversionRate: 0,
      conversionTrend: 0,
      qualityScore: 85,
      qualityTrend: 0,
    }
  }

  // Calculate previous period for trend comparison
  const prevStartTime = new Date(startTime.getTime() - hoursBack * 60 * 60 * 1000)
  const { data: prevStats } = await supabase
    .from('supplier_stats_view')
    .select('*')
    .eq('supplier_id', supplierId)
    .gte('created_at', prevStartTime.toISOString())
    .lt('created_at', startTime.toISOString())
    .single()

  const calculateTrend = (current: number, previous: number): number => {
    if (previous === 0) return current > 0 ? 100 : 0
    return ((current - previous) / previous) * 100
  }

  return {
    totalCalls: currentStats?.total_calls || 0,
    callsTrend: calculateTrend(currentStats?.total_calls || 0, prevStats?.total_calls || 0),
    revenue: currentStats?.total_revenue || 0,
    revenueTrend: calculateTrend(currentStats?.total_revenue || 0, prevStats?.total_revenue || 0),
    conversionRate: currentStats?.conversion_rate || 0,
    conversionTrend: calculateTrend(
      currentStats?.conversion_rate || 0,
      prevStats?.conversion_rate || 0
    ),
    qualityScore: currentStats?.quality_score || 85,
    qualityTrend: calculateTrend(currentStats?.quality_score || 85, prevStats?.quality_score || 85),
  }
}

function StatCard({
  title,
  value,
  trend,
  icon: Icon,
  format = 'number',
  loading = false,
}: {
  title: string
  value: number
  trend: number
  icon: React.ComponentType<{ className?: string }>
  format?: 'number' | 'currency' | 'percentage'
  loading?: boolean
}) {
  const formatValue = (val: number) => {
    switch (format) {
      case 'currency':
        return new Intl.NumberFormat('en-US', {
          style: 'currency',
          currency: 'USD',
        }).format(val)
      case 'percentage':
        return `${val.toFixed(1)}%`
      default:
        return val.toLocaleString()
    }
  }

  const getTrendColor = (trend: number) => {
    if (trend > 0) return 'text-green-600'
    if (trend < 0) return 'text-red-600'
    return 'text-gray-500'
  }

  const getTrendIcon = (trend: number) => {
    if (trend > 0) return 'â†—'
    if (trend < 0) return 'â†˜'
    return 'â†’'
  }

  if (loading) {
    return (
      <div className="bg-white rounded-lg shadow p-6">
        <div className="animate-pulse">
          <div className="h-4 bg-gray-200 rounded w-1/2 mb-2"></div>
          <div className="h-8 bg-gray-200 rounded w-3/4 mb-2"></div>
          <div className="h-3 bg-gray-200 rounded w-1/3"></div>
        </div>
      </div>
    )
  }

  return (
    <div className="bg-white rounded-lg shadow p-6">
      <div className="flex items-center justify-between">
        <div className="flex items-center">
          <Icon className="h-8 w-8 text-primary-600" />
          <div className="ml-3">
            <p className="text-sm font-medium text-gray-600">{title}</p>
            <p className="text-2xl font-bold text-gray-900">{formatValue(value)}</p>
          </div>
        </div>
        <div className={`text-sm font-medium ${getTrendColor(trend)}`}>
          <span className="inline-flex items-center">
            {getTrendIcon(trend)} {Math.abs(trend).toFixed(1)}%
          </span>
        </div>
      </div>
    </div>
  )
}

export function QuickStatsBar({ timeRange, supplierId }: QuickStatsBarProps) {
  const { data: stats, isLoading } = useQuery({
    queryKey: ['supplier-stats', supplierId, timeRange],
    queryFn: () => fetchSupplierStats(supplierId, timeRange),
    refetchInterval: 30000, // Refresh every 30 seconds
  })

  // Use real-time updates for live stats
  const liveStats = useRealTimeStats(supplierId)

  // Merge real-time data with cached data
  const displayStats = liveStats ? { ...stats, ...liveStats } : stats

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
      <StatCard
        title="Today's Calls"
        value={displayStats?.totalCalls || 0}
        trend={displayStats?.callsTrend || 0}
        icon={PhoneIcon}
        loading={isLoading}
      />
      <StatCard
        title="Revenue Today"
        value={displayStats?.revenue || 0}
        trend={displayStats?.revenueTrend || 0}
        icon={CurrencyDollarIcon}
        format="currency"
        loading={isLoading}
      />
      <StatCard
        title="Conversion Rate"
        value={displayStats?.conversionRate || 0}
        trend={displayStats?.conversionTrend || 0}
        icon={ChartBarIcon}
        format="percentage"
        loading={isLoading}
      />
      <StatCard
        title="Quality Score"
        value={displayStats?.qualityScore || 85}
        trend={displayStats?.qualityTrend || 0}
        icon={StarIcon}
        loading={isLoading}
      />
    </div>
  )
}
</file>

<file path="src/components/dashboard/supplier/RecentCallsList.tsx">
import { useState } from 'react'
import { useQuery } from '@tanstack/react-query'
import {
  PhoneIcon,
  PlayIcon,
  EyeIcon,
  ClockIcon,
  CurrencyDollarIcon,
} from '@heroicons/react/24/outline'
import { supabase } from '../../../lib/supabase'
import { useRealTimeCallUpdates } from '../../../hooks/useRealTimeCallUpdates'

interface RecentCallsListProps {
  supplierId: string
}

interface CallRecord {
  id: string
  created_at: string
  caller_number: string
  duration: number
  status: 'active' | 'completed' | 'failed'
  buyer_name: string
  campaign_name: string
  payout: number
  quality_score?: number
}

async function fetchRecentCalls(supplierId: string): Promise<CallRecord[]> {
  const { data, error } = await supabase
    .from('recent_calls_view')
    .select('*')
    .eq('supplier_id', supplierId)
    .order('created_at', { ascending: false })
    .limit(10)

  if (error) {
    console.error('Error fetching recent calls:', error)
    return []
  }

  return data || []
}

function formatDuration(seconds: number): string {
  if (seconds < 60) {
    return `${seconds}s`
  }
  const minutes = Math.floor(seconds / 60)
  const remainingSeconds = seconds % 60
  return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`
}

function formatPhoneNumber(phoneNumber: string): string {
  // Basic phone number formatting for US numbers
  const cleaned = phoneNumber.includes('***') ? phoneNumber : phoneNumber.replace(/\D/g, '')
  if (phoneNumber.includes('***')) {
    return phoneNumber // Already masked
  }
  if (cleaned.length === 10) {
    return `***-***-${cleaned.slice(-4)}`
  }
  return `***-***-${cleaned.slice(-4) || '****'}`
}

function CallStatusBadge({ status }: { status: CallRecord['status'] }) {
  const getStatusConfig = (status: string) => {
    switch (status) {
      case 'active':
        return {
          className: 'bg-green-100 text-green-800',
          text: 'Active',
          icon: 'ðŸŸ¢',
        }
      case 'completed':
        return {
          className: 'bg-blue-100 text-blue-800',
          text: 'Completed',
          icon: 'âœ…',
        }
      case 'failed':
        return {
          className: 'bg-red-100 text-red-800',
          text: 'Failed',
          icon: 'âŒ',
        }
      default:
        return {
          className: 'bg-gray-100 text-gray-800',
          text: 'Unknown',
          icon: 'â“',
        }
    }
  }

  const config = getStatusConfig(status)

  return (
    <span
      className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${config.className}`}
    >
      <span className="mr-1">{config.icon}</span>
      {config.text}
    </span>
  )
}

function CallRow({ call }: { call: CallRecord }) {
  const [showDetails, setShowDetails] = useState(false)

  const handlePlayRecording = () => {
    // In a real implementation, this would open an audio player modal
    console.log('Playing recording for call:', call.id)
    // Could integrate with a service like Twilio for call recordings
  }

  const handleViewDetails = () => {
    setShowDetails(!showDetails)
  }

  return (
    <div className="border-b border-gray-200 last:border-b-0">
      <div className="p-4 hover:bg-gray-50 transition-colors">
        <div className="flex items-center justify-between">
          <div className="flex items-center space-x-4 flex-1">
            {/* Call Status */}
            <div className="flex-shrink-0">
              <PhoneIcon className="h-5 w-5 text-gray-400" />
            </div>

            {/* Call Info */}
            <div className="flex-1 min-w-0">
              <div className="flex items-center justify-between">
                <div>
                  <p className="text-sm font-medium text-gray-900">
                    {formatPhoneNumber(call.caller_number)}
                  </p>
                  <p className="text-xs text-gray-500">
                    {new Date(call.created_at).toLocaleString()}
                  </p>
                </div>
                <div className="flex items-center space-x-4">
                  {/* Duration */}
                  <div className="flex items-center text-sm text-gray-600">
                    <ClockIcon className="h-4 w-4 mr-1" />
                    {formatDuration(call.duration)}
                  </div>

                  {/* Payout */}
                  <div className="flex items-center text-sm text-green-600 font-medium">
                    <CurrencyDollarIcon className="h-4 w-4 mr-1" />
                    {call.payout.toFixed(2)}
                  </div>

                  {/* Status */}
                  <CallStatusBadge status={call.status} />
                </div>
              </div>

              <div className="mt-1 flex items-center justify-between">
                <div className="text-sm text-gray-600">
                  <span className="font-medium">{call.buyer_name}</span>
                  <span className="mx-2">â€¢</span>
                  <span>{call.campaign_name}</span>
                </div>
              </div>
            </div>
          </div>

          {/* Actions */}
          <div className="flex items-center space-x-2 ml-4">
            {call.status === 'completed' && (
              <button
                onClick={handlePlayRecording}
                className="p-2 text-gray-400 hover:text-gray-600 transition-colors"
                title="Play Recording"
              >
                <PlayIcon className="h-4 w-4" />
              </button>
            )}
            <button
              onClick={handleViewDetails}
              className="p-2 text-gray-400 hover:text-gray-600 transition-colors"
              title="View Details"
            >
              <EyeIcon className="h-4 w-4" />
            </button>
          </div>
        </div>

        {/* Expanded Details */}
        {showDetails && (
          <div className="mt-3 pt-3 border-t border-gray-100">
            <div className="grid grid-cols-2 gap-4 text-sm">
              <div>
                <span className="text-gray-500">Call ID:</span>
                <span className="ml-2 font-mono">{call.id.slice(0, 8)}...</span>
              </div>
              {call.quality_score && (
                <div>
                  <span className="text-gray-500">Quality Score:</span>
                  <span className="ml-2 font-medium">{call.quality_score}/100</span>
                </div>
              )}
            </div>
          </div>
        )}
      </div>
    </div>
  )
}

export function RecentCallsList({ supplierId }: RecentCallsListProps) {
  const [loadingMore, setLoadingMore] = useState(false)

  const {
    data: calls,
    isLoading,
    error,
    refetch,
  } = useQuery({
    queryKey: ['recent-calls', supplierId],
    queryFn: () => fetchRecentCalls(supplierId),
    refetchInterval: 30000, // Refresh every 30 seconds
  })

  // Use real-time updates for call status changes
  const realTimeUpdates = useRealTimeCallUpdates(supplierId)

  // Merge real-time updates with cached data
  const displayCalls = realTimeUpdates.length > 0 ? realTimeUpdates : calls || []

  const handleLoadMore = async () => {
    setLoadingMore(true)
    try {
      // In a real implementation, this would fetch more calls with pagination
      await refetch()
    } finally {
      setLoadingMore(false)
    }
  }

  if (error) {
    return (
      <div className="bg-white rounded-lg shadow">
        <div className="p-6">
          <h3 className="text-lg font-semibold text-gray-900 mb-4">Recent Calls</h3>
          <div className="text-center py-8 text-red-500">
            <p>Error loading calls. Please try again.</p>
            <button
              onClick={() => refetch()}
              className="mt-2 text-primary-600 hover:text-primary-700"
            >
              Retry
            </button>
          </div>
        </div>
      </div>
    )
  }

  return (
    <div className="bg-white rounded-lg shadow">
      {/* Header */}
      <div className="p-6 border-b border-gray-200">
        <div className="flex items-center justify-between">
          <h3 className="text-lg font-semibold text-gray-900">Recent Calls</h3>
          {isLoading && (
            <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-primary-600"></div>
          )}
        </div>
      </div>

      {/* Calls List */}
      <div className="divide-y divide-gray-200">
        {isLoading && !calls ? (
          // Loading skeleton
          <div className="p-4 space-y-4">
            {[...Array(5)].map((_, i) => (
              <div key={i} className="animate-pulse">
                <div className="flex items-center space-x-4">
                  <div className="h-5 w-5 bg-gray-200 rounded"></div>
                  <div className="flex-1">
                    <div className="h-4 bg-gray-200 rounded w-1/4 mb-2"></div>
                    <div className="h-3 bg-gray-200 rounded w-1/3"></div>
                  </div>
                  <div className="h-6 w-16 bg-gray-200 rounded"></div>
                </div>
              </div>
            ))}
          </div>
        ) : displayCalls.length === 0 ? (
          <div className="p-8 text-center text-gray-500">
            <PhoneIcon className="h-12 w-12 mx-auto mb-4 text-gray-300" />
            <p>No recent calls found.</p>
            <p className="text-sm mt-1">Calls will appear here once you start receiving traffic.</p>
          </div>
        ) : (
          <>
            {displayCalls.map((call) => (
              <CallRow key={call.id} call={call} />
            ))}

            {/* Load More Button */}
            {displayCalls.length >= 10 && (
              <div className="p-4 text-center border-t border-gray-200">
                <button
                  onClick={handleLoadMore}
                  disabled={loadingMore}
                  className="text-primary-600 hover:text-primary-700 font-medium text-sm disabled:opacity-50"
                >
                  {loadingMore ? 'Loading...' : 'Load More Calls'}
                </button>
              </div>
            )}
          </>
        )}
      </div>
    </div>
  )
}
</file>

<file path="src/components/dashboard/supplier/SupplierDashboard.tsx">
import { useState } from 'react'
import { QuickStatsBar } from './QuickStatsBar'
import { CallVolumeChart } from './CallVolumeChart'
import { RecentCallsList } from './RecentCallsList'
import { ActiveCampaignsTable } from './ActiveCampaignsTable'
import { useAuth } from '../../../hooks/useAuth'

export function SupplierDashboard() {
  const { user } = useAuth()
  const [selectedTimeRange, setSelectedTimeRange] = useState<'24h' | '7d' | '30d'>('7d')

  if (!user || user.user_metadata?.userType !== 'supplier') {
    return (
      <div className="flex items-center justify-center h-64">
        <p className="text-gray-500">Access denied. Supplier account required.</p>
      </div>
    )
  }

  return (
    <div data-testid="supplier-dashboard" className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold text-gray-900">Supplier Dashboard</h1>
          <p className="text-gray-600">Track your call performance and earnings</p>
        </div>
        <div className="flex items-center space-x-2">
          <label htmlFor="timeRange" className="text-sm text-gray-700">
            Time Range:
          </label>
          <select
            id="timeRange"
            value={selectedTimeRange}
            onChange={(e) => setSelectedTimeRange(e.target.value as '24h' | '7d' | '30d')}
            className="rounded-md border-gray-300 text-sm focus:border-primary-500 focus:ring-primary-500"
          >
            <option value="24h">Last 24 Hours</option>
            <option value="7d">Last 7 Days</option>
            <option value="30d">Last 30 Days</option>
          </select>
        </div>
      </div>

      {/* Quick Stats Bar */}
      <QuickStatsBar timeRange={selectedTimeRange} supplierId={user.id} />

      {/* Main Content Grid */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        {/* Left Column - Performance Chart */}
        <div className="lg:col-span-1">
          <CallVolumeChart timeRange={selectedTimeRange} supplierId={user.id} />
        </div>

        {/* Right Column - Recent Calls */}
        <div className="lg:col-span-1">
          <RecentCallsList supplierId={user.id} />
        </div>
      </div>

      {/* Active Campaigns Table */}
      <ActiveCampaignsTable supplierId={user.id} />
    </div>
  )
}
</file>

<file path="src/components/dashboard/CLAUDE.md">
# Dashboard Components

# Dashboard Structure
- `DashboardHeader.tsx` - Top navigation and user info
- `MetricsCards.tsx` - Key performance indicators
- `RealtimeChart.tsx` - Live data visualization
- `ActivityFeed.tsx` - Recent activity timeline
- `QuickActions.tsx` - Common action buttons

# Real-time Metrics
```tsx
interface MetricsCardsProps {
  userRole: UserRole;
  timeRange: TimeRange;
}

export function MetricsCards({ userRole, timeRange }: MetricsCardsProps) {
  const { data: metrics, loading } = useRealTimeMetrics(userRole, timeRange);
  
  const cards = useMemo(() => {
    switch (userRole) {
      case 'supplier':
        return [
          { label: 'Total Calls', value: metrics?.totalCalls, icon: PhoneIcon },
          { label: 'Earnings', value: formatCurrency(metrics?.earnings), icon: CurrencyDollarIcon },
          { label: 'Quality Score', value: `${metrics?.qualityScore}/10`, icon: StarIcon },
        ];
      case 'buyer':
        return [
          { label: 'Campaign Leads', value: metrics?.totalLeads, icon: UserGroupIcon },
          { label: 'Conversion Rate', value: `${metrics?.conversionRate}%`, icon: TrendingUpIcon },
          { label: 'Cost Per Lead', value: formatCurrency(metrics?.costPerLead), icon: CalculatorIcon },
        ];
      default:
        return [];
    }
  }, [userRole, metrics]);
  
  if (loading) return <MetricsCardsSkeleton />;
  
  return (
    <div className="metrics-cards">
      {cards.map(card => (
        <MetricCard key={card.label} {...card} />
      ))}
    </div>
  );
}
```

# Live Data Visualization
```tsx
interface RealtimeChartProps {
  chartType: 'calls' | 'revenue' | 'quality';
  timeRange: '1h' | '24h' | '7d' | '30d';
}

export function RealtimeChart({ chartType, timeRange }: RealtimeChartProps) {
  const [data, setData] = useState<ChartDataPoint[]>([]);
  
  useEffect(() => {
    const subscription = supabase
      .channel(`${chartType}-updates`)
      .on('postgres_changes', {
        event: '*',
        schema: 'public',
        table: getTableForChartType(chartType),
      }, (payload) => {
        setData(prev => updateChartData(prev, payload, timeRange));
      })
      .subscribe();
      
    return () => supabase.removeChannel(subscription);
  }, [chartType, timeRange]);
  
  return (
    <div className="chart-container">
      <ChartComponent data={data} type={chartType} />
    </div>
  );
}
```

# Activity Feed
```tsx
interface ActivityFeedProps {
  userId?: string;
  limit?: number;
}

export function ActivityFeed({ userId, limit = 10 }: ActivityFeedProps) {
  const { data: activities, loading } = useQuery({
    queryKey: ['activity-feed', userId, limit],
    queryFn: () => fetchUserActivities(userId, limit),
    refetchInterval: 30000, // Refresh every 30 seconds
  });
  
  if (loading) return <ActivityFeedSkeleton />;
  
  return (
    <div className="activity-feed">
      {activities?.map(activity => (
        <ActivityItem
          key={activity.id}
          activity={activity}
          timestamp={activity.created_at}
        />
      ))}
    </div>
  );
}
```

# Role-Specific Dashboards
```tsx
// Supplier Dashboard Components
export function SupplierDashboard() {
  return (
    <>
      <MetricsCards userRole="supplier" timeRange={timeRange} />
      <div className="dashboard-grid">
        <AvailableCampaigns />
        <RecentCalls />
        <EarningsChart />
        <QualityTrends />
      </div>
    </>
  );
}

// Buyer Dashboard Components
export function BuyerDashboard() {
  return (
    <>
      <MetricsCards userRole="buyer" timeRange={timeRange} />
      <div className="dashboard-grid">
        <CampaignPerformance />
        <IncomingLeads />
        <ConversionFunnel />
        <BudgetUtilization />
      </div>
    </>
  );
}
```

# Interactive Widgets
- Draggable widget positioning
- Resizable chart containers
- Customizable time ranges
- Filter and search capabilities

# Data Refresh Patterns
```tsx
// Auto-refresh hook for dashboard data
export function useAutoRefresh(interval = 30000) {
  const [lastRefresh, setLastRefresh] = useState(Date.now());
  
  useEffect(() => {
    const timer = setInterval(() => {
      setLastRefresh(Date.now());
    }, interval);
    
    return () => clearInterval(timer);
  }, [interval]);
  
  return lastRefresh;
}
```

# Performance Optimization
- Virtual scrolling for large datasets
- Memoized expensive calculations
- Debounced filter updates
- Lazy loading of chart components

# Mobile Dashboard
- Responsive grid layouts
- Touch-friendly interactions
- Swipeable metric cards
- Collapsible sections

# Error States
- Network connection issues
- Data loading failures
- Permission denied scenarios
- Empty state handling

# Customization Features
- Widget visibility toggles
- Color theme preferences
- Metric display options
- Export functionality

# CRITICAL RULES
- NO regex in dashboard logic
- NO any types in component interfaces
- ALWAYS handle real-time data properly
- ALWAYS implement proper loading states
- OPTIMIZE for performance with large datasets
- TEST all interactive dashboard features
- ENSURE mobile responsiveness
- IMPLEMENT proper error boundaries
</file>

<file path="src/components/dev/LogViewer.tsx">
import React, { useState, useEffect, useCallback } from 'react'
import { XMarkIcon, FunnelIcon } from '@heroicons/react/24/outline'
import type { LogEntry, LogLevel } from '../../lib/logger'

interface LogViewerProps {
  isOpen: boolean
  onClose: () => void
}

export const LogViewer: React.FC<LogViewerProps> = ({ isOpen, onClose }) => {
  const [logs, setLogs] = useState<LogEntry[]>([])
  const [filter, setFilter] = useState<LogLevel | 'all'>('all')
  const [search, setSearch] = useState('')
  const [autoScroll, setAutoScroll] = useState(true)

  // Intercept console methods in development
  useEffect(() => {
    if (!import.meta.env.DEV) return

    const originalMethods = {
      debug: console.debug,
      info: console.info,
      warn: console.warn,
      error: console.error,
    }

    const interceptLog = (level: LogLevel, args: unknown[]) => {
      const entry: LogEntry = {
        timestamp: new Date().toISOString(),
        level,
        message: args.map(arg => 
          typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)
        ).join(' '),
      }
      
      setLogs(prev => [...prev.slice(-200), entry]) // Keep last 200 logs
    }

    console.debug = (...args) => {
      originalMethods.debug(...args)
      interceptLog('debug', args)
    }
    
    console.info = (...args) => {
      originalMethods.info(...args)
      interceptLog('info', args)
    }
    
    console.warn = (...args) => {
      originalMethods.warn(...args)
      interceptLog('warn', args)
    }
    
    console.error = (...args) => {
      originalMethods.error(...args)
      interceptLog('error', args)
    }

    return () => {
      // Restore original methods
      Object.assign(console, originalMethods)
    }
  }, [])

  // Auto-scroll to bottom
  useEffect(() => {
    if (autoScroll && isOpen) {
      const logContainer = document.getElementById('log-container')
      if (logContainer) {
        logContainer.scrollTop = logContainer.scrollHeight
      }
    }
  }, [logs, autoScroll, isOpen])

  const filteredLogs = logs.filter(log => {
    if (filter !== 'all' && log.level !== filter) return false
    if (search && !log.message.toLowerCase().includes(search.toLowerCase())) return false
    return true
  })

  const clearLogs = useCallback(() => {
    setLogs([])
  }, [])

  const exportLogs = useCallback(() => {
    const data = JSON.stringify(filteredLogs, null, 2)
    const blob = new Blob([data], { type: 'application/json' })
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = `logs-${new Date().toISOString()}.json`
    a.click()
    URL.revokeObjectURL(url)
  }, [filteredLogs])

  const getLogColor = (level: LogLevel) => {
    switch (level) {
      case 'debug': return 'text-gray-500'
      case 'info': return 'text-blue-600'
      case 'warn': return 'text-yellow-600'
      case 'error': return 'text-red-600'
      case 'fatal': return 'text-red-800 font-bold'
      default: return 'text-gray-600'
    }
  }

  if (!isOpen || !import.meta.env.DEV) return null

  return (
    <div className="fixed bottom-0 right-0 w-full md:w-1/2 lg:w-1/3 h-96 bg-gray-900 text-white shadow-2xl z-50 flex flex-col">
      {/* Header */}
      <div className="flex items-center justify-between p-3 border-b border-gray-700">
        <h3 className="text-sm font-semibold">Dev Console</h3>
        <div className="flex items-center gap-2">
          <span className="text-xs text-gray-400">{filteredLogs.length} logs</span>
          <button
            onClick={onClose}
            className="text-gray-400 hover:text-white"
          >
            <XMarkIcon className="h-5 w-5" />
          </button>
        </div>
      </div>

      {/* Controls */}
      <div className="flex items-center gap-2 p-2 border-b border-gray-700">
        <div className="flex items-center gap-1 flex-1">
          <FunnelIcon className="h-4 w-4 text-gray-400" />
          <select
            value={filter}
            onChange={(e) => setFilter(e.target.value as LogLevel | 'all')}
            className="bg-gray-800 text-sm px-2 py-1 rounded"
          >
            <option value="all">All</option>
            <option value="debug">Debug</option>
            <option value="info">Info</option>
            <option value="warn">Warn</option>
            <option value="error">Error</option>
            <option value="fatal">Fatal</option>
          </select>
        </div>
        
        <input
          type="text"
          placeholder="Search logs..."
          value={search}
          onChange={(e) => setSearch(e.target.value)}
          className="bg-gray-800 text-sm px-2 py-1 rounded flex-1"
        />
        
        <label className="flex items-center gap-1 text-xs">
          <input
            type="checkbox"
            checked={autoScroll}
            onChange={(e) => setAutoScroll(e.target.checked)}
            className="rounded"
          />
          Auto-scroll
        </label>
        
        <button
          onClick={clearLogs}
          className="text-xs px-2 py-1 bg-gray-800 hover:bg-gray-700 rounded"
        >
          Clear
        </button>
        
        <button
          onClick={exportLogs}
          className="text-xs px-2 py-1 bg-gray-800 hover:bg-gray-700 rounded"
        >
          Export
        </button>
      </div>

      {/* Logs */}
      <div
        id="log-container"
        className="flex-1 overflow-y-auto p-2 font-mono text-xs"
      >
        {filteredLogs.length === 0 ? (
          <div className="text-center text-gray-500 mt-8">
            No logs to display
          </div>
        ) : (
          filteredLogs.map((log, index) => (
            <div
              key={index}
              className="py-1 px-2 hover:bg-gray-800 border-b border-gray-800"
            >
              <div className="flex items-start gap-2">
                <span className="text-gray-500 whitespace-nowrap">
                  {new Date(log.timestamp).toLocaleTimeString()}
                </span>
                <span className={`uppercase ${getLogColor(log.level)}`}>
                  [{log.level}]
                </span>
                <pre className="flex-1 whitespace-pre-wrap break-all">
                  {log.message}
                </pre>
              </div>
              {log.context && (
                <details className="ml-16 mt-1">
                  <summary className="cursor-pointer text-gray-500 text-xs">
                    Context
                  </summary>
                  <pre className="text-xs text-gray-400 mt-1">
                    {JSON.stringify(log.context, null, 2)}
                  </pre>
                </details>
              )}
              {log.error && (
                <details className="ml-16 mt-1">
                  <summary className="cursor-pointer text-red-400 text-xs">
                    Error Details
                  </summary>
                  <pre className="text-xs text-red-300 mt-1">
                    {log.stack || JSON.stringify(log.error, null, 2)}
                  </pre>
                </details>
              )}
            </div>
          ))
        )}
      </div>

      {/* Status bar */}
      <div className="flex items-center justify-between px-3 py-1 border-t border-gray-700 text-xs text-gray-400">
        <div className="flex items-center gap-4">
          <span>Debug: {logs.filter(l => l.level === 'debug').length}</span>
          <span className="text-blue-400">Info: {logs.filter(l => l.level === 'info').length}</span>
          <span className="text-yellow-400">Warn: {logs.filter(l => l.level === 'warn').length}</span>
          <span className="text-red-400">Error: {logs.filter(l => l.level === 'error').length}</span>
        </div>
        <span>
          {new Date().toLocaleTimeString()}
        </span>
      </div>
    </div>
  )
}

// Development toolbar to toggle log viewer
export const DevToolbar: React.FC = () => {
  const [showLogs, setShowLogs] = useState(false)
  
  if (!import.meta.env.DEV) return null
  
  return (
    <>
      <button
        onClick={() => setShowLogs(!showLogs)}
        className="fixed bottom-4 right-4 p-3 bg-gray-900 text-white rounded-full shadow-lg hover:bg-gray-800 z-40"
        title="Toggle dev console"
      >
        <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
        </svg>
      </button>
      <LogViewer isOpen={showLogs} onClose={() => setShowLogs(false)} />
    </>
  )
}
</file>

<file path="src/components/layout/CLAUDE.md">
# Layout Components

# Layout Structure
- `AppLayout.tsx` - Main application wrapper
- `PublicLayout.tsx` - Public pages wrapper
- `Sidebar.tsx` - Navigation sidebar
- `Header.tsx` - Top navigation bar
- `Footer.tsx` - Page footer

# Main Application Layout
```tsx
interface AppLayoutProps {
  children: React.ReactNode;
  showSidebar?: boolean;
}

export function AppLayout({ children, showSidebar = true }: AppLayoutProps) {
  const { user } = useAuth();
  const [sidebarOpen, setSidebarOpen] = useState(false);
  
  return (
    <div className="app-layout">
      <Header onMenuClick={() => setSidebarOpen(!sidebarOpen)} />
      
      <div className="app-content">
        {showSidebar && (
          <Sidebar
            user={user}
            isOpen={sidebarOpen}
            onClose={() => setSidebarOpen(false)}
          />
        )}
        
        <main className="main-content">
          <ErrorBoundary>
            {children}
          </ErrorBoundary>
        </main>
      </div>
      
      <Footer />
    </div>
  );
}
```

# Navigation Sidebar
```tsx
interface SidebarProps {
  user: User | null;
  isOpen: boolean;
  onClose: () => void;
}

export function Sidebar({ user, isOpen, onClose }: SidebarProps) {
  const navigate = useNavigate();
  const location = useLocation();
  
  const navigationItems = useMemo(() => {
    if (!user) return [];
    
    const baseItems = [
      { icon: HomeIcon, label: 'Dashboard', href: '/dashboard' },
      { icon: ChartBarIcon, label: 'Analytics', href: '/analytics' },
      { icon: CogIcon, label: 'Settings', href: '/settings' },
    ];
    
    switch (user.role) {
      case 'supplier':
        return [
          ...baseItems,
          { icon: PhoneIcon, label: 'Campaigns', href: '/campaigns' },
          { icon: CurrencyDollarIcon, label: 'Earnings', href: '/earnings' },
        ];
      case 'buyer':
        return [
          ...baseItems,
          { icon: FolderIcon, label: 'Campaigns', href: '/campaigns' },
          { icon: DocumentChartBarIcon, label: 'Reports', href: '/reports' },
          { icon: CreditCardIcon, label: 'Billing', href: '/billing' },
        ];
      case 'admin':
        return [
          ...baseItems,
          { icon: UsersIcon, label: 'Users', href: '/admin/users' },
          { icon: ShieldCheckIcon, label: 'Fraud', href: '/admin/fraud' },
        ];
      default:
        return baseItems;
    }
  }, [user]);
  
  return (
    <aside className={`sidebar ${isOpen ? 'sidebar-open' : ''}`}>
      <nav className="sidebar-nav">
        {navigationItems.map(item => (
          <SidebarItem
            key={item.href}
            {...item}
            active={location.pathname === item.href}
            onClick={() => {
              navigate(item.href);
              onClose();
            }}
          />
        ))}
      </nav>
    </aside>
  );
}
```

# Header Component
```tsx
interface HeaderProps {
  onMenuClick: () => void;
}

export function Header({ onMenuClick }: HeaderProps) {
  const { user, logout } = useAuth();
  const [notificationCount] = useNotifications();
  
  return (
    <header className="app-header">
      <div className="header-left">
        <button className="menu-button" onClick={onMenuClick}>
          <Bars3Icon className="h-6 w-6" />
        </button>
        <Logo />
      </div>
      
      <div className="header-right">
        <NotificationButton count={notificationCount} />
        <UserMenu user={user} onLogout={logout} />
      </div>
    </header>
  );
}
```

# Responsive Design
- Mobile-first layout approach
- Collapsible sidebar for mobile
- Touch-friendly navigation
- Adaptive content areas

# Theme Support
```tsx
interface ThemeProviderProps {
  children: React.ReactNode;
}

export function ThemeProvider({ children }: ThemeProviderProps) {
  const [theme, setTheme] = useLocalStorage<'light' | 'dark'>('theme', 'light');
  
  useEffect(() => {
    document.documentElement.setAttribute('data-theme', theme);
  }, [theme]);
  
  const toggleTheme = () => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light');
  };
  
  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}
```

# Loading States
- Page-level loading indicators
- Skeleton layouts during data fetch
- Progressive content loading
- Smooth transitions

# Breadcrumb Navigation
```tsx
interface BreadcrumbsProps {
  items: BreadcrumbItem[];
}

export function Breadcrumbs({ items }: BreadcrumbsProps) {
  return (
    <nav className="breadcrumbs">
      {items.map((item, index) => (
        <Fragment key={item.href || index}>
          {index > 0 && <ChevronRightIcon className="breadcrumb-separator" />}
          {item.href ? (
            <Link to={item.href} className="breadcrumb-link">
              {item.label}
            </Link>
          ) : (
            <span className="breadcrumb-current">{item.label}</span>
          )}
        </Fragment>
      ))}
    </nav>
  );
}
```

# Layout Animations
- Smooth sidebar transitions
- Page transition effects
- Loading state animations
- Hover interactions

# Accessibility Features
- Skip navigation links
- Proper heading hierarchy
- ARIA landmarks
- Keyboard navigation support
- Screen reader optimization

# Performance Optimization
- Layout shift prevention
- CSS containment
- Virtual scrolling for long lists
- Lazy loading of non-critical content

# Mobile Considerations
- Safe area handling (notch devices)
- Touch target sizing
- Gesture recognition
- Orientation changes

# CRITICAL RULES
- NO regex in layout logic
- NO any types in layout props
- ALWAYS implement responsive design
- ALWAYS support keyboard navigation
- ENSURE proper semantic HTML
- TEST on multiple screen sizes
- OPTIMIZE for performance
- MAINTAIN accessibility standards
- IMPLEMENT proper ARIA labels
</file>

<file path="src/components/payments/index.ts">
export { PaymentForm, PaymentFormWithErrorBoundary } from './PaymentForm'
export { QuickTopUpForm } from './QuickTopUpForm'
export { PaymentModal } from './PaymentModal'
export { PaymentDashboard } from './PaymentDashboard'
export { PayoutDashboard } from './PayoutDashboard'
export { StripeConnectOnboarding } from './StripeConnectOnboarding'
export { WebhookHandler } from './WebhookHandler'
export { PaymentErrorBoundary } from './PaymentErrorBoundary'
export { withPaymentErrorBoundary } from './withPaymentErrorBoundary'
</file>

<file path="src/components/payments/PaymentDashboard.tsx">
import React, { useState, useEffect, useCallback } from 'react'
import {
  CreditCardIcon,
  BanknotesIcon,
  ChartBarIcon,
  CalendarIcon,
  ExclamationTriangleIcon,
  CheckCircleIcon,
  ClockIcon,
} from '@heroicons/react/24/outline'
import { useAuth } from '@/hooks/useAuth'
import { supabase } from '@/lib/supabase'
import { formatCurrency, formatDate } from '@/utils/format'
import PaymentForm from './PaymentForm'
import PayoutDashboard from './PayoutDashboard'
import StripeConnectOnboarding from './StripeConnectOnboarding'

interface Transaction {
  id: string
  stripe_payment_intent_id: string
  amount: number
  currency: string
  status: 'pending' | 'processing' | 'succeeded' | 'failed'
  type: 'charge' | 'refund'
  description?: string
  created_at: string
  updated_at: string
}

interface Invoice {
  id: string
  number: string
  amount: number
  currency: string
  status: 'draft' | 'open' | 'paid' | 'void' | 'uncollectible'
  due_date: string
  created_at: string
  billing_period: string
}

interface PaymentStats {
  totalSpent: number
  totalEarned: number
  thisMonth: number
  lastMonth: number
  pendingPayments: number
  failedPayments: number
}

export const PaymentDashboard: React.FC = () => {
  const { user } = useAuth()
  const [activeTab, setActiveTab] = useState<'overview' | 'payments' | 'payouts' | 'invoices'>(
    'overview'
  )
  const [transactions, setTransactions] = useState<Transaction[]>([])
  const [invoices, setInvoices] = useState<Invoice[]>([])
  const [stats, setStats] = useState<PaymentStats | null>(null)
  const [isLoading, setIsLoading] = useState(true)
  const [error, setError] = useState<string>('')
  const [showPaymentForm, setShowPaymentForm] = useState(false)
  const [selectedInvoice, setSelectedInvoice] = useState<Invoice | null>(null)

  const loadPaymentData = useCallback(async () => {
    if (!user) return

    try {
      setIsLoading(true)
      setError('')

      const [transactionsResult, invoicesResult, statsResult] = await Promise.all([
        supabase
          .from('transactions')
          .select('*')
          .eq('user_id', user.id)
          .order('created_at', { ascending: false })
          .limit(20),
        supabase
          .from('invoices')
          .select('*')
          .eq('user_id', user.id)
          .order('created_at', { ascending: false })
          .limit(20),
        calculatePaymentStats(user.id),
      ])

      if (transactionsResult.error) throw transactionsResult.error
      if (invoicesResult.error) throw invoicesResult.error

      setTransactions(transactionsResult.data || [])
      setInvoices(invoicesResult.data || [])
      setStats(statsResult)
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to load payment data'
      setError(message)
    } finally {
      setIsLoading(false)
    }
  }, [user])

  useEffect(() => {
    if (user) {
      loadPaymentData()
    }
  }, [user, loadPaymentData])

  const calculatePaymentStats = async (userId: string): Promise<PaymentStats> => {
    const now = new Date()
    const thisMonthStart = new Date(now.getFullYear(), now.getMonth(), 1)
    const lastMonthStart = new Date(now.getFullYear(), now.getMonth() - 1, 1)
    const lastMonthEnd = new Date(now.getFullYear(), now.getMonth(), 0)

    // Get transaction stats
    const { data: transactionStats } = await supabase
      .from('transactions')
      .select('amount, type, status, created_at')
      .eq('user_id', userId)

    if (!transactionStats) {
      return {
        totalSpent: 0,
        totalEarned: 0,
        thisMonth: 0,
        lastMonth: 0,
        pendingPayments: 0,
        failedPayments: 0,
      }
    }

    const successfulCharges = transactionStats.filter(
      (t) => t.type === 'charge' && t.status === 'succeeded'
    )
    const successfulPayouts = transactionStats.filter(
      (t) => t.type === 'payout' && t.status === 'succeeded'
    )
    const thisMonthTransactions = transactionStats.filter(
      (t) => new Date(t.created_at) >= thisMonthStart && t.status === 'succeeded'
    )
    const lastMonthTransactions = transactionStats.filter((t) => {
      const date = new Date(t.created_at)
      return date >= lastMonthStart && date <= lastMonthEnd && t.status === 'succeeded'
    })

    return {
      totalSpent: successfulCharges.reduce((sum, t) => sum + t.amount, 0),
      totalEarned: successfulPayouts.reduce((sum, t) => sum + t.amount, 0),
      thisMonth: thisMonthTransactions.reduce(
        (sum, t) => sum + (t.type === 'charge' ? t.amount : -t.amount),
        0
      ),
      lastMonth: lastMonthTransactions.reduce(
        (sum, t) => sum + (t.type === 'charge' ? t.amount : -t.amount),
        0
      ),
      pendingPayments: transactionStats.filter((t) => t.status === 'processing').length,
      failedPayments: transactionStats.filter((t) => t.status === 'failed').length,
    }
  }

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'succeeded':
      case 'paid':
        return 'text-green-600 bg-green-100'
      case 'processing':
      case 'pending':
        return 'text-yellow-600 bg-yellow-100'
      case 'failed':
      case 'void':
        return 'text-red-600 bg-red-100'
      default:
        return 'text-gray-600 bg-gray-100'
    }
  }

  const getStatusIcon = (status: string) => {
    switch (status) {
      case 'succeeded':
      case 'paid':
        return <CheckCircleIcon className="w-4 h-4" />
      case 'processing':
      case 'pending':
        return <ClockIcon className="w-4 h-4" />
      case 'failed':
      case 'void':
        return <ExclamationTriangleIcon className="w-4 h-4" />
      default:
        return <ClockIcon className="w-4 h-4" />
    }
  }

  const handlePayInvoice = (invoice: Invoice) => {
    setSelectedInvoice(invoice)
    setShowPaymentForm(true)
  }

  const handlePaymentSuccess = () => {
    setShowPaymentForm(false)
    setSelectedInvoice(null)
    loadPaymentData() // Refresh data
  }

  const handlePaymentError = (error: string) => {
    console.error('Payment error:', error)
    // Could show a toast notification here
  }

  if (isLoading) {
    return (
      <div className="flex items-center justify-center py-12">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
        <span className="ml-3 text-gray-600">Loading payment data...</span>
      </div>
    )
  }

  if (error) {
    return (
      <div className="bg-red-50 border border-red-200 rounded-lg p-4">
        <p className="text-red-600">{error}</p>
        <button
          onClick={loadPaymentData}
          className="mt-2 text-red-700 hover:text-red-800 underline"
        >
          Try again
        </button>
      </div>
    )
  }

  return (
    <div className="space-y-6">
      {/* Tab Navigation */}
      <div className="border-b border-gray-200">
        <nav className="-mb-px flex space-x-8">
          {[
            { id: 'overview', name: 'Overview', icon: ChartBarIcon },
            { id: 'payments', name: 'Payments', icon: CreditCardIcon },
            ...(user?.role === 'supplier'
              ? [{ id: 'payouts' as const, name: 'Payouts', icon: BanknotesIcon }]
              : []),
            { id: 'invoices', name: 'Invoices', icon: CalendarIcon },
          ].map((tab) => (
            <button
              key={tab.id}
              onClick={() =>
                setActiveTab(tab.id as 'overview' | 'payments' | 'payouts' | 'invoices')
              }
              className={`py-2 px-1 border-b-2 font-medium text-sm flex items-center ${
                activeTab === tab.id
                  ? 'border-blue-500 text-blue-600'
                  : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
              }`}
            >
              <tab.icon className="w-5 h-5 mr-2" />
              {tab.name}
            </button>
          ))}
        </nav>
      </div>

      {/* Tab Content */}
      {activeTab === 'overview' && (
        <div className="space-y-6">
          {/* Stats Cards */}
          {stats && (
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
              <div className="bg-white rounded-lg border border-gray-200 p-6">
                <div className="flex items-center">
                  <div className="p-2 bg-blue-100 rounded-lg">
                    <CreditCardIcon className="w-6 h-6 text-blue-600" />
                  </div>
                  <div className="ml-4">
                    <p className="text-sm font-medium text-gray-600">
                      {user?.role === 'buyer' ? 'Total Spent' : 'Total Earned'}
                    </p>
                    <p className="text-2xl font-bold text-gray-900">
                      {formatCurrency(
                        user?.role === 'buyer' ? stats.totalSpent : stats.totalEarned
                      )}
                    </p>
                  </div>
                </div>
              </div>

              <div className="bg-white rounded-lg border border-gray-200 p-6">
                <div className="flex items-center">
                  <div className="p-2 bg-green-100 rounded-lg">
                    <CalendarIcon className="w-6 h-6 text-green-600" />
                  </div>
                  <div className="ml-4">
                    <p className="text-sm font-medium text-gray-600">This Month</p>
                    <p className="text-2xl font-bold text-gray-900">
                      {formatCurrency(stats.thisMonth)}
                    </p>
                    {stats.lastMonth > 0 && (
                      <p
                        className={`text-sm mt-1 ${
                          stats.thisMonth > stats.lastMonth ? 'text-green-600' : 'text-red-600'
                        }`}
                      >
                        {stats.thisMonth > stats.lastMonth ? '+' : ''}
                        {(((stats.thisMonth - stats.lastMonth) / stats.lastMonth) * 100).toFixed(1)}
                        %
                      </p>
                    )}
                  </div>
                </div>
              </div>

              <div className="bg-white rounded-lg border border-gray-200 p-6">
                <div className="flex items-center">
                  <div className="p-2 bg-yellow-100 rounded-lg">
                    <ClockIcon className="w-6 h-6 text-yellow-600" />
                  </div>
                  <div className="ml-4">
                    <p className="text-sm font-medium text-gray-600">Pending</p>
                    <p className="text-2xl font-bold text-gray-900">{stats.pendingPayments}</p>
                  </div>
                </div>
              </div>

              <div className="bg-white rounded-lg border border-gray-200 p-6">
                <div className="flex items-center">
                  <div className="p-2 bg-red-100 rounded-lg">
                    <ExclamationTriangleIcon className="w-6 h-6 text-red-600" />
                  </div>
                  <div className="ml-4">
                    <p className="text-sm font-medium text-gray-600">Failed</p>
                    <p className="text-2xl font-bold text-gray-900">{stats.failedPayments}</p>
                  </div>
                </div>
              </div>
            </div>
          )}

          {/* Recent Activity */}
          <div className="bg-white rounded-lg border border-gray-200">
            <div className="px-6 py-4 border-b border-gray-200">
              <h3 className="text-lg font-medium text-gray-900">Recent Activity</h3>
            </div>
            <div className="p-6">
              {transactions.slice(0, 5).length === 0 ? (
                <p className="text-gray-500 text-center">No recent activity</p>
              ) : (
                <div className="space-y-4">
                  {transactions.slice(0, 5).map((transaction) => (
                    <div key={transaction.id} className="flex items-center justify-between">
                      <div className="flex items-center">
                        <div className={`p-2 rounded-lg ${getStatusColor(transaction.status)}`}>
                          {getStatusIcon(transaction.status)}
                        </div>
                        <div className="ml-4">
                          <p className="text-sm font-medium text-gray-900">
                            {transaction.type === 'charge' ? 'Payment' : 'Refund'}
                          </p>
                          <p className="text-sm text-gray-500">
                            {formatDate(new Date(transaction.created_at))}
                          </p>
                        </div>
                      </div>
                      <div className="text-right">
                        <p
                          className={`text-sm font-medium ${
                            transaction.type === 'charge' ? 'text-red-600' : 'text-green-600'
                          }`}
                        >
                          {transaction.type === 'charge' ? '-' : '+'}
                          {formatCurrency(transaction.amount, transaction.currency)}
                        </p>
                        <p className="text-sm text-gray-500 capitalize">{transaction.status}</p>
                      </div>
                    </div>
                  ))}
                </div>
              )}
            </div>
          </div>
        </div>
      )}

      {activeTab === 'payments' && (
        <div className="space-y-6">
          {/* Payment Form Modal */}
          {showPaymentForm && selectedInvoice && (
            <div className="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4">
              <div className="bg-white rounded-lg max-w-md w-full max-h-screen overflow-y-auto">
                <div className="p-6">
                  <div className="flex items-center justify-between mb-6">
                    <h3 className="text-lg font-medium text-gray-900">
                      Pay Invoice {selectedInvoice.number}
                    </h3>
                    <button
                      onClick={() => setShowPaymentForm(false)}
                      className="text-gray-400 hover:text-gray-600"
                    >
                      <span className="sr-only">Close</span>
                      <svg
                        className="w-6 h-6"
                        fill="none"
                        viewBox="0 0 24 24"
                        stroke="currentColor"
                      >
                        <path
                          strokeLinecap="round"
                          strokeLinejoin="round"
                          strokeWidth={2}
                          d="M6 18L18 6M6 6l12 12"
                        />
                      </svg>
                    </button>
                  </div>
                  <PaymentForm
                    amount={selectedInvoice.amount * 100} // Convert to cents
                    currency={selectedInvoice.currency}
                    description={`Invoice ${selectedInvoice.number} - ${selectedInvoice.billing_period}`}
                    metadata={{
                      invoiceId: selectedInvoice.id,
                      buyerId: user?.id || '',
                      billingPeriod: selectedInvoice.billing_period,
                    }}
                    onSuccess={handlePaymentSuccess}
                    onError={handlePaymentError}
                  />
                </div>
              </div>
            </div>
          )}

          {/* Transactions Table */}
          <div className="bg-white rounded-lg border border-gray-200">
            <div className="px-6 py-4 border-b border-gray-200">
              <h3 className="text-lg font-medium text-gray-900">Payment History</h3>
            </div>
            <div className="overflow-x-auto">
              <table className="min-w-full divide-y divide-gray-200">
                <thead className="bg-gray-50">
                  <tr>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Date
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Type
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Amount
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Status
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Description
                    </th>
                  </tr>
                </thead>
                <tbody className="bg-white divide-y divide-gray-200">
                  {transactions.map((transaction) => (
                    <tr key={transaction.id} className="hover:bg-gray-50">
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                        {formatDate(new Date(transaction.created_at))}
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900 capitalize">
                        {transaction.type}
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                        <span
                          className={
                            transaction.type === 'charge' ? 'text-red-600' : 'text-green-600'
                          }
                        >
                          {transaction.type === 'charge' ? '-' : '+'}
                          {formatCurrency(transaction.amount, transaction.currency)}
                        </span>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap">
                        <span
                          className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${getStatusColor(transaction.status)}`}
                        >
                          {getStatusIcon(transaction.status)}
                          <span className="ml-1 capitalize">{transaction.status}</span>
                        </span>
                      </td>
                      <td className="px-6 py-4 text-sm text-gray-500">
                        {transaction.description || 'Payment transaction'}
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>
        </div>
      )}

      {activeTab === 'payouts' && user?.role === 'supplier' && (
        <div className="space-y-6">
          {/* Stripe Connect Onboarding */}
          {!user.stripe_account_id && (
            <StripeConnectOnboarding
              onComplete={(accountId) => {
                console.log('Stripe account connected:', accountId)
                // Refresh user data
                loadPaymentData()
              }}
              onError={(error) => {
                console.error('Stripe onboarding error:', error)
              }}
            />
          )}

          {/* Payout Dashboard */}
          {user.stripe_account_id && <PayoutDashboard />}
        </div>
      )}

      {activeTab === 'invoices' && (
        <div className="bg-white rounded-lg border border-gray-200">
          <div className="px-6 py-4 border-b border-gray-200">
            <h3 className="text-lg font-medium text-gray-900">Invoices</h3>
          </div>
          <div className="overflow-x-auto">
            <table className="min-w-full divide-y divide-gray-200">
              <thead className="bg-gray-50">
                <tr>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Invoice
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Amount
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Status
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Due Date
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Actions
                  </th>
                </tr>
              </thead>
              <tbody className="bg-white divide-y divide-gray-200">
                {invoices.map((invoice) => (
                  <tr key={invoice.id} className="hover:bg-gray-50">
                    <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                      {invoice.number}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                      {formatCurrency(invoice.amount, invoice.currency)}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap">
                      <span
                        className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${getStatusColor(invoice.status)}`}
                      >
                        {getStatusIcon(invoice.status)}
                        <span className="ml-1 capitalize">{invoice.status}</span>
                      </span>
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                      {formatDate(new Date(invoice.due_date))}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                      {invoice.status === 'open' && (
                        <button
                          onClick={() => handlePayInvoice(invoice)}
                          className="text-blue-600 hover:text-blue-800 font-medium"
                        >
                          Pay Now
                        </button>
                      )}
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        </div>
      )}
    </div>
  )
}

export default PaymentDashboard
</file>

<file path="src/components/payments/PaymentModal.tsx">
import React, { Fragment } from 'react'
import { Dialog, Transition } from '@headlessui/react'
import { XMarkIcon } from '@heroicons/react/24/outline'
import QuickTopUpForm from './QuickTopUpForm'
import PaymentForm from './PaymentForm'

interface PaymentModalProps {
  isOpen: boolean
  onClose: () => void
  type: 'topup' | 'invoice'
  invoiceData?: {
    amount: number
    invoiceId: string
    description: string
    billingPeriod: string
  }
  onSuccess?: (paymentIntentId: string, amount?: number) => void
}

export const PaymentModal: React.FC<PaymentModalProps> = ({
  isOpen,
  onClose,
  type,
  invoiceData,
  onSuccess,
}) => {
  const handleSuccess = (paymentIntentId: string, amount?: number) => {
    onSuccess?.(paymentIntentId, amount)
    // Close modal after a short delay to show success message
    setTimeout(() => {
      onClose()
    }, 2000)
  }

  return (
    <Transition appear show={isOpen} as={Fragment}>
      <Dialog as="div" className="relative z-50" onClose={onClose}>
        <Transition.Child
          as={Fragment}
          enter="ease-out duration-300"
          enterFrom="opacity-0"
          enterTo="opacity-100"
          leave="ease-in duration-200"
          leaveFrom="opacity-100"
          leaveTo="opacity-0"
        >
          <div className="fixed inset-0 bg-black bg-opacity-25" />
        </Transition.Child>

        <div className="fixed inset-0 overflow-y-auto">
          <div className="flex min-h-full items-center justify-center p-4 text-center">
            <Transition.Child
              as={Fragment}
              enter="ease-out duration-300"
              enterFrom="opacity-0 scale-95"
              enterTo="opacity-100 scale-100"
              leave="ease-in duration-200"
              leaveFrom="opacity-100 scale-100"
              leaveTo="opacity-0 scale-95"
            >
              <Dialog.Panel className="w-full max-w-md transform overflow-hidden rounded-2xl bg-white p-6 text-left align-middle shadow-xl transition-all">
                <div className="flex items-center justify-between mb-4">
                  <Dialog.Title as="h3" className="text-lg font-medium leading-6 text-gray-900">
                    {type === 'topup' ? 'Add Funds' : 'Pay Invoice'}
                  </Dialog.Title>
                  <button
                    type="button"
                    className="rounded-md bg-white text-gray-400 hover:text-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
                    onClick={onClose}
                  >
                    <span className="sr-only">Close</span>
                    <XMarkIcon className="h-6 w-6" aria-hidden="true" />
                  </button>
                </div>

                <div className="mt-2">
                  {type === 'topup' ? (
                    <QuickTopUpForm onSuccess={handleSuccess} onCancel={onClose} />
                  ) : invoiceData ? (
                    <PaymentForm
                      amount={invoiceData.amount}
                      description={invoiceData.description}
                      metadata={{
                        invoiceId: invoiceData.invoiceId,
                        buyerId: '', // Will be filled by PaymentForm from auth
                        billingPeriod: invoiceData.billingPeriod,
                      }}
                      onSuccess={handleSuccess}
                      onError={(error) => console.error('Payment error:', error)}
                    />
                  ) : (
                    <div className="text-center py-8 text-gray-500">No invoice data provided</div>
                  )}
                </div>
              </Dialog.Panel>
            </Transition.Child>
          </div>
        </div>
      </Dialog>
    </Transition>
  )
}
</file>

<file path="src/components/payments/PayoutDashboard.tsx">
import React, { useState, useEffect, useCallback } from 'react'
import {
  BanknotesIcon,
  CalendarIcon,
  ChartBarIcon,
  ClockIcon,
  CheckCircleIcon,
  ExclamationTriangleIcon,
} from '@heroicons/react/24/outline'
import { useAuth } from '@/hooks/useAuth'
import { getPayoutHistory, getPayoutBalance } from '@/integrations/stripe/payouts'
import { formatCurrency, formatDate } from '@/utils/format'

interface PayoutData {
  id: string
  amount: number
  currency: string
  status: 'pending' | 'in_transit' | 'paid' | 'failed'
  created: number
  arrival_date: number
  description?: string
  failure_code?: string
  failure_message?: string
}

interface PayoutBalance {
  available: Array<{
    amount: number
    currency: string
  }>
  pending: Array<{
    amount: number
    currency: string
  }>
}

interface PayoutStats {
  thisWeek: number
  thisMonth: number
  lastMonth: number
  total: number
}

export const PayoutDashboard: React.FC = () => {
  const { user } = useAuth()
  const [balance, setBalance] = useState<PayoutBalance | null>(null)
  const [payouts, setPayouts] = useState<PayoutData[]>([])
  const [stats, setStats] = useState<PayoutStats | null>(null)
  const [isLoading, setIsLoading] = useState(true)
  const [error, setError] = useState<string>('')

  const loadPayoutData = useCallback(async () => {
    if (!user?.stripe_account_id) return

    try {
      setIsLoading(true)
      setError('')

      const [balanceData, payoutHistory] = await Promise.all([
        getPayoutBalance(user.stripe_account_id),
        getPayoutHistory(user.stripe_account_id, 50),
      ])

      setBalance(balanceData)
      
      // Transform Stripe payouts to PayoutData format
      const transformedPayouts: PayoutData[] = payoutHistory.payouts.map((payout) => ({
        id: payout.id,
        amount: payout.amount,
        currency: payout.currency,
        status: payout.status as PayoutData['status'],
        created: payout.created,
        arrival_date: payout.arrival_date || payout.created,
        description: payout.description || undefined,
        failure_code: payout.failure_code || undefined,
        failure_message: payout.failure_message || undefined,
      }))
      
      setPayouts(transformedPayouts)
      setStats(calculateStats(transformedPayouts))
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to load payout data'
      setError(message)
    } finally {
      setIsLoading(false)
    }
  }, [user?.stripe_account_id])

  useEffect(() => {
    if (user?.stripe_account_id) {
      loadPayoutData()
    }
  }, [user?.stripe_account_id, loadPayoutData])

  const calculateStats = (payoutHistory: PayoutData[]): PayoutStats => {
    const now = new Date()
    const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)
    const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000)
    const twoMonthsAgo = new Date(now.getTime() - 60 * 24 * 60 * 60 * 1000)

    const paidPayouts = payoutHistory.filter((p) => p.status === 'paid')

    return {
      thisWeek:
        paidPayouts
          .filter((p) => new Date(p.created * 1000) >= weekAgo)
          .reduce((sum, p) => sum + p.amount, 0) / 100,
      thisMonth:
        paidPayouts
          .filter((p) => new Date(p.created * 1000) >= monthAgo)
          .reduce((sum, p) => sum + p.amount, 0) / 100,
      lastMonth:
        paidPayouts
          .filter((p) => {
            const date = new Date(p.created * 1000)
            return date >= twoMonthsAgo && date < monthAgo
          })
          .reduce((sum, p) => sum + p.amount, 0) / 100,
      total: paidPayouts.reduce((sum, p) => sum + p.amount, 0) / 100,
    }
  }

  const getStatusColor = (status: PayoutData['status']) => {
    switch (status) {
      case 'paid':
        return 'text-green-600 bg-green-100'
      case 'in_transit':
        return 'text-blue-600 bg-blue-100'
      case 'pending':
        return 'text-yellow-600 bg-yellow-100'
      case 'failed':
        return 'text-red-600 bg-red-100'
      default:
        return 'text-gray-600 bg-gray-100'
    }
  }

  const getStatusIcon = (status: PayoutData['status']) => {
    switch (status) {
      case 'paid':
        return <CheckCircleIcon className="w-4 h-4" />
      case 'in_transit':
        return <ClockIcon className="w-4 h-4" />
      case 'pending':
        return <ClockIcon className="w-4 h-4" />
      case 'failed':
        return <ExclamationTriangleIcon className="w-4 h-4" />
      default:
        return <ClockIcon className="w-4 h-4" />
    }
  }

  if (isLoading) {
    return (
      <div className="flex items-center justify-center py-12">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
        <span className="ml-3 text-gray-600">Loading payout data...</span>
      </div>
    )
  }

  if (error) {
    return (
      <div className="bg-red-50 border border-red-200 rounded-lg p-4">
        <p className="text-red-600">{error}</p>
        <button onClick={loadPayoutData} className="mt-2 text-red-700 hover:text-red-800 underline">
          Try again
        </button>
      </div>
    )
  }

  return (
    <div className="space-y-6">
      {/* Balance Cards */}
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div className="bg-white rounded-lg border border-gray-200 p-6">
          <div className="flex items-center">
            <div className="p-2 bg-green-100 rounded-lg">
              <BanknotesIcon className="w-6 h-6 text-green-600" />
            </div>
            <div className="ml-4">
              <p className="text-sm font-medium text-gray-600">Available Balance</p>
              <p className="text-2xl font-bold text-gray-900">
                {balance?.available?.[0]
                  ? formatCurrency(balance.available[0].amount / 100, balance.available[0].currency)
                  : '$0.00'}
              </p>
            </div>
          </div>
        </div>

        <div className="bg-white rounded-lg border border-gray-200 p-6">
          <div className="flex items-center">
            <div className="p-2 bg-blue-100 rounded-lg">
              <ClockIcon className="w-6 h-6 text-blue-600" />
            </div>
            <div className="ml-4">
              <p className="text-sm font-medium text-gray-600">Pending</p>
              <p className="text-2xl font-bold text-gray-900">
                {balance?.pending?.[0]
                  ? formatCurrency(balance.pending[0].amount / 100, balance.pending[0].currency)
                  : '$0.00'}
              </p>
            </div>
          </div>
        </div>
      </div>

      {/* Stats Cards */}
      {stats && (
        <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
          <div className="bg-white rounded-lg border border-gray-200 p-4">
            <div className="flex items-center">
              <ChartBarIcon className="w-5 h-5 text-gray-400" />
              <span className="ml-2 text-sm font-medium text-gray-600">This Week</span>
            </div>
            <p className="text-lg font-bold text-gray-900 mt-2">{formatCurrency(stats.thisWeek)}</p>
          </div>

          <div className="bg-white rounded-lg border border-gray-200 p-4">
            <div className="flex items-center">
              <CalendarIcon className="w-5 h-5 text-gray-400" />
              <span className="ml-2 text-sm font-medium text-gray-600">This Month</span>
            </div>
            <p className="text-lg font-bold text-gray-900 mt-2">
              {formatCurrency(stats.thisMonth)}
            </p>
            {stats.lastMonth > 0 && (
              <p
                className={`text-sm mt-1 ${
                  stats.thisMonth > stats.lastMonth ? 'text-green-600' : 'text-red-600'
                }`}
              >
                {stats.thisMonth > stats.lastMonth ? '+' : ''}
                {(((stats.thisMonth - stats.lastMonth) / stats.lastMonth) * 100).toFixed(1)}% vs
                last month
              </p>
            )}
          </div>

          <div className="bg-white rounded-lg border border-gray-200 p-4">
            <div className="flex items-center">
              <CalendarIcon className="w-5 h-5 text-gray-400" />
              <span className="ml-2 text-sm font-medium text-gray-600">Last Month</span>
            </div>
            <p className="text-lg font-bold text-gray-900 mt-2">
              {formatCurrency(stats.lastMonth)}
            </p>
          </div>

          <div className="bg-white rounded-lg border border-gray-200 p-4">
            <div className="flex items-center">
              <BanknotesIcon className="w-5 h-5 text-gray-400" />
              <span className="ml-2 text-sm font-medium text-gray-600">All Time</span>
            </div>
            <p className="text-lg font-bold text-gray-900 mt-2">{formatCurrency(stats.total)}</p>
          </div>
        </div>
      )}

      {/* Payout History */}
      <div className="bg-white rounded-lg border border-gray-200">
        <div className="px-6 py-4 border-b border-gray-200">
          <h3 className="text-lg font-medium text-gray-900">Payout History</h3>
        </div>

        {payouts.length === 0 ? (
          <div className="p-6 text-center">
            <BanknotesIcon className="w-12 h-12 text-gray-300 mx-auto mb-4" />
            <p className="text-gray-500">No payouts yet</p>
            <p className="text-sm text-gray-400 mt-1">Payouts are processed weekly on Fridays</p>
          </div>
        ) : (
          <div className="overflow-x-auto">
            <table className="min-w-full divide-y divide-gray-200">
              <thead className="bg-gray-50">
                <tr>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Date
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Amount
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Status
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Arrival Date
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Description
                  </th>
                </tr>
              </thead>
              <tbody className="bg-white divide-y divide-gray-200">
                {payouts.map((payout) => (
                  <tr key={payout.id} className="hover:bg-gray-50">
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                      {formatDate(new Date(payout.created * 1000))}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                      {formatCurrency(payout.amount / 100, payout.currency)}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap">
                      <span
                        className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${getStatusColor(payout.status)}`}
                      >
                        {getStatusIcon(payout.status)}
                        <span className="ml-1 capitalize">{payout.status.replace('_', ' ')}</span>
                      </span>
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                      {payout.arrival_date ? formatDate(new Date(payout.arrival_date * 1000)) : '-'}
                    </td>
                    <td className="px-6 py-4 text-sm text-gray-500">
                      {payout.description || 'Payout'}
                      {payout.status === 'failed' && payout.failure_message && (
                        <div className="text-red-600 text-xs mt-1">{payout.failure_message}</div>
                      )}
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        )}
      </div>

      {/* Next Payout Info */}
      <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
        <div className="flex items-start">
          <CalendarIcon className="w-5 h-5 text-blue-600 mt-0.5" />
          <div className="ml-3">
            <h4 className="text-sm font-medium text-blue-800">Next Payout</h4>
            <p className="text-sm text-blue-700 mt-1">
              Payouts are processed weekly on Fridays. Available balance will be paid out on the
              next Friday.
            </p>
          </div>
        </div>
      </div>
    </div>
  )
}

export default PayoutDashboard
</file>

<file path="src/components/payments/QuickTopUpForm.tsx">
import React, { useState, useCallback } from 'react'
import { loadStripe, type StripeElementsOptions } from '@stripe/stripe-js'
import { Elements, useStripe, useElements, PaymentElement } from '@stripe/react-stripe-js'
import {
  CreditCardIcon,
  LockClosedIcon,
  CheckCircleIcon,
  BoltIcon,
} from '@heroicons/react/24/outline'
import { createPaymentIntent } from '@/integrations/stripe/payments'
import { useAuth } from '@/hooks/useAuth'
import type { CreatePaymentIntentParams } from '@/integrations/stripe/types'
import { PaymentErrorBoundary } from './PaymentErrorBoundary'
import { useBuyerStore } from '@/store/buyerStore'
import { formatCurrency } from '@/utils/format'

const stripePromise = loadStripe(import.meta.env.VITE_STRIPE_PUBLISHABLE_KEY || '')

interface QuickTopUpFormProps {
  onSuccess?: (paymentIntentId: string, amount: number) => void
  onCancel?: () => void
  defaultAmount?: number
}

const QUICK_AMOUNTS = [100, 250, 500, 1000] // Amounts in dollars

interface QuickTopUpInnerProps extends QuickTopUpFormProps {
  clientSecret?: string
}

const QuickTopUpInner: React.FC<QuickTopUpInnerProps> = ({
  onSuccess,
  onCancel,
  defaultAmount = 250,
  clientSecret,
}) => {
  const stripe = useStripe()
  const elements = useElements()
  const { updateBalance } = useBuyerStore()
  const { user } = useAuth()
  const currentBalance = user?.current_balance || 0

  const [selectedAmount, setSelectedAmount] = useState(defaultAmount)
  const [customAmount, setCustomAmount] = useState('')
  const [isCustom, setIsCustom] = useState(false)
  const [isProcessing, setIsProcessing] = useState(false)
  const [paymentStatus, setPaymentStatus] = useState<
    'idle' | 'processing' | 'succeeded' | 'failed'
  >('idle')
  const [errorMessage, setErrorMessage] = useState('')

  const getAmount = useCallback(() => {
    if (isCustom && customAmount) {
      const parsed = parseFloat(customAmount)
      return isNaN(parsed) ? 0 : parsed
    }
    return selectedAmount
  }, [isCustom, customAmount, selectedAmount])

  const handleSubmit = async (event: React.FormEvent) => {
    event.preventDefault()

    if (!stripe || !elements || !clientSecret) {
      return
    }

    const amount = getAmount()
    if (amount < 10) {
      setErrorMessage('Minimum top-up amount is $10')
      return
    }

    if (amount > 10000) {
      setErrorMessage('Maximum top-up amount is $10,000')
      return
    }

    setIsProcessing(true)
    setErrorMessage('')
    setPaymentStatus('processing')

    try {
      const { error, paymentIntent } = await stripe.confirmPayment({
        elements,
        confirmParams: {
          return_url: `${window.location.origin}/app/buyer/payments/return`,
        },
        redirect: 'if_required',
      })

      if (error) {
        setErrorMessage(error.message || 'Payment failed')
        setPaymentStatus('failed')
      } else if (paymentIntent && paymentIntent.status === 'succeeded') {
        setPaymentStatus('succeeded')
        // Update local balance immediately
        updateBalance(currentBalance + amount)
        onSuccess?.(paymentIntent.id, amount)
      }
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Payment processing failed'
      setErrorMessage(message)
      setPaymentStatus('failed')
    } finally {
      setIsProcessing(false)
    }
  }

  if (paymentStatus === 'succeeded') {
    return (
      <div className="text-center py-8">
        <div className="mx-auto w-16 h-16 bg-green-100 rounded-full flex items-center justify-center mb-4">
          <CheckCircleIcon className="w-8 h-8 text-green-600" />
        </div>
        <h3 className="text-lg font-medium text-gray-900 mb-2">Top-Up Successful!</h3>
        <p className="text-gray-600 mb-4">
          ${getAmount().toFixed(2)} has been added to your account balance.
        </p>
        <p className="text-sm text-gray-500">New balance: {formatCurrency(currentBalance)}</p>
      </div>
    )
  }

  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      <div>
        <h3 className="text-lg font-medium text-gray-900 mb-4">
          <BoltIcon className="w-5 h-5 inline mr-2 text-blue-600" />
          Quick Top-Up
        </h3>

        <div className="mb-4 p-4 bg-gray-50 rounded-lg">
          <div className="text-sm text-gray-600">Current Balance</div>
          <div className="text-2xl font-bold text-gray-900">{formatCurrency(currentBalance)}</div>
        </div>

        <label className="block text-sm font-medium text-gray-700 mb-3">Select Amount</label>
        <div className="grid grid-cols-2 gap-3 mb-4">
          {QUICK_AMOUNTS.map((amount) => (
            <button
              key={amount}
              type="button"
              onClick={() => {
                setSelectedAmount(amount)
                setIsCustom(false)
                setCustomAmount('')
              }}
              className={`p-3 rounded-lg border-2 transition-colors ${
                !isCustom && selectedAmount === amount
                  ? 'border-blue-600 bg-blue-50 text-blue-700'
                  : 'border-gray-300 hover:border-gray-400'
              }`}
            >
              ${amount}
            </button>
          ))}
        </div>

        <div className="relative">
          <input
            type="text"
            inputMode="decimal"
            placeholder="Enter custom amount"
            value={customAmount}
            onChange={(e) => {
              const value = e.target.value
              // Allow only numbers and decimal point
              if (value === '' || /^\d*\.?\d*$/.test(value)) {
                setCustomAmount(value)
                setIsCustom(true)
              }
            }}
            onFocus={() => setIsCustom(true)}
            className={`w-full px-4 py-3 rounded-lg border-2 transition-colors ${
              isCustom ? 'border-blue-600 bg-blue-50' : 'border-gray-300 hover:border-gray-400'
            }`}
          />
          <span className="absolute left-4 top-1/2 -translate-y-1/2 text-gray-500 pointer-events-none">
            $
          </span>
        </div>
      </div>

      {clientSecret && (
        <>
          <div className="space-y-4">
            <label className="block text-sm font-medium text-gray-700">Payment Method</label>
            <div className="border border-gray-300 rounded-lg p-4">
              <PaymentElement
                options={{
                  layout: 'tabs',
                  paymentMethodOrder: ['card', 'us_bank_account'],
                }}
              />
            </div>
          </div>

          {errorMessage && (
            <div className="bg-red-50 border border-red-200 rounded-lg p-4">
              <p className="text-sm text-red-600">{errorMessage}</p>
            </div>
          )}

          <div className="flex items-center text-sm text-gray-500">
            <LockClosedIcon className="w-4 h-4 mr-2" />
            <span>Your payment information is secure and encrypted</span>
          </div>

          <div className="flex gap-3">
            <button
              type="button"
              onClick={onCancel}
              className="flex-1 py-3 px-4 rounded-lg font-medium border border-gray-300 hover:bg-gray-50 transition-colors"
              disabled={isProcessing}
            >
              Cancel
            </button>
            <button
              type="submit"
              disabled={!stripe || isProcessing || !getAmount()}
              className={`flex-1 py-3 px-4 rounded-lg font-medium transition-colors ${
                isProcessing ? 'bg-gray-400 cursor-not-allowed' : 'bg-blue-600 hover:bg-blue-700'
              } text-white`}
            >
              {isProcessing ? (
                <div className="flex items-center justify-center">
                  <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-white mr-2"></div>
                  Processing...
                </div>
              ) : (
                <>
                  <CreditCardIcon className="w-5 h-5 inline mr-2" />
                  Add ${getAmount().toFixed(2)}
                </>
              )}
            </button>
          </div>
        </>
      )}
    </form>
  )
}

// Main component that creates payment intent
export const QuickTopUpForm: React.FC<QuickTopUpFormProps> = (props) => {
  const { user } = useAuth()
  const [clientSecret, setClientSecret] = useState<string>('')
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string>('')
  const [selectedAmount] = useState(props.defaultAmount || 250)

  const createPaymentIntentForAmount = useCallback(
    async (amount: number) => {
      if (!user) {
        setError('User not authenticated')
        return
      }

      try {
        setIsLoading(true)
        setError('')

        const params: CreatePaymentIntentParams = {
          amount: Math.round(amount * 100), // Convert to cents
          currency: 'usd',
          customerId: user.stripe_customer_id || '',
          metadata: {
            invoiceId: `topup-${Date.now()}`,
            buyerId: user.id,
            billingPeriod: 'immediate',
          },
          paymentMethodTypes: ['card', 'us_bank_account'],
        }

        const paymentIntent = await createPaymentIntent(params)

        if (paymentIntent.client_secret) {
          setClientSecret(paymentIntent.client_secret)
        } else {
          throw new Error('Failed to create payment intent')
        }
      } catch (err) {
        const message = err instanceof Error ? err.message : 'Failed to initialize payment'
        setError(message)
      } finally {
        setIsLoading(false)
      }
    },
    [user]
  )

  // Create initial payment intent
  React.useEffect(() => {
    createPaymentIntentForAmount(selectedAmount)
  }, [selectedAmount, createPaymentIntentForAmount])

  if (isLoading && !clientSecret) {
    return (
      <div className="flex items-center justify-center py-12">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
        <span className="ml-3 text-gray-600">Setting up payment...</span>
      </div>
    )
  }

  if (error) {
    return (
      <div className="bg-red-50 border border-red-200 rounded-lg p-4">
        <p className="text-red-600">{error}</p>
        <button
          onClick={() => createPaymentIntentForAmount(selectedAmount)}
          className="mt-2 text-red-700 hover:text-red-800 underline"
        >
          Try again
        </button>
      </div>
    )
  }

  const elementsOptions: StripeElementsOptions = {
    clientSecret,
    appearance: {
      theme: 'stripe',
      variables: {
        colorPrimary: '#2563eb',
        colorBackground: '#ffffff',
        colorText: '#374151',
        colorDanger: '#ef4444',
        fontFamily: 'system-ui, sans-serif',
        spacingUnit: '4px',
        borderRadius: '8px',
      },
    },
  }

  return clientSecret ? (
    <Elements stripe={stripePromise} options={elementsOptions}>
      <QuickTopUpInner {...props} clientSecret={clientSecret} />
    </Elements>
  ) : null
}

// Export with error boundary
export default function QuickTopUpWithErrorBoundary(props: QuickTopUpFormProps) {
  const [retryKey, setRetryKey] = useState(0)

  return (
    <PaymentErrorBoundary
      onRetry={() => setRetryKey((prev) => prev + 1)}
      onUpdatePaymentMethod={() => (window.location.href = '/app/settings/payment-methods')}
      onContactSupport={() => (window.location.href = '/support?type=payment-error')}
      preserveFormData={true}
    >
      <QuickTopUpForm key={retryKey} {...props} />
    </PaymentErrorBoundary>
  )
}
</file>

<file path="src/components/payments/StripeConnectOnboarding.tsx">
import React, { useState, useEffect, useCallback } from 'react'
import { CheckCircleIcon, ExclamationTriangleIcon, ClockIcon } from '@heroicons/react/24/outline'
import { useAuth } from '@/hooks/useAuth'
import {
  createConnectedAccount,
  createAccountLink,
  getConnectedAccount,
} from '@/integrations/stripe/connected-accounts'
import type { ConnectedAccountStatus } from '@/integrations/stripe/types'

interface StripeConnectOnboardingProps {
  onComplete?: (accountId: string) => void
  onError?: (error: string) => void
}

export const StripeConnectOnboarding: React.FC<StripeConnectOnboardingProps> = ({
  onComplete,
  onError,
}) => {
  const { user } = useAuth()
  const [status, setStatus] = useState<
    'idle' | 'loading' | 'creating' | 'onboarding' | 'complete' | 'error'
  >('idle')
  const [error, setError] = useState<string>('')
  const [accountData, setAccountData] = useState<ConnectedAccountStatus | null>(null)

  const checkExistingAccount = useCallback(async () => {
    if (!user?.stripe_account_id) return

    try {
      setStatus('loading')
      const account = await getConnectedAccount(user.stripe_account_id)
      
      if (account) {
        const accountStatus: ConnectedAccountStatus = {
          id: account.id,
          chargesEnabled: account.charges_enabled || false,
          payoutsEnabled: account.payouts_enabled || false,
          detailsSubmitted: account.details_submitted || false,
          requirementsCurrentlyDue: account.requirements?.currently_due || [],
        }
        setAccountData(accountStatus)

        if (accountStatus.chargesEnabled && accountStatus.payoutsEnabled) {
          setStatus('complete')
          onComplete?.(accountStatus.id)
        } else {
          setStatus('onboarding')
        }
      } else {
        setStatus('idle')
      }
    } catch (err) {
      console.error('Error checking existing account:', err)
      setStatus('idle')
    }
  }, [user, onComplete])

  useEffect(() => {
    checkExistingAccount()
  }, [checkExistingAccount])

  const startOnboarding = async () => {
    if (!user || !user.email) {
      setError('User not authenticated or email missing')
      setStatus('error')
      return
    }

    try {
      setStatus('creating')
      setError('')

      // Create connected account if doesn't exist
      let accountId = user.stripe_account_id
      if (!accountId) {
        const account = await createConnectedAccount({
          email: user.email,
          country: 'US',
          businessType: 'company',
          metadata: {
            supplierId: user.id,
            companyName: user.company_name || undefined,
          },
        })
        accountId = account.id
      }

      // Create account link for onboarding
      const refreshUrl = `${window.location.origin}/suppliers/onboarding/refresh`
      const returnUrl = `${window.location.origin}/suppliers/onboarding/return`

      const accountLink = await createAccountLink(accountId, refreshUrl, returnUrl)

      setStatus('onboarding')

      // Redirect to Stripe onboarding
      window.location.href = accountLink.url
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to start onboarding'
      setError(errorMessage)
      setStatus('error')
      onError?.(errorMessage)
    }
  }

  const refreshOnboarding = async () => {
    if (!user?.stripe_account_id) return

    try {
      setStatus('creating')
      const refreshUrl = `${window.location.origin}/suppliers/onboarding/refresh`
      const returnUrl = `${window.location.origin}/suppliers/onboarding/return`

      const accountLink = await createAccountLink(user.stripe_account_id, refreshUrl, returnUrl)
      window.location.href = accountLink.url
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to refresh onboarding'
      setError(errorMessage)
      setStatus('error')
    }
  }

  const renderStatus = () => {
    switch (status) {
      case 'idle':
        return (
          <div className="text-center">
            <div className="mx-auto w-12 h-12 bg-blue-100 rounded-full flex items-center justify-center mb-4">
              <ClockIcon className="w-6 h-6 text-blue-600" />
            </div>
            <h3 className="text-lg font-medium text-gray-900 mb-2">Set Up Payouts</h3>
            <p className="text-gray-600 mb-6">
              Connect your bank account with Stripe to receive payments from calls.
            </p>
            <button
              onClick={startOnboarding}
              className="bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700 transition-colors"
            >
              Start Setup
            </button>
          </div>
        )

      case 'loading':
      case 'creating':
        return (
          <div className="text-center">
            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4"></div>
            <p className="text-gray-600">
              {status === 'loading' ? 'Checking account status...' : 'Setting up your account...'}
            </p>
          </div>
        )

      case 'onboarding':
        return (
          <div className="text-center">
            <div className="mx-auto w-12 h-12 bg-yellow-100 rounded-full flex items-center justify-center mb-4">
              <ClockIcon className="w-6 h-6 text-yellow-600" />
            </div>
            <h3 className="text-lg font-medium text-gray-900 mb-2">Complete Account Setup</h3>
            <p className="text-gray-600 mb-4">
              Your Stripe account is partially set up. Complete the remaining steps to start
              receiving payouts.
            </p>
            {accountData && (
              <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-4 mb-4 text-left">
                <h4 className="font-medium text-yellow-800 mb-2">Remaining Requirements:</h4>
                <ul className="text-sm text-yellow-700 space-y-1">
                  {accountData.requirementsCurrentlyDue.map(
                    (requirement: string, index: number) => (
                      <li key={index} className="flex items-start">
                        <span className="w-1.5 h-1.5 bg-yellow-600 rounded-full mt-2 mr-2 flex-shrink-0"></span>
                        {formatRequirement(requirement)}
                      </li>
                    )
                  )}
                </ul>
              </div>
            )}
            <button
              onClick={refreshOnboarding}
              className="bg-yellow-600 text-white px-6 py-2 rounded-lg hover:bg-yellow-700 transition-colors"
            >
              Continue Setup
            </button>
          </div>
        )

      case 'complete':
        return (
          <div className="text-center">
            <div className="mx-auto w-12 h-12 bg-green-100 rounded-full flex items-center justify-center mb-4">
              <CheckCircleIcon className="w-6 h-6 text-green-600" />
            </div>
            <h3 className="text-lg font-medium text-gray-900 mb-2">Payouts Enabled</h3>
            <p className="text-gray-600 mb-4">
              Your account is fully set up and ready to receive payments.
            </p>
            <div className="bg-green-50 border border-green-200 rounded-lg p-4 text-left">
              <div className="grid grid-cols-2 gap-4 text-sm">
                <div>
                  <span className="text-green-800 font-medium">Charges:</span>
                  <span className="text-green-700 ml-2">
                    {accountData?.chargesEnabled ? 'Enabled' : 'Disabled'}
                  </span>
                </div>
                <div>
                  <span className="text-green-800 font-medium">Payouts:</span>
                  <span className="text-green-700 ml-2">
                    {accountData?.payoutsEnabled ? 'Enabled' : 'Disabled'}
                  </span>
                </div>
              </div>
            </div>
          </div>
        )

      case 'error':
        return (
          <div className="text-center">
            <div className="mx-auto w-12 h-12 bg-red-100 rounded-full flex items-center justify-center mb-4">
              <ExclamationTriangleIcon className="w-6 h-6 text-red-600" />
            </div>
            <h3 className="text-lg font-medium text-gray-900 mb-2">Setup Error</h3>
            <p className="text-red-600 mb-4">{error}</p>
            <button
              onClick={() => setStatus('idle')}
              className="bg-gray-600 text-white px-6 py-2 rounded-lg hover:bg-gray-700 transition-colors"
            >
              Try Again
            </button>
          </div>
        )

      default:
        return null
    }
  }

  return (
    <div className="max-w-md mx-auto">
      <div className="bg-white rounded-lg border border-gray-200 p-6">{renderStatus()}</div>
    </div>
  )
}

const formatRequirement = (requirement: string): string => {
  const requirements: Record<string, string> = {
    external_account: 'Bank account information',
    'business_profile.url': 'Business website',
    'business_profile.mcc': 'Business category',
    business_type: 'Business type',
    'company.address.city': 'Business address - city',
    'company.address.line1': 'Business address - street',
    'company.address.postal_code': 'Business address - postal code',
    'company.address.state': 'Business address - state',
    'company.name': 'Business name',
    'company.phone': 'Business phone number',
    'company.tax_id': 'Business tax ID',
    'individual.address.city': 'Personal address - city',
    'individual.address.line1': 'Personal address - street',
    'individual.address.postal_code': 'Personal address - postal code',
    'individual.address.state': 'Personal address - state',
    'individual.dob.day': 'Date of birth - day',
    'individual.dob.month': 'Date of birth - month',
    'individual.dob.year': 'Date of birth - year',
    'individual.email': 'Email address',
    'individual.first_name': 'First name',
    'individual.last_name': 'Last name',
    'individual.phone': 'Phone number',
    'individual.ssn_last_4': 'Last 4 digits of SSN',
    'tos_acceptance.date': 'Terms of service acceptance',
    'tos_acceptance.ip': 'IP address for terms acceptance',
  }

  return (
    requirements[requirement] ||
    requirement.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase())
  )
}

export default StripeConnectOnboarding
</file>

<file path="src/components/reports/CLAUDE.md">
# Reports Components

# Report Structure
- `ReportBuilder.tsx` - Custom report creation
- `ReportViewer.tsx` - Report display and interaction
- `ChartComponents.tsx` - Various chart types
- `DataExport.tsx` - Export functionality
- `ReportFilters.tsx` - Advanced filtering

# Report Builder Interface
```tsx
interface ReportBuilderProps {
  onSave: (report: ReportConfig) => void;
  initialConfig?: ReportConfig;
}

export function ReportBuilder({ onSave, initialConfig }: ReportBuilderProps) {
  const [config, setConfig] = useState<ReportConfig>(
    initialConfig || {
      name: '',
      type: 'table',
      metrics: [],
      dimensions: [],
      filters: [],
      dateRange: { start: '', end: '' },
    }
  );
  
  const handleMetricAdd = (metric: ReportMetric) => {
    setConfig(prev => ({
      ...prev,
      metrics: [...prev.metrics, metric],
    }));
  };
  
  return (
    <div className="report-builder">
      <ReportConfigPanel
        config={config}
        onConfigChange={setConfig}
        onMetricAdd={handleMetricAdd}
      />
      <ReportPreview config={config} />
      <Button onClick={() => onSave(config)}>Save Report</Button>
    </div>
  );
}
```

# Chart Components
```tsx
interface ChartProps<T> {
  data: T[];
  type: 'line' | 'bar' | 'pie' | 'area';
  xKey: keyof T;
  yKey: keyof T;
  title?: string;
  loading?: boolean;
}

export function Chart<T>({ data, type, xKey, yKey, title, loading }: ChartProps<T>) {
  if (loading) return <ChartSkeleton />;
  
  const chartConfig = useMemo(() => ({
    data,
    xField: String(xKey),
    yField: String(yKey),
    title: { text: title },
    responsive: true,
  }), [data, xKey, yKey, title]);
  
  const ChartComponent = getChartComponent(type);
  
  return (
    <div className="chart-wrapper">
      <ChartComponent {...chartConfig} />
    </div>
  );
}
```

# Data Export Functionality
```tsx
interface DataExportProps {
  data: unknown[];
  fileName: string;
  formats: ExportFormat[];
}

export function DataExport({ data, fileName, formats }: DataExportProps) {
  const exportData = async (format: ExportFormat) => {
    switch (format) {
      case 'csv':
        return exportToCSV(data, fileName);
      case 'xlsx':
        return exportToExcel(data, fileName);
      case 'pdf':
        return exportToPDF(data, fileName);
      case 'json':
        return exportToJSON(data, fileName);
      default:
        throw new Error(`Unsupported format: ${format}`);
    }
  };
  
  return (
    <div className="export-controls">
      {formats.map(format => (
        <Button
          key={format}
          onClick={() => exportData(format)}
          variant="outline"
        >
          Export {format.toUpperCase()}
        </Button>
      ))}
    </div>
  );
}
```

# Advanced Filtering
```tsx
interface ReportFiltersProps {
  filters: ReportFilter[];
  onFiltersChange: (filters: ReportFilter[]) => void;
  availableFields: FilterField[];
}

export function ReportFilters({ filters, onFiltersChange, availableFields }: ReportFiltersProps) {
  const addFilter = () => {
    const newFilter: ReportFilter = {
      id: generateId(),
      field: '',
      operator: 'equals',
      value: '',
    };
    onFiltersChange([...filters, newFilter]);
  };
  
  const updateFilter = (id: string, updates: Partial<ReportFilter>) => {
    onFiltersChange(filters.map(filter =>
      filter.id === id ? { ...filter, ...updates } : filter
    ));
  };
  
  return (
    <div className="report-filters">
      {filters.map(filter => (
        <FilterRow
          key={filter.id}
          filter={filter}
          availableFields={availableFields}
          onChange={(updates) => updateFilter(filter.id, updates)}
          onRemove={() => onFiltersChange(filters.filter(f => f.id !== filter.id))}
        />
      ))}
      <Button onClick={addFilter} variant="outline">Add Filter</Button>
    </div>
  );
}
```

# Real-time Report Updates
```tsx
export function useRealtimeReportData(reportConfig: ReportConfig) {
  const [data, setData] = useState<ReportData[]>([]);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    const fetchInitialData = async () => {
      setLoading(true);
      const result = await generateReport(reportConfig);
      setData(result);
      setLoading(false);
    };
    
    fetchInitialData();
    
    // Set up real-time subscription
    const subscription = supabase
      .channel('report-updates')
      .on('postgres_changes', {
        event: '*',
        schema: 'public',
        table: getTableForReport(reportConfig),
      }, async () => {
        const updatedData = await generateReport(reportConfig);
        setData(updatedData);
      })
      .subscribe();
      
    return () => supabase.removeChannel(subscription);
  }, [reportConfig]);
  
  return { data, loading };
}
```

# Performance Metrics
- Call volume reports
- Conversion rate analysis
- Revenue tracking
- Quality score trends
- Fraud detection summaries

# Campaign Analytics
```tsx
interface CampaignReportProps {
  campaignId: string;
  dateRange: DateRange;
}

export function CampaignReport({ campaignId, dateRange }: CampaignReportProps) {
  const { data, loading } = useQuery({
    queryKey: ['campaign-report', campaignId, dateRange],
    queryFn: () => fetchCampaignAnalytics(campaignId, dateRange),
  });
  
  if (loading) return <ReportSkeleton />;
  
  return (
    <div className="campaign-report">
      <MetricsSummary metrics={data.summary} />
      <Chart
        data={data.callTrends}
        type="line"
        xKey="date"
        yKey="calls"
        title="Call Volume Over Time"
      />
      <DataTable
        data={data.details}
        columns={CAMPAIGN_REPORT_COLUMNS}
        exportable
      />
    </div>
  );
}
```

# Scheduled Reports
- Email delivery setup
- Recurring report generation
- Custom recipient lists
- Report template management

# Data Visualization Best Practices
- Color accessibility
- Clear axis labels
- Interactive tooltips
- Responsive charts
- Print-friendly formats

# Report Templates
```tsx
interface ReportTemplate {
  id: string;
  name: string;
  description: string;
  config: ReportConfig;
  category: 'performance' | 'financial' | 'quality' | 'fraud';
}

export const REPORT_TEMPLATES: ReportTemplate[] = [
  {
    id: 'daily-performance',
    name: 'Daily Performance Summary',
    description: 'Key metrics for the last 24 hours',
    config: {
      type: 'dashboard',
      metrics: ['calls', 'revenue', 'conversion_rate'],
      dateRange: { type: 'relative', value: '24h' },
    },
    category: 'performance',
  },
  // More templates...
];
```

# CRITICAL RULES
- NO regex in report logic
- NO any types in data interfaces
- ALWAYS validate data before visualization
- ALWAYS handle large datasets efficiently
- IMPLEMENT proper error handling
- TEST export functionality thoroughly
- OPTIMIZE chart rendering performance
- ENSURE accessibility compliance
- PROVIDE clear loading indicators
</file>

<file path="src/components/ui/QueryErrorFallback.tsx">
import { ErrorFallback } from './ErrorFallback'

interface QueryErrorFallbackProps {
  error: Error
  resetErrorBoundary: () => void
}

export function QueryErrorFallback({ error, resetErrorBoundary }: QueryErrorFallbackProps) {
  return <ErrorFallback error={error} resetErrorBoundary={resetErrorBoundary} isRoot={false} />
}
</file>

<file path="src/components/CLAUDE.md">
# Component Patterns

# Naming Conventions
- PascalCase for components: `UserProfile`, `CallTracker`
- camelCase for props: `isLoading`, `onCallEnd`
- kebab-case for CSS classes: `call-status`, `user-card`

# File Structure
```
ComponentName/
â”œâ”€â”€ index.tsx          # Main component
â”œâ”€â”€ ComponentName.tsx  # Alternative: direct export
â”œâ”€â”€ types.ts          # Component-specific types
â””â”€â”€ __tests__/        # Component tests
```

# TypeScript Requirements
- ALL props interfaces: `interface ComponentNameProps {}`
- NO any types - use proper typing
- Export prop types for reuse
- Use generic types for flexible components

# Component Template
```tsx
interface ComponentProps {
  title: string;
  isActive?: boolean;
  onAction: (id: string) => void;
}

export function ComponentName({ 
  title, 
  isActive = false, 
  onAction 
}: ComponentProps) {
  return (
    <div className="component-wrapper">
      {/* Component content */}
    </div>
  );
}
```

# Styling Guidelines
- Tailwind CSS classes only
- Use Headless UI for complex interactions
- Heroicons for all icons
- Mobile-first responsive design
- Dark mode support via CSS variables

# State Management
- Local state: `useState` for component-only data
- Global state: Zustand stores for shared data
- Server state: React Query for API data
- Forms: React Hook Form + Zod validation

# Accessibility Requirements
- ARIA labels on interactive elements
- Keyboard navigation support
- Screen reader compatibility
- Focus management for modals/dropdowns

# Testing Requirements
- Unit tests for all logic
- Component tests with Testing Library
- Snapshot tests for UI stability
- Accessibility tests with axe

# Performance Patterns
- React.memo for expensive renders
- useMemo for calculated values
- useCallback for event handlers
- Lazy loading for large components

# DCE-Specific Patterns
- Call status indicators with real-time updates
- Fraud detection UI components
- Supplier/Buyer role-based rendering
- Campaign management interfaces

# CRITICAL RULES
- NO regex in components
- NO any types allowed
- ALWAYS handle loading/error states
- ALWAYS validate props with TypeScript
</file>

<file path="src/data/blogPosts.ts">
export interface BlogPost {
  id: number
  title: string
  excerpt: string
  content: string
  author: string
  date: string
  readTime: string
  category: string
  slug: string
}

export const blogPosts: BlogPost[] = [
  {
    id: 1,
    title: 'Getting Started with Pay-Per-Call Marketing',
    excerpt:
      'Learn the fundamentals of pay-per-call marketing and how to maximize your ROI with quality traffic sources.',
    content: `
# Getting Started with Pay-Per-Call Marketing

Pay-per-call marketing has emerged as one of the most effective ways to connect businesses with high-intent customers. Unlike traditional digital advertising where you pay for clicks or impressions, pay-per-call marketing only charges advertisers when a qualified phone call is generated.

## What is Pay-Per-Call Marketing?

Pay-per-call is a performance marketing model where advertisers pay publishers (traffic sources) for qualified phone calls to their business. This model is particularly effective for industries where phone conversations are crucial to the sales process, such as:

- Insurance
- Legal services
- Home services
- Healthcare
- Financial services
- Real estate

## Key Benefits

### 1. Higher Conversion Rates
Phone calls typically convert at much higher rates than web form fills or other digital actions. When someone picks up the phone to call your business, they're showing genuine interest and are often ready to make a purchase decision.

### 2. Better Lead Quality
Callers are inherently more qualified than web visitors. The effort required to make a phone call means the person has genuine interest in your product or service.

### 3. Measurable ROI
With proper call tracking and analytics, you can measure exactly which traffic sources are driving the most valuable calls, allowing you to optimize your campaigns for maximum ROI.

## Getting Started

### Step 1: Choose Your Platform
Select a reliable pay-per-call network like DependableCalls.com that offers:
- Advanced fraud protection
- Real-time call tracking
- Transparent reporting
- Quality traffic sources

### Step 2: Set Up Your Campaign
Define your campaign parameters:
- Target geography
- Call duration requirements
- Business hours
- Pricing model (flat rate or duration-based)

### Step 3: Optimize and Scale
Monitor your campaigns closely and optimize based on performance data:
- Adjust bid prices for better traffic
- Refine targeting parameters
- Block low-quality sources
- Scale successful campaigns

## Best Practices

1. **Set Clear Quality Standards**: Define what constitutes a qualified call for your business
2. **Use Call Recording**: Record calls for quality assurance and training purposes
3. **Monitor in Real-Time**: Keep track of call volume and quality throughout the day
4. **Test Multiple Sources**: Don't rely on a single traffic source
5. **Optimize Landing Pages**: Ensure your landing pages are optimized for phone conversions

Pay-per-call marketing can be incredibly profitable when executed correctly. Start with clear goals, choose the right platform, and continuously optimize based on performance data.
    `,
    author: 'Sarah Johnson',
    date: 'January 15, 2025',
    readTime: '5 min read',
    category: 'Getting Started',
    slug: 'getting-started-pay-per-call',
  },
  {
    id: 2,
    title: 'Top 10 Traffic Sources for Call Campaigns',
    excerpt:
      'Discover the most effective traffic sources for driving high-quality calls to your campaigns in 2025.',
    content: `
# Top 10 Traffic Sources for Call Campaigns

Finding quality traffic sources is crucial for successful pay-per-call campaigns. Here are the top 10 traffic sources that consistently deliver high-quality calls across various industries.

## 1. Google Ads

Google Ads remains the gold standard for pay-per-call traffic. With its massive reach and sophisticated targeting options, Google Ads allows you to:

- Target high-intent keywords
- Use call extensions and call-only ads
- Leverage local search traffic
- Implement advanced bidding strategies

**Best for**: All industries, especially local services

## 2. Facebook and Instagram Ads

Social media advertising offers excellent targeting capabilities and can drive quality calls when properly optimized:

- Detailed demographic and interest targeting
- Lookalike audiences based on existing customers
- Video ads that explain your service
- Local awareness campaigns

**Best for**: B2C services, home improvement, healthcare

## 3. Microsoft Advertising (Bing)

Often overlooked, Bing can provide high-quality traffic at lower costs:

- Less competition than Google
- Older, more affluent demographic
- Strong integration with Microsoft products
- Lower cost-per-click rates

**Best for**: Financial services, insurance, B2B services

## 4. Native Advertising

Native ads blend seamlessly with content and can drive engaged traffic:

- Content-style advertisements
- Less ad-blind audience
- Higher engagement rates
- Works well with educational content

**Best for**: Insurance, legal services, financial products

## 5. Search Engine Optimization (SEO)

Organic search traffic is valuable for long-term success:

- No per-click costs
- High-intent traffic
- Builds trust and authority
- Sustainable long-term strategy

**Best for**: All industries with local presence

## 6. Directory Listings

Industry-specific directories can be goldmines for quality calls:

- Highly targeted audience
- Industry-specific platforms
- Local directory listings
- Professional service directories

**Best for**: Legal, medical, home services

## 7. YouTube Advertising

Video advertising on YouTube can be highly effective:

- Visual demonstration of services
- Targeting based on viewing behavior
- Skip-able and non-skippable options
- Integration with Google Ads platform

**Best for**: Home services, automotive, healthcare

## 8. Radio Advertising

Traditional radio still delivers quality calls:

- Local market penetration
- Trusted medium
- Drive-time advertising
- Sponsorship opportunities

**Best for**: Local services, automotive, financial services

## 9. Podcast Advertising

Growing rapidly as a quality traffic source:

- Engaged audience
- Host endorsements
- Niche targeting
- High-quality demographics

**Best for**: B2B services, professional services, healthcare

## 10. Direct Mail

When integrated with call tracking, direct mail can be very effective:

- Tangible marketing piece
- Less competition in mailbox
- Can include compelling offers
- Works well for local businesses

**Best for**: Home services, insurance, financial services

## Optimization Tips

1. **Track Everything**: Use unique phone numbers for each traffic source
2. **Test Continuously**: A/B test ad creative, landing pages, and offers
3. **Quality Over Quantity**: Focus on sources that deliver qualified calls
4. **Geographic Targeting**: Optimize for your service areas
5. **Time-of-Day Optimization**: Adjust bids based on when quality calls occur

The key to success is testing multiple traffic sources and optimizing based on actual call quality and conversion data.
    `,
    author: 'Mike Chen',
    date: 'January 10, 2025',
    readTime: '8 min read',
    category: 'Traffic Sources',
    slug: 'top-traffic-sources-2025',
  },
  {
    id: 3,
    title: 'Fraud Prevention: Protecting Your Campaigns',
    excerpt:
      'Essential strategies and tools for detecting and preventing fraud in your pay-per-call campaigns.',
    content: `
# Fraud Prevention: Protecting Your Campaigns

Fraud is unfortunately common in pay-per-call marketing. Implementing robust fraud prevention measures is essential to protect your investment and ensure campaign profitability.

## Common Types of Pay-Per-Call Fraud

### 1. Robocalls and Automated Calls
- Automated systems generating fake calls
- Often very short duration
- No human interaction
- Easy to detect with proper filtering

### 2. Repeated Calls from Same Number
- Single person calling multiple times
- Attempts to inflate call volume
- Can be filtered by time gaps and caller ID

### 3. International Call Centers
- Call centers generating fake calls
- Often from specific geographic regions
- Can be detected through call pattern analysis
- May have background noise or scripts

### 4. Short Duration Calls
- Calls that hang up immediately
- Designed to trigger payment without value
- Filtered by minimum duration requirements
- Often automated

### 5. Off-Hours Calls
- Calls outside business hours
- When businesses are closed
- Often automated or from different time zones
- Easy to filter with business hour settings

## Fraud Detection Strategies

### Real-Time Monitoring
Implement systems that can detect fraud as it happens:

- **Call Duration Analysis**: Flag calls shorter than your minimum threshold
- **Caller ID Verification**: Check for valid phone numbers and geographic consistency
- **Call Pattern Recognition**: Identify unusual calling patterns or volumes
- **Background Noise Analysis**: Detect call center environments

### Geographic Filtering
Use location-based fraud prevention:

- **IP Geolocation**: Verify caller location matches target demographics
- **Area Code Validation**: Ensure phone numbers match expected regions
- **International Blocking**: Block calls from high-risk countries
- **State/Regional Targeting**: Limit calls to specific service areas

### Call Quality Analysis
Monitor call quality indicators:

- **Audio Quality**: Poor connections may indicate VoIP fraud
- **Background Noise**: Excessive noise may indicate call centers
- **Script Detection**: Identify scripted or robotic speech patterns
- **Language Analysis**: Ensure calls are in expected languages

## Technical Implementation

### 1. Call Tracking Numbers
Use unique tracking numbers to:
- Identify traffic sources
- Monitor call quality by source
- Block fraudulent sources quickly
- Maintain detailed analytics

### 2. IVR (Interactive Voice Response)
Implement IVR systems to:
- Qualify callers before connecting
- Collect additional information
- Deter automated systems
- Filter out low-quality calls

### 3. Call Recording and Analysis
Record calls for:
- Quality assurance
- Fraud detection
- Training purposes
- Dispute resolution

### 4. Real-Time Filtering
Set up automated filters for:
- Minimum call duration (typically 30-90 seconds)
- Maximum calls per number per day
- Business hours enforcement
- Geographic restrictions

## Best Practices

### 1. Set Clear Quality Standards
Define what constitutes a qualified call:
- Minimum duration requirements
- Geographic targeting
- Business hours only
- Human callers only

### 2. Use Multiple Detection Methods
Layer your fraud prevention:
- Combine technical and human review
- Use multiple data points for decisions
- Implement both real-time and post-call analysis
- Regular pattern analysis and updates

### 3. Work with Reputable Partners
Choose partners carefully:
- Vet traffic sources thoroughly
- Monitor partner performance continuously
- Maintain clear quality agreements
- Regular performance reviews

### 4. Continuous Optimization
Fraud evolves, so must your defenses:
- Regular analysis of call patterns
- Update filtering rules based on new fraud types
- Monitor industry fraud trends
- Implement new technologies as available

## Red Flags to Watch For

- Sudden spikes in call volume
- Calls from unexpected geographic regions
- Extremely short or long call durations
- Background noise consistent with call centers
- Similar scripts or speech patterns
- Calls outside business hours
- Multiple calls from same numbers
- Poor call-to-conversion ratios

## Working with DependableCalls.com

Our platform includes advanced fraud protection:

- **AI-Powered Detection**: Machine learning algorithms identify fraud patterns
- **Real-Time Filtering**: Automatic blocking of suspicious calls
- **Comprehensive Analytics**: Detailed reporting on call quality
- **Human Review**: Expert analysis of questionable calls
- **Continuous Updates**: Regular updates to fraud detection algorithms

Protecting your campaigns from fraud is an ongoing process that requires vigilance, good tools, and continuous optimization. By implementing these strategies, you can significantly reduce fraud and improve campaign profitability.
    `,
    author: 'Emily Rodriguez',
    date: 'January 5, 2025',
    readTime: '6 min read',
    category: 'Security',
    slug: 'fraud-prevention-strategies',
  },
  {
    id: 4,
    title: 'Optimizing Call Quality with Advanced Analytics',
    excerpt:
      'How to use data-driven insights to improve call quality and increase conversion rates.',
    content: `
# Optimizing Call Quality with Advanced Analytics

Data-driven optimization is the key to successful pay-per-call campaigns. By leveraging advanced analytics, you can identify opportunities to improve call quality and increase conversion rates.

## Key Performance Indicators (KPIs)

### Primary Metrics
- **Call Volume**: Total number of calls received
- **Call Duration**: Average length of calls
- **Conversion Rate**: Percentage of calls that result in sales
- **Cost Per Acquisition (CPA)**: Cost to acquire each customer
- **Return on Ad Spend (ROAS)**: Revenue generated per dollar spent

### Secondary Metrics
- **Call Quality Score**: Composite score based on multiple factors
- **Lead-to-Close Rate**: Percentage of leads that become customers
- **Time to Conversion**: How long from call to sale
- **Geographic Performance**: Performance by location
- **Source Performance**: Performance by traffic source

## Analytics Tools and Platforms

### Call Tracking Platforms
Modern call tracking provides detailed insights:
- **Call recordings** for quality analysis
- **Real-time reporting** for immediate optimization
- **Integration capabilities** with CRM and analytics tools
- **Advanced attribution** for multi-touch journeys

### CRM Integration
Connect call data with customer data:
- Track complete customer journey
- Identify high-value customer patterns
- Optimize for lifetime value
- Improve sales team performance

### Business Intelligence Tools
Use BI tools for deeper analysis:
- **Custom dashboards** for real-time monitoring
- **Predictive analytics** for forecasting
- **Cohort analysis** for understanding trends
- **Attribution modeling** for multi-channel campaigns

## Advanced Analysis Techniques

### Call Pattern Analysis
Identify patterns in successful calls:
- **Time of day optimization**: When do quality calls occur?
- **Day of week trends**: Which days perform best?
- **Seasonal patterns**: How do seasons affect performance?
- **Geographic variations**: Where are the best calls coming from?

### Conversation Analysis
Analyze actual call content:
- **Keyword analysis**: What words indicate high intent?
- **Sentiment analysis**: How do emotions affect outcomes?
- **Talk time ratios**: Optimal agent vs. caller talk time
- **Script optimization**: Which approaches work best?

### Predictive Modeling
Use machine learning for optimization:
- **Lead scoring**: Predict which calls will convert
- **Churn prediction**: Identify at-risk customers
- **Lifetime value modeling**: Focus on high-value segments
- **Fraud detection**: Automatically identify suspicious calls

## Optimization Strategies

### 1. Source Optimization
Analyze performance by traffic source:

\`\`\`
Traffic Source Performance Analysis:
- Google Ads: 45% conversion rate, $85 CPA
- Facebook Ads: 32% conversion rate, $120 CPA
- Bing Ads: 38% conversion rate, $95 CPA
- Native Ads: 28% conversion rate, $140 CPA
\`\`\`

**Action**: Increase budget on Google Ads, optimize or pause Native Ads

### 2. Geographic Optimization
Identify high-performing regions:
- Analyze conversion rates by state/city
- Adjust bids based on geographic performance
- Identify expansion opportunities
- Block low-performing areas

### 3. Temporal Optimization
Optimize for time-based patterns:
- **Hour of day**: Adjust bids for peak performance hours
- **Day of week**: Increase budgets on high-converting days
- **Seasonal trends**: Plan campaigns around seasonal patterns
- **Business hours**: Optimize for when sales team is available

### 4. Creative Optimization
Use call data to improve creative:
- A/B test different ad messages
- Optimize landing pages based on caller feedback
- Test different offers and incentives
- Improve call-to-action placement

## Implementation Framework

### 1. Data Collection
Set up comprehensive tracking:
- Unique phone numbers for each source
- UTM parameters for digital campaigns
- Call recording for all conversations
- Integration with CRM and analytics platforms

### 2. Analysis and Insights
Regular analysis routine:
- Daily performance monitoring
- Weekly deep-dive analysis
- Monthly strategic reviews
- Quarterly campaign optimization

### 3. Testing and Optimization
Continuous improvement process:
- A/B test changes systematically
- Implement changes gradually
- Monitor impact closely
- Document lessons learned

### 4. Reporting and Communication
Keep stakeholders informed:
- Real-time dashboards for day-to-day monitoring
- Weekly performance reports
- Monthly strategic analysis
- Quarterly business reviews

## Advanced Techniques

### Cohort Analysis
Track groups of callers over time:
- Understand long-term value patterns
- Identify retention opportunities
- Optimize for lifetime value
- Plan capacity based on trends

### Attribution Modeling
Understand multi-touch journeys:
- First-touch attribution for awareness campaigns
- Last-touch attribution for direct response
- Multi-touch modeling for complex journeys
- Data-driven attribution for accuracy

### Machine Learning Applications
Leverage AI for optimization:
- **Automated bid optimization**: Adjust bids based on performance
- **Dynamic creative optimization**: Personalize ads in real-time
- **Predictive lead scoring**: Prioritize high-value prospects
- **Automated fraud detection**: Block suspicious activity

## Common Pitfalls to Avoid

1. **Over-optimization**: Making too many changes too quickly
2. **Data silos**: Not integrating all relevant data sources
3. **Short-term focus**: Optimizing for immediate results only
4. **Ignoring external factors**: Not accounting for market changes
5. **Analysis paralysis**: Spending too much time analyzing, not enough acting

## Getting Started with Analytics

1. **Audit current tracking**: Ensure all calls are being tracked properly
2. **Set up baseline metrics**: Establish current performance benchmarks
3. **Implement advanced tracking**: Add more detailed analytics tools
4. **Create reporting structure**: Regular analysis and optimization schedule
5. **Train your team**: Ensure everyone understands the metrics and insights

Advanced analytics is not just about collecting dataâ€”it's about turning that data into actionable insights that drive business growth. Start with basic tracking and gradually implement more sophisticated analysis techniques as your campaigns mature.
    `,
    author: 'David Thompson',
    date: 'December 28, 2024',
    readTime: '7 min read',
    category: 'Analytics',
    slug: 'optimizing-call-quality',
  },
  {
    id: 5,
    title: 'Building Trust with Transparent Reporting',
    excerpt:
      'How transparent reporting builds trust between advertisers and publishers in pay-per-call networks.',
    content: `
# Building Trust with Transparent Reporting

Trust is the foundation of successful pay-per-call partnerships. Transparent reporting is essential for building and maintaining trust between advertisers and publishers in the pay-per-call ecosystem.

## The Importance of Transparency

### Why Transparency Matters
- **Trust Building**: Open communication builds stronger partnerships
- **Performance Optimization**: Shared data leads to better results
- **Fraud Prevention**: Transparency helps identify and prevent fraudulent activity
- **Long-term Success**: Transparent relationships last longer and perform better

### The Cost of Opacity
When reporting lacks transparency:
- Partners question data accuracy
- Optimization becomes difficult
- Fraud goes undetected
- Partnerships deteriorate over time

## Key Elements of Transparent Reporting

### 1. Real-Time Data Access
Provide partners with immediate access to campaign data:
- **Live dashboards** showing current performance
- **Instant notifications** for important events
- **Real-time alerts** for performance changes
- **Immediate access** to call recordings

### 2. Detailed Call Information
Share comprehensive call data:
- **Call duration** and timestamps
- **Caller location** and phone number
- **Call quality scores** and ratings
- **Conversion outcomes** when available

### 3. Clear Metrics and Definitions
Ensure everyone understands the data:
- **Standardized definitions** for all metrics
- **Clear explanations** of calculation methods
- **Consistent terminology** across all reports
- **Regular training** on reporting features

### 4. Historical Data Access
Provide access to historical performance:
- **Trend analysis** over time
- **Seasonal patterns** and insights
- **Performance comparisons** across periods
- **Long-term optimization** opportunities

## Building Trust Through Communication

### Regular Check-ins
Schedule consistent communication:
- **Weekly performance reviews** with key partners
- **Monthly strategic discussions** about optimization
- **Quarterly business reviews** for long-term planning
- **Ad-hoc meetings** when issues arise

### Proactive Problem Reporting
Address issues before they become problems:
- **Early warning systems** for performance drops
- **Immediate notifications** of technical issues
- **Proactive solutions** to identified problems
- **Follow-up reporting** on resolution status

### Data Validation Processes
Implement systems to ensure data accuracy:
- **Automated quality checks** on all data
- **Manual audits** of high-value campaigns
- **Cross-validation** with partner systems
- **Regular reconciliation** processes

## Technology Solutions for Transparency

### Advanced Reporting Platforms
Invest in robust reporting infrastructure:
- **Cloud-based dashboards** accessible anywhere
- **Mobile-friendly interfaces** for on-the-go access
- **Customizable reports** for different stakeholders
- **API access** for system integration

### Call Recording and Analysis
Provide comprehensive call insights:
- **High-quality recordings** of all calls
- **Automated transcription** services
- **Sentiment analysis** of conversations
- **Call scoring** based on quality metrics

### Fraud Detection Systems
Implement transparent fraud prevention:
- **Real-time fraud scoring** for all calls
- **Detailed fraud reports** with explanations
- **Appeal processes** for disputed calls
- **Continuous improvement** of detection algorithms

## Best Practices for Transparent Reporting

### 1. Set Clear Expectations
Establish reporting standards from the beginning:
- **Define reporting frequency** and formats
- **Agree on key metrics** and benchmarks
- **Set data quality standards** and processes
- **Establish communication protocols**

### 2. Provide Training and Support
Ensure partners can use reporting tools effectively:
- **Comprehensive training** on platform features
- **Regular webinars** on best practices
- **Dedicated support** for technical issues
- **Documentation** and user guides

### 3. Regular Audits and Reviews
Continuously improve reporting quality:
- **Monthly data quality audits**
- **Quarterly reporting reviews** with partners
- **Annual system upgrades** and improvements
- **Ongoing feedback collection** and implementation

### 4. Maintain Data Security
Protect sensitive information while being transparent:
- **Secure data transmission** and storage
- **Role-based access** controls
- **Regular security audits** and updates
- **Compliance** with data protection regulations

## Measuring Trust and Satisfaction

### Key Trust Indicators
Monitor these metrics to gauge partner trust:
- **Partner retention rates** over time
- **Volume growth** with existing partners
- **Referral rates** from satisfied partners
- **Survey scores** on transparency and trust

### Regular Feedback Collection
Actively seek partner input:
- **Quarterly satisfaction surveys**
- **Annual partner conferences** for feedback
- **Regular one-on-one meetings** with key partners
- **Anonymous feedback systems** for honest input

## Common Transparency Challenges

### 1. Balancing Transparency with Competition
How to share data without revealing competitive advantages:
- **Aggregate reporting** to protect sensitive details
- **Anonymized benchmarking** for performance comparison
- **Selective disclosure** based on partnership level
- **Clear boundaries** on what information is shared

### 2. Technical Limitations
Overcoming system constraints:
- **Gradual system upgrades** to improve capabilities
- **Interim solutions** while building better systems
- **Clear communication** about current limitations
- **Timeline commitments** for improvements

### 3. Resource Constraints
Managing transparency with limited resources:
- **Automated reporting** to reduce manual work
- **Prioritized transparency** for key partners
- **Efficient processes** to maximize impact
- **Technology investments** to scale transparency

## The Future of Transparent Reporting

### Emerging Technologies
New tools enabling better transparency:
- **AI-powered insights** and recommendations
- **Blockchain** for immutable data records
- **Advanced analytics** for deeper insights
- **Real-time collaboration** tools

### Industry Standards
Movement toward standardized reporting:
- **Industry-wide metrics** and definitions
- **Standardized APIs** for data sharing
- **Common reporting formats** across platforms
- **Regulatory requirements** for transparency

## Implementation Roadmap

### Phase 1: Foundation (Months 1-3)
- **Audit current reporting** capabilities
- **Define transparency standards** and goals
- **Implement basic real-time** reporting
- **Train team** on new processes

### Phase 2: Enhancement (Months 4-6)
- **Add advanced reporting** features
- **Implement call recording** and analysis
- **Develop fraud detection** systems
- **Expand partner training** programs

### Phase 3: Optimization (Months 7-12)
- **Advanced analytics** and insights
- **Predictive modeling** capabilities
- **Automated optimization** recommendations
- **Full transparency** ecosystem

Transparent reporting is not just about sharing dataâ€”it's about building trust, enabling optimization, and creating long-term partnerships that benefit everyone involved. The investment in transparency pays dividends through stronger relationships, better performance, and sustainable business growth.
    `,
    author: 'Jennifer Liu',
    date: 'December 20, 2024',
    readTime: '6 min read',
    category: 'Best Practices',
    slug: 'transparent-reporting-trust',
  },
  {
    id: 6,
    title: 'Mobile Optimization for Call Campaigns',
    excerpt:
      'Essential strategies for optimizing your pay-per-call campaigns for mobile users and voice search.',
    content: `
# Mobile Optimization for Call Campaigns

With over 60% of searches now happening on mobile devices, optimizing your pay-per-call campaigns for mobile users is no longer optionalâ€”it's essential. Mobile users have different behaviors and expectations that require specific optimization strategies.

## Mobile User Behavior Patterns

### Key Differences from Desktop Users
- **Higher intent**: Mobile users are often ready to take immediate action
- **Location-aware**: Frequently searching for local services "near me"
- **Time-sensitive**: Often need immediate solutions
- **Call-friendly**: More likely to make phone calls than fill forms

### Mobile Search Context
Understanding when and why people search on mobile:
- **Urgent needs**: Emergency services, immediate problems
- **Location-based**: Finding nearby businesses and services
- **Voice searches**: "Call the nearest plumber"
- **On-the-go**: Quick decisions while mobile

## Mobile Landing Page Optimization

### Design Principles
Create mobile-first landing pages:
- **Clean, simple design** with minimal distractions
- **Large, prominent phone numbers** that are easy to tap
- **Fast loading times** (under 3 seconds)
- **Thumb-friendly navigation** and buttons

### Essential Elements
Every mobile landing page should include:
- **Click-to-call buttons** prominently displayed
- **Local business information** (address, hours)
- **Trust signals** (reviews, certifications)
- **Clear value proposition** above the fold

### Technical Optimization
Ensure technical excellence:
- **Responsive design** that works on all screen sizes
- **Fast server response** times
- **Optimized images** and compressed files
- **AMP (Accelerated Mobile Pages)** for lightning speed

## Voice Search Optimization

### Growing Importance
Voice search is rapidly expanding:
- **55% of teens** use voice search daily
- **40% of adults** use voice search at least once per day
- **Voice commerce** expected to reach $40 billion by 2025
- **Local searches** dominate voice queries

### Optimization Strategies
Prepare for voice search:
- **Natural language keywords**: "Where can I find..."
- **Question-based content**: Answer common questions
- **Local SEO focus**: "Near me" and location-specific terms
- **Featured snippet optimization**: Target position zero

### Schema Markup
Implement structured data:
- **Local business schema** for location information
- **Service schema** for specific offerings
- **Review schema** for ratings and testimonials
- **Phone number markup** for easy calling

## Call Button Optimization

### Design Best Practices
Make calling effortless:
- **Large call buttons** (minimum 44px touch target)
- **Contrasting colors** that stand out
- **Clear call-to-action text**: "Call Now" or "Tap to Call"
- **Strategic placement** above the fold and throughout page

### Technical Implementation
Ensure proper functionality:
- **Tel: links** for one-tap calling
- **Testing across devices** and browsers
- **Click tracking** for optimization
- **Fallback options** for edge cases

### A/B Testing Elements
Test different button variations:
- **Button size** and placement
- **Color combinations** and contrast
- **Text variations** and urgency indicators
- **Number of buttons** per page

## Mobile-Specific Keywords

### Intent-Based Keywords
Target mobile search patterns:
- **"Near me" keywords**: "plumber near me"
- **Urgent modifiers**: "emergency," "24/7," "immediate"
- **Action words**: "call," "contact," "hire"
- **Local qualifiers**: City, neighborhood, landmark names

### Long-Tail Mobile Keywords
Mobile users often use longer, more specific searches:
- **"Best emergency plumber in [city] open now"**
- **"Call roofing contractor for leak repair"**
- **"24 hour locksmith service near [location]"**
- **"Immediate towing service highway 101"**

## Local SEO for Mobile

### Google My Business Optimization
Essential for mobile visibility:
- **Complete profile** with all information
- **Regular updates** and posts
- **Customer reviews** and responses
- **Local photos** and virtual tours

### Location-Based Targeting
Optimize for local searches:
- **City and neighborhood pages** for each service area
- **Local landing pages** with unique content
- **Geographic keyword targeting** in ads
- **Location extensions** in search ads

## Mobile Analytics and Tracking

### Key Mobile Metrics
Track mobile-specific performance:
- **Mobile conversion rates** vs. desktop
- **Page load speed** on mobile devices
- **Call-through rates** from mobile ads
- **Local search visibility** and rankings

### Call Tracking Implementation
Set up comprehensive mobile call tracking:
- **Dynamic number insertion** for different sources
- **Mobile-specific tracking numbers**
- **Call recording** for quality analysis
- **Attribution reporting** for optimization

## Common Mobile Optimization Mistakes

### Technical Issues
Avoid these common problems:
- **Slow loading pages** that frustrate users
- **Non-responsive design** that doesn't scale
- **Small text** that's hard to read
- **Difficult navigation** with tiny menu items

### User Experience Problems
Don't make these UX mistakes:
- **Hidden phone numbers** or small call buttons
- **Pop-ups** that interfere with mobile browsing
- **Form-heavy pages** when calls are preferred
- **Irrelevant content** that doesn't match search intent

## Mobile Ad Campaign Strategies

### Google Ads Mobile Optimization
Optimize your Google Ads for mobile:
- **Call-only campaigns** for maximum call volume
- **Mobile bid adjustments** to prioritize mobile traffic
- **Call extensions** on all relevant ads
- **Location targeting** for local service areas

### Social Media Advertising
Leverage social platforms for mobile calls:
- **Facebook click-to-call ads** with local targeting
- **Instagram stories** with call-to-action stickers
- **LinkedIn sponsored content** for B2B services
- **TikTok ads** for younger demographics

## Future of Mobile Call Marketing

### Emerging Technologies
Stay ahead of mobile trends:
- **5G networks** enabling richer experiences
- **AR/VR integration** for virtual consultations
- **AI chatbots** that can transfer to calls
- **Progressive Web Apps** for app-like experiences

### Voice Technology Evolution
Prepare for voice technology advances:
- **Smart speaker integration** for voice calls
- **Voice assistant optimization** for service discovery
- **Conversational AI** for initial qualification
- **Voice-to-text** for improved accessibility

## Implementation Checklist

### Immediate Actions (Week 1)
- [ ] **Audit current mobile experience** across all devices
- [ ] **Implement click-to-call buttons** on all key pages
- [ ] **Test page load speeds** and optimize if needed
- [ ] **Set up mobile call tracking** for campaigns

### Short-term Improvements (Month 1)
- [ ] **Optimize landing pages** for mobile conversion
- [ ] **Implement schema markup** for local search
- [ ] **Set up mobile-specific campaigns** in Google Ads
- [ ] **Create mobile keyword lists** with local intent

### Long-term Strategy (Quarter 1)
- [ ] **Develop voice search strategy** and content
- [ ] **Build location-specific pages** for all service areas
- [ ] **Implement advanced analytics** for mobile attribution
- [ ] **Create mobile-first content** strategy

Mobile optimization is not a one-time task but an ongoing process. As mobile technology continues to evolve and user behaviors shift, your optimization strategies must adapt. The businesses that invest in mobile optimization now will have a significant competitive advantage in the increasingly mobile-first world of pay-per-call marketing.
    `,
    author: 'Alex Martinez',
    date: 'December 15, 2024',
    readTime: '7 min read',
    category: 'Mobile',
    slug: 'mobile-optimization-calls',
  },
  {
    id: 7,
    title: 'Legal Compliance in Pay-Per-Call Advertising',
    excerpt:
      'Navigate the complex legal landscape of pay-per-call marketing with this comprehensive compliance guide.',
    content: `
# Legal Compliance in Pay-Per-Call Advertising

Pay-per-call marketing operates in a complex legal environment with regulations at federal, state, and industry levels. Understanding and complying with these regulations is essential for sustainable business operations and avoiding costly penalties.

## Federal Regulations

### Telephone Consumer Protection Act (TCPA)
The TCPA is the primary federal law governing telephone marketing:

**Key Provisions:**
- **Written consent required** for autodialed or prerecorded calls to cell phones
- **Do Not Call Registry** compliance mandatory
- **Time restrictions**: No calls before 8 AM or after 9 PM
- **Identification requirements**: Must identify caller and purpose

**Penalties:**
- **$500-$1,500 per violation**
- **Treble damages** for willful violations
- **Class action lawsuits** possible

### CAN-SPAM Act
Applies to email marketing that drives calls:
- **Accurate header information** required
- **Clear sender identification**
- **Truthful subject lines**
- **Unsubscribe mechanisms** must be provided

### FTC Act Section 5
Prohibits unfair or deceptive practices:
- **Truthful advertising** requirements
- **Material disclosures** must be clear and prominent
- **Substantiation** required for all claims
- **Consumer privacy** protections

## State-Level Regulations

### State Do Not Call Lists
Many states maintain their own lists:
- **Registration requirements** vary by state
- **Additional restrictions** beyond federal rules
- **Separate penalties** and enforcement
- **Regular updates** required

### State Privacy Laws
Growing state privacy regulations:
- **California Consumer Privacy Act (CCPA)**
- **Virginia Consumer Data Protection Act**
- **Colorado Privacy Act**
- **Other emerging state laws**

### Professional Licensing Requirements
Industry-specific regulations:
- **Legal services**: Bar association rules
- **Insurance**: State insurance commission regulations
- **Healthcare**: HIPAA and state medical board rules
- **Financial services**: State and federal banking regulations

## Industry-Specific Compliance

### Insurance Marketing
Special requirements for insurance leads:
- **State licensing** for lead generators
- **TCPA compliance** for call transfers
- **Data security** requirements
- **Consumer disclosure** obligations

### Healthcare Marketing
HIPAA and healthcare-specific rules:
- **Patient privacy** protections
- **Consent requirements** for marketing
- **Security safeguards** for health information
- **State medical board** regulations

### Financial Services
Banking and lending compliance:
- **Fair Credit Reporting Act (FCRA)**
- **Equal Credit Opportunity Act (ECOA)**
- **Truth in Lending Act (TILA)**
- **State licensing** requirements

### Legal Services
Attorney advertising regulations:
- **State bar association** rules
- **Solicitation restrictions**
- **Disclosure requirements**
- **Client confidentiality** protections

## Consent Management

### Types of Consent
Understanding different consent levels:
- **Express written consent**: Required for autodialed calls to cell phones
- **Prior express consent**: Required for all telemarketing calls
- **Implied consent**: Limited circumstances, based on business relationship
- **Opt-in consent**: Affirmative action required

### Consent Documentation
Proper consent collection:
- **Clear language** explaining what consumer agrees to
- **Separate agreement** not buried in terms
- **Timestamp and IP tracking** for digital consent
- **Record retention** for compliance proof

### Consent Revocation
Consumers can withdraw consent:
- **Any reasonable method** must be honored
- **Immediate cessation** of calls required
- **Documentation** of revocation
- **System updates** to prevent future calls

## Data Protection and Privacy

### Data Collection Practices
Responsible data handling:
- **Minimal collection**: Only gather necessary information
- **Purpose limitation**: Use data only for stated purposes
- **Consent-based**: Obtain proper permissions
- **Security measures**: Protect against breaches

### Data Sharing and Transfers
When sharing lead data:
- **Contractual protections** with partners
- **Due diligence** on data recipients
- **Chain of custody** documentation
- **Compliance verification** throughout the chain

### Data Retention Policies
Proper data lifecycle management:
- **Retention schedules** based on legal requirements
- **Secure deletion** procedures
- **Regular audits** of stored data
- **Documentation** of data handling practices

## Compliance Program Implementation

### Policy Development
Create comprehensive compliance policies:
- **Written procedures** for all processes
- **Regular updates** as laws change
- **Clear responsibilities** for all team members
- **Training materials** and documentation

### Training and Education
Ongoing team education:
- **Initial compliance training** for all employees
- **Regular updates** on law changes
- **Role-specific training** for different functions
- **Testing and certification** programs

### Monitoring and Auditing
Regular compliance verification:
- **Call monitoring** for quality and compliance
- **Data audits** to verify proper handling
- **Partner audits** to ensure chain compliance
- **Regular legal reviews** of practices

### Record Keeping
Comprehensive documentation:
- **Consent records** with full audit trail
- **Call recordings** and logs
- **Training records** and certifications
- **Incident reports** and remediation actions

## Common Compliance Violations

### TCPA Violations
Frequent TCPA compliance issues:
- **Calling without consent** or after revocation
- **Autodialing cell phones** without written consent
- **Calling outside allowed hours**
- **Failure to maintain Do Not Call** list

### Misleading Marketing
FTC Act violations:
- **False or misleading claims** in advertisements
- **Failure to disclose** material terms
- **Deceptive pricing** or fee structures
- **Unsubstantiated performance** claims

### Privacy Violations
Data protection failures:
- **Unauthorized data sharing** without consent
- **Inadequate security measures**
- **Failure to honor privacy rights**
- **Non-compliance with state privacy laws**

## Risk Mitigation Strategies

### Legal Review Process
Regular legal oversight:
- **Quarterly compliance reviews** with legal counsel
- **Contract review** for all partnerships
- **Marketing material review** before launch
- **Incident response planning**

### Insurance and Bonding
Financial protection:
- **Errors and omissions insurance**
- **General liability coverage**
- **Cyber liability insurance**
- **Surety bonds** where required

### Vendor Management
Partner compliance verification:
- **Due diligence** on all partners
- **Contractual compliance requirements**
- **Regular audits** of partner practices
- **Performance monitoring** and reporting

## Technology Solutions

### Compliance Management Platforms
Automated compliance tools:
- **Consent management systems**
- **Do Not Call scrubbing** services
- **Call recording and monitoring** platforms
- **Data governance** tools

### Legal Technology
Specialized legal compliance tools:
- **Contract management** systems
- **Regulatory tracking** services
- **Policy management** platforms
- **Training and certification** systems

## Staying Current with Regulations

### Regulatory Monitoring
Keep up with changing laws:
- **Legal newsletters** and publications
- **Industry associations** and conferences
- **Government websites** and alerts
- **Legal counsel updates**

### Industry Best Practices
Learn from industry leaders:
- **Trade association guidelines**
- **Peer networking** and knowledge sharing
- **Compliance conferences** and training
- **Regulatory agency guidance**

## Enforcement and Penalties

### Federal Enforcement
Government enforcement actions:
- **FTC investigations** and consent orders
- **FCC TCPA enforcement**
- **State attorney general** actions
- **Industry-specific regulators**

### Private Litigation
Consumer and competitor lawsuits:
- **Class action lawsuits** under TCPA
- **Individual consumer complaints**
- **Competitor challenges** to practices
- **Regulatory compliance disputes**

## Building a Compliance Culture

### Leadership Commitment
Tone from the top:
- **Executive commitment** to compliance
- **Resource allocation** for compliance programs
- **Regular compliance reporting** to leadership
- **Accountability measures** for violations

### Employee Engagement
Making compliance everyone's responsibility:
- **Clear expectations** for all employees
- **Regular communication** about compliance
- **Incentive alignment** with compliance goals
- **Whistleblower protections** for reporting issues

Legal compliance in pay-per-call marketing is complex but essential. The key is to build comprehensive compliance programs, stay current with regulations, and work with experienced legal counsel. While compliance requires investment, the cost of non-complianceâ€”in penalties, litigation, and reputation damageâ€”is far greater.

Remember that laws and regulations change frequently. This guide provides general information but should not substitute for specific legal advice from qualified counsel familiar with your business and current regulations.
    `,
    author: 'Robert Kim',
    date: 'December 10, 2024',
    readTime: '9 min read',
    category: 'Legal',
    slug: 'legal-compliance-guide',
  },
  {
    id: 8,
    title: 'Seasonal Campaign Planning Strategies',
    excerpt:
      'How to plan and execute successful pay-per-call campaigns during peak seasonal periods.',
    content: `
# Seasonal Campaign Planning Strategies

Seasonal fluctuations can dramatically impact pay-per-call campaign performance. Smart marketers prepare for these changes by developing comprehensive seasonal strategies that maximize opportunities during peak periods and maintain profitability during slower times.

## Understanding Seasonal Patterns

### Industry-Specific Seasonality
Different industries have unique seasonal patterns:

**Home Services:**
- **HVAC**: Peak summer (cooling) and winter (heating)
- **Roofing**: Spring storm season, fall preparation
- **Landscaping**: Spring through fall, winter dormancy
- **Pest Control**: Spring and summer peaks

**Insurance:**
- **Auto**: New year resolution shoppers
- **Health**: Open enrollment periods
- **Home**: Hurricane season, winter storms
- **Life**: Year-end tax planning

**Legal Services:**
- **Personal Injury**: Higher after holidays, summer travel
- **Tax**: January through April peak
- **Family Law**: Post-holiday relationship stress
- **Estate Planning**: Year-end tax considerations

**Financial Services:**
- **Tax Services**: January through April
- **Financial Planning**: New year, retirement season
- **Debt Consolidation**: Post-holiday credit stress
- **Mortgage**: Spring home buying season

### Economic and Social Factors
External factors affecting call volume:
- **Economic conditions**: Recession, employment rates
- **Weather patterns**: Extreme temperatures, storms
- **Holiday schedules**: Call volume drops during holidays
- **School calendars**: Summer schedules, back-to-school

## Pre-Season Planning

### Historical Data Analysis
Review past performance to predict future trends:
- **Year-over-year comparisons** for each season
- **Monthly and weekly patterns** within seasons
- **Day-of-week variations** during peak periods
- **Hour-of-day patterns** for different seasons

### Competitive Intelligence
Monitor competitor activity:
- **Ad spend increases** during peak seasons
- **Creative message changes** for seasonal relevance
- **New competitor entries** in your market
- **Pricing adjustments** for peak demand

### Resource Planning
Prepare your team and systems:
- **Staff scheduling** for peak call volumes
- **Training updates** for seasonal campaigns
- **Technology upgrades** to handle increased traffic
- **Budget allocation** across seasonal periods

## Campaign Strategy Development

### Seasonal Messaging
Adapt your marketing messages:
- **Urgency indicators**: "Before winter hits," "Storm season prep"
- **Seasonal benefits**: "Stay cool this summer," "Holiday peace of mind"
- **Timely solutions**: "New year, new start," "Spring cleaning"
- **Weather-related triggers**: "Don't wait for the next storm"

### Keyword Strategy
Adjust keywords for seasonal search patterns:
- **Add seasonal modifiers**: "winter," "summer," "holiday"
- **Include weather terms**: "storm damage," "heat wave"
- **Target preparation keywords**: "before," "prepare," "ready"
- **Use urgency keywords**: "emergency," "immediate," "now"

### Landing Page Optimization
Create season-specific landing pages:
- **Seasonal imagery** and design elements
- **Relevant offers** and promotions
- **Time-sensitive messaging** and deadlines
- **Weather-appropriate solutions**

## Budget Management

### Seasonal Budget Allocation
Distribute budgets based on seasonal performance:
- **Peak season premium**: Allocate 40-60% during peak months
- **Shoulder season balance**: Maintain presence with reduced spend
- **Off-season minimum**: Keep brand visibility with basic campaigns
- **Emergency reserves**: Budget for unexpected opportunities

### Dynamic Bidding Strategies
Adjust bids based on seasonal demand:
- **Increased bids** during peak conversion periods
- **Dayparting adjustments** for seasonal call patterns
- **Geographic targeting** based on weather and regional seasons
- **Competitive adjustments** as market dynamics change

### ROI Optimization
Balance volume and profitability:
- **Higher CPAs acceptable** during peak demand
- **Volume targets** adjusted for seasonal reality
- **Profit margin protection** during competitive periods
- **Long-term value consideration** for customer acquisition

## Peak Season Execution

### Campaign Launch Timing
Strategic timing for maximum impact:
- **Early market entry**: Before competitors ramp up
- **Gradual scaling**: Avoid budget exhaustion too early
- **Peak period optimization**: Maximum visibility during highest demand
- **Extended seasons**: Capitalize on longer seasonal patterns

### Performance Monitoring
Intensive monitoring during peak periods:
- **Hourly performance checks** during critical periods
- **Real-time bid adjustments** based on competition
- **Quality score monitoring** as search volume increases
- **Conversion tracking** for immediate optimization

### Rapid Response Strategies
Quick adaptation to changing conditions:
- **Weather-triggered campaigns** for emergency services
- **News-responsive messaging** for relevant events
- **Competitor response tactics** for market share protection
- **Inventory-based scaling** for capacity management

## Off-Season Strategies

### Maintaining Visibility
Stay present during slower periods:
- **Brand awareness campaigns** at reduced costs
- **Content marketing** to maintain engagement
- **SEO optimization** for long-term positioning
- **Email nurturing** of existing leads

### Preparation Activities
Use off-season time for improvement:
- **Campaign optimization** and testing
- **New market research** and expansion planning
- **Technology upgrades** and system improvements
- **Team training** and skill development

### Alternative Revenue Streams
Diversify during slow periods:
- **Related service offerings** with different seasonal patterns
- **Geographic expansion** to markets with opposite seasons
- **B2B services** that may have different timing
- **Maintenance and prevention** services year-round

## Weather-Based Campaigns

### Weather Triggers
Automated responses to weather conditions:
- **Storm warnings**: Emergency service campaigns
- **Temperature extremes**: HVAC and heating services
- **Seasonal transitions**: Preparation and maintenance services
- **Weather forecasts**: Proactive service offerings

### Geographic Considerations
Regional weather impact strategies:
- **Multi-market campaigns** following weather patterns
- **Regional budget shifts** based on local conditions
- **Climate-specific messaging** for different areas
- **Seasonal migration** following weather-driven demand

## Technology and Automation

### Seasonal Campaign Automation
Automated systems for seasonal management:
- **Scheduled campaigns** that activate automatically
- **Weather-triggered ads** that respond to conditions
- **Inventory-based scaling** that adjusts to capacity
- **Performance-triggered optimization** for changing conditions

### Predictive Analytics
Use data to predict seasonal patterns:
- **Machine learning models** for demand forecasting
- **Historical pattern analysis** for trend prediction
- **External data integration** for weather and economic factors
- **Scenario planning** for different seasonal outcomes

## Multi-Channel Coordination

### Integrated Seasonal Campaigns
Coordinate across all channels:
- **Search campaigns** aligned with seasonal keywords
- **Social media** reflecting seasonal themes
- **Email marketing** with seasonal messaging
- **Traditional advertising** coordinated with digital efforts

### Cross-Channel Attribution
Track seasonal performance across channels:
- **Multi-touch attribution** for seasonal journeys
- **Channel interaction analysis** during peak periods
- **Cross-channel optimization** for maximum efficiency
- **Holistic performance measurement** across all touchpoints

## Performance Analysis and Optimization

### Seasonal KPIs
Track season-specific metrics:
- **Seasonal conversion rates** compared to baseline
- **Cost per acquisition** during different periods
- **Market share** during competitive seasons
- **Customer lifetime value** by acquisition season

### Post-Season Analysis
Learn from each seasonal campaign:
- **Performance retrospectives** after each season
- **Competitive analysis** of market changes
- **Customer feedback** about seasonal experiences
- **Strategy refinement** for future seasons

## Common Seasonal Mistakes

### Timing Errors
Avoid these common timing mistakes:
- **Starting too late**: Missing early seasonal demand
- **Ending too early**: Abandoning extended seasonal periods
- **Poor weather response**: Not adapting to unexpected conditions
- **Holiday neglect**: Failing to adjust for holiday schedules

### Budget Mismanagement
Don't make these budget errors:
- **Under-budgeting peak seasons**: Missing growth opportunities
- **Over-spending early**: Exhausting budgets before peak demand
- **Ignoring shoulder seasons**: Missing cost-effective opportunities
- **Poor contingency planning**: No budget for unexpected situations

### Message Misalignment
Avoid messaging problems:
- **Generic messaging**: Not adapting to seasonal needs
- **Inappropriate timing**: Wrong seasonal references
- **Competitor copying**: Lack of unique seasonal positioning
- **Cultural insensitivity**: Ignoring diverse seasonal celebrations

## Future-Proofing Seasonal Strategies

### Climate Change Impact
Adapt to changing seasonal patterns:
- **Extended seasons**: Longer peak periods in some industries
- **Weather unpredictability**: More flexible response strategies
- **New seasonal patterns**: Emerging demand cycles
- **Geographic shifts**: Changing regional seasonal differences

### Technology Evolution
Leverage advancing technology:
- **AI-powered optimization** for seasonal campaigns
- **Real-time weather integration** for trigger campaigns
- **Predictive modeling** for demand forecasting
- **Automated creative optimization** for seasonal relevance

Successful seasonal campaign planning requires a combination of historical analysis, strategic thinking, and operational excellence. The businesses that invest time in understanding their seasonal patterns and preparing comprehensive strategies will consistently outperform competitors who take a reactive approach to seasonal changes.

Remember that seasonal patterns can evolve, so continuous monitoring and adaptation are essential for long-term success in seasonal pay-per-call marketing.
    `,
    author: 'Maria Garcia',
    date: 'December 5, 2024',
    readTime: '8 min read',
    category: 'Strategy',
    slug: 'seasonal-campaign-planning',
  },
  {
    id: 9,
    title: 'Advanced Call Tracking Technologies',
    excerpt:
      'Explore the latest technologies in call tracking and how they can improve your campaign performance.',
    content: `
# Advanced Call Tracking Technologies

Call tracking technology has evolved dramatically, offering sophisticated capabilities that go far beyond simple call counting. Modern call tracking systems provide deep insights into customer behavior, campaign performance, and conversion optimization opportunities.

## Evolution of Call Tracking

### Traditional Call Tracking
Early call tracking systems provided basic functionality:
- **Static phone numbers** for different campaigns
- **Simple call counting** and duration tracking
- **Basic reporting** on call volume
- **Manual call review** for quality assessment

### Modern Call Tracking
Today's systems offer advanced capabilities:
- **Dynamic number insertion** for precise attribution
- **Real-time analytics** and reporting
- **AI-powered insights** and optimization
- **Automated quality scoring** and fraud detection

### Next-Generation Features
Emerging technologies pushing boundaries:
- **Voice recognition** and sentiment analysis
- **Predictive analytics** for lead scoring
- **Machine learning** optimization
- **Integration ecosystems** with marketing platforms

## Dynamic Number Insertion (DNI)

### How DNI Works
Sophisticated visitor tracking and number assignment:
- **Cookie-based tracking** for returning visitors
- **UTM parameter integration** for campaign attribution
- **Geographic targeting** with local numbers
- **Real-time number pooling** for scalability

### Advanced DNI Features
Modern DNI capabilities:
- **Cross-device tracking** for omnichannel attribution
- **Session-based attribution** for accurate reporting
- **Visitor journey mapping** across multiple touchpoints
- **First-party data integration** for personalization

### Implementation Best Practices
Optimize DNI for maximum effectiveness:
- **Sufficient number pools** to avoid conflicts
- **Local number provisioning** for trust building
- **Fallback number strategies** for edge cases
- **Regular number rotation** for optimal performance

## AI-Powered Call Analytics

### Speech Recognition Technology
Advanced voice-to-text capabilities:
- **Real-time transcription** with high accuracy
- **Multiple language support** for diverse markets
- **Accent and dialect recognition** for clear understanding
- **Background noise filtering** for better quality

### Natural Language Processing
Understanding conversation context:
- **Intent recognition** from conversation content
- **Sentiment analysis** throughout the call
- **Topic extraction** for content insights
- **Conversation flow analysis** for optimization

### Automated Call Scoring
AI-driven quality assessment:
- **Real-time quality scoring** during calls
- **Custom scoring criteria** based on business goals
- **Automated lead qualification** and routing
- **Performance benchmarking** against historical data

## Predictive Analytics and Machine Learning

### Lead Scoring Models
Predict call quality before they happen:
- **Historical data analysis** for pattern recognition
- **Real-time scoring** based on visitor behavior
- **Multi-factor models** considering various signals
- **Continuous learning** and model improvement

### Conversion Prediction
Forecast call outcomes:
- **Probability scoring** for conversion likelihood
- **Revenue prediction** based on call characteristics
- **Optimal timing** recommendations for callbacks
- **Channel optimization** for best conversion rates

### Fraud Detection
Advanced fraud prevention:
- **Pattern recognition** for suspicious activity
- **Real-time fraud scoring** for immediate action
- **Behavioral analysis** for bot detection
- **Network analysis** for organized fraud rings

## Integration Capabilities

### CRM Integration
Seamless data flow to customer systems:
- **Automatic lead creation** from qualified calls
- **Call recording attachments** to lead records
- **Real-time data synchronization** across platforms
- **Custom field mapping** for specific business needs

### Marketing Platform Integration
Connect with existing marketing technology:
- **Google Ads integration** for offline conversion tracking
- **Facebook Ads integration** for attribution
- **Marketing automation platforms** for lead nurturing
- **Analytics platforms** for comprehensive reporting

### Business Intelligence Tools
Advanced reporting and analysis:
- **Data warehouse integration** for historical analysis
- **Custom dashboard creation** for stakeholder reporting
- **API access** for custom applications
- **Real-time data streaming** for immediate insights

## Real-Time Optimization

### Dynamic Campaign Adjustment
Automated optimization based on call performance:
- **Bid adjustments** based on call quality
- **Budget reallocation** to high-performing sources
- **Keyword optimization** based on call outcomes
- **Creative testing** driven by call feedback

### Call Routing Optimization
Intelligent call distribution:
- **Skills-based routing** to best-qualified agents
- **Geographic routing** for local expertise
- **Performance-based routing** to top converters
- **Load balancing** for optimal wait times

### Real-Time Alerts
Immediate notifications for important events:
- **Performance threshold alerts** for campaign changes
- **Quality score notifications** for immediate action
- **Fraud alerts** for suspicious activity
- **System status updates** for technical issues

## Advanced Attribution Models

### Multi-Touch Attribution
Understanding complex customer journeys:
- **First-touch attribution** for awareness measurement
- **Last-touch attribution** for direct response
- **Linear attribution** for equal credit distribution
- **Time-decay attribution** for recency weighting

### Cross-Device Attribution
Tracking customers across devices:
- **Deterministic matching** using login data
- **Probabilistic matching** using behavioral signals
- **Cross-device journey mapping** for complete picture
- **Device-specific optimization** strategies

### Offline Attribution
Connecting online activity to offline calls:
- **View-through attribution** for display advertising
- **Assisted conversion tracking** for research behavior
- **Brand search attribution** for awareness campaigns
- **Social media attribution** for engagement campaigns

## Privacy and Compliance Technology

### Data Protection Features
Built-in privacy compliance:
- **PII redaction** for sensitive information
- **Consent management** integration
- **Data retention policies** automated enforcement
- **Regional compliance** for different jurisdictions

### TCPA Compliance Tools
Automated compliance management:
- **Do Not Call scrubbing** with real-time updates
- **Consent verification** and documentation
- **Time zone enforcement** for calling hours
- **Opt-out management** and processing

### Security Features
Enterprise-grade security:
- **End-to-end encryption** for call data
- **Role-based access controls** for user management
- **Audit trails** for compliance verification
- **Secure API endpoints** for integrations

## Emerging Technologies

### Voice Biometrics
Advanced caller identification:
- **Voiceprint recognition** for repeat caller identification
- **Fraud prevention** through voice analysis
- **Personalization** based on caller history
- **Security enhancement** for sensitive calls

### Conversational AI
AI-powered call assistance:
- **Real-time coaching** for agents during calls
- **Automated responses** for common questions
- **Call summarization** for follow-up actions
- **Intent prediction** for better routing

### Blockchain Technology
Immutable call records:
- **Tamper-proof call logs** for compliance
- **Smart contracts** for automated payments
- **Decentralized verification** for trust building
- **Transparent reporting** for all stakeholders

## Implementation Strategy

### Technology Assessment
Evaluate current and future needs:
- **Current system audit** for capability gaps
- **Business requirement analysis** for feature needs
- **Scalability planning** for future growth
- **Integration requirements** with existing systems

### Vendor Selection
Choose the right technology partner:
- **Feature comparison** across platforms
- **Scalability and reliability** assessment
- **Support and training** capabilities
- **Pricing and contract** terms evaluation

### Deployment Planning
Systematic implementation approach:
- **Phased rollout** for risk management
- **Testing protocols** for quality assurance
- **Training programs** for user adoption
- **Performance monitoring** for optimization

## ROI Measurement

### Technology Investment Analysis
Measure the value of advanced call tracking:
- **Cost savings** from automation and efficiency
- **Revenue increases** from better optimization
- **Risk reduction** from compliance and fraud protection
- **Competitive advantage** from superior insights

### Performance Benchmarking
Compare advanced vs. basic tracking:
- **Attribution accuracy** improvements
- **Optimization speed** and effectiveness
- **Lead quality** and conversion rates
- **Overall campaign performance** enhancement

## Future Outlook

### Technology Trends
Emerging developments in call tracking:
- **5G networks** enabling richer data collection
- **Edge computing** for real-time processing
- **Quantum computing** for complex analysis
- **Augmented reality** for enhanced reporting

### Industry Evolution
Changes shaping the call tracking landscape:
- **Privacy regulations** driving feature development
- **AI advancement** improving accuracy and insights
- **Integration ecosystems** becoming more sophisticated
- **Real-time requirements** increasing across industries

## Best Practices for Advanced Implementation

### Strategic Planning
Long-term technology strategy:
- **Business alignment** with technology capabilities
- **Stakeholder engagement** throughout implementation
- **Change management** for user adoption
- **Continuous optimization** and improvement

### Data Quality Management
Ensure accurate and actionable data:
- **Data validation** processes and protocols
- **Regular audits** for accuracy verification
- **Cleaning procedures** for data hygiene
- **Quality metrics** and monitoring

### Performance Optimization
Maximize technology value:
- **Regular tuning** of AI models and algorithms
- **A/B testing** of different configurations
- **Performance monitoring** and alerting
- **Continuous learning** and adaptation

Advanced call tracking technologies offer unprecedented opportunities for campaign optimization and business growth. The key is selecting the right technologies for your specific needs and implementing them strategically to maximize ROI.

As these technologies continue to evolve, staying informed about emerging capabilities and maintaining a forward-looking technology strategy will be essential for competitive advantage in the pay-per-call marketing landscape.
    `,
    author: 'Thomas Chen',
    date: 'November 28, 2024',
    readTime: '10 min read',
    category: 'Technology',
    slug: 'advanced-call-tracking',
  },
  {
    id: 10,
    title: 'ROI Optimization Techniques',
    excerpt:
      'Proven techniques for maximizing return on investment in your pay-per-call marketing campaigns.',
    content: `
# ROI Optimization Techniques

Maximizing return on investment (ROI) is the ultimate goal of any pay-per-call marketing campaign. This comprehensive guide covers proven techniques for optimizing every aspect of your campaigns to achieve maximum profitability and sustainable growth.

## Understanding ROI in Pay-Per-Call Marketing

### ROI Calculation Fundamentals
Basic ROI formula and variations:
- **Simple ROI**: (Revenue - Cost) / Cost Ã— 100
- **Customer Lifetime Value ROI**: (CLV - CAC) / CAC Ã— 100
- **Return on Ad Spend (ROAS)**: Revenue / Ad Spend
- **Profit ROI**: (Profit - Investment) / Investment Ã— 100

### Key Performance Indicators
Essential metrics for ROI optimization:
- **Cost Per Acquisition (CPA)**: Total cost to acquire one customer
- **Customer Lifetime Value (CLV)**: Total revenue from a customer relationship
- **Conversion Rate**: Percentage of calls that result in sales
- **Average Order Value (AOV)**: Average revenue per converted call

### ROI Benchmarking
Industry standards and expectations:
- **Minimum acceptable ROI**: Typically 300-500% for sustainable growth
- **Industry averages**: Vary by vertical and competition level
- **Seasonal fluctuations**: Account for natural ROI variations
- **Channel comparisons**: Different sources may have different ROI profiles

## Campaign-Level Optimization

### Source Performance Analysis
Evaluate traffic sources for ROI efficiency:
- **Google Ads performance**: Keywords, ad groups, and campaigns
- **Social media ROI**: Platform-specific performance analysis
- **Partner network evaluation**: Publisher and affiliate performance
- **Organic traffic value**: SEO contribution to overall ROI

### Budget Allocation Strategies
Optimize spend distribution:
- **Performance-based budgeting**: Allocate more to high-ROI sources
- **Diversification balance**: Maintain multiple sources for stability
- **Testing budgets**: Reserve funds for new opportunity exploration
- **Seasonal adjustments**: Shift budgets based on seasonal performance

### Bid Management Optimization
Strategic bidding for maximum efficiency:
- **Automated bidding strategies**: Leverage platform AI for optimization
- **Dayparting optimization**: Adjust bids for time-of-day performance
- **Geographic bid adjustments**: Optimize for location-based ROI
- **Device targeting**: Mobile vs. desktop performance optimization

## Call Quality Optimization

### Lead Qualification Improvement
Enhance call quality for better ROI:
- **Pre-call qualification**: Use forms or IVR to screen callers
- **Landing page optimization**: Better pre-qualification content
- **Call-to-action refinement**: Clearer expectations for callers
- **Targeting improvements**: More precise audience selection

### Call Handling Excellence
Optimize the call experience:
- **Agent training programs**: Improve conversion skills
- **Script optimization**: Test different approaches systematically
- **Call routing efficiency**: Get calls to the right agents quickly
- **Follow-up processes**: Maximize conversion from initial calls

### Conversion Rate Optimization
Systematic testing for improvement:
- **A/B testing protocols**: Test one variable at a time
- **Landing page optimization**: Continuous improvement testing
- **Offer testing**: Different incentives and value propositions
- **Timing optimization**: Best times to contact prospects

## Cost Reduction Strategies

### Fraud Prevention
Protect ROI through fraud reduction:
- **Real-time fraud detection**: Automated filtering systems
- **Call quality monitoring**: Regular audits of call quality
- **Source verification**: Vet new traffic sources thoroughly
- **Pattern analysis**: Identify and block suspicious activity

### Operational Efficiency
Reduce costs through better operations:
- **Automation implementation**: Reduce manual work and errors
- **Process optimization**: Streamline workflows for efficiency
- **Technology integration**: Eliminate duplicate systems and processes
- **Performance monitoring**: Quick identification and resolution of issues

### Vendor Negotiation
Optimize costs with suppliers:
- **Volume-based pricing**: Negotiate better rates for higher volumes
- **Performance incentives**: Align vendor compensation with results
- **Contract optimization**: Regular review and renegotiation
- **Alternative sourcing**: Competitive bidding for services

## Revenue Maximization

### Upselling and Cross-selling
Increase revenue per customer:
- **Product bundling**: Offer complementary services
- **Premium service tiers**: Higher-value service options
- **Extended service contracts**: Longer-term commitments
- **Referral programs**: Leverage satisfied customers for growth

### Customer Lifetime Value Enhancement
Focus on long-term value:
- **Retention programs**: Keep customers longer
- **Service quality excellence**: Exceed expectations consistently
- **Regular communication**: Stay connected with customers
- **Value-added services**: Additional services that enhance relationships

### Pricing Optimization
Strategic pricing for maximum profitability:
- **Value-based pricing**: Price based on customer value received
- **Dynamic pricing**: Adjust pricing based on demand and seasonality
- **Competitive analysis**: Monitor and respond to market pricing
- **A/B testing**: Test different pricing strategies systematically

## Advanced Analytics and Attribution

### Multi-Touch Attribution
Understand the complete customer journey:
- **First-touch attribution**: Credit awareness-building activities
- **Last-touch attribution**: Credit final conversion drivers
- **Multi-touch modeling**: Distribute credit across touchpoints
- **Custom attribution**: Create models specific to your business

### Predictive Analytics
Use data to predict and optimize ROI:
- **Lead scoring models**: Predict which calls will convert
- **Lifetime value prediction**: Identify high-value prospects
- **Churn prediction**: Identify at-risk customers early
- **Seasonal forecasting**: Predict and prepare for seasonal changes

### Advanced Segmentation
Optimize for different customer segments:
- **Demographic segmentation**: Different approaches for different groups
- **Behavioral segmentation**: Based on past actions and preferences
- **Geographic segmentation**: Location-specific optimization
- **Psychographic segmentation**: Values and lifestyle-based targeting

## Technology and Automation

### Marketing Automation
Automate for efficiency and consistency:
- **Lead nurturing sequences**: Automated follow-up campaigns
- **Behavioral triggers**: Respond to specific customer actions
- **Personalization at scale**: Customized messages for different segments
- **Performance optimization**: Automated bid and budget adjustments

### AI and Machine Learning
Leverage artificial intelligence:
- **Predictive bidding**: AI-driven bid optimization
- **Creative optimization**: Automated testing of ad variations
- **Audience optimization**: AI-powered targeting improvements
- **Anomaly detection**: Automatic identification of performance issues

### Integration Optimization
Connect systems for better ROI:
- **CRM integration**: Seamless data flow for better insights
- **Analytics integration**: Comprehensive performance tracking
- **Marketing platform integration**: Unified campaign management
- **Business intelligence**: Advanced reporting and analysis

## Testing and Experimentation

### Systematic Testing Framework
Structured approach to optimization:
- **Hypothesis development**: Clear predictions about improvements
- **Test design**: Proper statistical methodology
- **Result analysis**: Statistical significance and practical impact
- **Implementation**: Roll out winning variations systematically

### Creative Testing
Optimize marketing creative:
- **Ad copy variations**: Headlines, descriptions, and calls-to-action
- **Visual elements**: Images, colors, and design layouts
- **Landing page elements**: Headlines, forms, and content
- **Video content**: Different approaches and messaging

### Channel Testing
Explore new opportunities:
- **New traffic sources**: Test emerging platforms and channels
- **Alternative approaches**: Different campaign types and strategies
- **Market expansion**: Test new geographic or demographic markets
- **Partnership opportunities**: Test new affiliate or partnership models

## Performance Monitoring and Optimization

### Real-Time Monitoring
Continuous performance oversight:
- **Dashboard development**: Key metrics visible at all times
- **Alert systems**: Immediate notification of performance changes
- **Automated responses**: Predefined actions for common issues
- **Performance reviews**: Regular analysis and optimization sessions

### Reporting and Analysis
Comprehensive performance measurement:
- **ROI reporting**: Regular analysis of return on investment
- **Trend analysis**: Identify patterns and opportunities
- **Competitive analysis**: Monitor market changes and respond
- **Strategic planning**: Use data to inform future strategies

### Continuous Optimization
Ongoing improvement processes:
- **Regular audits**: Systematic review of all campaign elements
- **Performance benchmarking**: Compare against industry standards
- **Best practice implementation**: Apply proven optimization techniques
- **Innovation testing**: Experiment with new approaches and technologies

## Common ROI Optimization Mistakes

### Short-Term Thinking
Avoid these common pitfalls:
- **Premature optimization**: Making changes too quickly
- **Ignoring lifetime value**: Focus only on immediate returns
- **Under-investing in testing**: Not allocating sufficient budget for experiments
- **Chasing vanity metrics**: Optimizing for volume instead of profitability

### Data and Attribution Issues
Measurement problems that hurt optimization:
- **Attribution errors**: Incorrectly crediting conversion sources
- **Data quality issues**: Basing decisions on inaccurate information
- **Incomplete tracking**: Missing important conversion events
- **Analysis paralysis**: Over-analyzing instead of taking action

### Resource Allocation Problems
Common resource management mistakes:
- **Under-investing in winners**: Not scaling successful campaigns
- **Over-investing in losers**: Continuing poor-performing campaigns too long
- **Neglecting maintenance**: Not optimizing existing successful campaigns
- **Insufficient testing budget**: Not investing enough in optimization

## Building an ROI-Focused Organization

### Team Structure and Skills
Organize for optimization success:
- **Dedicated optimization roles**: Specialists focused on ROI improvement
- **Cross-functional collaboration**: Marketing, sales, and analytics working together
- **Continuous learning**: Ongoing education and skill development
- **Performance accountability**: Clear ROI targets and accountability

### Culture and Processes
Create an optimization-focused culture:
- **Data-driven decision making**: Decisions based on evidence
- **Experimentation mindset**: Willingness to test and learn
- **Long-term thinking**: Balance short-term and long-term optimization
- **Customer focus**: Optimization that improves customer experience

### Technology Infrastructure
Build systems that support optimization:
- **Comprehensive tracking**: Complete measurement of customer journeys
- **Integration capabilities**: Connected systems for unified insights
- **Automation tools**: Efficient execution of optimization strategies
- **Scalable platforms**: Technology that grows with your business

## Future of ROI Optimization

### Emerging Technologies
New tools and capabilities:
- **Advanced AI**: More sophisticated prediction and optimization
- **Real-time personalization**: Customized experiences at scale
- **Voice and visual search**: New channels requiring optimization
- **Privacy-focused tracking**: New approaches to measurement and attribution

### Market Evolution
Changing landscape considerations:
- **Increased competition**: Need for more sophisticated optimization
- **Privacy regulations**: Impact on tracking and optimization capabilities
- **Customer expectations**: Higher standards for experience and value
- **Technology advancement**: New opportunities and challenges

ROI optimization is not a destination but a continuous journey of improvement. The most successful pay-per-call marketers combine strategic thinking, systematic testing, advanced analytics, and operational excellence to achieve superior returns.

The key is to start with solid fundamentals, implement systematic optimization processes, and continuously evolve your approach based on data and market changes. Remember that sustainable ROI optimization requires balancing short-term performance with long-term customer value and business growth.
    `,
    author: 'Lisa Wang',
    date: 'November 20, 2024',
    readTime: '7 min read',
    category: 'Optimization',
    slug: 'roi-optimization-techniques',
  },
]
</file>

<file path="src/hooks/CLAUDE.md">
# Custom Hook Patterns

# Naming Conventions
- ALL hooks start with "use": `useAuth`, `useApi`, `useCampaign`
- Be descriptive: `useRealTimeCallTracking` vs `useRealTime`
- Group related hooks: `useAuth`, `useAuthActions`, `useAuthState`

# File Structure
```
hooks/
â”œâ”€â”€ useAuth.ts          # Authentication hooks
â”œâ”€â”€ useApi.ts           # API data fetching
â”œâ”€â”€ useLocalStorage.ts  # Browser storage
â”œâ”€â”€ useRealtime.ts      # Supabase real-time
â”œâ”€â”€ useForm.ts          # Form management
â”œâ”€â”€ useStripe.ts        # Payment processing
â”œâ”€â”€ useCampaign.ts      # Campaign management
â”œâ”€â”€ useCall.ts          # Call tracking
â””â”€â”€ index.ts            # Hook exports
```

# Basic Hook Template
```tsx
import { useState, useEffect } from 'react';

interface UseHookResult<T> {
  data: T | null;
  loading: boolean;
  error: string | null;
}

export function useHookName<T>(params: HookParams): UseHookResult<T> {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  useEffect(() => {
    // Hook logic here
  }, [/* dependencies */]);
  
  return { data, loading, error };
}
```

# API Data Fetching Hooks
```tsx
import { useQuery } from '@tanstack/react-query';
import { fetchUser } from '@/lib/api';

export function useUser(userId: string) {
  return useQuery({
    queryKey: ['user', userId],
    queryFn: () => fetchUser(userId),
    enabled: !!userId,
  });
}

// Mutation hook
export function useUpdateUser() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: updateUser,
    onSuccess: (user) => {
      queryClient.setQueryData(['user', user.id], user);
      queryClient.invalidateQueries({ queryKey: ['users'] });
    },
  });
}
```

# Authentication Hooks
```tsx
export function useAuth() {
  const user = useAuthStore(state => state.user);
  const isAuthenticated = useAuthStore(state => state.isAuthenticated);
  const login = useAuthStore(state => state.login);
  const logout = useAuthStore(state => state.logout);
  
  return {
    user,
    isAuthenticated,
    login,
    logout,
    isSupplier: user?.role === 'supplier',
    isBuyer: user?.role === 'buyer',
    isAdmin: user?.role === 'admin',
  };
}
```

# Real-time Data Hooks
```tsx
export function useRealTimeCall(callId: string) {
  const [call, setCall] = useState<Call | null>(null);
  
  useEffect(() => {
    if (!callId) return;
    
    const channel = supabase
      .channel(`call-${callId}`)
      .on('postgres_changes', {
        event: 'UPDATE',
        schema: 'public',
        table: 'calls',
        filter: `id=eq.${callId}`,
      }, (payload) => {
        setCall(payload.new as Call);
      })
      .subscribe();
    
    return () => {
      supabase.removeChannel(channel);
    };
  }, [callId]);
  
  return call;
}
```

# Form Hooks
```tsx
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { loginSchema, type LoginFormData } from '@/types/auth';

export function useLoginForm() {
  const { login } = useAuth();
  
  const form = useForm<LoginFormData>({
    resolver: zodResolver(loginSchema),
    defaultValues: {
      email: '',
      password: '',
    },
  });
  
  const onSubmit = async (data: LoginFormData) => {
    try {
      await login(data.email, data.password);
    } catch (error) {
      form.setError('root', {
        message: handleApiError(error),
      });
    }
  };
  
  return {
    ...form,
    onSubmit: form.handleSubmit(onSubmit),
  };
}
```

# Local Storage Hooks
```tsx
export function useLocalStorage<T>(
  key: string,
  initialValue: T
): [T, (value: T | ((prev: T) => T)) => void] {
  const [storedValue, setStoredValue] = useState<T>(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(`Error reading localStorage key "${key}":`, error);
      return initialValue;
    }
  });
  
  const setValue = (value: T | ((prev: T) => T)) => {
    try {
      const valueToStore = value instanceof Function 
        ? value(storedValue) 
        : value;
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(`Error setting localStorage key "${key}":`, error);
    }
  };
  
  return [storedValue, setValue];
}
```

# Performance Optimization Hooks
```tsx
import { useMemo, useCallback } from 'react';

export function useOptimizedData<T>(
  data: T[],
  filterFn: (item: T) => boolean,
  sortFn: (a: T, b: T) => number
) {
  const filteredAndSorted = useMemo(() => {
    return data.filter(filterFn).sort(sortFn);
  }, [data, filterFn, sortFn]);
  
  return filteredAndSorted;
}

// Debounced value hook
export function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState(value);
  
  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);
    
    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);
  
  return debouncedValue;
}
```

# DCE-Specific Hooks

## Campaign Management
```tsx
export function useCampaignStats(campaignId: string) {
  return useQuery({
    queryKey: ['campaign-stats', campaignId],
    queryFn: () => fetchCampaignStats(campaignId),
    refetchInterval: 30000, // Refresh every 30 seconds
  });
}
```

## Call Tracking
```tsx
export function useActiveCallCount() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    const channel = supabase
      .channel('active-calls')
      .on('postgres_changes', {
        event: '*',
        schema: 'public',
        table: 'calls',
        filter: 'status=eq.active',
      }, () => {
        // Refetch active call count
        fetchActiveCallCount().then(setCount);
      })
      .subscribe();
    
    return () => supabase.removeChannel(channel);
  }, []);
  
  return count;
}
```

# Error Handling in Hooks
```tsx
export function useApiWithErrorHandling<T>(
  fetcher: () => Promise<T>
) {
  const [state, setState] = useState<{
    data: T | null;
    loading: boolean;
    error: string | null;
  }>({
    data: null,
    loading: false,
    error: null,
  });
  
  const execute = useCallback(async () => {
    setState(prev => ({ ...prev, loading: true, error: null }));
    
    try {
      const data = await fetcher();
      setState({ data, loading: false, error: null });
    } catch (error) {
      setState(prev => ({
        ...prev,
        loading: false,
        error: handleApiError(error),
      }));
    }
  }, [fetcher]);
  
  return { ...state, execute };
}
```

# Testing Custom Hooks
```tsx
import { renderHook, act } from '@testing-library/react';
import { useLocalStorage } from './useLocalStorage';

describe('useLocalStorage', () => {
  beforeEach(() => {
    localStorage.clear();
  });
  
  it('should return initial value', () => {
    const { result } = renderHook(() => 
      useLocalStorage('test-key', 'initial')
    );
    
    expect(result.current[0]).toBe('initial');
  });
  
  it('should update value', () => {
    const { result } = renderHook(() => 
      useLocalStorage('test-key', 'initial')
    );
    
    act(() => {
      result.current[1]('updated');
    });
    
    expect(result.current[0]).toBe('updated');
  });
});
```

# CRITICAL RULES
- NO regex in custom hooks
- NO any types in hook parameters or returns
- ALWAYS handle cleanup in useEffect
- ALWAYS provide proper TypeScript types
- ALWAYS handle error states explicitly
- USE useCallback for functions returned from hooks
- USE useMemo for expensive calculations
- TEST all custom hooks thoroughly
- FOLLOW React hooks rules (no conditional hooks)
</file>

<file path="src/hooks/index.ts">
export { useAuth } from './useAuth';
export { useLoadingState } from './useLoadingState';
export { useDebounce } from './useDebounce';
export { useLocalStorage } from './useLocalStorage';
export { useSupabase } from './useSupabase';
export { 
  useRealtimeSubscription, 
  useCampaignSubscription, 
  useCallSubscription, 
  useStatsSubscription 
} from './useRealtimeSubscription';
</file>

<file path="src/hooks/useAuth.ts">
import { useAuthStore } from '../store/authStore'

export function useAuth() {
  const user = useAuthStore((state) => state.user)
  const isAuthenticated = useAuthStore((state) => state.isAuthenticated)
  const signIn = useAuthStore((state) => state.signIn)
  const signUp = useAuthStore((state) => state.signUp)
  const signOut = useAuthStore((state) => state.signOut)
  const loading = useAuthStore((state) => state.loading)

  return {
    user,
    isAuthenticated,
    signIn,
    signUp,
    signOut,
    loading,
    isSupplier: user?.user_metadata?.userType === 'supplier',
    isBuyer: user?.user_metadata?.userType === 'buyer',
    isAdmin: user?.user_metadata?.userType === 'admin',
  }
}
</file>

<file path="src/hooks/useDebounce.ts">
import { useState, useEffect } from 'react'

/**
 * Hook that debounces a value by delaying updates
 * Useful for search inputs and API calls
 */
export function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState(value)

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value)
    }, delay)

    return () => {
      clearTimeout(handler)
    }
  }, [value, delay])

  return debouncedValue
}

/**
 * Hook that provides a debounced callback function
 * Useful for handling user input events
 */
export function useDebouncedCallback<T extends unknown[]>(
  callback: (...args: T) => void,
  delay: number
) {
  const [timeoutId, setTimeoutId] = useState<NodeJS.Timeout | null>(null)

  const debouncedCallback = (...args: T) => {
    if (timeoutId) {
      clearTimeout(timeoutId)
    }

    const newTimeoutId = setTimeout(() => {
      callback(...args)
    }, delay)

    setTimeoutId(newTimeoutId)
  }

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (timeoutId) {
        clearTimeout(timeoutId)
      }
    }
  }, [timeoutId])

  return debouncedCallback
}
</file>

<file path="src/hooks/useFormSubmission.ts">
import { useState } from 'react'

export interface FormSubmissionState {
  isLoading: boolean
  error: string | null
  isSuccess: boolean
}

export function useFormSubmission() {
  const [state, setState] = useState<FormSubmissionState>({
    isLoading: false,
    error: null,
    isSuccess: false,
  })

  const setLoading = (isLoading: boolean) => {
    setState((prev) => ({ ...prev, isLoading, error: null }))
  }

  const setError = (error: string) => {
    setState((prev) => ({ ...prev, isLoading: false, error, isSuccess: false }))
  }

  const setSuccess = () => {
    setState((prev) => ({ ...prev, isLoading: false, error: null, isSuccess: true }))
  }

  const reset = () => {
    setState({ isLoading: false, error: null, isSuccess: false })
  }

  const handleSubmit = async <T>(
    data: T,
    submitFn: (data: T) => Promise<void>,
    options?: {
      onSuccess?: () => void
      onError?: (error: unknown) => void
      resetSuccessAfter?: number
    }
  ) => {
    setLoading(true)

    try {
      await submitFn(data)
      setSuccess()
      options?.onSuccess?.()

      if (options?.resetSuccessAfter) {
        setTimeout(() => {
          setState((prev) => ({ ...prev, isSuccess: false }))
        }, options.resetSuccessAfter)
      }
    } catch (err: unknown) {
      const errorMessage = err instanceof Error ? err.message : 'An error occurred'
      setError(errorMessage)
      options?.onError?.(err)
    }
  }

  return {
    ...state,
    setLoading,
    setError,
    setSuccess,
    reset,
    handleSubmit,
  }
}
</file>

<file path="src/hooks/useLoadingState.ts">
import { useState, useCallback } from 'react'

interface UseLoadingStateResult {
  loading: boolean
  error: string | null
  setLoading: (loading: boolean) => void
  setError: (error: string | null) => void
  clearError: () => void
  withLoading: <T>(fn: () => Promise<T>) => Promise<T | null>
}

/**
 * Hook for managing loading and error states
 * Provides utilities for async operations
 */
export function useLoadingState(): UseLoadingStateResult {
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  const clearError = useCallback(() => setError(null), [])

  const withLoading = useCallback(async <T>(fn: () => Promise<T>): Promise<T | null> => {
    try {
      setLoading(true)
      setError(null)
      const result = await fn()
      return result
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'An error occurred'
      setError(errorMessage)
      return null
    } finally {
      setLoading(false)
    }
  }, [])

  return {
    loading,
    error,
    setLoading,
    setError,
    clearError,
    withLoading,
  }
}
</file>

<file path="src/hooks/useLocalStorage.ts">
import { useState, useEffect, useCallback } from 'react'

type SetValue<T> = T | ((val: T) => T)

/**
 * Hook for managing localStorage with TypeScript support
 * Handles JSON serialization and provides sync across tabs
 */
export function useLocalStorage<T>(
  key: string,
  initialValue: T
): [T, (value: SetValue<T>) => void] {
  // Get from local storage then parse stored json or return initialValue
  const [storedValue, setStoredValue] = useState<T>(() => {
    if (typeof window === 'undefined') {
      return initialValue
    }

    try {
      const item = window.localStorage.getItem(key)
      return item ? JSON.parse(item) : initialValue
    } catch (error) {
      console.error(`Error reading localStorage key "${key}":`, error)
      return initialValue
    }
  })

  // Return a wrapped version of useState's setter function that persists the new value to localStorage
  const setValue = useCallback(
    (value: SetValue<T>) => {
      try {
        // Allow value to be a function so we have the same API as useState
        const valueToStore = value instanceof Function ? value(storedValue) : value
        setStoredValue(valueToStore)

        // Save to local storage
        if (typeof window !== 'undefined') {
          window.localStorage.setItem(key, JSON.stringify(valueToStore))
        }
      } catch (error) {
        console.error(`Error setting localStorage key "${key}":`, error)
      }
    },
    [key, storedValue]
  )

  // Listen for changes to localStorage from other tabs
  useEffect(() => {
    if (typeof window === 'undefined') {
      return
    }

    const handleStorageChange = (e: StorageEvent) => {
      if (e.key === key && e.newValue) {
        try {
          setStoredValue(JSON.parse(e.newValue))
        } catch (error) {
          console.error(`Error parsing localStorage value for key "${key}":`, error)
        }
      }
    }

    window.addEventListener('storage', handleStorageChange)
    return () => window.removeEventListener('storage', handleStorageChange)
  }, [key])

  return [storedValue, setValue]
}
</file>

<file path="src/hooks/useRealTimeCallUpdates.ts">
import { useState, useEffect } from 'react'
import { supabase } from '../lib/supabase'
import type { RealtimePostgresChangesPayload } from '@supabase/supabase-js'

interface CallRecord {
  id: string
  created_at: string
  caller_number: string
  duration: number
  status: 'active' | 'completed' | 'failed'
  buyer_name: string
  campaign_name: string
  payout: number
  quality_score?: number
}

export function useRealTimeCallUpdates(supplierId: string) {
  const [calls, setCalls] = useState<CallRecord[]>([])

  useEffect(() => {
    if (!supplierId) return

    // Subscribe to real-time call updates for this supplier
    const channel = supabase
      .channel(`supplier-call-updates-${supplierId}`)
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'calls',
          filter: `supplier_id=eq.${supplierId}`,
        },
        (payload: RealtimePostgresChangesPayload<CallRecord>) => {
          handleCallUpdate(payload)
        }
      )
      .subscribe()

    return () => {
      supabase.removeChannel(channel)
    }
  }, [supplierId])

  const handleCallUpdate = (payload: RealtimePostgresChangesPayload<CallRecord>) => {
    const { eventType, new: newCall, old: oldCall } = payload

    setCalls((currentCalls) => {
      switch (eventType) {
        case 'INSERT':
          // Add new call to the beginning of the list
          if (newCall) {
            return [newCall, ...currentCalls.slice(0, 9)] // Keep only 10 most recent
          }
          return currentCalls

        case 'UPDATE':
          // Update existing call
          if (newCall) {
            return currentCalls.map((call) => (call.id === newCall.id ? newCall : call))
          }
          return currentCalls

        case 'DELETE':
          // Remove deleted call
          if (oldCall) {
            return currentCalls.filter((call) => call.id !== oldCall.id)
          }
          return currentCalls

        default:
          return currentCalls
      }
    })
  }

  return calls
}
</file>

<file path="src/hooks/useRealTimeStats.ts">
import { useState, useEffect } from 'react'
import { supabase } from '../lib/supabase'
import type { RealtimePostgresChangesPayload } from '@supabase/supabase-js'

interface RealTimeStats {
  totalCalls?: number
  revenue?: number
  conversionRate?: number
  qualityScore?: number
}

interface CallUpdate {
  id: string
  supplier_id: string
  status: 'active' | 'completed' | 'failed'
  duration?: number
  revenue?: number
  created_at: string
}

export function useRealTimeStats(supplierId: string) {
  const [liveStats, setLiveStats] = useState<RealTimeStats | null>(null)

  useEffect(() => {
    if (!supplierId) return

    // Subscribe to call updates for this supplier
    const callsChannel = supabase
      .channel(`supplier-calls-${supplierId}`)
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'calls',
          filter: `supplier_id=eq.${supplierId}`,
        },
        (payload: RealtimePostgresChangesPayload<CallUpdate>) => {
          handleCallUpdate(payload)
        }
      )
      .subscribe()

    // Subscribe to supplier stats updates
    const statsChannel = supabase
      .channel(`supplier-stats-${supplierId}`)
      .on(
        'postgres_changes',
        {
          event: 'UPDATE',
          schema: 'public',
          table: 'supplier_stats',
          filter: `supplier_id=eq.${supplierId}`,
        },
        (payload: RealtimePostgresChangesPayload<RealTimeStats>) => {
          if (payload.new) {
            setLiveStats((prev) => ({
              ...prev,
              ...payload.new,
            }))
          }
        }
      )
      .subscribe()

    return () => {
      supabase.removeChannel(callsChannel)
      supabase.removeChannel(statsChannel)
    }
  }, [supplierId])

  const handleCallUpdate = (payload: RealtimePostgresChangesPayload<CallUpdate>) => {
    const { eventType, new: newCall, old: oldCall } = payload

    switch (eventType) {
      case 'INSERT':
        // New call started
        if (newCall?.status === 'active') {
          setLiveStats((prev) => ({
            ...prev,
            totalCalls: (prev?.totalCalls || 0) + 1,
          }))
        }
        break

      case 'UPDATE':
        // Call status or data updated
        if (newCall?.status === 'completed' && oldCall?.status === 'active') {
          // Call completed - update revenue and conversion stats
          setLiveStats((prev) => ({
            ...prev,
            revenue: (prev?.revenue || 0) + (newCall.revenue || 0),
          }))
        }
        break

      case 'DELETE':
        // Call removed (rare, but handle gracefully)
        if (oldCall) {
          setLiveStats((prev) => ({
            ...prev,
            totalCalls: Math.max((prev?.totalCalls || 0) - 1, 0),
          }))
        }
        break
    }
  }

  return liveStats
}

// Hook for real-time call count
export function useRealTimeCallCount(supplierId: string) {
  const [activeCallCount, setActiveCallCount] = useState(0)

  useEffect(() => {
    if (!supplierId) return

    // Initial fetch of active calls
    const fetchActiveCallCount = async () => {
      const { count } = await supabase
        .from('calls')
        .select('*', { count: 'exact', head: true })
        .eq('supplier_id', supplierId)
        .eq('status', 'active')

      setActiveCallCount(count || 0)
    }

    fetchActiveCallCount()

    // Subscribe to real-time updates
    const channel = supabase
      .channel(`active-calls-${supplierId}`)
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'calls',
          filter: `supplier_id=eq.${supplierId}`,
        },
        (payload: RealtimePostgresChangesPayload<CallUpdate>) => {
          const { eventType, new: newCall, old: oldCall } = payload

          if (eventType === 'INSERT' && newCall?.status === 'active') {
            setActiveCallCount((prev) => prev + 1)
          } else if (eventType === 'UPDATE') {
            if (oldCall?.status === 'active' && newCall?.status !== 'active') {
              setActiveCallCount((prev) => Math.max(prev - 1, 0))
            } else if (oldCall?.status !== 'active' && newCall?.status === 'active') {
              setActiveCallCount((prev) => prev + 1)
            }
          } else if (eventType === 'DELETE' && oldCall?.status === 'active') {
            setActiveCallCount((prev) => Math.max(prev - 1, 0))
          }
        }
      )
      .subscribe()

    return () => {
      supabase.removeChannel(channel)
    }
  }, [supplierId])

  return activeCallCount
}
</file>

<file path="src/hooks/useSupabase.ts">
import { supabase } from '@/lib/supabase'

/**
 * Hook to access the Supabase client instance
 * Ensures consistent client usage across the application
 */
export function useSupabase() {
  return supabase
}
</file>

<file path="src/integrations/fraud/blocking.ts">
import { supabase } from '../../lib/supabase'
import type { BlockingRule, UnifiedFraudScore } from './types'

export class AutoBlockingService {
  private blockingThreshold = 85 // Auto-block threshold
  private temporaryBlockDuration = 24 * 60 * 60 * 1000 // 24 hours in ms

  async checkBlocked(type: 'phone' | 'ip' | 'email', value: string): Promise<BlockingRule | null> {
    try {
      const { data, error } = await supabase
        .from('blocking_rules')
        .select('*')
        .eq('type', type)
        .eq('value', value)
        .or('expires_at.is.null,expires_at.gt.now()')
        .single()

      if (error && error.code !== 'PGRST116') {
        // Not found error
        console.error('Error checking blocking rule:', error)
        return null
      }

      if (data) {
        return {
          id: data.id,
          type: data.type,
          value: data.value,
          reason: data.reason,
          createdAt: new Date(data.created_at),
          expiresAt: data.expires_at ? new Date(data.expires_at) : undefined,
          autoBlocked: data.auto_blocked,
        }
      }

      return null
    } catch (error) {
      console.error('Error in checkBlocked:', error)
      return null
    }
  }

  async createBlockingRule(
    type: 'phone' | 'ip' | 'email' | 'pattern',
    value: string,
    reason: string,
    temporary: boolean = false,
    autoBlocked: boolean = true
  ): Promise<BlockingRule | null> {
    try {
      const expiresAt = temporary ? new Date(Date.now() + this.temporaryBlockDuration) : null

      const { data, error } = await supabase
        .from('blocking_rules')
        .insert({
          type,
          value,
          reason,
          expires_at: expiresAt,
          auto_blocked: autoBlocked,
        })
        .select()
        .single()

      if (error) {
        console.error('Error creating blocking rule:', error)
        return null
      }

      return {
        id: data.id,
        type: data.type,
        value: data.value,
        reason: data.reason,
        createdAt: new Date(data.created_at),
        expiresAt: data.expires_at ? new Date(data.expires_at) : undefined,
        autoBlocked: data.auto_blocked,
      }
    } catch (error) {
      console.error('Error in createBlockingRule:', error)
      return null
    }
  }

  async removeBlockingRule(id: string): Promise<boolean> {
    try {
      const { error } = await supabase.from('blocking_rules').delete().eq('id', id)

      if (error) {
        console.error('Error removing blocking rule:', error)
        return false
      }

      return true
    } catch (error) {
      console.error('Error in removeBlockingRule:', error)
      return false
    }
  }

  async processAutoBlocking(
    fraudScore: UnifiedFraudScore,
    request: {
      phone?: string
      ip?: string
      email?: string
    }
  ): Promise<void> {
    // Only auto-block if score exceeds threshold
    if (fraudScore.overallScore < this.blockingThreshold) {
      return
    }

    const blockingPromises: Promise<BlockingRule | null>[] = []

    // Block phone if it contributed significantly to high score
    if (request.phone && fraudScore.phoneScore && fraudScore.phoneScore >= 70) {
      const reason =
        fraudScore.reasons.filter((r) => r.toLowerCase().includes('phone')).join(', ') ||
        'High fraud score on phone verification'

      blockingPromises.push(this.createBlockingRule('phone', request.phone, reason, true))
    }

    // Block IP if it's high risk
    if (request.ip && fraudScore.ipScore && fraudScore.ipScore >= 80) {
      const reason =
        fraudScore.reasons
          .filter(
            (r) =>
              r.toLowerCase().includes('ip') ||
              r.toLowerCase().includes('proxy') ||
              r.toLowerCase().includes('vpn') ||
              r.toLowerCase().includes('tor')
          )
          .join(', ') || 'High risk IP address'

      blockingPromises.push(this.createBlockingRule('ip', request.ip, reason, true))
    }

    // Block email if flagged
    if (
      request.email &&
      fraudScore.reasons.some(
        (r) =>
          r.toLowerCase().includes('email') ||
          r.toLowerCase().includes('disposable') ||
          r.toLowerCase().includes('blacklisted')
      )
    ) {
      const reason =
        fraudScore.reasons.filter((r) => r.toLowerCase().includes('email')).join(', ') ||
        'Suspicious email address'

      blockingPromises.push(this.createBlockingRule('email', request.email, reason, false))
    }

    // Execute all blocking operations
    await Promise.allSettled(blockingPromises)
  }

  async listActiveBlocks(type?: 'phone' | 'ip' | 'email' | 'pattern'): Promise<BlockingRule[]> {
    try {
      let query = supabase
        .from('blocking_rules')
        .select('*')
        .or('expires_at.is.null,expires_at.gt.now()')
        .order('created_at', { ascending: false })

      if (type) {
        query = query.eq('type', type)
      }

      const { data, error } = await query

      if (error) {
        console.error('Error listing blocking rules:', error)
        return []
      }

      return data.map((rule) => ({
        id: rule.id,
        type: rule.type,
        value: rule.value,
        reason: rule.reason,
        createdAt: new Date(rule.created_at),
        expiresAt: rule.expires_at ? new Date(rule.expires_at) : undefined,
        autoBlocked: rule.auto_blocked,
      }))
    } catch (error) {
      console.error('Error in listActiveBlocks:', error)
      return []
    }
  }

  async cleanupExpiredRules(): Promise<number> {
    try {
      const { data, error } = await supabase
        .from('blocking_rules')
        .delete()
        .lt('expires_at', new Date().toISOString())
        .select()

      if (error) {
        console.error('Error cleaning up expired rules:', error)
        return 0
      }

      return data?.length || 0
    } catch (error) {
      console.error('Error in cleanupExpiredRules:', error)
      return 0
    }
  }

  // Pattern matching for advanced blocking
  async checkPatternBlock(value: string, type: 'phone' | 'ip' | 'email'): Promise<boolean> {
    try {
      const { data, error } = await supabase
        .from('blocking_rules')
        .select('value')
        .eq('type', 'pattern')
        .or('expires_at.is.null,expires_at.gt.now()')

      if (error || !data) {
        return false
      }

      // Check if value matches any patterns
      for (const rule of data) {
        if (this.matchesPattern(value, rule.value, type)) {
          return true
        }
      }

      return false
    } catch (error) {
      console.error('Error in checkPatternBlock:', error)
      return false
    }
  }

  private matchesPattern(value: string, pattern: string, type: string): boolean {
    // Simple pattern matching without regex
    switch (type) {
      case 'phone':
        // Check for area code patterns (e.g., "+1555*")
        if (pattern.endsWith('*')) {
          const prefix = pattern.slice(0, -1)
          return value.startsWith(prefix)
        }
        break

      case 'ip':
        // Check for IP range patterns (e.g., "192.168.*")
        if (pattern.includes('*')) {
          const parts = pattern.split('.')
          const valueParts = value.split('.')

          for (let i = 0; i < parts.length; i++) {
            if (parts[i] !== '*' && parts[i] !== valueParts[i]) {
              return false
            }
          }
          return true
        }
        break

      case 'email':
        // Check for domain patterns (e.g., "*@spam.com")
        if (pattern.startsWith('*@')) {
          const domain = pattern.slice(2)
          return value.endsWith(`@${domain}`)
        }
        break
    }

    return value === pattern
  }
}

// Export singleton instance
export const autoBlockingService = new AutoBlockingService()
</file>

<file path="src/integrations/fraud/CLAUDE.md">
# Fraud Detection Integration

# Fraud Detection Structure
- `detector.ts` - Main fraud detection engine
- `rules.ts` - Fraud detection rules
- `scoring.ts` - Risk scoring algorithms
- `prevention.ts` - Prevention mechanisms
- `reporting.ts` - Fraud reporting and alerts

# Fraud Detection Engine
```tsx
export class FraudDetector {
  private rules: FraudRule[] = [];
  private threshold = 0.7; // Risk score threshold
  
  constructor() {
    this.loadRules();
  }
  
  async analyzeCall(callData: CallAnalysisData): Promise<FraudAnalysisResult> {
    const riskFactors: RiskFactor[] = [];
    let totalScore = 0;
    
    // Run all fraud detection rules
    for (const rule of this.rules) {
      const result = await rule.evaluate(callData);
      if (result.triggered) {
        riskFactors.push({
          ruleId: rule.id,
          name: rule.name,
          score: result.score,
          description: result.description,
          severity: result.severity,
        });
        totalScore += result.score;
      }
    }
    
    const normalizedScore = Math.min(totalScore, 1.0);
    const isFraud = normalizedScore >= this.threshold;
    
    const analysis: FraudAnalysisResult = {
      callId: callData.callId,
      riskScore: normalizedScore,
      isFraud,
      riskFactors,
      confidence: this.calculateConfidence(riskFactors),
      timestamp: new Date(),
    };
    
    // Store analysis result
    await this.storeAnalysisResult(analysis);
    
    // Take action if fraud detected
    if (isFraud) {
      await this.handleFraudDetected(analysis);
    }
    
    return analysis;
  }
  
  private async handleFraudDetected(analysis: FraudAnalysisResult) {
    // Flag the call
    await supabase
      .from('calls')
      .update({
        status: 'fraud',
        fraud_score: analysis.riskScore,
        quality_score: 0,
        payout_amount: 0,
      })
      .eq('id', analysis.callId);
    
    // Alert administrators
    await this.sendFraudAlert(analysis);
    
    // Block payout
    await this.blockPayout(analysis.callId);
  }
}
```

# Fraud Detection Rules
```tsx
interface FraudRule {
  id: string;
  name: string;
  description: string;
  enabled: boolean;
  severity: 'low' | 'medium' | 'high' | 'critical';
  evaluate: (data: CallAnalysisData) => Promise<RuleResult>;
}

export const FRAUD_RULES: FraudRule[] = [
  {
    id: 'duplicate_caller',
    name: 'Duplicate Caller Detection',
    description: 'Detects multiple calls from same number in short time',
    enabled: true,
    severity: 'high',
    evaluate: async (data) => {
      const recentCalls = await supabase
        .from('calls')
        .select('*')
        .eq('caller_number', data.callerNumber)
        .gte('created_at', new Date(Date.now() - 3600000).toISOString()) // Last hour
        .neq('id', data.callId);
      
      const count = recentCalls.data?.length || 0;
      
      if (count >= 3) {
        return {
          triggered: true,
          score: Math.min(count * 0.2, 0.8),
          description: `${count} calls from same number in last hour`,
          severity: 'high',
        };
      }
      
      return { triggered: false, score: 0 };
    },
  },
  
  {
    id: 'short_call_duration',
    name: 'Short Call Duration',
    description: 'Flags unusually short calls',
    enabled: true,
    severity: 'medium',
    evaluate: async (data) => {
      if (data.duration < 30) { // Less than 30 seconds
        return {
          triggered: true,
          score: 0.4,
          description: `Call duration only ${data.duration} seconds`,
          severity: 'medium',
        };
      }
      
      return { triggered: false, score: 0 };
    },
  },
  
  {
    id: 'geographic_anomaly',
    name: 'Geographic Anomaly',
    description: 'Detects calls from unexpected locations',
    enabled: true,
    severity: 'medium',
    evaluate: async (data) => {
      const callerState = await this.getCallerState(data.callerNumber);
      const campaignStates = data.campaign.filters.states || [];
      
      if (campaignStates.length > 0 && !campaignStates.includes(callerState)) {
        return {
          triggered: true,
          score: 0.5,
          description: `Call from ${callerState}, campaign targets ${campaignStates.join(', ')}`,
          severity: 'medium',
        };
      }
      
      return { triggered: false, score: 0 };
    },
  },
  
  {
    id: 'velocity_check',
    name: 'Call Velocity Check',
    description: 'Detects unusually high call volume from supplier',
    enabled: true,
    severity: 'high',
    evaluate: async (data) => {
      const hourlyLimit = 100; // Max calls per hour per supplier
      
      const recentCalls = await supabase
        .from('calls')
        .select('id')
        .eq('supplier_id', data.supplierId)
        .gte('created_at', new Date(Date.now() - 3600000).toISOString());
      
      const count = recentCalls.data?.length || 0;
      
      if (count > hourlyLimit) {
        return {
          triggered: true,
          score: 0.9,
          description: `${count} calls in last hour (limit: ${hourlyLimit})`,
          severity: 'critical',
        };
      }
      
      return { triggered: false, score: 0 };
    },
  },
];
```

# Risk Scoring System
```tsx
export class RiskScorer {
  calculateCallRiskScore(call: Call, context: CallContext): number {
    let score = 0;
    
    // Duration-based scoring
    score += this.scoreDuration(call.duration);
    
    // Time-based scoring
    score += this.scoreTimeOfDay(call.created_at);
    
    // Caller history scoring
    score += this.scoreCallerHistory(call.caller_number, context);
    
    // Supplier reputation scoring
    score += this.scoreSupplierReputation(call.supplier_id, context);
    
    // Campaign compliance scoring
    score += this.scoreCampaignCompliance(call, context.campaign);
    
    return Math.min(score, 1.0);
  }
  
  private scoreDuration(duration: number): number {
    if (duration < 10) return 0.8; // Very short calls are suspicious
    if (duration < 30) return 0.4;
    if (duration > 1800) return 0.2; // Very long calls might be suspicious
    return 0; // Normal duration
  }
  
  private scoreTimeOfDay(timestamp: string): number {
    const hour = new Date(timestamp).getHours();
    
    // Calls outside business hours are more suspicious
    if (hour < 6 || hour > 22) return 0.3;
    if (hour < 8 || hour > 20) return 0.1;
    return 0;
  }
  
  private async scoreCallerHistory(callerNumber: string, context: CallContext): Promise<number> {
    const history = await this.getCallerHistory(callerNumber, 30); // Last 30 days
    
    if (history.totalCalls === 0) return 0.1; // New caller, slight risk
    
    const fraudRate = history.fraudCalls / history.totalCalls;
    return fraudRate * 0.8; // Scale fraud rate
  }
}
```

# Real-time Fraud Prevention
```tsx
export class FraudPrevention {
  async checkCallAllowed(callData: IncomingCallData): Promise<CallDecision> {
    // Quick pre-checks before allowing call
    const checks = await Promise.all([
      this.checkBlacklist(callData.callerNumber),
      this.checkRateLimit(callData.supplierId),
      this.checkCampaignFilters(callData),
      this.checkSupplierStatus(callData.supplierId),
    ]);
    
    const blocked = checks.some(check => check.blocked);
    
    if (blocked) {
      const reasons = checks
        .filter(check => check.blocked)
        .map(check => check.reason);
      
      return {
        allowed: false,
        reasons,
        action: 'block',
      };
    }
    
    return { allowed: true, action: 'allow' };
  }
  
  private async checkBlacklist(callerNumber: string): Promise<CheckResult> {
    const { data: blacklisted } = await supabase
      .from('phone_blacklist')
      .select('*')
      .eq('phone_number', callerNumber)
      .single();
    
    return {
      blocked: !!blacklisted,
      reason: blacklisted ? 'Caller number is blacklisted' : undefined,
    };
  }
  
  async addToBlacklist(phoneNumber: string, reason: string, addedBy: string) {
    await supabase.from('phone_blacklist').insert({
      phone_number: phoneNumber,
      reason,
      added_by: addedBy,
      created_at: new Date(),
    });
    
    // Immediately block any active calls from this number
    await this.blockActiveCallsFromNumber(phoneNumber);
  }
}
```

# Machine Learning Integration
```tsx
export class MLFraudDetector {
  private model: MLModel | null = null;
  
  async initialize() {
    // Load pre-trained fraud detection model
    this.model = await this.loadModel();
  }
  
  async predictFraud(features: CallFeatures): Promise<MLPrediction> {
    if (!this.model) {
      throw new Error('ML model not initialized');
    }
    
    const prediction = await this.model.predict(features);
    
    return {
      fraudProbability: prediction.probability,
      confidence: prediction.confidence,
      features: this.explainFeatures(features, prediction),
    };
  }
  
  async retrainModel() {
    // Collect recent fraud data for model retraining
    const trainingData = await this.collectTrainingData();
    
    // Retrain model with new data
    this.model = await this.trainModel(trainingData);
    
    // Validate model performance
    const metrics = await this.validateModel(this.model);
    
    if (metrics.accuracy < 0.85) {
      throw new Error('Model performance below threshold');
    }
  }
}
```

# Fraud Reporting
```tsx
export class FraudReporter {
  async generateFraudReport(params: FraudReportParams): Promise<FraudReport> {
    const { startDate, endDate, supplierId, campaignId } = params;
    
    const fraudStats = await this.getFraudStatistics(params);
    const trends = await this.getFraudTrends(params);
    const topRisks = await this.getTopRiskFactors(params);
    
    return {
      period: { startDate, endDate },
      summary: {
        totalCalls: fraudStats.totalCalls,
        fraudCalls: fraudStats.fraudCalls,
        fraudRate: fraudStats.fraudRate,
        blockedAmount: fraudStats.blockedAmount,
      },
      trends,
      topRisks,
      recommendations: this.generateRecommendations(fraudStats),
    };
  }
  
  private generateRecommendations(stats: FraudStatistics): string[] {
    const recommendations: string[] = [];
    
    if (stats.fraudRate > 0.05) {
      recommendations.push('Consider tightening campaign filters');
    }
    
    if (stats.duplicateCallerRate > 0.1) {
      recommendations.push('Implement stricter duplicate caller detection');
    }
    
    if (stats.shortCallRate > 0.2) {
      recommendations.push('Review minimum call duration requirements');
    }
    
    return recommendations;
  }
}
```

# CRITICAL RULES
- NO regex in fraud detection logic
- NO any types in fraud interfaces
- ALWAYS validate fraud detection accuracy
- ALWAYS provide clear fraud explanations
- IMPLEMENT multiple detection layers
- TEST fraud detection thoroughly
- BALANCE false positives vs false negatives
- MAINTAIN audit trails for all decisions
- REGULARLY update fraud rules
- ENSURE fair treatment of legitimate traffic
</file>

<file path="src/integrations/fraud/fraudlabs.ts">
import axios from 'axios'
import { fraudConfig } from './config'
import type { TransactionScreeningResult, FraudCheckRequest } from './types'

export class FraudLabsClient {
  private client = axios.create({
    baseURL: fraudConfig.fraudlabs.baseUrl,
    timeout: fraudConfig.fraudlabs.timeout,
  })

  async screenTransaction(request: FraudCheckRequest): Promise<TransactionScreeningResult> {
    try {
      const response = await this.client.post('/screen', {
        key: fraudConfig.fraudlabs.apiKey,
        format: 'json',
        ip: request.ip,
        email: request.email,
        phone: request.phone,
        amount: request.amount,
        currency: request.currency || 'USD',
        user_order_id: request.campaignId,
        user_order_memo: request.userId,
        // Additional parameters for better fraud detection
        payment_mode: 'creditcard',
        flp_checksum: '',
      })

      const data = response.data

      // Parse the fraud score
      const fraudScore = parseFloat(data.fraudlabspro_score) || 0

      // Determine status based on score and rules
      const status = this.determineStatus(fraudScore, data)

      // Extract triggered rules
      const rules = this.extractTriggeredRules(data)

      // Build risk factors
      const riskFactors = {
        ip: data.ip_address,
        email: data.email_address,
        phone: data.phone_number,
        billing: data.billing_address,
        shipping: data.shipping_address,
      }

      return {
        fraudScore,
        status,
        rules,
        riskFactors,
      }
    } catch (error) {
      console.error('FraudLabs screening error:', error)

      if (axios.isAxiosError(error)) {
        return {
          fraudScore: 0,
          status: 'review',
          rules: [],
          riskFactors: {},
          error: `Transaction screening failed: ${error.response?.data?.message || error.message}`,
        }
      }

      return {
        fraudScore: 0,
        status: 'review',
        rules: [],
        riskFactors: {},
        error: 'Transaction screening service unavailable',
      }
    }
  }

  private determineStatus(
    score: number,
    data: Record<string, unknown>
  ): 'approve' | 'review' | 'reject' {
    // Check if FraudLabs already made a decision
    const flpStatus = String(data.fraudlabspro_status || '').toLowerCase()

    if (flpStatus === 'approve') return 'approve'
    if (flpStatus === 'reject') return 'reject'
    if (flpStatus === 'review') return 'review'

    // Otherwise, use score-based decision
    if (score >= 90) return 'reject'
    if (score >= 60) return 'review'
    return 'approve'
  }

  private extractTriggeredRules(data: Record<string, unknown>): string[] {
    const rules: string[] = []

    // Check various risk indicators
    const riskIndicators = [
      { field: 'is_proxy_ip', message: 'Proxy IP detected' },
      { field: 'is_free_email', message: 'Free email provider' },
      { field: 'is_disposable_email', message: 'Disposable email detected' },
      { field: 'is_new_domain_name', message: 'Newly registered domain' },
      { field: 'is_phone_blacklisted', message: 'Phone number blacklisted' },
      { field: 'is_email_blacklisted', message: 'Email blacklisted' },
      { field: 'is_high_risk_country', message: 'High risk country' },
      { field: 'is_ip_country_mismatch', message: 'IP country mismatch' },
      { field: 'is_phone_country_mismatch', message: 'Phone country mismatch' },
    ]

    for (const indicator of riskIndicators) {
      if (data[indicator.field] === 'Y' || data[indicator.field] === true) {
        rules.push(indicator.message)
      }
    }

    // Check velocity rules
    if (Number(data.ip_velocity) > 5) {
      rules.push(`High IP velocity: ${data.ip_velocity} orders`)
    }
    if (Number(data.email_velocity) > 5) {
      rules.push(`High email velocity: ${data.email_velocity} orders`)
    }

    // Check credit usage
    if (Number(data.remaining_credits) < 100) {
      console.warn('FraudLabs Pro credits running low:', data.remaining_credits)
    }

    return rules
  }

  // Utility methods
  async quickCheck(ip: string, email: string): Promise<number> {
    const result = await this.screenTransaction({ ip, email })
    return result.fraudScore
  }

  async isBlacklisted(email?: string, phone?: string): Promise<boolean> {
    if (!email && !phone) return false

    const result = await this.screenTransaction({ email, phone })
    return result.rules.some((rule) => rule.includes('blacklisted') || rule.includes('blocked'))
  }

  async checkEmailReputation(email: string): Promise<{
    isFree: boolean
    isDisposable: boolean
    isValid: boolean
  }> {
    const result = await this.screenTransaction({ email })

    // Extract email-specific indicators from the response
    const isFree = result.rules.includes('Free email provider')
    const isDisposable = result.rules.includes('Disposable email detected')
    const isValid = !result.error && result.fraudScore < 80

    return { isFree, isDisposable, isValid }
  }
}

// Export singleton instance
export const fraudLabsClient = new FraudLabsClient()
</file>

<file path="src/integrations/fraud/ipquality.ts">
import axios from 'axios'
import { fraudConfig } from './config'
import type { IPReputationResult } from './types'

export class IPQualityClient {
  private client = axios.create({
    baseURL: fraudConfig.ipquality.baseUrl,
    timeout: fraudConfig.ipquality.timeout,
  })

  async checkIPReputation(ipAddress: string): Promise<IPReputationResult> {
    try {
      const response = await this.client.get(`/ip/${fraudConfig.ipquality.apiKey}/${ipAddress}`, {
        params: {
          strictness: 1, // Medium strictness level
          user_agent: '', // Optional user agent
          user_language: 'en-US', // Optional language
          fast: false, // Perform full check
          mobile: true, // Check mobile networks
          allow_public_access_points: false,
          lighter_penalties: false,
        },
      })

      const data = response.data

      // Calculate fraud score based on multiple factors
      const fraudScore = this.calculateFraudScore(data)

      return {
        fraudScore,
        countryCode: data.country_code,
        region: data.region,
        city: data.city,
        isp: data.ISP,
        proxy: data.proxy || false,
        vpn: data.vpn || false,
        tor: data.tor || false,
        recentAbuse: data.recent_abuse || false,
        botStatus: data.bot_status || false,
      }
    } catch (error) {
      console.error('IPQuality check error:', error)

      if (axios.isAxiosError(error)) {
        return {
          fraudScore: 0,
          error: `IP reputation check failed: ${error.response?.data?.message || error.message}`,
        }
      }

      return {
        fraudScore: 0,
        error: 'IP reputation service unavailable',
      }
    }
  }

  private calculateFraudScore(data: Record<string, unknown>): number {
    let score = Number(data.fraud_score) || 0

    // Additional factors that increase fraud risk
    const riskFactors = [
      { condition: data.proxy === true, penalty: 20 },
      { condition: data.vpn === true, penalty: 15 },
      { condition: data.tor === true, penalty: 30 },
      { condition: data.recent_abuse === true, penalty: 25 },
      { condition: data.bot_status === true, penalty: 20 },
      { condition: data.active_vpn === true, penalty: 15 },
      { condition: data.active_tor === true, penalty: 30 },
      { condition: data.mobile === true && data.connection_type === 'Premium', penalty: 10 },
    ]

    // Apply penalties
    for (const factor of riskFactors) {
      if (factor.condition) {
        score = Math.min(100, score + factor.penalty)
      }
    }

    // Reduce score for positive indicators
    const positiveFactors = [
      { condition: data.success === true, bonus: -5 },
      { condition: data.timezone && data.timezone === 'America/New_York', bonus: -5 },
      { condition: Number(data.abuse_velocity) < 1, bonus: -10 },
    ]

    // Apply bonuses
    for (const factor of positiveFactors) {
      if (factor.condition) {
        score = Math.max(0, score + factor.bonus)
      }
    }

    return Math.round(score)
  }

  // Utility methods
  async isHighRiskIP(ipAddress: string): Promise<boolean> {
    const result = await this.checkIPReputation(ipAddress)
    return result.fraudScore >= 75
  }

  async isProxyOrVPN(ipAddress: string): Promise<boolean> {
    const result = await this.checkIPReputation(ipAddress)
    return !!(result.proxy || result.vpn || result.tor)
  }

  async getIPLocation(ipAddress: string): Promise<{
    country?: string
    region?: string
    city?: string
  }> {
    const result = await this.checkIPReputation(ipAddress)
    return {
      country: result.countryCode,
      region: result.region,
      city: result.city,
    }
  }
}

// Export singleton instance
export const ipQualityClient = new IPQualityClient()
</file>

<file path="src/integrations/fraud/maxmind.ts">
import axios from 'axios'
import { fraudConfig } from './config'
import type { MaxMindGeoResult } from './types'

export class MaxMindClient {
  private client = axios.create({
    baseURL: fraudConfig.maxmind.baseUrl,
    timeout: fraudConfig.maxmind.timeout,
    auth: {
      username: fraudConfig.maxmind.apiKey,
      password: '', // MaxMind uses account ID as username and license key as password
    },
    headers: {
      Accept: 'application/json',
    },
  })

  async checkIPLocation(ipAddress: string): Promise<MaxMindGeoResult> {
    try {
      // Get both insights and country data
      const [insightsResponse, countryResponse] = await Promise.allSettled([
        this.getInsights(ipAddress),
        this.getCountry(ipAddress),
      ])

      let insightsData: Record<string, unknown> = {}
      let countryData: Record<string, unknown> = {}

      if (insightsResponse.status === 'fulfilled') {
        insightsData = insightsResponse.value.data as Record<string, unknown>
      }

      if (countryResponse.status === 'fulfilled') {
        countryData = countryResponse.value.data as Record<string, unknown>
      }

      return this.processGeoData(insightsData, countryData)
    } catch (error) {
      console.error('MaxMind GeoIP check error:', error)

      if (axios.isAxiosError(error)) {
        return {
          fraudScore: 0,
          riskLevel: 'low',
          error: `MaxMind check failed: ${error.response?.data?.error || error.message}`,
        }
      }

      return {
        fraudScore: 0,
        riskLevel: 'low',
        error: 'MaxMind GeoIP service unavailable',
      }
    }
  }

  private async getInsights(ip: string): Promise<{ data: unknown }> {
    return this.client.get(`/insights/${ip}`)
  }

  private async getCountry(ip: string): Promise<{ data: unknown }> {
    return this.client.get(`/country/${ip}`)
  }

  private processGeoData(
    insights: Record<string, unknown>,
    country: Record<string, unknown>
  ): MaxMindGeoResult {
    // Extract location data
    const countryInfo = (insights.country || country.country || {}) as Record<string, unknown>
    const city = (insights.city as Record<string, unknown>) || {}
    const location = (insights.location as Record<string, unknown>) || {}
    const traits = (insights.traits as Record<string, unknown>) || {}

    const countryCode = countryInfo.iso_code as string
    const region = (city.names as Record<string, unknown>)?.en as string
    const cityName = (city.names as Record<string, unknown>)?.en as string

    // Extract risk indicators
    const riskScore = Number(traits.risk_score) || 0
    const isAnonymousProxy = Boolean(traits.is_anonymous_proxy)
    const isSatelliteProvider = Boolean(traits.is_satellite_provider)
    const userType = traits.user_type as string

    // Calculate fraud score based on various factors
    let fraudScore = riskScore * 10 // MaxMind risk score is 0-10, convert to 0-100

    // Apply additional risk factors
    const riskFactors = [
      { condition: isAnonymousProxy, penalty: 30 },
      { condition: isSatelliteProvider, penalty: 15 },
      { condition: userType === 'hosting', penalty: 20 },
      { condition: userType === 'cellular', penalty: 5 },
      { condition: this.isHighRiskCountry(countryCode), penalty: 25 },
      { condition: Number(location.accuracy_radius) > 1000, penalty: 10 },
    ]

    for (const factor of riskFactors) {
      if (factor.condition) {
        fraudScore = Math.min(100, fraudScore + factor.penalty)
      }
    }

    // Determine risk level
    let riskLevel: 'low' | 'medium' | 'high' = 'low'
    if (fraudScore >= 70) {
      riskLevel = 'high'
    } else if (fraudScore >= 40) {
      riskLevel = 'medium'
    }

    return {
      fraudScore: Math.round(fraudScore),
      countryCode,
      region,
      city: cityName,
      riskLevel,
      isVpn: userType === 'hosting' || isAnonymousProxy,
      isProxy: isAnonymousProxy,
      isp: traits.isp as string,
      accuracyRadius: Number(location.accuracy_radius),
    }
  }

  private isHighRiskCountry(countryCode?: string): boolean {
    // List of countries commonly associated with higher fraud risk
    const highRiskCountries = [
      'CN',
      'RU',
      'NG',
      'PK',
      'BD',
      'ID',
      'VN',
      'IN',
      'MY',
      'TH',
      'PH',
      'EG',
      'MA',
      'RO',
      'BG',
      'UA',
    ]

    return countryCode ? highRiskCountries.includes(countryCode) : false
  }

  // Utility methods
  async isVpnOrProxy(ipAddress: string): Promise<boolean> {
    const result = await this.checkIPLocation(ipAddress)
    return !!(result.isVpn || result.isProxy)
  }

  async getCountryRisk(ipAddress: string): Promise<{
    country?: string
    riskLevel: 'low' | 'medium' | 'high'
  }> {
    const result = await this.checkIPLocation(ipAddress)
    return {
      country: result.countryCode,
      riskLevel: result.riskLevel,
    }
  }

  async validateIPLocation(
    ipAddress: string,
    expectedCountry: string
  ): Promise<{
    matches: boolean
    actualCountry?: string
    distance?: number
  }> {
    const result = await this.checkIPLocation(ipAddress)

    const matches = result.countryCode === expectedCountry.toUpperCase()

    return {
      matches,
      actualCountry: result.countryCode,
      distance: result.accuracyRadius,
    }
  }

  async detectAnomalousLocation(
    ipAddress: string,
    previousLocations: Array<{ country: string; timestamp: Date }>
  ): Promise<{
    isAnomalous: boolean
    reason?: string
    newLocation?: string
  }> {
    const result = await this.checkIPLocation(ipAddress)

    if (result.error || !result.countryCode) {
      return { isAnomalous: false }
    }

    // Check for rapid location changes
    const recentLocations = previousLocations.filter(
      (loc) => Date.now() - loc.timestamp.getTime() < 24 * 60 * 60 * 1000 // Last 24 hours
    )

    const uniqueCountries = new Set(recentLocations.map((loc) => loc.country))

    if (uniqueCountries.size > 3 && !uniqueCountries.has(result.countryCode)) {
      return {
        isAnomalous: true,
        reason: 'Multiple countries accessed within 24 hours',
        newLocation: result.countryCode,
      }
    }

    // Check for impossible travel
    const lastLocation = recentLocations[recentLocations.length - 1]
    if (lastLocation && lastLocation.country !== result.countryCode) {
      const timeDiff = Date.now() - lastLocation.timestamp.getTime()
      const hoursDiff = timeDiff / (1000 * 60 * 60)

      // If location changed in less than 2 hours, flag as suspicious
      if (hoursDiff < 2) {
        return {
          isAnomalous: true,
          reason: 'Impossible travel time between locations',
          newLocation: result.countryCode,
        }
      }
    }

    return { isAnomalous: false, newLocation: result.countryCode }
  }
}

// Export singleton instance
export const maxMindClient = new MaxMindClient()
</file>

<file path="src/integrations/fraud/sift.ts">
import axios from 'axios'
import { fraudConfig } from './config'
import type { SiftFraudResult, FraudCheckRequest } from './types'

export class SiftClient {
  private client = axios.create({
    baseURL: fraudConfig.sift.baseUrl,
    timeout: fraudConfig.sift.timeout,
    headers: {
      'Content-Type': 'application/json',
    },
  })

  async screenTransaction(request: FraudCheckRequest): Promise<SiftFraudResult> {
    try {
      // Create user if needed and send events
      if (request.userId) {
        await this.sendUserEvent(request)
      }

      // Send transaction event for payment fraud detection
      if (request.amount) {
        await this.sendTransactionEvent(request)
      }

      // Get fraud score
      const scoreResponse = await this.getScore(request.userId || 'anonymous')

      return this.processScoreResponse(scoreResponse.data as Record<string, unknown>)
    } catch (error) {
      console.error('Sift fraud check error:', error)

      if (axios.isAxiosError(error)) {
        return {
          fraudScore: 0,
          status: 'review',
          reasons: [],
          error: `Sift screening failed: ${error.response?.data?.message || error.message}`,
        }
      }

      return {
        fraudScore: 0,
        status: 'review',
        reasons: [],
        error: 'Sift fraud detection service unavailable',
      }
    }
  }

  private async sendUserEvent(request: FraudCheckRequest): Promise<void> {
    const eventData = {
      $type: '$create_account',
      $api_key: fraudConfig.sift.apiKey,
      $user_id: request.userId,
      $session_id: this.generateSessionId(),
      $ip: request.ip,
      $user_email: request.email,
      $phone: request.phone,
      $time: Math.floor(Date.now() / 1000),
      // Additional context
      $brand_name: 'DependableCalls',
      $site_country: 'US',
      $site_domain: 'dependablecalls.com',
    }

    await this.client.post('/events', eventData)
  }

  private async sendTransactionEvent(request: FraudCheckRequest): Promise<void> {
    const eventData = {
      $type: '$transaction',
      $api_key: fraudConfig.sift.apiKey,
      $user_id: request.userId || 'anonymous',
      $session_id: this.generateSessionId(),
      $ip: request.ip,
      $time: Math.floor(Date.now() / 1000),
      $amount: Math.round((request.amount || 0) * 1000000), // Convert to micros
      $currency_code: request.currency || 'USD',
      $transaction_type: '$sale',
      $transaction_status: '$pending',
      $order_id: request.campaignId,
      // Payment method details
      $payment_method: {
        $payment_type: '$credit_card',
        $payment_gateway: '$stripe',
      },
      // Additional fraud signals
      $digital_goods: false,
      $shipping_address: {
        $country: 'US', // Default for call platform
      },
      $billing_address: {
        $country: 'US',
      },
    }

    await this.client.post('/events', eventData)
  }

  private async getScore(userId: string): Promise<{ data: unknown }> {
    const params = new URLSearchParams({
      api_key: fraudConfig.sift.apiKey,
      abuse_types: 'payment_abuse,account_abuse',
    })

    const response = await this.client.get(`/score/${userId}?${params.toString()}`)
    return response
  }

  private processScoreResponse(data: Record<string, unknown>): SiftFraudResult {
    const scores = (data.scores as Record<string, unknown>) || {}
    const paymentAbuse = (scores.payment_abuse as Record<string, unknown>) || {}
    const accountAbuse = (scores.account_abuse as Record<string, unknown>) || {}

    const paymentScore = Number(paymentAbuse.score) || 0
    const accountScore = Number(accountAbuse.score) || 0

    // Take the higher of the two scores
    const fraudScore = Math.max(paymentScore, accountScore) * 100 // Convert to 0-100 scale

    const reasons: string[] = []
    const workflowStatus = (data.workflow_statuses as Record<string, unknown>) || {}

    // Extract reasons from workflow decisions
    Object.entries(workflowStatus).forEach(([key, value]) => {
      if (value && typeof value === 'object') {
        const decision = value as Record<string, unknown>
        if (decision.decision === 'block' || decision.decision === 'review') {
          reasons.push(`Sift ${key} triggered: ${decision.decision}`)
        }
      }
    })

    // Determine status based on score and workflow
    let status: 'approve' | 'review' | 'reject' = 'approve'

    if (
      Object.values(workflowStatus).some(
        (w) => w && typeof w === 'object' && (w as Record<string, unknown>).decision === 'block'
      )
    ) {
      status = 'reject'
    } else if (
      fraudScore >= 80 ||
      Object.values(workflowStatus).some(
        (w) => w && typeof w === 'object' && (w as Record<string, unknown>).decision === 'review'
      )
    ) {
      status = 'review'
    }

    return {
      fraudScore: Math.round(fraudScore),
      status,
      workflowStatus: JSON.stringify(workflowStatus),
      reasons,
      paymentAbuseScore: paymentScore * 100,
      accountAbuseScore: accountScore * 100,
    }
  }

  private generateSessionId(): string {
    return `sess_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  }

  // Utility methods
  async reportGoodTransaction(userId: string): Promise<void> {
    const eventData = {
      $type: '$label',
      $api_key: fraudConfig.sift.apiKey,
      $is_fraud: false,
      $abuse_type: 'payment_abuse',
      $description: 'Confirmed good transaction',
      $source: 'manual_review',
      $analyst: 'system',
      $time: Math.floor(Date.now() / 1000),
    }

    await this.client.post(`/users/${userId}/labels`, eventData)
  }

  async reportFraudulentTransaction(userId: string, reason: string): Promise<void> {
    const eventData = {
      $type: '$label',
      $api_key: fraudConfig.sift.apiKey,
      $is_fraud: true,
      $abuse_type: 'payment_abuse',
      $description: `Fraudulent transaction: ${reason}`,
      $source: 'manual_review',
      $analyst: 'system',
      $time: Math.floor(Date.now() / 1000),
    }

    await this.client.post(`/users/${userId}/labels`, eventData)
  }

  async sendCallEvent(phoneNumber: string, campaignId: string, ip: string): Promise<void> {
    const eventData = {
      $type: '$create_content',
      $api_key: fraudConfig.sift.apiKey,
      $user_id: `phone_${phoneNumber}`,
      $session_id: this.generateSessionId(),
      $ip: ip,
      $time: Math.floor(Date.now() / 1000),
      $content_id: campaignId,
      $contact_phone: phoneNumber,
      // Custom properties for call fraud detection
      $custom: {
        event_type: 'incoming_call',
        campaign_id: campaignId,
        call_source: 'external',
      },
    }

    await this.client.post('/events', eventData)
  }
}

// Export singleton instance
export const siftClient = new SiftClient()
</file>

<file path="src/integrations/fraud/truecaller.ts">
import axios from 'axios'
import { fraudConfig } from './config'
import type { PhoneVerificationResult } from './types'

export class TruecallerClient {
  private client = axios.create({
    baseURL: fraudConfig.truecaller.baseUrl,
    timeout: fraudConfig.truecaller.timeout,
    headers: {
      Authorization: `Bearer ${fraudConfig.truecaller.apiKey}`,
      'Content-Type': 'application/json',
    },
  })

  async verifyPhone(phoneNumber: string): Promise<PhoneVerificationResult> {
    try {
      // Format phone number to E.164 format if needed
      const formattedPhone = this.formatPhoneNumber(phoneNumber)

      const response = await this.client.get('/search', {
        params: {
          q: formattedPhone,
          countryCode: 'US',
        },
      })

      const data = response.data?.data?.[0]

      if (!data) {
        return {
          valid: false,
          error: 'Phone number not found',
        }
      }

      return {
        valid: true,
        carrier: data.carrier,
        country: data.countryCode,
        lineType: this.mapPhoneType(data.phoneType),
        name: data.name,
        spamScore: data.spamScore || 0,
        isActive: data.isActive !== false,
      }
    } catch (error) {
      console.error('TrueCaller verification error:', error)

      if (axios.isAxiosError(error)) {
        if (error.response?.status === 404) {
          return {
            valid: false,
            error: 'Phone number not found',
          }
        }
        return {
          valid: false,
          error: `Verification failed: ${error.response?.data?.message || error.message}`,
        }
      }

      return {
        valid: false,
        error: 'Phone verification service unavailable',
      }
    }
  }

  private formatPhoneNumber(phone: string): string {
    // Remove all non-numeric characters
    const cleaned = phone.replace(/\D/g, '')

    // Add country code if missing (assume US)
    if (cleaned.length === 10) {
      return `+1${cleaned}`
    } else if (cleaned.length === 11 && cleaned.startsWith('1')) {
      return `+${cleaned}`
    }

    // If already has country code or different format, return as is
    return phone.startsWith('+') ? phone : `+${cleaned}`
  }

  private mapPhoneType(type?: string): 'mobile' | 'landline' | 'voip' | 'unknown' {
    switch (type?.toLowerCase()) {
      case 'mobile':
      case 'cellular':
        return 'mobile'
      case 'fixed':
      case 'landline':
        return 'landline'
      case 'voip':
      case 'virtual':
        return 'voip'
      default:
        return 'unknown'
    }
  }

  // Additional utility methods
  async checkSpamScore(phoneNumber: string): Promise<number> {
    const result = await this.verifyPhone(phoneNumber)
    return result.spamScore || 0
  }

  async isPhoneActive(phoneNumber: string): Promise<boolean> {
    const result = await this.verifyPhone(phoneNumber)
    return result.valid && (result.isActive ?? false)
  }
}

// Export singleton instance
export const truecallerClient = new TruecallerClient()
</file>

<file path="src/integrations/stripe/CLAUDE.md">
# Stripe Payment Integration

# Integration Structure  
- `client.ts` - Stripe client configuration
- `payments.ts` - Payment processing
- `subscriptions.ts` - Subscription management
- `webhooks.ts` - Webhook handlers
- `types.ts` - Stripe type definitions

# Client Configuration
```tsx
import Stripe from 'stripe';

export const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: '2024-12-18.acacia',
  typescript: true,
});

export const stripePublishableKey = process.env.VITE_STRIPE_PUBLIC_KEY!;

// Client-side Stripe instance
export const getStripeInstance = async () => {
  const { loadStripe } = await import('@stripe/stripe-js');
  return loadStripe(stripePublishableKey);
};
```

# Payment Processing
```tsx
export class PaymentService {
  async createPaymentIntent(params: PaymentIntentParams): Promise<Stripe.PaymentIntent> {
    const paymentIntent = await stripe.paymentIntents.create({
      amount: Math.round(params.amount * 100), // Convert to cents
      currency: params.currency || 'usd',
      customer: params.customerId,
      metadata: {
        user_id: params.userId,
        campaign_id: params.campaignId,
        ...params.metadata,
      },
      automatic_payment_methods: {
        enabled: true,
      },
    });
    
    // Log payment intent creation
    await this.logPaymentEvent('payment_intent_created', {
      payment_intent_id: paymentIntent.id,
      amount: params.amount,
      user_id: params.userId,
    });
    
    return paymentIntent;
  }
  
  async confirmPayment(paymentIntentId: string): Promise<Stripe.PaymentIntent> {
    const paymentIntent = await stripe.paymentIntents.confirm(paymentIntentId);
    
    if (paymentIntent.status === 'succeeded') {
      await this.handleSuccessfulPayment(paymentIntent);
    }
    
    return paymentIntent;
  }
  
  private async handleSuccessfulPayment(paymentIntent: Stripe.PaymentIntent) {
    const { metadata } = paymentIntent;
    
    // Record transaction in database
    await supabase.from('transactions').insert({
      stripe_payment_intent_id: paymentIntent.id,
      user_id: metadata.user_id,
      amount: paymentIntent.amount / 100,
      currency: paymentIntent.currency,
      status: 'succeeded',
      type: 'charge',
    });
    
    // Update campaign budget if applicable
    if (metadata.campaign_id) {
      await this.updateCampaignBudget(metadata.campaign_id, paymentIntent.amount / 100);
    }
  }
}
```

# Subscription Management
```tsx
export class SubscriptionService {
  async createSubscription(params: CreateSubscriptionParams): Promise<Stripe.Subscription> {
    const subscription = await stripe.subscriptions.create({
      customer: params.customerId,
      items: [{
        price: params.priceId,
        quantity: params.quantity || 1,
      }],
      payment_behavior: 'default_incomplete',
      payment_settings: { save_default_payment_method: 'on_subscription' },
      expand: ['latest_invoice.payment_intent'],
      metadata: {
        user_id: params.userId,
        plan_type: params.planType,
      },
    });
    
    return subscription;
  }
  
  async updateSubscription(subscriptionId: string, updates: UpdateSubscriptionParams) {
    const subscription = await stripe.subscriptions.update(subscriptionId, {
      items: updates.items,
      proration_behavior: 'always_invoice',
      metadata: updates.metadata,
    });
    
    // Update local subscription data
    await supabase
      .from('user_subscriptions')
      .update({
        stripe_subscription_id: subscription.id,
        status: subscription.status,
        current_period_end: new Date(subscription.current_period_end * 1000),
      })
      .eq('user_id', updates.userId);
      
    return subscription;
  }
  
  async cancelSubscription(subscriptionId: string, immediately = false) {
    const subscription = await stripe.subscriptions.update(subscriptionId, {
      cancel_at_period_end: !immediately,
      ...(immediately && { cancel_at: Math.floor(Date.now() / 1000) }),
    });
    
    return subscription;
  }
}
```

# Webhook Handlers
```tsx
export async function handleStripeWebhook(
  body: string,
  signature: string
): Promise<{ success: boolean; error?: string }> {
  let event: Stripe.Event;
  
  try {
    event = stripe.webhooks.constructEvent(
      body,
      signature,
      process.env.STRIPE_WEBHOOK_SECRET!
    );
  } catch (error) {
    console.error('Webhook signature verification failed:', error);
    return { success: false, error: 'Invalid signature' };
  }
  
  try {
    switch (event.type) {
      case 'payment_intent.succeeded':
        await handlePaymentSucceeded(event.data.object as Stripe.PaymentIntent);
        break;
        
      case 'payment_intent.payment_failed':
        await handlePaymentFailed(event.data.object as Stripe.PaymentIntent);
        break;
        
      case 'customer.subscription.updated':
        await handleSubscriptionUpdated(event.data.object as Stripe.Subscription);
        break;
        
      case 'customer.subscription.deleted':
        await handleSubscriptionDeleted(event.data.object as Stripe.Subscription);
        break;
        
      case 'invoice.payment_succeeded':
        await handleInvoicePaymentSucceeded(event.data.object as Stripe.Invoice);
        break;
        
      default:
        console.log(`Unhandled event type: ${event.type}`);
    }
    
    return { success: true };
  } catch (error) {
    console.error(`Error processing webhook ${event.type}:`, error);
    return { success: false, error: error.message };
  }
}

async function handlePaymentSucceeded(paymentIntent: Stripe.PaymentIntent) {
  const { metadata } = paymentIntent;
  
  // Update transaction status
  await supabase
    .from('transactions')
    .update({ status: 'succeeded' })
    .eq('stripe_payment_intent_id', paymentIntent.id);
  
  // Send confirmation email
  await emailService.sendPaymentConfirmation({
    userId: metadata.user_id,
    amount: paymentIntent.amount / 100,
    currency: paymentIntent.currency,
  });
  
  // Update user credits or campaign budget
  if (metadata.campaign_id) {
    await campaignService.addBudget(metadata.campaign_id, paymentIntent.amount / 100);
  }
}
```

# Payout Processing
```tsx
export class PayoutService {
  async createPayout(params: PayoutParams): Promise<Stripe.Transfer> {
    // Create Stripe Connect transfer
    const transfer = await stripe.transfers.create({
      amount: Math.round(params.amount * 100),
      currency: params.currency || 'usd',
      destination: params.stripeAccountId,
      metadata: {
        user_id: params.userId,
        payout_period: params.payoutPeriod,
      },
    });
    
    // Record payout in database
    await supabase.from('payouts').insert({
      user_id: params.userId,
      stripe_transfer_id: transfer.id,
      amount: params.amount,
      currency: params.currency,
      status: 'processing',
      payout_period: params.payoutPeriod,
    });
    
    return transfer;
  }
  
  async processScheduledPayouts() {
    // Get suppliers eligible for payout
    const { data: suppliers } = await supabase
      .from('users')
      .select('*')
      .eq('role', 'supplier')
      .eq('payout_enabled', true);
    
    for (const supplier of suppliers) {
      const earnings = await this.calculateSupplierEarnings(supplier.id);
      
      if (earnings.amount >= MINIMUM_PAYOUT_AMOUNT) {
        await this.createPayout({
          userId: supplier.id,
          amount: earnings.amount,
          stripeAccountId: supplier.stripe_account_id,
          payoutPeriod: getCurrentPayoutPeriod(),
        });
      }
    }
  }
}
```

# Customer Management
```tsx
export class CustomerService {
  async createCustomer(user: User): Promise<Stripe.Customer> {
    const customer = await stripe.customers.create({
      email: user.email,
      name: user.profile?.company || `${user.first_name} ${user.last_name}`,
      metadata: {
        user_id: user.id,
        role: user.role,
      },
    });
    
    // Store Stripe customer ID
    await supabase
      .from('users')
      .update({ stripe_customer_id: customer.id })
      .eq('id', user.id);
    
    return customer;
  }
  
  async updateCustomer(customerId: string, updates: CustomerUpdateParams) {
    return stripe.customers.update(customerId, {
      email: updates.email,
      name: updates.name,
      phone: updates.phone,
      address: updates.address,
    });
  }
}
```

# Error Handling
```tsx
export function handleStripeError(error: Stripe.StripeError): string {
  switch (error.code) {
    case 'card_declined':
      return 'Your card was declined. Please try a different payment method.';
    case 'insufficient_funds':
      return 'Insufficient funds on your card. Please try a different payment method.';
    case 'expired_card':
      return 'Your card has expired. Please use a different payment method.';
    case 'incorrect_cvc':
      return 'The security code you entered is incorrect.';
    case 'payment_intent_authentication_failure':
      return 'Payment authentication failed. Please try again.';
    default:
      return 'Payment processing failed. Please try again.';
  }
}
```

# Testing Helpers
```tsx
export const TEST_PAYMENT_METHODS = {
  visa: 'pm_card_visa',
  visaDebit: 'pm_card_visa_debit',
  mastercard: 'pm_card_mastercard',
  amex: 'pm_card_amex',
  declined: 'pm_card_declined',
  insufficientFunds: 'pm_card_chargeDeclinedInsufficientFunds',
  fraudulent: 'pm_card_chargeDeclinedFraudulent',
};

export async function createTestPaymentIntent(amount: number) {
  return stripe.paymentIntents.create({
    amount: Math.round(amount * 100),
    currency: 'usd',
    payment_method: TEST_PAYMENT_METHODS.visa,
    confirm: true,
  });
}
```

# CRITICAL RULES
- NO regex in Stripe integration
- NO any types in Stripe interfaces
- ALWAYS verify webhook signatures
- ALWAYS handle Stripe errors gracefully
- SECURE API key management
- NEVER log sensitive payment data
- IMPLEMENT proper retry logic
- TEST with Stripe test environment
- COMPLY with PCI DSS requirements
- HANDLE idempotency for payments
</file>

<file path="src/integrations/stripe/README.md">
# Stripe Integration

This directory contains the complete Stripe integration for the Dependable Call Exchange platform.

## Setup

1. Create a Stripe account at https://stripe.com
2. Get your API keys from the Stripe Dashboard
3. Copy `.env.example` to `.env` and fill in your Stripe keys:
   ```
   VITE_STRIPE_PUBLISHABLE_KEY=pk_test_...
   VITE_STRIPE_SECRET_KEY=sk_test_...
   VITE_STRIPE_WEBHOOK_SECRET=whsec_...
   VITE_STRIPE_CONNECT_CLIENT_ID=ca_...
   ```

## Architecture

### Core Modules

- **client.ts** - Stripe SDK initialization and configuration
- **types.ts** - TypeScript interfaces for Stripe operations
- **customers.ts** - Customer and payment method management
- **connected-accounts.ts** - Stripe Connect for supplier payouts
- **payments.ts** - Payment intent creation and management
- **subscriptions.ts** - Subscription handling for buyers
- **billing.ts** - Invoice and usage-based billing
- **payouts.ts** - Transfer and payout management for suppliers
- **webhooks.ts** - Webhook event handlers

### Key Features

1. **Buyer Payments**
   - Credit card and ACH support
   - Subscription management
   - Usage-based billing
   - Invoice generation

2. **Supplier Payouts**
   - Stripe Connect Express accounts
   - Automatic weekly payouts (Fridays)
   - Real-time balance tracking
   - Payout history

3. **Security**
   - Webhook signature verification
   - PCI compliance through Stripe
   - Secure payment method storage

## Usage Examples

### Creating a Customer

```typescript
import { createStripeCustomer } from '@/integrations/stripe';

const customer = await createStripeCustomer(email, {
  userId: user.id,
  userType: 'buyer',
  companyName: user.company_name,
});
```

### Creating a Payment Intent

```typescript
import { createPaymentIntent } from '@/integrations/stripe';

const paymentIntent = await createPaymentIntent({
  amount: 10000, // $100.00 in cents
  currency: 'usd',
  customerId: customer.id,
  metadata: {
    invoiceId: invoice.id,
    buyerId: buyer.id,
    billingPeriod: '2024-01',
  },
});
```

### Setting up Supplier Payouts

```typescript
import { createConnectedAccount, createAccountLink } from '@/integrations/stripe';

// Create connected account
const account = await createConnectedAccount({
  email: supplier.email,
  metadata: {
    supplierId: supplier.id,
    companyName: supplier.company_name,
  },
});

// Generate onboarding link
const accountLink = await createAccountLink(
  account.id,
  'https://app.dependablecalls.com/suppliers/onboarding/refresh',
  'https://app.dependablecalls.com/suppliers/onboarding/return'
);
```

### Processing Weekly Payouts

```typescript
import { scheduleWeeklyPayouts } from '@/integrations/stripe';

const suppliers = await getSupplierPayoutData();
const transfers = await scheduleWeeklyPayouts(suppliers);
```

## Webhook Configuration

1. Set up webhook endpoint in Stripe Dashboard
2. Point to: `https://yourdomain.com/.netlify/functions/stripe-webhook`
3. Select events:
   - payment_intent.succeeded
   - payment_intent.payment_failed
   - charge.dispute.created
   - account.updated
   - account.application.authorized
   - account.application.deauthorized
   - payout.created
   - payout.paid
   - payout.failed
   - transfer.created
   - transfer.reversed

## Testing

Use Stripe test cards:
- Success: 4242 4242 4242 4242
- Decline: 4000 0000 0000 0002
- 3D Secure: 4000 0000 0000 3220

Test bank accounts (ACH):
- Success: 000123456789
- Failure: 000111111113

## Error Handling

All functions include proper error handling and will throw descriptive errors. Wrap calls in try-catch blocks:

```typescript
try {
  const result = await stripeOperation();
} catch (error) {
  console.error('Stripe error:', error.message);
  // Handle error appropriately
}
```

## Security Considerations

1. Never expose secret keys in client-side code
2. Always verify webhook signatures
3. Use HTTPS in production
4. Implement rate limiting on payment endpoints
5. Log all payment-related activities
6. Monitor for suspicious patterns
</file>

<file path="src/integrations/CLAUDE.md">
# API Integration Patterns

# File Structure
```
integrations/
â”œâ”€â”€ stripe/           # Stripe payment integration
â”œâ”€â”€ supabase/         # Database and auth
â”œâ”€â”€ sentry/           # Error monitoring
â”œâ”€â”€ analytics/        # Tracking and analytics
â””â”€â”€ webhooks/         # Webhook handlers
```

# API Client Pattern
```tsx
import axios, { AxiosInstance, AxiosError } from 'axios';

class ApiClient {
  private client: AxiosInstance;
  
  constructor(baseURL: string) {
    this.client = axios.create({
      baseURL,
      headers: {
        'Content-Type': 'application/json',
      },
    });
    
    this.setupInterceptors();
  }
  
  private setupInterceptors() {
    // Request interceptor for auth
    this.client.interceptors.request.use((config) => {
      const token = getAuthToken();
      if (token) {
        config.headers.Authorization = `Bearer ${token}`;
      }
      return config;
    });
    
    // Response interceptor for errors
    this.client.interceptors.response.use(
      (response) => response,
      (error: AxiosError) => {
        handleApiError(error);
        return Promise.reject(error);
      }
    );
  }
}
```

# Error Handling Strategy
```tsx
// Centralized error handling
export class ApiError extends Error {
  constructor(
    message: string,
    public statusCode: number,
    public code?: string
  ) {
    super(message);
    this.name = 'ApiError';
  }
}

export function handleApiError(error: unknown): ApiError {
  if (axios.isAxiosError(error)) {
    const status = error.response?.status ?? 500;
    const message = error.response?.data?.message ?? 'Network error';
    const code = error.response?.data?.code;
    
    return new ApiError(message, status, code);
  }
  
  return new ApiError('Unknown error occurred', 500);
}
```

# Stripe Integration
- Use official Stripe libraries only
- Implement webhook verification
- Handle payment intents properly
- Secure API key management

```tsx
import { Stripe } from 'stripe';

export class StripeService {
  private stripe: Stripe;
  
  constructor() {
    this.stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
      apiVersion: '2024-12-18.acacia',
    });
  }
  
  async createPaymentIntent(amount: number, currency = 'usd') {
    return await this.stripe.paymentIntents.create({
      amount: Math.round(amount * 100), // Convert to cents
      currency,
    });
  }
}
```

# Supabase Integration
- Use typed clients
- Implement RLS policies
- Handle real-time subscriptions
- Proper error handling

```tsx
import { createClient, SupabaseClient } from '@supabase/supabase-js';
import { Database } from '@/types/database';

export const supabase: SupabaseClient<Database> = createClient(
  import.meta.env.VITE_SUPABASE_URL,
  import.meta.env.VITE_SUPABASE_ANON_KEY
);

// Typed query helper
export async function fetchUser(id: string) {
  const { data, error } = await supabase
    .from('users')
    .select('*')
    .eq('id', id)
    .single();
    
  if (error) throw new ApiError(error.message, 400);
  return data;
}
```

# Real-time Subscriptions
```tsx
export class RealtimeService {
  private subscriptions = new Map<string, RealtimeChannel>();
  
  subscribeToTable<T>(
    table: string,
    callback: (payload: RealtimePostgresChangesPayload<T>) => void
  ) {
    const channel = supabase
      .channel(`${table}-changes`)
      .on('postgres_changes', 
        { event: '*', schema: 'public', table },
        callback
      )
      .subscribe();
      
    this.subscriptions.set(table, channel);
    return channel;
  }
  
  unsubscribe(table: string) {
    const channel = this.subscriptions.get(table);
    if (channel) {
      supabase.removeChannel(channel);
      this.subscriptions.delete(table);
    }
  }
}
```

# Webhook Handling
```tsx
// Webhook verification
export function verifyWebhookSignature(
  payload: string,
  signature: string,
  secret: string
): boolean {
  // Use crypto.timingSafeEqual for security
  const expectedSignature = createHmac('sha256', secret)
    .update(payload)
    .digest('hex');
    
  return crypto.timingSafeEqual(
    Buffer.from(signature),
    Buffer.from(expectedSignature)
  );
}
```

# Secret Management
- ALL secrets in environment variables
- Different secrets for dev/staging/prod
- NO secrets in code or version control
- Use proper key rotation practices

```tsx
// Environment validation
const requiredEnvVars = [
  'VITE_SUPABASE_URL',
  'VITE_SUPABASE_ANON_KEY',
  'VITE_STRIPE_PUBLIC_KEY',
] as const;

export function validateEnvironment() {
  for (const envVar of requiredEnvVars) {
    if (!import.meta.env[envVar]) {
      throw new Error(`Missing required environment variable: ${envVar}`);
    }
  }
}
```

# Rate Limiting & Retry Logic
```tsx
import { retry } from '@/lib/retry';

export async function apiCallWithRetry<T>(
  fn: () => Promise<T>,
  maxRetries = 3
): Promise<T> {
  return retry(fn, {
    retries: maxRetries,
    retryDelay: (attempt) => Math.min(1000 * Math.pow(2, attempt), 30000),
    retryIf: (error) => {
      // Retry on network errors and 5xx responses
      return axios.isAxiosError(error) && 
             (!error.response || error.response.status >= 500);
    },
  });
}
```

# Type Safety for APIs
- Generate types from OpenAPI specs where possible
- Create proper TypeScript interfaces for all responses
- Use Zod for runtime validation of external API responses

# Testing Integrations
- Mock external services in tests
- Use test-specific API keys/endpoints
- Test error scenarios explicitly
- Integration tests with real services in CI

# DCE-Specific Integrations
- Call tracking APIs
- Fraud detection services
- Campaign management APIs
- Real-time analytics
- Billing and payout systems

# CRITICAL RULES
- NO regex in integration code
- NO any types in API responses
- ALWAYS validate external API responses
- ALWAYS handle network errors gracefully
- NEVER commit secrets or API keys
- ALWAYS use proper authentication
- ALWAYS implement proper error boundaries
- ALWAYS log integration failures for monitoring
</file>

<file path="src/lib/auth-middleware.ts">
import { createClient, type SupabaseClient } from '@supabase/supabase-js'
import type { Database } from '../types/database'

const supabase = createClient<Database>(
  import.meta.env.VITE_SUPABASE_URL!,
  import.meta.env.VITE_SUPABASE_ANON_KEY!
)

export interface AuthContext {
  user: {
    id: string
    email: string
    role?: 'supplier' | 'buyer' | 'admin'
  } | null
  supabase: SupabaseClient<Database>
}

export interface ApiRequest {
  headers: Record<string, string | string[] | undefined>
  body?: string
  httpMethod: string
  queryStringParameters?: Record<string, string>
}

export interface ApiResponse {
  statusCode: number
  headers?: Record<string, string>
  body: string
}

export class ApiError extends Error {
  public statusCode: number
  public code?: string

  constructor(message: string, statusCode: number = 500, code?: string) {
    super(message)
    this.name = 'ApiError'
    this.statusCode = statusCode
    this.code = code
  }
}

export async function withAuth<T>(
  request: ApiRequest,
  handler: (context: AuthContext, request: ApiRequest) => Promise<T>
): Promise<ApiResponse> {
  try {
    // Extract token from Authorization header
    const authHeader = request.headers.authorization || request.headers.Authorization

    if (!authHeader || typeof authHeader !== 'string') {
      throw new ApiError('Missing authorization header', 401, 'UNAUTHORIZED')
    }

    const token = authHeader.replace('Bearer ', '')

    if (!token) {
      throw new ApiError('Invalid authorization header format', 401, 'UNAUTHORIZED')
    }

    // Verify the JWT token with Supabase
    const {
      data: { user },
      error,
    } = await supabase.auth.getUser(token)

    if (error || !user) {
      throw new ApiError('Invalid or expired token', 401, 'UNAUTHORIZED')
    }

    // Get user role from database
    const { error: userError } = await supabase
      .from('users')
      .select('id, email, metadata')
      .eq('id', user.id)
      .single()

    if (userError) {
      console.error('Error fetching user data:', userError)
      throw new ApiError('User not found', 404, 'USER_NOT_FOUND')
    }

    // Determine user role by checking related tables
    let role: 'supplier' | 'buyer' | 'admin' | undefined

    const [supplierCheck, buyerCheck, adminCheck] = await Promise.all([
      supabase.from('suppliers').select('id').eq('user_id', user.id).single(),
      supabase.from('buyers').select('id').eq('user_id', user.id).single(),
      supabase.from('admins').select('id').eq('user_id', user.id).single(),
    ])

    if (adminCheck.data) {
      role = 'admin'
    } else if (buyerCheck.data) {
      role = 'buyer'
    } else if (supplierCheck.data) {
      role = 'supplier'
    }

    const context: AuthContext = {
      user: {
        id: user.id,
        email: user.email!,
        role,
      },
      supabase,
    }

    const result = await handler(context, request)

    return {
      statusCode: 200,
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization',
        'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      },
      body: JSON.stringify(result),
    }
  } catch (error) {
    console.error('API Error:', error)

    if (error instanceof ApiError) {
      return {
        statusCode: error.statusCode,
        headers: {
          'Content-Type': 'application/json',
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Headers': 'Content-Type, Authorization',
          'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
        },
        body: JSON.stringify({
          error: error.message,
          code: error.code,
        }),
      }
    }

    return {
      statusCode: 500,
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization',
        'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      },
      body: JSON.stringify({
        error: 'Internal server error',
      }),
    }
  }
}

export async function withoutAuth<T>(
  request: ApiRequest,
  handler: (supabase: SupabaseClient<Database>, request: ApiRequest) => Promise<T>
): Promise<ApiResponse> {
  try {
    const result = await handler(supabase, request)

    return {
      statusCode: 200,
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization',
        'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      },
      body: JSON.stringify(result),
    }
  } catch (error) {
    console.error('API Error:', error)

    if (error instanceof ApiError) {
      return {
        statusCode: error.statusCode,
        headers: {
          'Content-Type': 'application/json',
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Headers': 'Content-Type, Authorization',
          'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
        },
        body: JSON.stringify({
          error: error.message,
          code: error.code,
        }),
      }
    }

    return {
      statusCode: 500,
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization',
        'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      },
      body: JSON.stringify({
        error: 'Internal server error',
      }),
    }
  }
}

export function requireRole(allowedRoles: Array<'supplier' | 'buyer' | 'admin'>) {
  return function <T>(
    request: ApiRequest,
    handler: (context: AuthContext, request: ApiRequest) => Promise<T>
  ) {
    return withAuth(request, async (context, req) => {
      if (!context.user?.role || !allowedRoles.includes(context.user.role)) {
        throw new ApiError('Insufficient permissions', 403, 'FORBIDDEN')
      }
      return handler(context, req)
    })
  }
}
</file>

<file path="src/lib/CLAUDE.md">
# Utility Functions & Libraries

# File Organization
```
lib/
â”œâ”€â”€ supabase.ts        # Supabase client config
â”œâ”€â”€ validators.ts      # Zod validation schemas
â”œâ”€â”€ formatters.ts      # Data formatting utilities
â”œâ”€â”€ constants.ts       # App-wide constants
â”œâ”€â”€ api.ts            # API helpers
â”œâ”€â”€ auth.ts           # Auth utilities
â”œâ”€â”€ utils.ts          # General utilities
â””â”€â”€ types.ts          # Shared utility types
```

# Validation Patterns
- ALWAYS use Zod for validation
- NO regex patterns - use Zod string validators
- Create reusable schemas

```tsx
import { z } from 'zod';

export const phoneSchema = z.string()
  .min(10, 'Phone number must be at least 10 digits')
  .transform(val => val.replace(/\D/g, '')); // Remove non-digits

export const emailSchema = z.string().email('Invalid email format');
```

# External Library Usage
- Check if library exists before adding new ones
- Use existing project dependencies:
  - axios for HTTP requests
  - zod for validation
  - date-fns for date manipulation
  - lodash for utility functions (if needed)

# API Helpers
```tsx
// Use axios instance with proper typing
export const api = axios.create({
  baseURL: import.meta.env.VITE_API_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Typed API functions
export async function fetchUser(id: string): Promise<User> {
  const response = await api.get<User>(`/users/${id}`);
  return response.data;
}
```

# Error Handling Patterns
```tsx
// Custom error types
export class ValidationError extends Error {
  constructor(message: string, public field: string) {
    super(message);
    this.name = 'ValidationError';
  }
}

// Error handling utilities
export function handleApiError(error: unknown): string {
  if (error instanceof ValidationError) {
    return `Validation error: ${error.message}`;
  }
  if (axios.isAxiosError(error)) {
    return error.response?.data?.message ?? 'Network error';
  }
  return 'An unexpected error occurred';
}
```

# Data Formatting
```tsx
// Currency formatting
export function formatCurrency(
  amount: number, 
  currency = 'USD'
): string {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency,
  }).format(amount);
}

// Date formatting
export function formatDate(date: Date | string): string {
  return new Intl.DateTimeFormat('en-US').format(new Date(date));
}
```

# Secret Management
- Use environment variables for all secrets
- NO hardcoded API keys or passwords
- Use proper typing for env vars

```tsx
// Environment variable typing
interface ImportMetaEnv {
  readonly VITE_SUPABASE_URL: string;
  readonly VITE_SUPABASE_ANON_KEY: string;
  readonly VITE_STRIPE_PUBLIC_KEY: string;
}
```

# Performance Utilities
```tsx
// Debounce for search inputs
export function debounce<T extends unknown[]>(
  fn: (...args: T) => void,
  delay: number
): (...args: T) => void {
  let timeoutId: NodeJS.Timeout;
  return (...args: T) => {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => fn(...args), delay);
  };
}
```

# DCE-Specific Utilities
- Call duration calculation
- Commission rate calculations
- Traffic quality scoring
- Fraud detection helpers
- Real-time connection utilities

# Type Safety Requirements
- ALL functions must have proper TypeScript types
- Use generics for flexible utilities
- Export types alongside functions
- NO any types allowed

# Testing Utilities
- Create test helpers in lib/__tests__/
- Mock external dependencies
- Use fixtures for test data

# CRITICAL RULES
- NO regex patterns anywhere
- NO any types in utility functions
- ALWAYS validate inputs with Zod
- ALWAYS handle errors explicitly
- ALWAYS use proper TypeScript typing
- NO direct external API calls - use abstractions
</file>

<file path="src/lib/database.ts">
import { supabase } from './supabase'
import type { Database } from '../types/database'

// Type aliases for cleaner code
type Views = Database['public']['Views']
type Functions = Database['public']['Functions']

// View types
type SupplierStats = Views['supplier_stats_view']['Row']
type BuyerStats = Views['buyer_stats_view']['Row']
type CampaignPerformance = Views['campaign_performance_view']['Row']

// Function return types
type UserStatsReturn = Functions['get_user_stats']['Returns']
type SupplierPayoutReturn = Functions['calculate_supplier_payout']['Returns']
type AddCreditsReturn = Functions['add_buyer_credits']['Returns']
type DeductBalanceReturn = Functions['deduct_buyer_balance']['Returns']

/**
 * Database View Queries
 */

/**
 * Get supplier statistics from the view
 * @param supplierId - The supplier ID to filter by (optional)
 * @returns Array of supplier statistics
 */
export async function getSupplierStats(supplierId?: string): Promise<SupplierStats[]> {
  const query = supabase.from('supplier_stats_view').select('*')

  if (supplierId) {
    query.eq('supplier_id', supplierId)
  }

  const { data, error } = await query

  if (error) {
    throw new Error(`Failed to fetch supplier stats: ${error.message}`)
  }

  return data || []
}

/**
 * Get buyer statistics from the view
 * @param buyerId - The buyer ID to filter by (optional)
 * @returns Array of buyer statistics
 */
export async function getBuyerStats(buyerId?: string): Promise<BuyerStats[]> {
  const query = supabase.from('buyer_stats_view').select('*')

  if (buyerId) {
    query.eq('buyer_id', buyerId)
  }

  const { data, error } = await query

  if (error) {
    throw new Error(`Failed to fetch buyer stats: ${error.message}`)
  }

  return data || []
}

/**
 * Get campaign performance data from the view
 * @param filters - Optional filters for campaign performance
 * @returns Array of campaign performance data
 */
export async function getCampaignPerformance(filters?: {
  campaignId?: string
  supplierId?: string
  status?: string
}): Promise<CampaignPerformance[]> {
  const query = supabase.from('campaign_performance_view').select('*')

  if (filters?.campaignId) {
    query.eq('campaign_id', filters.campaignId)
  }

  if (filters?.supplierId) {
    query.eq('supplier_id', filters.supplierId)
  }

  if (filters?.status) {
    query.eq('status', filters.status)
  }

  const { data, error } = await query

  if (error) {
    throw new Error(`Failed to fetch campaign performance: ${error.message}`)
  }

  return data || []
}

/**
 * Database RPC Functions
 */

/**
 * Get user statistics including calls, minutes, revenue, and average call duration
 * @param userId - The user ID to get stats for
 * @returns User statistics object
 */
export async function getUserStats(userId: string): Promise<UserStatsReturn> {
  const { data, error } = await supabase.rpc('get_user_stats', {
    user_id: userId,
  })

  if (error) {
    throw new Error(`Failed to get user stats: ${error.message}`)
  }

  if (!data) {
    throw new Error('No data returned from get_user_stats')
  }

  return data
}

/**
 * Calculate supplier payout for a given date range
 * @param supplierId - The supplier ID
 * @param startDate - Start date for the calculation (ISO string)
 * @param endDate - End date for the calculation (ISO string)
 * @returns Payout calculation result with total amount, call count, and call details
 */
export async function calculateSupplierPayout(
  supplierId: string,
  startDate: string,
  endDate: string
): Promise<SupplierPayoutReturn> {
  const { data, error } = await supabase.rpc('calculate_supplier_payout', {
    supplier_id: supplierId,
    start_date: startDate,
    end_date: endDate,
  })

  if (error) {
    throw new Error(`Failed to calculate supplier payout: ${error.message}`)
  }

  if (!data) {
    throw new Error('No data returned from calculate_supplier_payout')
  }

  return data
}

/**
 * Add credits to a buyer's account
 * @param buyerId - The buyer ID
 * @param amount - Amount to add (positive number)
 * @param paymentIntentId - Stripe payment intent ID for tracking
 * @returns New balance and transaction ID
 */
export async function addBuyerCredits(
  buyerId: string,
  amount: number,
  paymentIntentId: string
): Promise<AddCreditsReturn> {
  if (amount <= 0) {
    throw new Error('Amount must be greater than 0')
  }

  const { data, error } = await supabase.rpc('add_buyer_credits', {
    buyer_id: buyerId,
    amount: amount,
    payment_intent_id: paymentIntentId,
  })

  if (error) {
    throw new Error(`Failed to add buyer credits: ${error.message}`)
  }

  if (!data) {
    throw new Error('No data returned from add_buyer_credits')
  }

  return data
}

/**
 * Deduct from a buyer's balance for a call
 * @param buyerId - The buyer ID
 * @param amount - Amount to deduct (positive number)
 * @param callId - The call ID this deduction is for
 * @returns New balance and transaction ID
 */
export async function deductBuyerBalance(
  buyerId: string,
  amount: number,
  callId: string
): Promise<DeductBalanceReturn> {
  if (amount <= 0) {
    throw new Error('Amount must be greater than 0')
  }

  const { data, error } = await supabase.rpc('deduct_buyer_balance', {
    buyer_id: buyerId,
    amount: amount,
    call_id: callId,
  })

  if (error) {
    throw new Error(`Failed to deduct buyer balance: ${error.message}`)
  }

  if (!data) {
    throw new Error('No data returned from deduct_buyer_balance')
  }

  return data
}

/**
 * Helper function to format dates for database queries
 * @param date - JavaScript Date object
 * @returns ISO string formatted for PostgreSQL
 */
export function formatDateForDB(date: Date): string {
  return date.toISOString()
}

/**
 * Helper to check if a database error is due to insufficient funds
 * @param error - The error object from Supabase
 * @returns boolean indicating if it's an insufficient funds error
 */
export function isInsufficientFundsError(error: unknown): boolean {
  if (error instanceof Error) {
    return (
      error.message.toLowerCase().includes('insufficient') ||
      error.message.toLowerCase().includes('balance')
    )
  }
  return false
}

// Re-export types for convenience
export type {
  SupplierStats,
  BuyerStats,
  CampaignPerformance,
  UserStatsReturn,
  SupplierPayoutReturn,
  AddCreditsReturn,
  DeductBalanceReturn,
}
</file>

<file path="src/lib/error-utils.ts">
/**
 * Utility functions for safe error handling and type guards
 */

/**
 * Type guard to check if a value is an Error
 */
export function isError(error: unknown): error is Error {
  return error instanceof Error
}

/**
 * Safely converts unknown error to Error instance
 */
export function toError(error: unknown): Error {
  if (isError(error)) {
    return error
  }

  if (typeof error === 'string') {
    return new Error(error)
  }

  if (error && typeof error === 'object' && 'message' in error) {
    return new Error(String(error.message))
  }

  return new Error('Unknown error occurred')
}

/**
 * Safely extracts error message from unknown error
 */
export function getErrorMessage(error: unknown): string {
  if (isError(error)) {
    return error.message
  }

  if (typeof error === 'string') {
    return error
  }

  if (error && typeof error === 'object' && 'message' in error) {
    return String(error.message)
  }

  return 'Unknown error occurred'
}

/**
 * Creates a standardized error context for logging
 */
export function createErrorContext(error: unknown): {
  error: Error
  message: string
} {
  const errorInstance = toError(error)
  return {
    error: errorInstance,
    message: errorInstance.message,
  }
}
</file>

<file path="src/lib/scroll.ts">
/**
 * Smooth scroll utility functions
 */

export function scrollToElement(elementId: string, offset: number = 80): void {
  const element = document.getElementById(elementId)
  if (!element) {
    console.warn(`Element with id "${elementId}" not found`)
    return
  }

  const elementPosition = element.getBoundingClientRect().top + window.pageYOffset
  const offsetPosition = elementPosition - offset

  window.scrollTo({
    top: offsetPosition,
    behavior: 'smooth',
  })
}

export function scrollToTop(): void {
  window.scrollTo({
    top: 0,
    behavior: 'smooth',
  })
}

export function handleAnchorClick(
  event: React.MouseEvent<HTMLAnchorElement>,
  targetId: string,
  offset: number = 80
): void {
  event.preventDefault()
  scrollToElement(targetId, offset)
}
</file>

<file path="src/lib/supabase.ts">
import { createClient } from '@supabase/supabase-js'
import type { Database } from '../types/database'

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error('Missing Supabase environment variables')
}

export const supabase = createClient<Database>(supabaseUrl, supabaseAnonKey, {
  auth: {
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: true,
  },
})
</file>

<file path="src/pages/auth/CLAUDE.md">
# Authentication Pages

# Page Structure
- `LoginPage.tsx` - User login interface
- `RegisterPage.tsx` - User registration
- `ForgotPasswordPage.tsx` - Password reset
- `VerifyEmailPage.tsx` - Email verification
- `ResetPasswordPage.tsx` - Password reset completion

# Login Page Implementation
```tsx
export function LoginPage() {
  const navigate = useNavigate();
  const location = useLocation();
  const { user } = useAuth();
  
  const redirectTo = location.state?.from?.pathname || '/dashboard';
  
  useEffect(() => {
    if (user) {
      navigate(redirectTo);
    }
  }, [user, navigate, redirectTo]);
  
  const handleLoginSuccess = (user: User) => {
    // Track login event
    analytics.track('user_login', {
      user_id: user.id,
      role: user.role,
      method: 'email',
    });
    
    navigate(redirectTo);
  };
  
  return (
    <PublicLayout>
      <div className="auth-page">
        <div className="auth-container">
          <h1>Sign In to DCE Platform</h1>
          <LoginForm onSuccess={handleLoginSuccess} />
          <div className="auth-links">
            <Link to="/auth/forgot-password">Forgot password?</Link>
            <Link to="/auth/register">Create account</Link>
          </div>
        </div>
      </div>
    </PublicLayout>
  );
}
```

# Registration Flow
```tsx
export function RegisterPage() {
  const [step, setStep] = useState(1);
  const [formData, setFormData] = useState<RegistrationData>({});
  
  const handleStepComplete = (stepData: Partial<RegistrationData>) => {
    setFormData(prev => ({ ...prev, ...stepData }));
    setStep(prev => prev + 1);
  };
  
  const handleRegistrationComplete = async (finalData: RegistrationData) => {
    try {
      await authService.register(finalData);
      navigate('/auth/verify-email');
    } catch (error) {
      // Handle registration error
    }
  };
  
  return (
    <PublicLayout>
      <div className="registration-page">
        <RegistrationStepper currentStep={step} totalSteps={3} />
        
        {step === 1 && (
          <BasicInfoStep onComplete={handleStepComplete} />
        )}
        {step === 2 && (
          <CompanyInfoStep 
            data={formData}
            onComplete={handleStepComplete}
          />
        )}
        {step === 3 && (
          <VerificationStep
            data={formData}
            onComplete={handleRegistrationComplete}
          />
        )}
      </div>
    </PublicLayout>
  );
}
```

# Role-Specific Registration
```tsx
interface RegistrationStepProps {
  userType: 'supplier' | 'buyer';
  onComplete: (data: Partial<RegistrationData>) => void;
}

export function CompanyInfoStep({ userType, onComplete }: RegistrationStepProps) {
  const form = useForm({
    resolver: zodResolver(getRegistrationSchema(userType)),
  });
  
  const fields = useMemo(() => {
    const baseFields = [
      { name: 'company_name', label: 'Company Name', required: true },
      { name: 'phone', label: 'Phone Number', required: true },
      { name: 'website', label: 'Website', required: false },
    ];
    
    if (userType === 'supplier') {
      return [
        ...baseFields,
        { name: 'traffic_sources', label: 'Traffic Sources', type: 'multiselect' },
        { name: 'monthly_volume', label: 'Monthly Call Volume', type: 'number' },
      ];
    } else {
      return [
        ...baseFields,
        { name: 'industry', label: 'Industry', type: 'select' },
        { name: 'monthly_budget', label: 'Monthly Budget', type: 'currency' },
      ];
    }
  }, [userType]);
  
  return (
    <form onSubmit={form.handleSubmit(onComplete)}>
      {fields.map(field => (
        <FormField
          key={field.name}
          {...field}
          {...form.register(field.name)}
          error={form.formState.errors[field.name]?.message}
        />
      ))}
      <Button type="submit">Continue</Button>
    </form>
  );
}
```

# Email Verification
```tsx
export function VerifyEmailPage() {
  const [verificationSent, setVerificationSent] = useState(false);
  const { user } = useAuth();
  
  const resendVerification = async () => {
    try {
      await authService.resendVerification();
      setVerificationSent(true);
      toast.success('Verification email sent!');
    } catch (error) {
      toast.error('Failed to send verification email');
    }
  };
  
  return (
    <PublicLayout>
      <div className="verify-email-page">
        <div className="verification-container">
          <CheckCircleIcon className="verification-icon" />
          <h1>Check Your Email</h1>
          <p>
            We've sent a verification link to <strong>{user?.email}</strong>
          </p>
          <p>Click the link in the email to verify your account.</p>
          
          <div className="verification-actions">
            <Button 
              onClick={resendVerification}
              disabled={verificationSent}
              variant="outline"
            >
              {verificationSent ? 'Email Sent' : 'Resend Email'}
            </Button>
            <Link to="/auth/login">Back to Login</Link>
          </div>
        </div>
      </div>
    </PublicLayout>
  );
}
```

# Password Reset Flow
```tsx
export function ForgotPasswordPage() {
  const [emailSent, setEmailSent] = useState(false);
  const form = useForm<{ email: string }>({
    resolver: zodResolver(z.object({
      email: z.string().email('Invalid email address'),
    })),
  });
  
  const handleSubmit = async (data: { email: string }) => {
    try {
      await authService.requestPasswordReset(data.email);
      setEmailSent(true);
    } catch (error) {
      form.setError('email', {
        message: 'Failed to send reset email',
      });
    }
  };
  
  if (emailSent) {
    return (
      <PublicLayout>
        <div className="password-reset-sent">
          <h1>Reset Link Sent</h1>
          <p>Check your email for password reset instructions.</p>
          <Link to="/auth/login">Back to Login</Link>
        </div>
      </PublicLayout>
    );
  }
  
  return (
    <PublicLayout>
      <div className="forgot-password-page">
        <form onSubmit={form.handleSubmit(handleSubmit)}>
          <h1>Reset Password</h1>
          <Input
            {...form.register('email')}
            type="email"
            label="Email Address"
            error={form.formState.errors.email?.message}
          />
          <Button 
            type="submit" 
            loading={form.formState.isSubmitting}
          >
            Send Reset Link
          </Button>
          <Link to="/auth/login">Back to Login</Link>
        </form>
      </div>
    </PublicLayout>
  );
}
```

# Security Features
- Rate limiting on auth attempts
- CAPTCHA for suspicious activity
- Session management
- Password strength validation
- Account lockout protection

# SEO and Meta Tags
```tsx
export function LoginPage() {
  useEffect(() => {
    document.title = 'Sign In - DCE Platform';
    document.querySelector('meta[name="description"]')?.setAttribute(
      'content',
      'Sign in to your DCE Platform account to manage campaigns and track performance.'
    );
  }, []);
  
  // Rest of component...
}
```

# Analytics Integration
- Track authentication events
- Monitor conversion rates
- A/B test registration flows
- User journey analysis

# Error Handling
- Network error recovery
- Invalid credential feedback
- Account status notifications
- Clear error messages

# Accessibility Features
- Proper form labels
- Screen reader support
- Keyboard navigation
- Focus management
- Error announcements

# CRITICAL RULES
- NO regex for form validation - use Zod
- NO any types in form interfaces
- ALWAYS handle authentication errors gracefully
- ALWAYS provide clear user feedback
- IMPLEMENT proper security measures
- TEST all authentication flows
- ENSURE accessibility compliance
- TRACK user behavior analytically
</file>

<file path="src/pages/auth/ResetPasswordPage.tsx">
import { useState, useEffect } from 'react'
import { Link, useNavigate, useSearchParams } from 'react-router-dom'
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { z } from 'zod'
import { supabase } from '../../lib/supabase'

const resetPasswordSchema = z
  .object({
    password: z
      .string()
      .min(8, 'Password must be at least 8 characters')
      .regex(/[A-Z]/, 'Password must contain at least one uppercase letter')
      .regex(/[a-z]/, 'Password must contain at least one lowercase letter')
      .regex(/[0-9]/, 'Password must contain at least one number'),
    confirmPassword: z.string(),
  })
  .refine((data) => data.password === data.confirmPassword, {
    message: "Passwords don't match",
    path: ['confirmPassword'],
  })

type ResetPasswordFormData = z.infer<typeof resetPasswordSchema>

export default function ResetPasswordPage() {
  const navigate = useNavigate()
  const [searchParams] = useSearchParams()
  const [error, setError] = useState('')
  const [loading, setLoading] = useState(false)
  const [success, setSuccess] = useState(false)

  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<ResetPasswordFormData>({
    resolver: zodResolver(resetPasswordSchema),
  })

  useEffect(() => {
    // Handle the password reset session from the URL
    const handlePasswordReset = async () => {
      const accessToken = searchParams.get('access_token')
      const refreshToken = searchParams.get('refresh_token')

      if (accessToken && refreshToken) {
        const { error } = await supabase.auth.setSession({
          access_token: accessToken,
          refresh_token: refreshToken,
        })

        if (error) {
          setError('Invalid or expired reset link')
        }
      } else {
        setError('Invalid reset link')
      }
    }

    handlePasswordReset()
  }, [searchParams])

  const onSubmit = async (data: ResetPasswordFormData) => {
    setError('')
    setLoading(true)

    try {
      const { error } = await supabase.auth.updateUser({
        password: data.password,
      })

      if (error) throw error

      setSuccess(true)

      // Redirect to login after 3 seconds
      setTimeout(() => {
        navigate('/login')
      }, 3000)
    } catch (err: unknown) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to reset password'
      setError(errorMessage)
    } finally {
      setLoading(false)
    }
  }

  if (success) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
        <div className="max-w-md w-full space-y-8">
          <div className="text-center">
            <h2 className="mt-6 text-3xl font-extrabold text-gray-900">
              Password updated successfully
            </h2>
            <p className="mt-2 text-sm text-gray-600">
              Your password has been updated. You will be redirected to the login page shortly.
            </p>
            <Link
              to="/login"
              className="mt-4 inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-primary-600 bg-primary-100 hover:bg-primary-200"
            >
              Go to login now
            </Link>
          </div>
        </div>
      </div>
    )
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
      <div className="max-w-md w-full space-y-8">
        <div>
          <h2 className="mt-6 text-center text-3xl font-extrabold text-gray-900">
            Reset your password
          </h2>
          <p className="mt-2 text-center text-sm text-gray-600">Enter your new password below.</p>
        </div>

        <form className="mt-8 space-y-6" onSubmit={handleSubmit(onSubmit)}>
          <div className="space-y-4">
            <div>
              <label htmlFor="password" className="block text-sm font-medium text-gray-700">
                New Password
              </label>
              <input
                {...register('password')}
                type="password"
                autoComplete="new-password"
                className="mt-1 appearance-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-md focus:outline-none focus:ring-primary-500 focus:border-primary-500 focus:z-10 sm:text-sm"
                placeholder="Create a new password"
              />
              {errors.password && (
                <p className="mt-1 text-sm text-red-600">{errors.password.message}</p>
              )}
            </div>

            <div>
              <label htmlFor="confirmPassword" className="block text-sm font-medium text-gray-700">
                Confirm New Password
              </label>
              <input
                {...register('confirmPassword')}
                type="password"
                autoComplete="new-password"
                className="mt-1 appearance-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-md focus:outline-none focus:ring-primary-500 focus:border-primary-500 focus:z-10 sm:text-sm"
                placeholder="Confirm your new password"
              />
              {errors.confirmPassword && (
                <p className="mt-1 text-sm text-red-600">{errors.confirmPassword.message}</p>
              )}
            </div>
          </div>

          {error && (
            <div className="rounded-md bg-red-50 p-4">
              <div className="flex">
                <div className="ml-3">
                  <h3 className="text-sm font-medium text-red-800">{error}</h3>
                </div>
              </div>
            </div>
          )}

          <div>
            <button
              type="submit"
              disabled={loading}
              className="group relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-primary-600 hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {loading ? 'Updating password...' : 'Update password'}
            </button>
          </div>

          <div className="text-center">
            <Link to="/login" className="font-medium text-primary-600 hover:text-primary-500">
              Back to login
            </Link>
          </div>
        </form>
      </div>
    </div>
  )
}
</file>

<file path="src/pages/billing/BillingPage.tsx">
export default function BillingPage() {
  return (
    <div className="py-6">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <h1 className="text-2xl font-semibold text-gray-900">Billing</h1>
        <p className="mt-1 text-sm text-gray-600">
          Manage your billing and payment methods.
        </p>
        
        <div className="mt-8">
          <div className="bg-white shadow overflow-hidden sm:rounded-md p-6">
            <p className="text-gray-500">Billing interface coming soon...</p>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/pages/billing/CLAUDE.md">
# Billing Pages

# Page Structure
- `BillingDashboard.tsx` - Main billing overview
- `PaymentMethods.tsx` - Payment method management
- `InvoiceHistory.tsx` - Invoice viewing and management
- `BillingSettings.tsx` - Billing preferences
- `AddPaymentMethod.tsx` - New payment method form

# Billing Dashboard
```tsx
export function BillingDashboard() {
  const { user } = useAuth();
  const { data: billingData, loading } = useBilling(user?.id);
  
  if (loading) return <BillingSkeleton />;
  
  return (
    <AppLayout>
      <div className="billing-dashboard">
        <PageHeader title="Billing & Payments" />
        
        <div className="billing-overview">
          <BillingCard
            title="Current Balance"
            amount={billingData.currentBalance}
            status={billingData.accountStatus}
          />
          <BillingCard
            title="Monthly Spend"
            amount={billingData.monthlySpend}
            trend={billingData.spendTrend}
          />
          <BillingCard
            title="Next Payment"
            amount={billingData.nextPayment?.amount}
            date={billingData.nextPayment?.dueDate}
          />
        </div>
        
        <div className="billing-sections">
          <PaymentMethodsSection methods={billingData.paymentMethods} />
          <RecentInvoicesSection invoices={billingData.recentInvoices} />
          <UsageMetricsSection usage={billingData.usage} />
        </div>
      </div>
    </AppLayout>
  );
}
```

# Payment Method Management
```tsx
interface PaymentMethodsProps {
  methods: PaymentMethod[];
  onMethodAdded: (method: PaymentMethod) => void;
  onMethodRemoved: (methodId: string) => void;
}

export function PaymentMethods({ methods, onMethodAdded, onMethodRemoved }: PaymentMethodsProps) {
  const [showAddForm, setShowAddForm] = useState(false);
  
  const handleSetDefault = async (methodId: string) => {
    try {
      await billingService.setDefaultPaymentMethod(methodId);
      toast.success('Default payment method updated');
    } catch (error) {
      toast.error('Failed to update payment method');
    }
  };
  
  return (
    <div className="payment-methods">
      <div className="section-header">
        <h2>Payment Methods</h2>
        <Button onClick={() => setShowAddForm(true)}>
          Add Payment Method
        </Button>
      </div>
      
      <div className="payment-methods-list">
        {methods.map(method => (
          <PaymentMethodCard
            key={method.id}
            method={method}
            onSetDefault={() => handleSetDefault(method.id)}
            onRemove={() => onMethodRemoved(method.id)}
          />
        ))}
      </div>
      
      {showAddForm && (
        <AddPaymentMethodModal
          onClose={() => setShowAddForm(false)}
          onSuccess={onMethodAdded}
        />
      )}
    </div>
  );
}
```

# Stripe Payment Integration
```tsx
export function AddPaymentMethodModal({ onClose, onSuccess }: AddPaymentMethodModalProps) {
  const stripe = useStripe();
  const elements = useElements();
  const [processing, setProcessing] = useState(false);
  
  const handleSubmit = async (event: React.FormEvent) => {
    event.preventDefault();
    
    if (!stripe || !elements) return;
    
    setProcessing(true);
    
    const cardElement = elements.getElement(CardElement);
    
    const { error, paymentMethod } = await stripe.createPaymentMethod({
      type: 'card',
      card: cardElement!,
    });
    
    if (error) {
      toast.error(error.message);
      setProcessing(false);
      return;
    }
    
    try {
      await billingService.addPaymentMethod(paymentMethod.id);
      onSuccess(paymentMethod);
      onClose();
    } catch (error) {
      toast.error('Failed to add payment method');
    } finally {
      setProcessing(false);
    }
  };
  
  return (
    <Modal onClose={onClose}>
      <form onSubmit={handleSubmit}>
        <h2>Add Payment Method</h2>
        <CardElement
          options={{
            style: {
              base: {
                fontSize: '16px',
                color: '#424770',
                '::placeholder': {
                  color: '#aab7c4',
                },
              },
            },
          }}
        />
        <div className="modal-actions">
          <Button type="button" variant="outline" onClick={onClose}>
            Cancel
          </Button>
          <Button type="submit" loading={processing}>
            Add Payment Method
          </Button>
        </div>
      </form>
    </Modal>
  );
}
```

# Invoice Management
```tsx
export function InvoiceHistory() {
  const { data: invoices, loading } = useInvoices();
  const [selectedInvoice, setSelectedInvoice] = useState<Invoice | null>(null);
  
  const downloadInvoice = async (invoiceId: string) => {
    try {
      const pdf = await billingService.downloadInvoice(invoiceId);
      downloadFile(pdf, `invoice-${invoiceId}.pdf`);
    } catch (error) {
      toast.error('Failed to download invoice');
    }
  };
  
  return (
    <div className="invoice-history">
      <PageHeader title="Invoice History" />
      
      <DataTable
        data={invoices}
        columns={[
          { key: 'invoiceNumber', label: 'Invoice #' },
          { key: 'date', label: 'Date', render: (date) => formatDate(date) },
          { key: 'amount', label: 'Amount', render: (amount) => formatCurrency(amount) },
          { key: 'status', label: 'Status', render: (status) => <StatusBadge status={status} /> },
          {
            key: 'actions',
            label: 'Actions',
            render: (_, invoice) => (
              <div className="table-actions">
                <Button
                  size="sm"
                  variant="outline"
                  onClick={() => setSelectedInvoice(invoice)}
                >
                  View
                </Button>
                <Button
                  size="sm"
                  variant="outline"
                  onClick={() => downloadInvoice(invoice.id)}
                >
                  Download
                </Button>
              </div>
            ),
          },
        ]}
        loading={loading}
      />
      
      {selectedInvoice && (
        <InvoiceDetailModal
          invoice={selectedInvoice}
          onClose={() => setSelectedInvoice(null)}
        />
      )}
    </div>
  );
}
```

# Usage Tracking
```tsx
export function UsageMetrics() {
  const { data: usage } = useUsageMetrics();
  
  return (
    <div className="usage-metrics">
      <h3>Usage This Month</h3>
      
      <div className="usage-grid">
        <UsageCard
          title="API Calls"
          current={usage.apiCalls}
          limit={usage.apiCallsLimit}
          unit="calls"
        />
        <UsageCard
          title="Storage"
          current={usage.storage}
          limit={usage.storageLimit}
          unit="GB"
        />
        <UsageCard
          title="Bandwidth"
          current={usage.bandwidth}
          limit={usage.bandwidthLimit}
          unit="GB"
        />
      </div>
      
      <UsageChart data={usage.dailyUsage} />
    </div>
  );
}
```

# Billing Alerts
```tsx
export function BillingAlerts() {
  const { data: alerts } = useBillingAlerts();
  
  return (
    <div className="billing-alerts">
      {alerts.map(alert => (
        <Alert key={alert.id} type={alert.severity}>
          <AlertIcon type={alert.type} />
          <div className="alert-content">
            <h4>{alert.title}</h4>
            <p>{alert.description}</p>
            {alert.action && (
              <Button
                size="sm"
                onClick={() => handleAlertAction(alert.id, alert.action)}
              >
                {alert.action.label}
              </Button>
            )}
          </div>
        </Alert>
      ))}
    </div>
  );
}
```

# Auto-billing Setup
```tsx
export function AutoBillingSettings() {
  const { data: settings, update } = useAutoBillingSettings();
  
  const handleToggleAutoBilling = async (enabled: boolean) => {
    try {
      await update({ autoBillingEnabled: enabled });
      toast.success('Auto-billing settings updated');
    } catch (error) {
      toast.error('Failed to update settings');
    }
  };
  
  return (
    <div className="auto-billing-settings">
      <h3>Auto-billing Settings</h3>
      
      <div className="setting-item">
        <div className="setting-info">
          <h4>Enable Auto-billing</h4>
          <p>Automatically charge your default payment method when balance is low</p>
        </div>
        <Switch
          checked={settings.autoBillingEnabled}
          onChange={handleToggleAutoBilling}
        />
      </div>
      
      {settings.autoBillingEnabled && (
        <>
          <div className="setting-item">
            <label>Minimum Balance Threshold</label>
            <CurrencyInput
              value={settings.minBalance}
              onChange={(value) => update({ minBalance: value })}
            />
          </div>
          
          <div className="setting-item">
            <label>Auto-recharge Amount</label>
            <CurrencyInput
              value={settings.rechargeAmount}
              onChange={(value) => update({ rechargeAmount: value })}
            />
          </div>
        </>
      )}
    </div>
  );
}
```

# Tax Management
- Tax calculation integration
- Tax exemption certificate upload
- Tax reporting for compliance
- Multi-jurisdiction support

# Payment Security
- PCI DSS compliance
- Encrypted payment data
- Fraud detection
- Secure payment processing

# Subscription Management
- Plan upgrades/downgrades
- Billing cycle management
- Proration calculations
- Cancel/reactivate subscriptions

# CRITICAL RULES
- NO regex in billing logic
- NO any types in payment interfaces
- ALWAYS handle payment errors gracefully
- ALWAYS validate payment amounts
- SECURE payment data handling
- NEVER log sensitive payment info
- IMPLEMENT proper error recovery
- TEST payment flows thoroughly
- COMPLY with financial regulations
- AUDIT all billing transactions
</file>

<file path="src/pages/calls/CallsPage.tsx">
export default function CallsPage() {
  return (
    <div className="py-6">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <h1 className="text-2xl font-semibold text-gray-900">Calls</h1>
        <p className="mt-1 text-sm text-gray-600">
          View and manage your call history.
        </p>
        
        <div className="mt-8">
          <div className="bg-white shadow overflow-hidden sm:rounded-md p-6">
            <p className="text-gray-500">Call tracking interface coming soon...</p>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/pages/calls/CLAUDE.md">
# Call Tracking Pages

# Page Structure
- `CallDashboard.tsx` - Real-time call monitoring
- `CallDetails.tsx` - Individual call analysis
- `CallHistory.tsx` - Historical call data
- `CallRecordings.tsx` - Call recording playback
- `LiveCallTracker.tsx` - Active call monitoring

# Real-time Call Dashboard
```tsx
export function CallDashboard() {
  const { user } = useAuth();
  const { data: activeCalls, loading } = useActiveCalls();
  const { data: callStats } = useCallStats();
  
  // Real-time subscription for call updates
  useEffect(() => {
    const subscription = supabase
      .channel('call-updates')
      .on('postgres_changes', {
        event: '*',
        schema: 'public',
        table: 'calls',
      }, (payload) => {
        handleCallUpdate(payload);
      })
      .subscribe();
      
    return () => supabase.removeChannel(subscription);
  }, []);
  
  return (
    <AppLayout>
      <div className="call-dashboard">
        <PageHeader title="Call Tracking" />
        
        <div className="call-stats-grid">
          <StatCard
            title="Active Calls"
            value={callStats.activeCalls}
            icon={PhoneIcon}
            status="success"
          />
          <StatCard
            title="Calls Today"
            value={callStats.callsToday}
            trend={callStats.todayTrend}
            icon={ChartBarIcon}
          />
          <StatCard
            title="Conversion Rate"
            value={`${callStats.conversionRate}%`}
            trend={callStats.conversionTrend}
            icon={TrendingUpIcon}
          />
          <StatCard
            title="Avg Duration"
            value={formatDuration(callStats.avgDuration)}
            icon={ClockIcon}
          />
        </div>
        
        <div className="call-monitoring">
          <LiveCallList calls={activeCalls} loading={loading} />
          <CallActivityFeed />
        </div>
        
        <CallPerformanceCharts data={callStats.chartData} />
      </div>
    </AppLayout>
  );
}
```

# Live Call Monitoring
```tsx
interface LiveCallListProps {
  calls: ActiveCall[];
  loading: boolean;
}

export function LiveCallList({ calls, loading }: LiveCallListProps) {
  const [selectedCall, setSelectedCall] = useState<string | null>(null);
  
  if (loading) return <CallListSkeleton />;
  
  return (
    <div className="live-call-list">
      <div className="section-header">
        <h3>Active Calls ({calls.length})</h3>
        <div className="call-controls">
          <Button size="sm" onClick={() => window.location.reload()}>
            <ArrowPathIcon className="h-4 w-4" />
            Refresh
          </Button>
        </div>
      </div>
      
      <div className="call-list">
        {calls.map(call => (
          <CallListItem
            key={call.id}
            call={call}
            isSelected={selectedCall === call.id}
            onClick={() => setSelectedCall(call.id)}
          />
        ))}
      </div>
      
      {calls.length === 0 && (
        <EmptyState
          icon={PhoneIcon}
          title="No active calls"
          description="When calls are in progress, they'll appear here"
        />
      )}
    </div>
  );
}
```

# Call Details Analysis
```tsx
interface CallDetailsPageProps {
  callId: string;
}

export function CallDetailsPage({ callId }: CallDetailsPageProps) {
  const { data: call, loading } = useCall(callId);
  const { data: fraudAnalysis } = useFraudAnalysis(callId);
  const { data: recordings } = useCallRecordings(callId);
  
  if (loading) return <CallDetailsSkeleton />;
  if (!call) return <NotFound />;
  
  return (
    <AppLayout>
      <div className="call-details">
        <PageHeader
          title={`Call #${call.id.slice(0, 8)}`}
          breadcrumbs={[
            { label: 'Calls', href: '/calls' },
            { label: 'Call Details' },
          ]}
        />
        
        <div className="call-overview">
          <CallStatusCard call={call} />
          <CallMetricsCard call={call} />
          <CallTimelineCard call={call} />
        </div>
        
        <div className="call-analysis">
          <CallQualityAnalysis call={call} />
          {fraudAnalysis && (
            <FraudAnalysisCard analysis={fraudAnalysis} />
          )}
          {recordings.length > 0 && (
            <CallRecordingsSection recordings={recordings} />
          )}
        </div>
        
        <CallActivityLog callId={callId} />
      </div>
    </AppLayout>
  );
}
```

# Call Quality Analysis
```tsx
interface CallQualityAnalysisProps {
  call: Call;
}

export function CallQualityAnalysis({ call }: CallQualityAnalysisProps) {
  const qualityMetrics = [
    {
      name: 'Duration Score',
      value: call.quality_metrics.duration_score,
      description: 'Based on call length vs. expected duration',
    },
    {
      name: 'Engagement Score',
      value: call.quality_metrics.engagement_score,
      description: 'Based on conversation analysis',
    },
    {
      name: 'Intent Score',
      value: call.quality_metrics.intent_score,
      description: 'Likelihood of genuine purchase intent',
    },
  ];
  
  return (
    <div className="call-quality-analysis">
      <h3>Quality Analysis</h3>
      
      <div className="overall-score">
        <div className="score-circle">
          <span className="score-value">{call.quality_score}</span>
          <span className="score-label">Overall Score</span>
        </div>
      </div>
      
      <div className="quality-metrics">
        {qualityMetrics.map(metric => (
          <div key={metric.name} className="metric-item">
            <div className="metric-header">
              <span className="metric-name">{metric.name}</span>
              <span className="metric-value">{metric.value}/100</span>
            </div>
            <ProgressBar value={metric.value} max={100} />
            <p className="metric-description">{metric.description}</p>
          </div>
        ))}
      </div>
    </div>
  );
}
```

# Call Recording Playback
```tsx
export function CallRecordingsSection({ recordings }: { recordings: CallRecording[] }) {
  const [currentRecording, setCurrentRecording] = useState<CallRecording | null>(null);
  const [isPlaying, setIsPlaying] = useState(false);
  const audioRef = useRef<HTMLAudioElement>(null);
  
  const playRecording = (recording: CallRecording) => {
    setCurrentRecording(recording);
    if (audioRef.current) {
      audioRef.current.src = recording.url;
      audioRef.current.play();
      setIsPlaying(true);
    }
  };
  
  const togglePlayback = () => {
    if (audioRef.current) {
      if (isPlaying) {
        audioRef.current.pause();
      } else {
        audioRef.current.play();
      }
      setIsPlaying(!isPlaying);
    }
  };
  
  return (
    <div className="call-recordings">
      <h3>Call Recordings</h3>
      
      <div className="recordings-list">
        {recordings.map(recording => (
          <div key={recording.id} className="recording-item">
            <div className="recording-info">
              <span className="recording-name">{recording.name}</span>
              <span className="recording-duration">
                {formatDuration(recording.duration)}
              </span>
            </div>
            <div className="recording-controls">
              <Button
                size="sm"
                onClick={() => playRecording(recording)}
                disabled={!recording.url}
              >
                <PlayIcon className="h-4 w-4" />
                Play
              </Button>
              <Button
                size="sm"
                variant="outline"
                onClick={() => downloadRecording(recording)}
              >
                <ArrowDownTrayIcon className="h-4 w-4" />
                Download
              </Button>
            </div>
          </div>
        ))}
      </div>
      
      {currentRecording && (
        <div className="audio-player">
          <audio
            ref={audioRef}
            onEnded={() => setIsPlaying(false)}
            onPlay={() => setIsPlaying(true)}
            onPause={() => setIsPlaying(false)}
          />
          
          <div className="player-controls">
            <Button onClick={togglePlayback}>
              {isPlaying ? (
                <PauseIcon className="h-5 w-5" />
              ) : (
                <PlayIcon className="h-5 w-5" />
              )}
            </Button>
            <span className="player-title">{currentRecording.name}</span>
          </div>
        </div>
      )}
    </div>
  );
}
```

# Call History with Filtering
```tsx
export function CallHistory() {
  const [filters, setFilters] = useState<CallFilters>({
    dateRange: { start: '', end: '' },
    status: 'all',
    campaign: '',
    supplier: '',
  });
  
  const { data: calls, loading, hasMore, loadMore } = useCallHistory(filters);
  
  return (
    <AppLayout>
      <div className="call-history">
        <PageHeader title="Call History" />
        
        <CallFilters
          filters={filters}
          onChange={setFilters}
        />
        
        <DataTable
          data={calls}
          columns={[
            {
              key: 'created_at',
              label: 'Time',
              render: (date) => formatDateTime(date),
            },
            {
              key: 'caller_number',
              label: 'Caller',
              render: (number) => formatPhoneNumber(number),
            },
            {
              key: 'campaign',
              label: 'Campaign',
              render: (campaign) => campaign?.name || 'N/A',
            },
            {
              key: 'duration',
              label: 'Duration',
              render: (duration) => formatDuration(duration),
            },
            {
              key: 'status',
              label: 'Status',
              render: (status) => <StatusBadge status={status} />,
            },
            {
              key: 'quality_score',
              label: 'Quality',
              render: (score) => (
                <QualityScore score={score} />
              ),
            },
            {
              key: 'actions',
              label: 'Actions',
              render: (_, call) => (
                <CallActions call={call} />
              ),
            },
          ]}
          loading={loading}
          onRowClick={(call) => navigate(`/calls/${call.id}`)}
        />
        
        {hasMore && (
          <div className="load-more">
            <Button onClick={loadMore} loading={loading}>
              Load More Calls
            </Button>
          </div>
        )}
      </div>
    </AppLayout>
  );
}
```

# Real-time Call Notifications
```tsx
export function useCallNotifications() {
  const { user } = useAuth();
  
  useEffect(() => {
    if (!user) return;
    
    const subscription = supabase
      .channel('call-notifications')
      .on('postgres_changes', {
        event: 'INSERT',
        schema: 'public',
        table: 'calls',
        filter: `supplier_id=eq.${user.id}`,
      }, (payload) => {
        const newCall = payload.new as Call;
        
        // Show notification for new calls
        toast.success(`New call received: ${newCall.caller_number}`, {
          action: {
            label: 'View',
            onClick: () => navigate(`/calls/${newCall.id}`),
          },
        });
        
        // Play notification sound
        playNotificationSound();
      })
      .on('postgres_changes', {
        event: 'UPDATE',
        schema: 'public',
        table: 'calls',
        filter: `supplier_id=eq.${user.id}`,
      }, (payload) => {
        const updatedCall = payload.new as Call;
        
        // Notify on call completion
        if (updatedCall.status === 'completed') {
          toast.info(`Call completed: $${updatedCall.payout_amount}`);
        }
      })
      .subscribe();
      
    return () => supabase.removeChannel(subscription);
  }, [user]);
}
```

# Call Analytics
- Real-time call volume tracking
- Conversion rate analysis
- Quality score trends
- Fraud detection patterns
- Revenue attribution

# Mobile Optimization
- Touch-friendly call controls
- Responsive call tables
- Mobile audio player
- Offline call data viewing

# Performance Features
- Virtual scrolling for large call lists
- Progressive data loading
- Efficient real-time updates
- Background call status sync

# CRITICAL RULES
- NO regex in call tracking logic
- NO any types in call interfaces
- ALWAYS handle real-time data safely
- ALWAYS validate call data integrity
- IMPLEMENT proper error recovery
- TEST real-time features thoroughly
- ENSURE data consistency
- MAINTAIN call privacy standards
</file>

<file path="src/pages/campaigns/CLAUDE.md">
# Campaign Management Pages

# Page Structure
- `CampaignDashboard.tsx` - Campaign overview and management
- `CreateCampaign.tsx` - New campaign creation wizard
- `EditCampaign.tsx` - Campaign editing interface
- `CampaignDetails.tsx` - Individual campaign analytics
- `CampaignSettings.tsx` - Campaign configuration

# Campaign Dashboard
```tsx
export function CampaignDashboard() {
  const { user } = useAuth();
  const { data: campaigns, loading } = useCampaigns(user?.id);
  const [selectedCampaign, setSelectedCampaign] = useState<string | null>(null);
  
  const handleCampaignAction = async (action: CampaignAction, campaignId: string) => {
    try {
      switch (action) {
        case 'pause':
          await campaignService.pauseCampaign(campaignId);
          toast.success('Campaign paused successfully');
          break;
        case 'resume':
          await campaignService.resumeCampaign(campaignId);
          toast.success('Campaign resumed successfully');
          break;
        case 'duplicate':
          const duplicated = await campaignService.duplicateCampaign(campaignId);
          navigate(`/campaigns/${duplicated.id}/edit`);
          break;
      }
    } catch (error) {
      toast.error('Failed to perform campaign action');
    }
  };
  
  return (
    <AppLayout>
      <div className="campaign-dashboard">
        <PageHeader
          title="Campaign Management"
          action={
            <Button onClick={() => navigate('/campaigns/create')}>
              <PlusIcon className="h-4 w-4" />
              Create Campaign
            </Button>
          }
        />
        
        <div className="campaign-stats">
          <CampaignStatsCards campaigns={campaigns} />
        </div>
        
        <div className="campaign-filters">
          <CampaignFilters onFiltersChange={handleFiltersChange} />
        </div>
        
        <div className="campaigns-grid">
          {campaigns.map(campaign => (
            <CampaignCard
              key={campaign.id}
              campaign={campaign}
              onAction={(action) => handleCampaignAction(action, campaign.id)}
              onClick={() => navigate(`/campaigns/${campaign.id}`)}
            />
          ))}
        </div>
        
        {campaigns.length === 0 && (
          <EmptyState
            icon={FolderIcon}
            title="No campaigns yet"
            description="Create your first campaign to start receiving calls"
            action={
              <Button onClick={() => navigate('/campaigns/create')}>
                Create Campaign
              </Button>
            }
          />
        )}
      </div>
    </AppLayout>
  );
}
```

# Campaign Creation Wizard
```tsx
export function CreateCampaign() {
  const [currentStep, setCurrentStep] = useState(1);
  const [campaignData, setCampaignData] = useState<Partial<Campaign>>({});
  const navigate = useNavigate();
  
  const steps = [
    { id: 1, name: 'Basic Info', component: BasicInfoStep },
    { id: 2, name: 'Targeting', component: TargetingStep },
    { id: 3, name: 'Pricing', component: PricingStep },
    { id: 4, name: 'Review', component: ReviewStep },
  ];
  
  const handleStepComplete = (stepData: Partial<Campaign>) => {
    setCampaignData(prev => ({ ...prev, ...stepData }));
    if (currentStep < steps.length) {
      setCurrentStep(prev => prev + 1);
    }
  };
  
  const handleCampaignCreate = async (finalData: Campaign) => {
    try {
      const campaign = await campaignService.createCampaign(finalData);
      toast.success('Campaign created successfully!');
      navigate(`/campaigns/${campaign.id}`);
    } catch (error) {
      toast.error('Failed to create campaign');
    }
  };
  
  const CurrentStepComponent = steps[currentStep - 1].component;
  
  return (
    <AppLayout>
      <div className="create-campaign">
        <PageHeader
          title="Create New Campaign"
          breadcrumbs={[
            { label: 'Campaigns', href: '/campaigns' },
            { label: 'Create' },
          ]}
        />
        
        <div className="wizard-container">
          <WizardSteps
            steps={steps}
            currentStep={currentStep}
            onStepClick={setCurrentStep}
          />
          
          <div className="wizard-content">
            <CurrentStepComponent
              data={campaignData}
              onComplete={currentStep === steps.length ? handleCampaignCreate : handleStepComplete}
              onBack={() => setCurrentStep(prev => Math.max(1, prev - 1))}
            />
          </div>
        </div>
      </div>
    </AppLayout>
  );
}
```

# Campaign Targeting Configuration
```tsx
interface TargetingStepProps {
  data: Partial<Campaign>;
  onComplete: (data: Partial<Campaign>) => void;
  onBack: () => void;
}

export function TargetingStep({ data, onComplete, onBack }: TargetingStepProps) {
  const form = useForm({
    resolver: zodResolver(campaignTargetingSchema),
    defaultValues: {
      geoTargeting: data.geo_targeting || {},
      timeTargeting: data.time_targeting || {},
      deviceTargeting: data.device_targeting || {},
      filters: data.filters || {},
    },
  });
  
  const handleSubmit = (formData: TargetingFormData) => {
    onComplete({
      geo_targeting: formData.geoTargeting,
      time_targeting: formData.timeTargeting,
      device_targeting: formData.deviceTargeting,
      filters: formData.filters,
    });
  };
  
  return (
    <form onSubmit={form.handleSubmit(handleSubmit)} className="targeting-step">
      <div className="step-header">
        <h2>Campaign Targeting</h2>
        <p>Define who should see your campaign</p>
      </div>
      
      <div className="targeting-sections">
        <div className="targeting-section">
          <h3>Geographic Targeting</h3>
          <GeographicTargeting
            value={form.watch('geoTargeting')}
            onChange={(value) => form.setValue('geoTargeting', value)}
          />
          {form.formState.errors.geoTargeting && (
            <ErrorMessage>{form.formState.errors.geoTargeting.message}</ErrorMessage>
          )}
        </div>
        
        <div className="targeting-section">
          <h3>Time Targeting</h3>
          <TimeTargeting
            value={form.watch('timeTargeting')}
            onChange={(value) => form.setValue('timeTargeting', value)}
          />
        </div>
        
        <div className="targeting-section">
          <h3>Device Targeting</h3>
          <DeviceTargeting
            value={form.watch('deviceTargeting')}
            onChange={(value) => form.setValue('deviceTargeting', value)}
          />
        </div>
        
        <div className="targeting-section">
          <h3>Advanced Filters</h3>
          <AdvancedFilters
            value={form.watch('filters')}
            onChange={(value) => form.setValue('filters', value)}
          />
        </div>
      </div>
      
      <div className="step-actions">
        <Button type="button" variant="outline" onClick={onBack}>
          Back
        </Button>
        <Button type="submit">
          Continue
        </Button>
      </div>
    </form>
  );
}
```

# Campaign Performance Analytics
```tsx
interface CampaignDetailsProps {
  campaignId: string;
}

export function CampaignDetails({ campaignId }: CampaignDetailsProps) {
  const { data: campaign, loading } = useCampaign(campaignId);
  const { data: analytics } = useCampaignAnalytics(campaignId);
  const { data: calls } = useCampaignCalls(campaignId);
  const [dateRange, setDateRange] = useState<DateRange>({
    start: startOfMonth(new Date()),
    end: new Date(),
  });
  
  if (loading) return <CampaignDetailsSkeleton />;
  if (!campaign) return <NotFound />;
  
  return (
    <AppLayout>
      <div className="campaign-details">
        <PageHeader
          title={campaign.name}
          subtitle={`Campaign #${campaign.id.slice(0, 8)}`}
          breadcrumbs={[
            { label: 'Campaigns', href: '/campaigns' },
            { label: campaign.name },
          ]}
          action={
            <div className="campaign-actions">
              <CampaignStatusToggle
                campaign={campaign}
                onStatusChange={handleStatusChange}
              />
              <Button
                variant="outline"
                onClick={() => navigate(`/campaigns/${campaign.id}/edit`)}
              >
                <PencilIcon className="h-4 w-4" />
                Edit
              </Button>
            </div>
          }
        />
        
        <div className="campaign-overview">
          <CampaignMetricsCards
            campaign={campaign}
            analytics={analytics}
          />
        </div>
        
        <div className="analytics-section">
          <div className="section-header">
            <h2>Performance Analytics</h2>
            <DateRangePicker
              value={dateRange}
              onChange={setDateRange}
            />
          </div>
          
          <div className="analytics-grid">
            <CallVolumeChart
              data={analytics.callVolume}
              dateRange={dateRange}
            />
            <ConversionChart
              data={analytics.conversions}
              dateRange={dateRange}
            />
            <RevenueChart
              data={analytics.revenue}
              dateRange={dateRange}
            />
            <QualityChart
              data={analytics.quality}
              dateRange={dateRange}
            />
          </div>
        </div>
        
        <div className="calls-section">
          <CampaignCallsTable
            calls={calls}
            campaignId={campaignId}
          />
        </div>
      </div>
    </AppLayout>
  );
}
```

# Campaign Budget Management
```tsx
export function CampaignBudgetSettings({ campaign }: { campaign: Campaign }) {
  const [budgetSettings, setBudgetSettings] = useState({
    dailyBudget: campaign.daily_budget,
    monthlyBudget: campaign.monthly_budget,
    bidAmount: campaign.bid_amount,
    autoBudget: campaign.auto_budget_enabled,
  });
  
  const handleBudgetUpdate = async () => {
    try {
      await campaignService.updateBudget(campaign.id, budgetSettings);
      toast.success('Budget settings updated');
    } catch (error) {
      toast.error('Failed to update budget settings');
    }
  };
  
  return (
    <div className="budget-settings">
      <h3>Budget & Bidding</h3>
      
      <div className="budget-form">
        <div className="form-group">
          <label>Daily Budget</label>
          <CurrencyInput
            value={budgetSettings.dailyBudget}
            onChange={(value) => setBudgetSettings(prev => ({
              ...prev,
              dailyBudget: value,
            }))}
            placeholder="Enter daily budget"
          />
        </div>
        
        <div className="form-group">
          <label>Monthly Budget</label>
          <CurrencyInput
            value={budgetSettings.monthlyBudget}
            onChange={(value) => setBudgetSettings(prev => ({
              ...prev,
              monthlyBudget: value,
            }))}
            placeholder="Enter monthly budget"
          />
        </div>
        
        <div className="form-group">
          <label>Bid Amount per Call</label>
          <CurrencyInput
            value={budgetSettings.bidAmount}
            onChange={(value) => setBudgetSettings(prev => ({
              ...prev,
              bidAmount: value,
            }))}
            placeholder="Enter bid amount"
          />
        </div>
        
        <div className="form-group">
          <div className="checkbox-group">
            <Checkbox
              checked={budgetSettings.autoBudget}
              onChange={(checked) => setBudgetSettings(prev => ({
                ...prev,
                autoBudget: checked,
              }))}
            />
            <div className="checkbox-content">
              <label>Enable Auto Budget Optimization</label>
              <p>Automatically adjust bids based on performance</p>
            </div>
          </div>
        </div>
        
        <Button onClick={handleBudgetUpdate}>
          Update Budget Settings
        </Button>
      </div>
    </div>
  );
}
```

# Campaign A/B Testing
```tsx
export function CampaignABTesting({ campaignId }: { campaignId: string }) {
  const { data: tests, loading } = useABTests(campaignId);
  const [showCreateTest, setShowCreateTest] = useState(false);
  
  return (
    <div className="ab-testing">
      <div className="section-header">
        <h3>A/B Tests</h3>
        <Button onClick={() => setShowCreateTest(true)}>
          Create Test
        </Button>
      </div>
      
      <div className="tests-list">
        {tests.map(test => (
          <ABTestCard
            key={test.id}
            test={test}
            onViewResults={() => navigate(`/campaigns/${campaignId}/tests/${test.id}`)}
          />
        ))}
      </div>
      
      {showCreateTest && (
        <CreateABTestModal
          campaignId={campaignId}
          onClose={() => setShowCreateTest(false)}
          onSuccess={() => {
            setShowCreateTest(false);
            // Refresh tests
          }}
        />
      )}
    </div>
  );
}
```

# Campaign Fraud Prevention
```tsx
export function CampaignFraudSettings({ campaign }: { campaign: Campaign }) {
  const [fraudSettings, setFraudSettings] = useState({
    enableFraudDetection: campaign.fraud_detection_enabled,
    qualityThreshold: campaign.quality_threshold,
    blockDuplicates: campaign.block_duplicate_calls,
    geoValidation: campaign.geo_validation_enabled,
  });
  
  return (
    <div className="fraud-settings">
      <h3>Fraud Prevention</h3>
      
      <div className="settings-list">
        <div className="setting-item">
          <div className="setting-info">
            <h4>Enable Fraud Detection</h4>
            <p>Automatically screen calls for fraudulent activity</p>
          </div>
          <Switch
            checked={fraudSettings.enableFraudDetection}
            onChange={(checked) => setFraudSettings(prev => ({
              ...prev,
              enableFraudDetection: checked,
            }))}
          />
        </div>
        
        <div className="setting-item">
          <div className="setting-info">
            <h4>Quality Threshold</h4>
            <p>Minimum quality score required for payout</p>
          </div>
          <Slider
            value={fraudSettings.qualityThreshold}
            onChange={(value) => setFraudSettings(prev => ({
              ...prev,
              qualityThreshold: value,
            }))}
            min={0}
            max={100}
            step={5}
          />
        </div>
        
        <div className="setting-item">
          <div className="setting-info">
            <h4>Block Duplicate Calls</h4>
            <p>Prevent multiple calls from the same number</p>
          </div>
          <Switch
            checked={fraudSettings.blockDuplicates}
            onChange={(checked) => setFraudSettings(prev => ({
              ...prev,
              blockDuplicates: checked,
            }))}
          />
        </div>
      </div>
    </div>
  );
}
```

# Campaign Optimization
- Performance-based bid adjustments
- Quality score optimization
- Conversion rate improvements
- Cost per acquisition tracking
- ROI analysis and recommendations

# Real-time Campaign Monitoring
- Live campaign status updates
- Budget spend tracking
- Call volume alerts
- Performance notifications
- Quality score changes

# Campaign Templates
- Industry-specific templates
- Best practice configurations
- Quick setup wizards
- Template sharing between users

# CRITICAL RULES
- NO regex in campaign logic
- NO any types in campaign interfaces
- ALWAYS validate campaign settings
- ALWAYS handle budget limits properly
- IMPLEMENT proper access controls
- TEST campaign creation flows
- ENSURE data consistency
- MAINTAIN campaign performance metrics
</file>

<file path="src/pages/campaigns/CreateCampaignPage.tsx">
import { useState, useEffect } from 'react'
import { useNavigate } from 'react-router-dom'
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { z } from 'zod'
import { useAuthStore } from '../../store/authStore'
import {
  ChevronLeftIcon,
  CheckCircleIcon,
  ExclamationTriangleIcon,
  InformationCircleIcon,
  PhoneIcon,
  GlobeAltIcon,
  ClockIcon,
  CurrencyDollarIcon,
  ShieldCheckIcon,
} from '@heroicons/react/24/outline'
import { Button } from '../../components/common/Button'
import { Card, CardContent, CardHeader } from '../../components/common/Card'
import { Input } from '../../components/common/Input'
import { Loading } from '../../components/common/Loading'
import { FormErrorBoundary } from '../../components/forms/FormErrorBoundary'

// Campaign creation schema
const createCampaignSchema = z.object({
  name: z
    .string()
    .min(3, 'Campaign name must be at least 3 characters')
    .max(100, 'Campaign name must be less than 100 characters'),
  vertical: z.enum([
    'insurance',
    'home_services',
    'legal',
    'medical',
    'financial',
    'education',
    'automotive',
    'real_estate',
  ]),
  description: z
    .string()
    .min(10, 'Description must be at least 10 characters')
    .max(500, 'Description must be less than 500 characters'),
  target_cpa: z
    .number()
    .min(1, 'Target CPA must be at least $1')
    .max(1000, 'Target CPA must be less than $1,000'),
  daily_budget: z
    .number()
    .min(10, 'Daily budget must be at least $10')
    .max(10000, 'Daily budget must be less than $10,000'),
  monthly_budget: z
    .number()
    .min(100, 'Monthly budget must be at least $100')
    .max(100000, 'Monthly budget must be less than $100,000'),
  geo_targeting: z.object({
    countries: z.array(z.string()).min(1, 'Select at least one country'),
    states: z.array(z.string()).optional(),
    cities: z.array(z.string()).optional(),
    radius_miles: z.number().min(1).max(500).optional(),
  }),
  time_targeting: z.object({
    days_of_week: z
      .array(
        z.enum([
          'monday',
          'tuesday',
          'wednesday',
          'thursday',
          'friday',
          'saturday',
          'sunday',
        ] as const)
      )
      .min(1, 'Select at least one day'),
    hours: z.object({
      start: z.string().length(5, 'Invalid time format'), // HH:MM format
      end: z.string().length(5, 'Invalid time format'),
    }),
    timezone: z.string().min(1, 'Select a timezone'),
  }),
  quality_requirements: z.object({
    minimum_call_duration: z
      .number()
      .min(30, 'Minimum call duration must be at least 30 seconds')
      .max(600, 'Maximum call duration is 10 minutes'),
    quality_score_threshold: z.number().min(1).max(100),
    allow_transferred_calls: z.boolean(),
    require_unique_callers: z.boolean(),
  }),
  payout_settings: z.object({
    payout_model: z.enum(['cpa', 'cpc', 'cpm']),
    base_payout: z
      .number()
      .min(1, 'Base payout must be at least $1')
      .max(500, 'Base payout must be less than $500'),
    bonus_conditions: z
      .array(
        z.object({
          condition: z.string(),
          bonus_amount: z.number().min(0),
        })
      )
      .optional(),
  }),
})

type CreateCampaignFormData = z.infer<typeof createCampaignSchema>

const CAMPAIGN_VERTICALS = [
  { value: 'insurance', label: 'Insurance', description: 'Auto, home, life, and health insurance' },
  {
    value: 'home_services',
    label: 'Home Services',
    description: 'HVAC, plumbing, roofing, and contractors',
  },
  { value: 'legal', label: 'Legal Services', description: 'Personal injury, DUI, and family law' },
  { value: 'medical', label: 'Medical', description: 'Healthcare services and treatments' },
  {
    value: 'financial',
    label: 'Financial Services',
    description: 'Loans, mortgages, and financial planning',
  },
  { value: 'education', label: 'Education', description: 'Online courses and degree programs' },
  { value: 'automotive', label: 'Automotive', description: 'Car sales, repairs, and services' },
  {
    value: 'real_estate',
    label: 'Real Estate',
    description: 'Property buying, selling, and rentals',
  },
]

const US_STATES = [
  'Alabama',
  'Alaska',
  'Arizona',
  'Arkansas',
  'California',
  'Colorado',
  'Connecticut',
  'Delaware',
  'Florida',
  'Georgia',
  'Hawaii',
  'Idaho',
  'Illinois',
  'Indiana',
  'Iowa',
  'Kansas',
  'Kentucky',
  'Louisiana',
  'Maine',
  'Maryland',
  'Massachusetts',
  'Michigan',
  'Minnesota',
  'Mississippi',
  'Missouri',
  'Montana',
  'Nebraska',
  'Nevada',
  'New Hampshire',
  'New Jersey',
  'New Mexico',
  'New York',
  'North Carolina',
  'North Dakota',
  'Ohio',
  'Oklahoma',
  'Oregon',
  'Pennsylvania',
  'Rhode Island',
  'South Carolina',
  'South Dakota',
  'Tennessee',
  'Texas',
  'Utah',
  'Vermont',
  'Virginia',
  'Washington',
  'West Virginia',
  'Wisconsin',
  'Wyoming',
]

type DayOfWeek = 'monday' | 'tuesday' | 'wednesday' | 'thursday' | 'friday' | 'saturday' | 'sunday'

const DAYS_OF_WEEK: Array<{ value: DayOfWeek; label: string }> = [
  { value: 'monday', label: 'Monday' },
  { value: 'tuesday', label: 'Tuesday' },
  { value: 'wednesday', label: 'Wednesday' },
  { value: 'thursday', label: 'Thursday' },
  { value: 'friday', label: 'Friday' },
  { value: 'saturday', label: 'Saturday' },
  { value: 'sunday', label: 'Sunday' },
]

const TIMEZONES = [
  'America/New_York',
  'America/Chicago',
  'America/Denver',
  'America/Los_Angeles',
  'America/Phoenix',
  'America/Anchorage',
  'Pacific/Honolulu',
]

function CreateCampaignPageInner() {
  const navigate = useNavigate()
  const { user } = useAuthStore()
  const [isSubmitting, setIsSubmitting] = useState(false)
  const [currentStep, setCurrentStep] = useState(1)

  // Restore draft on mount
  useEffect(() => {
    const savedDraft = localStorage.getItem('formDraft_createCampaign')
    if (savedDraft) {
      try {
        const { data } = JSON.parse(savedDraft)
        // In a real implementation, we would merge this data into the form
        console.log('Draft data available:', data)
      } catch (err) {
        console.error('Failed to restore draft:', err)
      }
    }
  }, [])

  const form = useForm<CreateCampaignFormData>({
    resolver: zodResolver(createCampaignSchema),
    defaultValues: {
      name: '',
      vertical: 'insurance',
      description: '',
      target_cpa: 50,
      daily_budget: 500,
      monthly_budget: 15000,
      geo_targeting: {
        countries: ['US'],
        states: [],
        cities: [],
      },
      time_targeting: {
        days_of_week: ['monday', 'tuesday', 'wednesday', 'thursday', 'friday'],
        hours: {
          start: '09:00',
          end: '17:00',
        },
        timezone: 'America/New_York',
      },
      quality_requirements: {
        minimum_call_duration: 60,
        quality_score_threshold: 70,
        allow_transferred_calls: true,
        require_unique_callers: true,
      },
      payout_settings: {
        payout_model: 'cpa',
        base_payout: 25,
        bonus_conditions: [],
      },
    },
  })

  const handleSubmit = async (data: CreateCampaignFormData) => {
    if (!user) {
      navigate('/login')
      return
    }

    setIsSubmitting(true)
    try {
      // TODO: Replace with actual API call
      console.log('Creating campaign:', data)

      // Simulate API call
      await new Promise((resolve) => setTimeout(resolve, 2000))

      // Mock successful creation
      const campaignId = 'new-campaign-id'

      navigate(`/app/campaigns/${campaignId}`, {
        state: {
          message: 'Campaign created successfully! It may take a few minutes to become active.',
        },
      })
    } catch (error) {
      console.error('Failed to create campaign:', error)
      // Handle error (show toast, etc.)
    } finally {
      setIsSubmitting(false)
    }
  }

  const steps = [
    { id: 1, name: 'Basic Info', description: 'Campaign details and vertical' },
    { id: 2, name: 'Targeting', description: 'Geographic and time targeting' },
    { id: 3, name: 'Quality', description: 'Quality requirements and filters' },
    { id: 4, name: 'Payout', description: 'Pricing and payout settings' },
    { id: 5, name: 'Review', description: 'Review and launch campaign' },
  ]

  const currentStepData = steps[currentStep - 1]
  const isLastStep = currentStep === steps.length

  const canProceedToNextStep = () => {
    switch (currentStep) {
      case 1:
        return form.watch('name') && form.watch('vertical') && form.watch('description')
      case 2:
        return (
          form.watch('geo_targeting.countries').length > 0 &&
          form.watch('time_targeting.days_of_week').length > 0
        )
      case 3:
        return form.watch('quality_requirements.minimum_call_duration') > 0
      case 4:
        return form.watch('payout_settings.base_payout') > 0
      default:
        return true
    }
  }

  const renderStepContent = () => {
    switch (currentStep) {
      case 1:
        return (
          <div className="space-y-6">
            <Card>
              <CardHeader>
                <h3 className="text-lg font-medium flex items-center">
                  <InformationCircleIcon className="h-5 w-5 mr-2 text-blue-500" />
                  Campaign Basics
                </h3>
                <p className="text-sm text-gray-600">
                  Start by providing basic information about your campaign.
                </p>
              </CardHeader>
              <CardContent className="space-y-4">
                <Input
                  {...form.register('name')}
                  label="Campaign Name"
                  placeholder="e.g., Auto Insurance - California"
                  error={form.formState.errors.name?.message}
                />

                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2">Vertical</label>
                  <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
                    {CAMPAIGN_VERTICALS.map((vertical) => (
                      <label
                        key={vertical.value}
                        className={`relative cursor-pointer rounded-lg border p-4 hover:border-blue-300 ${
                          form.watch('vertical') === vertical.value
                            ? 'border-blue-500 bg-blue-50'
                            : 'border-gray-300'
                        }`}
                      >
                        <input
                          {...form.register('vertical')}
                          type="radio"
                          value={vertical.value}
                          className="absolute top-4 right-4 text-blue-600 focus:ring-blue-500"
                        />
                        <div>
                          <h4 className="font-medium text-gray-900">{vertical.label}</h4>
                          <p className="text-sm text-gray-500">{vertical.description}</p>
                        </div>
                      </label>
                    ))}
                  </div>
                  {form.formState.errors.vertical && (
                    <p className="mt-1 text-sm text-red-600">
                      {form.formState.errors.vertical.message}
                    </p>
                  )}
                </div>

                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2">
                    Description
                  </label>
                  <textarea
                    {...form.register('description')}
                    rows={4}
                    className="block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm"
                    placeholder="Describe your campaign goals, target audience, and specific requirements..."
                  />
                  {form.formState.errors.description && (
                    <p className="mt-1 text-sm text-red-600">
                      {form.formState.errors.description.message}
                    </p>
                  )}
                </div>

                <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                  <Input
                    {...form.register('target_cpa', { valueAsNumber: true })}
                    type="number"
                    label="Target CPA ($)"
                    placeholder="50"
                    error={form.formState.errors.target_cpa?.message}
                  />
                  <Input
                    {...form.register('daily_budget', { valueAsNumber: true })}
                    type="number"
                    label="Daily Budget ($)"
                    placeholder="500"
                    error={form.formState.errors.daily_budget?.message}
                  />
                </div>

                <Input
                  {...form.register('monthly_budget', { valueAsNumber: true })}
                  type="number"
                  label="Monthly Budget ($)"
                  placeholder="15000"
                  error={form.formState.errors.monthly_budget?.message}
                />
              </CardContent>
            </Card>
          </div>
        )

      case 2:
        return (
          <div className="space-y-6">
            <Card>
              <CardHeader>
                <h3 className="text-lg font-medium flex items-center">
                  <GlobeAltIcon className="h-5 w-5 mr-2 text-green-500" />
                  Geographic Targeting
                </h3>
                <p className="text-sm text-gray-600">
                  Define where you want to receive calls from.
                </p>
              </CardHeader>
              <CardContent className="space-y-4">
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2">
                    States (Leave empty for nationwide)
                  </label>
                  <div className="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-2 max-h-60 overflow-y-auto border rounded-md p-3">
                    {US_STATES.map((state) => (
                      <label key={state} className="flex items-center">
                        <input
                          type="checkbox"
                          value={state}
                          checked={form.watch('geo_targeting.states')?.includes(state) || false}
                          onChange={(e) => {
                            const states = form.watch('geo_targeting.states') || []
                            if (e.target.checked) {
                              form.setValue('geo_targeting.states', [...states, state])
                            } else {
                              form.setValue(
                                'geo_targeting.states',
                                states.filter((s) => s !== state)
                              )
                            }
                          }}
                          className="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500"
                        />
                        <span className="ml-2 text-sm text-gray-700">{state}</span>
                      </label>
                    ))}
                  </div>
                </div>
              </CardContent>
            </Card>

            <Card>
              <CardHeader>
                <h3 className="text-lg font-medium flex items-center">
                  <ClockIcon className="h-5 w-5 mr-2 text-purple-500" />
                  Time Targeting
                </h3>
                <p className="text-sm text-gray-600">Set when your campaign should be active.</p>
              </CardHeader>
              <CardContent className="space-y-4">
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2">
                    Days of Week
                  </label>
                  <div className="grid grid-cols-2 sm:grid-cols-4 gap-2">
                    {DAYS_OF_WEEK.map((day) => (
                      <label key={day.value} className="flex items-center">
                        <input
                          type="checkbox"
                          value={day.value}
                          checked={form.watch('time_targeting.days_of_week').includes(day.value)}
                          onChange={(e) => {
                            const days = form.watch('time_targeting.days_of_week')
                            if (e.target.checked) {
                              form.setValue('time_targeting.days_of_week', [...days, day.value])
                            } else {
                              form.setValue(
                                'time_targeting.days_of_week',
                                days.filter((d) => d !== day.value)
                              )
                            }
                          }}
                          className="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500"
                        />
                        <span className="ml-2 text-sm text-gray-700">{day.label}</span>
                      </label>
                    ))}
                  </div>
                  {form.formState.errors.time_targeting?.days_of_week && (
                    <p className="mt-1 text-sm text-red-600">
                      {form.formState.errors.time_targeting.days_of_week.message}
                    </p>
                  )}
                </div>

                <div className="grid grid-cols-1 sm:grid-cols-3 gap-4">
                  <Input
                    {...form.register('time_targeting.hours.start')}
                    type="time"
                    label="Start Time"
                    error={form.formState.errors.time_targeting?.hours?.start?.message}
                  />
                  <Input
                    {...form.register('time_targeting.hours.end')}
                    type="time"
                    label="End Time"
                    error={form.formState.errors.time_targeting?.hours?.end?.message}
                  />
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-2">Timezone</label>
                    <select
                      {...form.register('time_targeting.timezone')}
                      className="block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm"
                    >
                      {TIMEZONES.map((timezone) => (
                        <option key={timezone} value={timezone}>
                          {timezone.replace('America/', '').replace('_', ' ')}
                        </option>
                      ))}
                    </select>
                    {form.formState.errors.time_targeting?.timezone && (
                      <p className="mt-1 text-sm text-red-600">
                        {form.formState.errors.time_targeting.timezone.message}
                      </p>
                    )}
                  </div>
                </div>
              </CardContent>
            </Card>
          </div>
        )

      case 3:
        return (
          <div className="space-y-6">
            <Card>
              <CardHeader>
                <h3 className="text-lg font-medium flex items-center">
                  <ShieldCheckIcon className="h-5 w-5 mr-2 text-green-500" />
                  Quality Requirements
                </h3>
                <p className="text-sm text-gray-600">
                  Set standards for call quality and filtering.
                </p>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                  <Input
                    {...form.register('quality_requirements.minimum_call_duration', {
                      valueAsNumber: true,
                    })}
                    type="number"
                    label="Minimum Call Duration (seconds)"
                    placeholder="60"
                    error={
                      form.formState.errors.quality_requirements?.minimum_call_duration?.message
                    }
                  />
                  <Input
                    {...form.register('quality_requirements.quality_score_threshold', {
                      valueAsNumber: true,
                    })}
                    type="number"
                    label="Quality Score Threshold (%)"
                    min="1"
                    max="100"
                    placeholder="70"
                    error={
                      form.formState.errors.quality_requirements?.quality_score_threshold?.message
                    }
                  />
                </div>

                <div className="space-y-3">
                  <label className="flex items-center">
                    <input
                      {...form.register('quality_requirements.allow_transferred_calls')}
                      type="checkbox"
                      className="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500"
                    />
                    <span className="ml-2 text-sm text-gray-700">Allow transferred calls</span>
                  </label>

                  <label className="flex items-center">
                    <input
                      {...form.register('quality_requirements.require_unique_callers')}
                      type="checkbox"
                      className="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500"
                    />
                    <span className="ml-2 text-sm text-gray-700">
                      Require unique callers (block repeat calls)
                    </span>
                  </label>
                </div>
              </CardContent>
            </Card>
          </div>
        )

      case 4:
        return (
          <div className="space-y-6">
            <Card>
              <CardHeader>
                <h3 className="text-lg font-medium flex items-center">
                  <CurrencyDollarIcon className="h-5 w-5 mr-2 text-green-500" />
                  Payout Settings
                </h3>
                <p className="text-sm text-gray-600">
                  Configure how much you'll pay for qualified calls.
                </p>
              </CardHeader>
              <CardContent className="space-y-4">
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2">
                    Payout Model
                  </label>
                  <div className="grid grid-cols-1 sm:grid-cols-3 gap-3">
                    <label
                      className={`cursor-pointer rounded-lg border p-4 ${
                        form.watch('payout_settings.payout_model') === 'cpa'
                          ? 'border-blue-500 bg-blue-50'
                          : 'border-gray-300'
                      }`}
                    >
                      <input
                        {...form.register('payout_settings.payout_model')}
                        type="radio"
                        value="cpa"
                        className="sr-only"
                      />
                      <div className="text-center">
                        <h4 className="font-medium">CPA</h4>
                        <p className="text-sm text-gray-500">Cost Per Acquisition</p>
                      </div>
                    </label>
                    <label
                      className={`cursor-pointer rounded-lg border p-4 ${
                        form.watch('payout_settings.payout_model') === 'cpc'
                          ? 'border-blue-500 bg-blue-50'
                          : 'border-gray-300'
                      }`}
                    >
                      <input
                        {...form.register('payout_settings.payout_model')}
                        type="radio"
                        value="cpc"
                        className="sr-only"
                      />
                      <div className="text-center">
                        <h4 className="font-medium">CPC</h4>
                        <p className="text-sm text-gray-500">Cost Per Call</p>
                      </div>
                    </label>
                    <label
                      className={`cursor-pointer rounded-lg border p-4 ${
                        form.watch('payout_settings.payout_model') === 'cpm'
                          ? 'border-blue-500 bg-blue-50'
                          : 'border-gray-300'
                      }`}
                    >
                      <input
                        {...form.register('payout_settings.payout_model')}
                        type="radio"
                        value="cpm"
                        className="sr-only"
                      />
                      <div className="text-center">
                        <h4 className="font-medium">CPM</h4>
                        <p className="text-sm text-gray-500">Cost Per Mille</p>
                      </div>
                    </label>
                  </div>
                </div>

                <Input
                  {...form.register('payout_settings.base_payout', { valueAsNumber: true })}
                  type="number"
                  label="Base Payout ($)"
                  placeholder="25"
                  error={form.formState.errors.payout_settings?.base_payout?.message}
                />
              </CardContent>
            </Card>
          </div>
        )

      case 5:
        return (
          <div className="space-y-6">
            <Card>
              <CardHeader>
                <h3 className="text-lg font-medium flex items-center">
                  <CheckCircleIcon className="h-5 w-5 mr-2 text-green-500" />
                  Review Campaign
                </h3>
                <p className="text-sm text-gray-600">
                  Review your campaign settings before launching.
                </p>
              </CardHeader>
              <CardContent className="space-y-6">
                <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                  <div className="space-y-4">
                    <div>
                      <h4 className="font-medium text-gray-900">Basic Information</h4>
                      <div className="mt-2 space-y-1 text-sm text-gray-600">
                        <p>
                          <span className="font-medium">Name:</span> {form.watch('name')}
                        </p>
                        <p>
                          <span className="font-medium">Vertical:</span>{' '}
                          {
                            CAMPAIGN_VERTICALS.find((v) => v.value === form.watch('vertical'))
                              ?.label
                          }
                        </p>
                        <p>
                          <span className="font-medium">Target CPA:</span> $
                          {form.watch('target_cpa')}
                        </p>
                        <p>
                          <span className="font-medium">Daily Budget:</span> $
                          {form.watch('daily_budget')}
                        </p>
                        <p>
                          <span className="font-medium">Monthly Budget:</span> $
                          {form.watch('monthly_budget')}
                        </p>
                      </div>
                    </div>

                    <div>
                      <h4 className="font-medium text-gray-900">Geographic Targeting</h4>
                      <div className="mt-2 space-y-1 text-sm text-gray-600">
                        <p>
                          <span className="font-medium">Countries:</span>{' '}
                          {form.watch('geo_targeting.countries').join(', ')}
                        </p>
                        <p>
                          <span className="font-medium">States:</span>{' '}
                          {form.watch('geo_targeting.states') &&
                          form.watch('geo_targeting.states')!.length > 0
                            ? form.watch('geo_targeting.states')!.slice(0, 3).join(', ') +
                              (form.watch('geo_targeting.states')!.length > 3
                                ? `... (+${form.watch('geo_targeting.states')!.length - 3} more)`
                                : '')
                            : 'All states'}
                        </p>
                      </div>
                    </div>
                  </div>

                  <div className="space-y-4">
                    <div>
                      <h4 className="font-medium text-gray-900">Time Targeting</h4>
                      <div className="mt-2 space-y-1 text-sm text-gray-600">
                        <p>
                          <span className="font-medium">Days:</span>{' '}
                          {form
                            .watch('time_targeting.days_of_week')
                            .map((d) => DAYS_OF_WEEK.find((day) => day.value === d)?.label)
                            .join(', ')}
                        </p>
                        <p>
                          <span className="font-medium">Hours:</span>{' '}
                          {form.watch('time_targeting.hours.start')} -{' '}
                          {form.watch('time_targeting.hours.end')}
                        </p>
                        <p>
                          <span className="font-medium">Timezone:</span>{' '}
                          {form.watch('time_targeting.timezone')}
                        </p>
                      </div>
                    </div>

                    <div>
                      <h4 className="font-medium text-gray-900">Quality & Payout</h4>
                      <div className="mt-2 space-y-1 text-sm text-gray-600">
                        <p>
                          <span className="font-medium">Min Call Duration:</span>{' '}
                          {form.watch('quality_requirements.minimum_call_duration')}s
                        </p>
                        <p>
                          <span className="font-medium">Quality Threshold:</span>{' '}
                          {form.watch('quality_requirements.quality_score_threshold')}%
                        </p>
                        <p>
                          <span className="font-medium">Payout Model:</span>{' '}
                          {form.watch('payout_settings.payout_model').toUpperCase()}
                        </p>
                        <p>
                          <span className="font-medium">Base Payout:</span> $
                          {form.watch('payout_settings.base_payout')}
                        </p>
                      </div>
                    </div>
                  </div>
                </div>

                <div className="bg-yellow-50 border border-yellow-200 rounded-md p-4">
                  <div className="flex">
                    <ExclamationTriangleIcon className="h-5 w-5 text-yellow-400" />
                    <div className="ml-3">
                      <h3 className="text-sm font-medium text-yellow-800">Campaign Review</h3>
                      <div className="mt-2 text-sm text-yellow-700">
                        <p>
                          Your campaign will be reviewed by our team and should be active within 2-4
                          hours. You'll receive an email notification when it's approved and live.
                        </p>
                      </div>
                    </div>
                  </div>
                </div>
              </CardContent>
            </Card>
          </div>
        )

      default:
        return null
    }
  }

  return (
    <div className="py-6">
      <div className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8">
        {/* Header */}
        <div className="mb-8">
          <button
            onClick={() => navigate('/app/campaigns')}
            className="flex items-center text-sm text-gray-500 hover:text-gray-700 mb-4"
          >
            <ChevronLeftIcon className="h-4 w-4 mr-1" />
            Back to Campaigns
          </button>

          <div className="flex items-center justify-between">
            <div>
              <h1 className="text-2xl font-bold text-gray-900">Create New Campaign</h1>
              <p className="text-sm text-gray-600 mt-1">{currentStepData.description}</p>
            </div>
            <div className="text-sm text-gray-500">
              Step {currentStep} of {steps.length}
            </div>
          </div>
        </div>

        {/* Progress Steps */}
        <div className="mb-8">
          <div className="flex items-center justify-between">
            {steps.map((step, index) => (
              <div key={step.id} className="flex items-center">
                <div
                  className={`flex items-center justify-center w-8 h-8 rounded-full border-2 ${
                    currentStep > step.id
                      ? 'bg-green-500 border-green-500 text-white'
                      : currentStep === step.id
                        ? 'bg-blue-500 border-blue-500 text-white'
                        : 'bg-white border-gray-300 text-gray-500'
                  }`}
                >
                  {currentStep > step.id ? (
                    <CheckCircleIcon className="h-5 w-5" />
                  ) : (
                    <span className="text-sm font-medium">{step.id}</span>
                  )}
                </div>
                <div className="ml-3 hidden sm:block">
                  <p
                    className={`text-sm font-medium ${
                      currentStep >= step.id ? 'text-gray-900' : 'text-gray-500'
                    }`}
                  >
                    {step.name}
                  </p>
                </div>
                {index < steps.length - 1 && (
                  <div
                    className={`flex-1 mx-4 h-0.5 ${
                      currentStep > step.id ? 'bg-green-500' : 'bg-gray-300'
                    }`}
                  />
                )}
              </div>
            ))}
          </div>
        </div>

        {/* Form Content */}
        <form onSubmit={form.handleSubmit(handleSubmit)}>
          {renderStepContent()}

          {/* Navigation */}
          <div className="flex justify-between items-center mt-8 pt-6 border-t border-gray-200">
            <Button
              type="button"
              variant="outline"
              onClick={() => setCurrentStep(Math.max(1, currentStep - 1))}
              disabled={currentStep === 1}
            >
              Previous
            </Button>

            <div className="flex space-x-3">
              <Button type="button" variant="outline" onClick={() => navigate('/app/campaigns')}>
                Cancel
              </Button>

              {isLastStep ? (
                <Button type="submit" loading={isSubmitting} disabled={!canProceedToNextStep()}>
                  {isSubmitting ? (
                    <>
                      <Loading variant="spinner" className="mr-2" />
                      Creating Campaign...
                    </>
                  ) : (
                    <>
                      <PhoneIcon className="h-4 w-4 mr-2" />
                      Launch Campaign
                    </>
                  )}
                </Button>
              ) : (
                <Button
                  type="button"
                  onClick={() => setCurrentStep(currentStep + 1)}
                  disabled={!canProceedToNextStep()}
                >
                  Next
                </Button>
              )}
            </div>
          </div>
        </form>
      </div>
    </div>
  )
}

// Export with error boundary wrapper
export default function CreateCampaignPage() {
  const [retryKey, setRetryKey] = useState(0)

  const handleRetry = () => {
    setRetryKey((prev) => prev + 1)
  }

  const handleSaveDraft = (data: Record<string, unknown>) => {
    localStorage.setItem(
      'formDraft_createCampaign',
      JSON.stringify({
        data,
        timestamp: new Date().toISOString(),
      })
    )
    alert('Draft saved successfully!')
  }

  const handleReset = () => {
    localStorage.removeItem('formDraft_createCampaign')
    setRetryKey((prev) => prev + 1)
  }

  return (
    <FormErrorBoundary
      formName="createCampaign"
      enableDraftSaving={true}
      validationSchema={createCampaignSchema}
      onRetry={handleRetry}
      onSaveDraft={handleSaveDraft}
      onReset={handleReset}
      onError={(error) => {
        console.error('Campaign creation form error:', error)
      }}
    >
      <CreateCampaignPageInner key={retryKey} />
    </FormErrorBoundary>
  )
}
</file>

<file path="src/pages/campaigns/EditCampaignPage.tsx">
import { useState, useEffect } from 'react'
import { useParams, useNavigate } from 'react-router-dom'
import { z } from 'zod'
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { FormErrorBoundary } from '../../components/forms/FormErrorBoundary'

// Reuse the same schema from CreateCampaignPage but make fields optional for partial updates
const editCampaignSchema = z.object({
  // Basic Information
  name: z.string().min(3, 'Campaign name must be at least 3 characters'),
  vertical: z.enum([
    'insurance',
    'home_services',
    'legal',
    'healthcare',
    'financial',
    'education',
    'real_estate',
    'automotive',
    'travel',
    'retail',
  ]),
  description: z.string().min(10, 'Description must be at least 10 characters'),
  status: z.enum(['active', 'paused', 'ended']),
  
  // Targeting
  geoTargeting: z.object({
    countries: z.array(z.string()).min(1, 'Select at least one country'),
    states: z.array(z.string()).optional(),
    cities: z.array(z.string()).optional(),
    zipcodes: z.array(z.string()).optional(),
  }),
  timeTargeting: z.object({
    timezone: z.string(),
    businessHours: z.boolean(),
    customHours: z.object({
      monday: z.object({ start: z.string(), end: z.string(), enabled: z.boolean() }),
      tuesday: z.object({ start: z.string(), end: z.string(), enabled: z.boolean() }),
      wednesday: z.object({ start: z.string(), end: z.string(), enabled: z.boolean() }),
      thursday: z.object({ start: z.string(), end: z.string(), enabled: z.boolean() }),
      friday: z.object({ start: z.string(), end: z.string(), enabled: z.boolean() }),
      saturday: z.object({ start: z.string(), end: z.string(), enabled: z.boolean() }),
      sunday: z.object({ start: z.string(), end: z.string(), enabled: z.boolean() }),
    }).optional(),
  }),
  
  // Quality Requirements
  qualityRequirements: z.object({
    minCallDuration: z.number().min(30, 'Minimum call duration must be at least 30 seconds'),
    uniqueCallerOnly: z.boolean(),
    recordCalls: z.boolean(),
    requireKeypress: z.boolean(),
    blockDuplicates: z.boolean(),
    duplicateWindow: z.number().min(1).max(90).optional(),
  }),
  
  // Payout Settings
  payoutSettings: z.object({
    model: z.enum(['pay_per_call', 'pay_per_qualified_call', 'pay_per_conversion']),
    baseRate: z.number().min(0.01, 'Base rate must be greater than 0'),
    qualifiedRate: z.number().min(0.01).optional(),
    conversionRate: z.number().min(0.01).optional(),
    currency: z.enum(['USD', 'EUR', 'GBP', 'CAD', 'AUD']),
    dailyBudget: z.number().min(1).optional(),
    monthlyBudget: z.number().min(1).optional(),
  }),
})

type EditCampaignFormData = z.infer<typeof editCampaignSchema>

// Mock function to fetch campaign data - replace with actual API call
async function fetchCampaign(id: string): Promise<EditCampaignFormData | null> {
  // Simulate API delay
  await new Promise(resolve => setTimeout(resolve, 1000))
  
  // Return mock data for demo
  if (id === '1') {
    return {
      name: 'Auto Insurance Leads - California',
      vertical: 'insurance',
      description: 'High-quality auto insurance leads from California residents seeking quotes',
      status: 'active',
      geoTargeting: {
        countries: ['US'],
        states: ['CA'],
        cities: ['Los Angeles', 'San Francisco', 'San Diego'],
      },
      timeTargeting: {
        timezone: 'America/Los_Angeles',
        businessHours: true,
      },
      qualityRequirements: {
        minCallDuration: 90,
        uniqueCallerOnly: true,
        recordCalls: true,
        requireKeypress: true,
        blockDuplicates: true,
        duplicateWindow: 30,
      },
      payoutSettings: {
        model: 'pay_per_qualified_call',
        baseRate: 15,
        qualifiedRate: 45,
        currency: 'USD',
        dailyBudget: 1000,
        monthlyBudget: 25000,
      },
    }
  }
  
  return null
}

// Mock function to update campaign - replace with actual API call
async function updateCampaign(id: string, data: EditCampaignFormData): Promise<void> {
  console.log('Updating campaign:', id, data)
  // Simulate API delay
  await new Promise(resolve => setTimeout(resolve, 1500))
}

function EditCampaignPageInner() {
  const { id } = useParams<{ id: string }>()
  const navigate = useNavigate()
  const [loading, setLoading] = useState(true)
  const [campaignNotFound, setCampaignNotFound] = useState(false)
  const [activeTab, setActiveTab] = useState<'basic' | 'targeting' | 'quality' | 'payout'>('basic')
  
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting, isDirty },
    reset,
    watch,
  } = useForm<EditCampaignFormData>({
    resolver: zodResolver(editCampaignSchema),
  })
  
  const payoutModel = watch('payoutSettings.model')
  const blockDuplicates = watch('qualityRequirements.blockDuplicates')
  
  useEffect(() => {
    async function loadCampaign() {
      if (!id) {
        setCampaignNotFound(true)
        setLoading(false)
        return
      }
      
      try {
        const campaign = await fetchCampaign(id)
        if (campaign) {
          reset(campaign)
        } else {
          setCampaignNotFound(true)
        }
      } catch (error) {
        console.error('Failed to load campaign:', error)
        setCampaignNotFound(true)
      } finally {
        setLoading(false)
      }
    }
    
    loadCampaign()
  }, [id, reset])
  
  const onSubmit = async (data: EditCampaignFormData) => {
    if (!id) return
    
    try {
      await updateCampaign(id, data)
      navigate('/app/campaigns')
    } catch (error) {
      console.error('Failed to update campaign:', error)
      alert('Failed to update campaign. Please try again.')
    }
  }
  
  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-center">
          <div className="inline-flex items-center justify-center w-16 h-16 border-4 border-primary-600 border-t-transparent rounded-full animate-spin"></div>
          <p className="mt-4 text-gray-600">Loading campaign...</p>
        </div>
      </div>
    )
  }
  
  if (campaignNotFound) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-center">
          <h2 className="text-2xl font-bold text-gray-900 mb-4">Campaign Not Found</h2>
          <p className="text-gray-600 mb-8">The campaign you're looking for doesn't exist or you don't have access to it.</p>
          <button
            onClick={() => navigate('/app/campaigns')}
            className="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-primary-600 hover:bg-primary-700"
          >
            Back to Campaigns
          </button>
        </div>
      </div>
    )
  }
  
  return (
    <div className="min-h-screen bg-gray-50 py-8">
      <div className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="mb-8">
          <h1 className="text-3xl font-bold text-gray-900">Edit Campaign</h1>
          <p className="mt-2 text-gray-600">Update your campaign settings and targeting options</p>
        </div>
        
        {/* Tab Navigation */}
        <div className="bg-white shadow rounded-lg mb-6">
          <div className="border-b border-gray-200">
            <nav className="-mb-px flex">
              <button
                onClick={() => setActiveTab('basic')}
                className={`py-2 px-6 border-b-2 font-medium text-sm ${
                  activeTab === 'basic'
                    ? 'border-primary-500 text-primary-600'
                    : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
                }`}
              >
                Basic Info
              </button>
              <button
                onClick={() => setActiveTab('targeting')}
                className={`py-2 px-6 border-b-2 font-medium text-sm ${
                  activeTab === 'targeting'
                    ? 'border-primary-500 text-primary-600'
                    : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
                }`}
              >
                Targeting
              </button>
              <button
                onClick={() => setActiveTab('quality')}
                className={`py-2 px-6 border-b-2 font-medium text-sm ${
                  activeTab === 'quality'
                    ? 'border-primary-500 text-primary-600'
                    : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
                }`}
              >
                Quality
              </button>
              <button
                onClick={() => setActiveTab('payout')}
                className={`py-2 px-6 border-b-2 font-medium text-sm ${
                  activeTab === 'payout'
                    ? 'border-primary-500 text-primary-600'
                    : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
                }`}
              >
                Payout
              </button>
            </nav>
          </div>
        </div>
        
        <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
          {/* Basic Information Tab */}
          {activeTab === 'basic' && (
            <div className="bg-white shadow rounded-lg p-6">
              <h2 className="text-xl font-semibold text-gray-900 mb-6">Basic Information</h2>
              
              <div className="space-y-6">
                <div>
                  <label htmlFor="name" className="block text-sm font-medium text-gray-700">
                    Campaign Name
                  </label>
                  <input
                    type="text"
                    id="name"
                    {...register('name')}
                    className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-primary-500 focus:ring-primary-500"
                  />
                  {errors.name && (
                    <p className="mt-1 text-sm text-red-600">{errors.name.message}</p>
                  )}
                </div>
                
                <div>
                  <label htmlFor="vertical" className="block text-sm font-medium text-gray-700">
                    Industry Vertical
                  </label>
                  <select
                    id="vertical"
                    {...register('vertical')}
                    className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-primary-500 focus:ring-primary-500"
                  >
                    <option value="insurance">Insurance</option>
                    <option value="home_services">Home Services</option>
                    <option value="legal">Legal</option>
                    <option value="healthcare">Healthcare</option>
                    <option value="financial">Financial</option>
                    <option value="education">Education</option>
                    <option value="real_estate">Real Estate</option>
                    <option value="automotive">Automotive</option>
                    <option value="travel">Travel</option>
                    <option value="retail">Retail</option>
                  </select>
                  {errors.vertical && (
                    <p className="mt-1 text-sm text-red-600">{errors.vertical.message}</p>
                  )}
                </div>
                
                <div>
                  <label htmlFor="description" className="block text-sm font-medium text-gray-700">
                    Description
                  </label>
                  <textarea
                    id="description"
                    rows={4}
                    {...register('description')}
                    className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-primary-500 focus:ring-primary-500"
                  />
                  {errors.description && (
                    <p className="mt-1 text-sm text-red-600">{errors.description.message}</p>
                  )}
                </div>
                
                <div>
                  <label htmlFor="status" className="block text-sm font-medium text-gray-700">
                    Campaign Status
                  </label>
                  <select
                    id="status"
                    {...register('status')}
                    className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-primary-500 focus:ring-primary-500"
                  >
                    <option value="active">Active</option>
                    <option value="paused">Paused</option>
                    <option value="ended">Ended</option>
                  </select>
                  {errors.status && (
                    <p className="mt-1 text-sm text-red-600">{errors.status.message}</p>
                  )}
                </div>
              </div>
            </div>
          )}
          
          {/* Targeting Tab */}
          {activeTab === 'targeting' && (
            <div className="bg-white shadow rounded-lg p-6">
              <h2 className="text-xl font-semibold text-gray-900 mb-6">Targeting Settings</h2>
              
              <div className="space-y-6">
                <div>
                  <h3 className="text-lg font-medium text-gray-900 mb-4">Geographic Targeting</h3>
                  
                  <div className="space-y-4">
                    <div>
                      <label className="block text-sm font-medium text-gray-700">Countries</label>
                      <select
                        multiple
                        {...register('geoTargeting.countries')}
                        className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-primary-500 focus:ring-primary-500"
                      >
                        <option value="US">United States</option>
                        <option value="CA">Canada</option>
                        <option value="GB">United Kingdom</option>
                        <option value="AU">Australia</option>
                      </select>
                      {errors.geoTargeting?.countries && (
                        <p className="mt-1 text-sm text-red-600">{errors.geoTargeting.countries.message}</p>
                      )}
                    </div>
                    
                    <div>
                      <label className="block text-sm font-medium text-gray-700">
                        States/Provinces (optional)
                      </label>
                      <input
                        type="text"
                        placeholder="e.g., CA, NY, TX"
                        {...register('geoTargeting.states.0')}
                        className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-primary-500 focus:ring-primary-500"
                      />
                    </div>
                    
                    <div>
                      <label className="block text-sm font-medium text-gray-700">
                        Cities (optional)
                      </label>
                      <input
                        type="text"
                        placeholder="e.g., Los Angeles, New York"
                        {...register('geoTargeting.cities.0')}
                        className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-primary-500 focus:ring-primary-500"
                      />
                    </div>
                  </div>
                </div>
                
                <div>
                  <h3 className="text-lg font-medium text-gray-900 mb-4">Time Targeting</h3>
                  
                  <div className="space-y-4">
                    <div>
                      <label htmlFor="timezone" className="block text-sm font-medium text-gray-700">
                        Timezone
                      </label>
                      <select
                        id="timezone"
                        {...register('timeTargeting.timezone')}
                        className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-primary-500 focus:ring-primary-500"
                      >
                        <option value="America/New_York">Eastern Time</option>
                        <option value="America/Chicago">Central Time</option>
                        <option value="America/Denver">Mountain Time</option>
                        <option value="America/Los_Angeles">Pacific Time</option>
                      </select>
                    </div>
                    
                    <div className="flex items-center">
                      <input
                        type="checkbox"
                        id="businessHours"
                        {...register('timeTargeting.businessHours')}
                        className="h-4 w-4 text-primary-600 focus:ring-primary-500 border-gray-300 rounded"
                      />
                      <label htmlFor="businessHours" className="ml-2 block text-sm text-gray-900">
                        Business hours only (9 AM - 5 PM)
                      </label>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          )}
          
          {/* Quality Tab */}
          {activeTab === 'quality' && (
            <div className="bg-white shadow rounded-lg p-6">
              <h2 className="text-xl font-semibold text-gray-900 mb-6">Quality Requirements</h2>
              
              <div className="space-y-6">
                <div>
                  <label htmlFor="minCallDuration" className="block text-sm font-medium text-gray-700">
                    Minimum Call Duration (seconds)
                  </label>
                  <input
                    type="number"
                    id="minCallDuration"
                    {...register('qualityRequirements.minCallDuration', { valueAsNumber: true })}
                    className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-primary-500 focus:ring-primary-500"
                  />
                  {errors.qualityRequirements?.minCallDuration && (
                    <p className="mt-1 text-sm text-red-600">{errors.qualityRequirements.minCallDuration.message}</p>
                  )}
                </div>
                
                <div className="space-y-3">
                  <div className="flex items-center">
                    <input
                      type="checkbox"
                      id="uniqueCallerOnly"
                      {...register('qualityRequirements.uniqueCallerOnly')}
                      className="h-4 w-4 text-primary-600 focus:ring-primary-500 border-gray-300 rounded"
                    />
                    <label htmlFor="uniqueCallerOnly" className="ml-2 block text-sm text-gray-900">
                      Accept unique callers only
                    </label>
                  </div>
                  
                  <div className="flex items-center">
                    <input
                      type="checkbox"
                      id="recordCalls"
                      {...register('qualityRequirements.recordCalls')}
                      className="h-4 w-4 text-primary-600 focus:ring-primary-500 border-gray-300 rounded"
                    />
                    <label htmlFor="recordCalls" className="ml-2 block text-sm text-gray-900">
                      Record calls for quality assurance
                    </label>
                  </div>
                  
                  <div className="flex items-center">
                    <input
                      type="checkbox"
                      id="requireKeypress"
                      {...register('qualityRequirements.requireKeypress')}
                      className="h-4 w-4 text-primary-600 focus:ring-primary-500 border-gray-300 rounded"
                    />
                    <label htmlFor="requireKeypress" className="ml-2 block text-sm text-gray-900">
                      Require keypress confirmation
                    </label>
                  </div>
                  
                  <div className="flex items-center">
                    <input
                      type="checkbox"
                      id="blockDuplicates"
                      {...register('qualityRequirements.blockDuplicates')}
                      className="h-4 w-4 text-primary-600 focus:ring-primary-500 border-gray-300 rounded"
                    />
                    <label htmlFor="blockDuplicates" className="ml-2 block text-sm text-gray-900">
                      Block duplicate calls
                    </label>
                  </div>
                  
                  {blockDuplicates && (
                    <div className="ml-6">
                      <label htmlFor="duplicateWindow" className="block text-sm font-medium text-gray-700">
                        Duplicate window (days)
                      </label>
                      <input
                        type="number"
                        id="duplicateWindow"
                        {...register('qualityRequirements.duplicateWindow', { valueAsNumber: true })}
                        className="mt-1 block w-32 rounded-md border-gray-300 shadow-sm focus:border-primary-500 focus:ring-primary-500"
                      />
                    </div>
                  )}
                </div>
              </div>
            </div>
          )}
          
          {/* Payout Tab */}
          {activeTab === 'payout' && (
            <div className="bg-white shadow rounded-lg p-6">
              <h2 className="text-xl font-semibold text-gray-900 mb-6">Payout Settings</h2>
              
              <div className="space-y-6">
                <div>
                  <label htmlFor="payoutModel" className="block text-sm font-medium text-gray-700">
                    Payout Model
                  </label>
                  <select
                    id="payoutModel"
                    {...register('payoutSettings.model')}
                    className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-primary-500 focus:ring-primary-500"
                  >
                    <option value="pay_per_call">Pay Per Call</option>
                    <option value="pay_per_qualified_call">Pay Per Qualified Call</option>
                    <option value="pay_per_conversion">Pay Per Conversion</option>
                  </select>
                </div>
                
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div>
                    <label htmlFor="baseRate" className="block text-sm font-medium text-gray-700">
                      Base Rate ($)
                    </label>
                    <input
                      type="number"
                      step="0.01"
                      id="baseRate"
                      {...register('payoutSettings.baseRate', { valueAsNumber: true })}
                      className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-primary-500 focus:ring-primary-500"
                    />
                    {errors.payoutSettings?.baseRate && (
                      <p className="mt-1 text-sm text-red-600">{errors.payoutSettings.baseRate.message}</p>
                    )}
                  </div>
                  
                  {payoutModel === 'pay_per_qualified_call' && (
                    <div>
                      <label htmlFor="qualifiedRate" className="block text-sm font-medium text-gray-700">
                        Qualified Rate ($)
                      </label>
                      <input
                        type="number"
                        step="0.01"
                        id="qualifiedRate"
                        {...register('payoutSettings.qualifiedRate', { valueAsNumber: true })}
                        className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-primary-500 focus:ring-primary-500"
                      />
                    </div>
                  )}
                  
                  {payoutModel === 'pay_per_conversion' && (
                    <div>
                      <label htmlFor="conversionRate" className="block text-sm font-medium text-gray-700">
                        Conversion Rate ($)
                      </label>
                      <input
                        type="number"
                        step="0.01"
                        id="conversionRate"
                        {...register('payoutSettings.conversionRate', { valueAsNumber: true })}
                        className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-primary-500 focus:ring-primary-500"
                      />
                    </div>
                  )}
                </div>
                
                <div>
                  <label htmlFor="currency" className="block text-sm font-medium text-gray-700">
                    Currency
                  </label>
                  <select
                    id="currency"
                    {...register('payoutSettings.currency')}
                    className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-primary-500 focus:ring-primary-500"
                  >
                    <option value="USD">USD - US Dollar</option>
                    <option value="EUR">EUR - Euro</option>
                    <option value="GBP">GBP - British Pound</option>
                    <option value="CAD">CAD - Canadian Dollar</option>
                    <option value="AUD">AUD - Australian Dollar</option>
                  </select>
                </div>
                
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div>
                    <label htmlFor="dailyBudget" className="block text-sm font-medium text-gray-700">
                      Daily Budget (optional)
                    </label>
                    <input
                      type="number"
                      id="dailyBudget"
                      {...register('payoutSettings.dailyBudget', { valueAsNumber: true })}
                      className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-primary-500 focus:ring-primary-500"
                    />
                  </div>
                  
                  <div>
                    <label htmlFor="monthlyBudget" className="block text-sm font-medium text-gray-700">
                      Monthly Budget (optional)
                    </label>
                    <input
                      type="number"
                      id="monthlyBudget"
                      {...register('payoutSettings.monthlyBudget', { valueAsNumber: true })}
                      className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-primary-500 focus:ring-primary-500"
                    />
                  </div>
                </div>
              </div>
            </div>
          )}
          
          {/* Action Buttons */}
          <div className="flex justify-between">
            <button
              type="button"
              onClick={() => navigate('/app/campaigns')}
              className="inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50"
            >
              Cancel
            </button>
            
            <div className="flex space-x-3">
              {isDirty && (
                <button
                  type="button"
                  onClick={() => reset()}
                  className="inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50"
                >
                  Reset Changes
                </button>
              )}
              
              <button
                type="submit"
                disabled={isSubmitting || !isDirty}
                className={`inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white ${
                  isSubmitting || !isDirty
                    ? 'bg-gray-400 cursor-not-allowed'
                    : 'bg-primary-600 hover:bg-primary-700'
                }`}
              >
                {isSubmitting ? 'Saving...' : 'Save Changes'}
              </button>
            </div>
          </div>
        </form>
      </div>
    </div>
  )
}

export default function EditCampaignPage() {
  return (
    <FormErrorBoundary>
      <EditCampaignPageInner />
    </FormErrorBoundary>
  )
}
</file>

<file path="src/pages/dashboard/CLAUDE.md">
# Dashboard Pages

# Page Structure
- `SupplierDashboard.tsx` - Traffic provider dashboard
- `BuyerDashboard.tsx` - Advertiser dashboard
- `AdminDashboard.tsx` - Platform administration
- `DashboardOverview.tsx` - Shared dashboard components
- `RealTimeMetrics.tsx` - Live performance tracking

# Supplier Dashboard
```tsx
export function SupplierDashboard() {
  const { user } = useAuth();
  const { data: metrics, loading } = useSupplierMetrics(user?.id);
  const { data: activeCampaigns } = useActiveCampaigns(user?.id);
  const { data: recentCalls } = useRecentCalls(user?.id, 10);
  
  // Real-time earnings updates
  const { data: liveEarnings } = useRealtimeEarnings(user?.id);
  
  if (loading) return <DashboardSkeleton />;
  
  return (
    <AppLayout>
      <div className="supplier-dashboard">
        <PageHeader
          title={`Welcome back, ${user?.first_name}`}
          subtitle="Here's your traffic performance overview"
        />
        
        <div className="metrics-grid">
          <MetricCard
            title="Today's Earnings"
            value={formatCurrency(metrics.todayEarnings)}
            change={metrics.earningsChange}
            icon={CurrencyDollarIcon}
            trend="up"
          />
          <MetricCard
            title="Calls Today"
            value={metrics.todayCalls}
            change={metrics.callsChange}
            icon={PhoneIcon}
          />
          <MetricCard
            title="Conversion Rate"
            value={`${metrics.conversionRate}%`}
            change={metrics.conversionChange}
            icon={TrendingUpIcon}
          />
          <MetricCard
            title="Quality Score"
            value={metrics.qualityScore}
            change={metrics.qualityChange}
            icon={StarIcon}
          />
        </div>
        
        <div className="dashboard-content">
          <div className="left-column">
            <EarningsChart data={metrics.earningsChart} />
            <CampaignPerformanceTable campaigns={activeCampaigns} />
          </div>
          
          <div className="right-column">
            <RecentCallsPanel calls={recentCalls} />
            <QuickActions />
            <NotificationsPanel />
          </div>
        </div>
      </div>
    </AppLayout>
  );
}
```

# Buyer Dashboard
```tsx
export function BuyerDashboard() {
  const { user } = useAuth();
  const { data: metrics, loading } = useBuyerMetrics(user?.id);
  const { data: campaigns } = useBuyerCampaigns(user?.id);
  const { data: leadQuality } = useLeadQualityMetrics(user?.id);
  
  return (
    <AppLayout>
      <div className="buyer-dashboard">
        <PageHeader
          title={`Welcome back, ${user?.first_name}`}
          subtitle="Manage your campaigns and track lead quality"
        />
        
        <div className="metrics-grid">
          <MetricCard
            title="Today's Spend"
            value={formatCurrency(metrics.todaySpend)}
            target={metrics.dailyBudget}
            icon={CreditCardIcon}
            showProgress
          />
          <MetricCard
            title="Leads Received"
            value={metrics.todayLeads}
            change={metrics.leadsChange}
            icon={UserGroupIcon}
          />
          <MetricCard
            title="Cost Per Lead"
            value={formatCurrency(metrics.costPerLead)}
            change={metrics.cplChange}
            icon={CalculatorIcon}
          />
          <MetricCard
            title="Campaign ROI"
            value={`${metrics.roi}%`}
            change={metrics.roiChange}
            icon={ChartBarIcon}
          />
        </div>
        
        <div className="dashboard-content">
          <div className="left-column">
            <LeadVolumeChart data={metrics.leadVolumeChart} />
            <CampaignBudgetOverview campaigns={campaigns} />
          </div>
          
          <div className="right-column">
            <LeadQualityPanel quality={leadQuality} />
            <TopPerformingCampaigns campaigns={campaigns} />
            <BudgetAlerts />
          </div>
        </div>
      </div>
    </AppLayout>
  );
}
```

# Admin Dashboard
```tsx
export function AdminDashboard() {
  const { data: platformMetrics } = usePlatformMetrics();
  const { data: userStats } = useUserStats();
  const { data: fraudMetrics } = useFraudMetrics();
  const { data: systemHealth } = useSystemHealth();
  
  return (
    <AppLayout>
      <div className="admin-dashboard">
        <PageHeader
          title="Platform Administration"
          subtitle="Monitor system performance and user activity"
        />
        
        <div className="admin-metrics-grid">
          <MetricCard
            title="Platform Revenue"
            value={formatCurrency(platformMetrics.totalRevenue)}
            period="today"
            icon={CurrencyDollarIcon}
          />
          <MetricCard
            title="Total Calls"
            value={platformMetrics.totalCalls}
            change={platformMetrics.callsChange}
            icon={PhoneIcon}
          />
          <MetricCard
            title="Active Users"
            value={userStats.activeUsers}
            breakdown={{ suppliers: userStats.suppliers, buyers: userStats.buyers }}
            icon={UsersIcon}
          />
          <MetricCard
            title="Fraud Rate"
            value={`${fraudMetrics.fraudRate}%`}
            severity={fraudMetrics.fraudRate > 5 ? 'high' : 'normal'}
            icon={ShieldExclamationIcon}
          />
        </div>
        
        <div className="admin-content">
          <div className="admin-grid">
            <SystemHealthPanel health={systemHealth} />
            <RecentUsersPanel />
            <FraudAlertsPanel alerts={fraudMetrics.recentAlerts} />
            <PlatformAnalyticsChart data={platformMetrics.analytics} />
          </div>
        </div>
      </div>
    </AppLayout>
  );
}
```

# Real-time Metrics Component
```tsx
export function RealTimeMetrics() {
  const [metrics, setMetrics] = useState<RealtimeMetrics | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  
  useEffect(() => {
    // Set up real-time subscription for metrics
    const subscription = supabase
      .channel('dashboard-metrics')
      .on('postgres_changes', {
        event: '*',
        schema: 'public',
        table: 'real_time_metrics',
      }, (payload) => {
        setMetrics(payload.new as RealtimeMetrics);
      })
      .on('presence', { event: 'sync' }, () => {
        setIsConnected(true);
      })
      .subscribe();
      
    return () => supabase.removeChannel(subscription);
  }, []);
  
  return (
    <div className="realtime-metrics">
      <div className="metrics-header">
        <h3>Live Metrics</h3>
        <div className="connection-status">
          <div className={`status-indicator ${isConnected ? 'connected' : 'disconnected'}`} />
          <span>{isConnected ? 'Live' : 'Connecting...'}</span>
        </div>
      </div>
      
      {metrics && (
        <div className="live-stats">
          <div className="stat-item">
            <span className="stat-label">Active Calls</span>
            <span className="stat-value">{metrics.activeCalls}</span>
          </div>
          <div className="stat-item">
            <span className="stat-label">Calls/Hour</span>
            <span className="stat-value">{metrics.callsPerHour}</span>
          </div>
          <div className="stat-item">
            <span className="stat-label">Revenue/Hour</span>
            <span className="stat-value">{formatCurrency(metrics.revenuePerHour)}</span>
          </div>
        </div>
      )}
    </div>
  );
}
```

# Dashboard Widget System
```tsx
interface DashboardWidgetProps {
  widget: Widget;
  onEdit?: (widget: Widget) => void;
  onRemove?: (widgetId: string) => void;
}

export function DashboardWidget({ widget, onEdit, onRemove }: DashboardWidgetProps) {
  const WidgetComponent = getWidgetComponent(widget.type);
  
  return (
    <div className="dashboard-widget" data-widget-id={widget.id}>
      <div className="widget-header">
        <h4>{widget.title}</h4>
        <div className="widget-actions">
          {onEdit && (
            <Button
              size="sm"
              variant="ghost"
              onClick={() => onEdit(widget)}
            >
              <Cog6ToothIcon className="h-4 w-4" />
            </Button>
          )}
          {onRemove && (
            <Button
              size="sm"
              variant="ghost"
              onClick={() => onRemove(widget.id)}
            >
              <XMarkIcon className="h-4 w-4" />
            </Button>
          )}
        </div>
      </div>
      
      <div className="widget-content">
        <WidgetComponent {...widget.config} />
      </div>
    </div>
  );
}
```

# Customizable Dashboard Layout
```tsx
export function CustomDashboard() {
  const { user } = useAuth();
  const [layout, setLayout] = useState<DashboardLayout | null>(null);
  const [isEditing, setIsEditing] = useState(false);
  
  const { data: widgets } = useDashboardWidgets(user?.id);
  
  const handleLayoutChange = (newLayout: Layout[]) => {
    setLayout(prev => ({ ...prev, layout: newLayout }));
  };
  
  const addWidget = (widgetType: WidgetType) => {
    const newWidget: Widget = {
      id: generateId(),
      type: widgetType,
      title: getWidgetTitle(widgetType),
      config: getDefaultWidgetConfig(widgetType),
    };
    
    // Add widget to layout
    setLayout(prev => ({
      ...prev,
      widgets: [...(prev?.widgets || []), newWidget],
    }));
  };
  
  return (
    <AppLayout>
      <div className="custom-dashboard">
        <PageHeader
          title="Dashboard"
          action={
            <div className="dashboard-actions">
              <Button
                variant="outline"
                onClick={() => setIsEditing(!isEditing)}
              >
                {isEditing ? 'Done' : 'Customize'}
              </Button>
            </div>
          }
        />
        
        {isEditing && (
          <div className="widget-palette">
            <h3>Add Widgets</h3>
            <div className="widget-options">
              {AVAILABLE_WIDGETS.map(widgetType => (
                <Button
                  key={widgetType}
                  variant="outline"
                  onClick={() => addWidget(widgetType)}
                >
                  Add {getWidgetTitle(widgetType)}
                </Button>
              ))}
            </div>
          </div>
        )}
        
        <ResponsiveGridLayout
          layout={layout?.layout || []}
          onLayoutChange={handleLayoutChange}
          isDraggable={isEditing}
          isResizable={isEditing}
        >
          {widgets?.map(widget => (
            <div key={widget.id}>
              <DashboardWidget
                widget={widget}
                onEdit={isEditing ? handleEditWidget : undefined}
                onRemove={isEditing ? handleRemoveWidget : undefined}
              />
            </div>
          ))}
        </ResponsiveGridLayout>
      </div>
    </AppLayout>
  );
}
```

# Performance Monitoring
```tsx
export function PerformanceMonitor() {
  const [performanceData, setPerformanceData] = useState<PerformanceMetrics[]>([]);
  
  useEffect(() => {
    // Monitor key performance metrics
    const observer = new PerformanceObserver((list) => {
      const entries = list.getEntries();
      entries.forEach(entry => {
        if (entry.entryType === 'measure') {
          setPerformanceData(prev => [...prev, {
            name: entry.name,
            duration: entry.duration,
            timestamp: Date.now(),
          }]);
        }
      });
    });
    
    observer.observe({ entryTypes: ['measure', 'navigation'] });
    
    return () => observer.disconnect();
  }, []);
  
  return (
    <div className="performance-monitor">
      <h3>Performance Metrics</h3>
      <div className="performance-stats">
        {performanceData.slice(-5).map(metric => (
          <div key={metric.timestamp} className="performance-stat">
            <span>{metric.name}</span>
            <span>{Math.round(metric.duration)}ms</span>
          </div>
        ))}
      </div>
    </div>
  );
}
```

# Dashboard Notifications
```tsx
export function DashboardNotifications() {
  const { data: notifications } = useNotifications();
  const [showAll, setShowAll] = useState(false);
  
  const visibleNotifications = showAll 
    ? notifications 
    : notifications?.slice(0, 5);
  
  return (
    <div className="dashboard-notifications">
      <div className="notifications-header">
        <h3>Notifications</h3>
        {notifications?.length > 5 && (
          <Button
            variant="ghost"
            size="sm"
            onClick={() => setShowAll(!showAll)}
          >
            {showAll ? 'Show Less' : `View All (${notifications.length})`}
          </Button>
        )}
      </div>
      
      <div className="notifications-list">
        {visibleNotifications?.map(notification => (
          <NotificationItem
            key={notification.id}
            notification={notification}
            onClick={() => handleNotificationClick(notification)}
          />
        ))}
      </div>
      
      {notifications?.length === 0 && (
        <EmptyState
          icon={BellIcon}
          title="No notifications"
          description="You're all caught up!"
        />
      )}
    </div>
  );
}
```

# Dashboard Export Features
- Export dashboard data to PDF/Excel
- Schedule automated reports
- Custom report generation
- Data visualization exports
- Performance snapshot sharing

# Mobile Dashboard Optimization
- Touch-optimized controls
- Responsive widget layouts
- Mobile-specific metrics
- Gesture navigation
- Offline data caching

# Dashboard Analytics
- User engagement tracking
- Widget usage analytics
- Performance optimization
- Feature adoption metrics
- User behavior insights

# CRITICAL RULES
- NO regex in dashboard logic
- NO any types in dashboard interfaces
- ALWAYS handle real-time data safely
- ALWAYS optimize for performance
- IMPLEMENT proper error boundaries
- TEST dashboard responsiveness
- ENSURE data accuracy
- MAINTAIN dashboard load times
</file>

<file path="src/pages/legal/CompliancePage.tsx">
import { ShieldCheckIcon, LockClosedIcon, CheckCircleIcon, DocumentTextIcon } from '@heroicons/react/24/outline'

const certifications = [
  {
    icon: ShieldCheckIcon,
    title: 'SOC 2 Type II Certified',
    description: 'Our systems and processes are audited annually to ensure the highest standards of security and availability.',
  },
  {
    icon: LockClosedIcon,
    title: 'PCI DSS Compliant',
    description: 'We maintain PCI compliance for secure payment processing and protection of financial data.',
  },
  {
    icon: CheckCircleIcon,
    title: 'TCPA Compliant',
    description: 'Our platform helps ensure compliance with Telephone Consumer Protection Act regulations.',
  },
  {
    icon: DocumentTextIcon,
    title: 'GDPR & CCPA Ready',
    description: 'We support data privacy requirements under GDPR and California Consumer Privacy Act.',
  },
]

const regulations = [
  {
    title: 'FCC Regulations',
    items: [
      'Compliance with robocall mitigation requirements',
      'STIR/SHAKEN implementation for call authentication',
      'Adherence to Do Not Call Registry requirements',
      'Regular compliance audits and reporting',
    ],
  },
  {
    title: 'State Regulations',
    items: [
      'State-specific telemarketing laws compliance',
      'Licensing requirements for different jurisdictions',
      'Time-of-day calling restrictions',
      'Industry-specific regulations (insurance, finance, etc.)',
    ],
  },
  {
    title: 'Data Protection',
    items: [
      'End-to-end encryption for sensitive data',
      'Regular security assessments and penetration testing',
      'Data retention and deletion policies',
      'Employee security training and background checks',
    ],
  },
]

export default function CompliancePage() {
  return (
    <div className="bg-white">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-12">
        <div className="text-center mb-12">
          <h1 className="text-4xl font-extrabold text-gray-900 mb-4">Compliance & Security</h1>
          <p className="text-xl text-gray-500 max-w-3xl mx-auto">
            DependableCalls maintains the highest standards of compliance and security to protect our partners and ensure 
            regulatory adherence across all operations.
          </p>
        </div>

        {/* Certifications */}
        <section className="mb-16">
          <h2 className="text-3xl font-bold text-gray-900 text-center mb-8">Our Certifications</h2>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
            {certifications.map((cert, index) => (
              <div key={index} className="bg-gray-50 rounded-lg p-6 flex items-start">
                <cert.icon className="h-12 w-12 text-primary-600 flex-shrink-0" />
                <div className="ml-4">
                  <h3 className="text-lg font-semibold text-gray-900 mb-2">{cert.title}</h3>
                  <p className="text-gray-600">{cert.description}</p>
                </div>
              </div>
            ))}
          </div>
        </section>

        {/* Regulatory Compliance */}
        <section className="mb-16">
          <h2 className="text-3xl font-bold text-gray-900 text-center mb-8">Regulatory Compliance</h2>
          <div className="grid grid-cols-1 md:grid-cols-3 gap-8">
            {regulations.map((reg, index) => (
              <div key={index} className="bg-white border border-gray-200 rounded-lg p-6">
                <h3 className="text-xl font-semibold text-gray-900 mb-4">{reg.title}</h3>
                <ul className="space-y-2">
                  {reg.items.map((item, itemIndex) => (
                    <li key={itemIndex} className="flex items-start">
                      <CheckCircleIcon className="h-5 w-5 text-green-500 flex-shrink-0 mt-0.5" />
                      <span className="ml-2 text-gray-600">{item}</span>
                    </li>
                  ))}
                </ul>
              </div>
            ))}
          </div>
        </section>

        {/* Security Measures */}
        <section className="mb-16">
          <div className="bg-primary-50 rounded-lg p-8">
            <h2 className="text-3xl font-bold text-gray-900 mb-6">Security Infrastructure</h2>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div>
                <h3 className="text-xl font-semibold text-gray-900 mb-3">Technical Security</h3>
                <ul className="space-y-2 text-gray-600">
                  <li>â€¢ 256-bit SSL encryption for all data transmission</li>
                  <li>â€¢ Multi-factor authentication for all accounts</li>
                  <li>â€¢ Real-time threat monitoring and response</li>
                  <li>â€¢ Regular security updates and patches</li>
                  <li>â€¢ Secure API endpoints with rate limiting</li>
                </ul>
              </div>
              <div>
                <h3 className="text-xl font-semibold text-gray-900 mb-3">Operational Security</h3>
                <ul className="space-y-2 text-gray-600">
                  <li>â€¢ 24/7 security operations center</li>
                  <li>â€¢ Incident response team and protocols</li>
                  <li>â€¢ Regular third-party security audits</li>
                  <li>â€¢ Comprehensive disaster recovery plan</li>
                  <li>â€¢ Strict access controls and monitoring</li>
                </ul>
              </div>
            </div>
          </div>
        </section>

        {/* Fraud Prevention */}
        <section className="mb-16">
          <h2 className="text-3xl font-bold text-gray-900 text-center mb-8">Fraud Prevention</h2>
          <div className="bg-white border border-gray-200 rounded-lg p-8">
            <p className="text-lg text-gray-600 mb-6">
              Our advanced fraud detection system uses machine learning and real-time analysis to protect all parties:
            </p>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <ul className="space-y-3">
                <li className="flex items-start">
                  <span className="text-primary-600 font-bold mr-2">â€¢</span>
                  <span>Real-time call analysis and scoring</span>
                </li>
                <li className="flex items-start">
                  <span className="text-primary-600 font-bold mr-2">â€¢</span>
                  <span>Duplicate and repeat caller detection</span>
                </li>
                <li className="flex items-start">
                  <span className="text-primary-600 font-bold mr-2">â€¢</span>
                  <span>Geographic and demographic verification</span>
                </li>
                <li className="flex items-start">
                  <span className="text-primary-600 font-bold mr-2">â€¢</span>
                  <span>Voice pattern and audio analysis</span>
                </li>
              </ul>
              <ul className="space-y-3">
                <li className="flex items-start">
                  <span className="text-primary-600 font-bold mr-2">â€¢</span>
                  <span>Network traffic pattern monitoring</span>
                </li>
                <li className="flex items-start">
                  <span className="text-primary-600 font-bold mr-2">â€¢</span>
                  <span>Automated blocking of suspicious sources</span>
                </li>
                <li className="flex items-start">
                  <span className="text-primary-600 font-bold mr-2">â€¢</span>
                  <span>Manual review processes for edge cases</span>
                </li>
                <li className="flex items-start">
                  <span className="text-primary-600 font-bold mr-2">â€¢</span>
                  <span>Continuous model improvement and updates</span>
                </li>
              </ul>
            </div>
          </div>
        </section>

        {/* Contact Section */}
        <section className="text-center">
          <div className="bg-gray-50 rounded-lg p-8">
            <h2 className="text-2xl font-bold text-gray-900 mb-4">Questions About Compliance?</h2>
            <p className="text-lg text-gray-600 mb-6">
              Our compliance team is here to help with any questions about our security measures, certifications, or regulatory adherence.
            </p>
            <div className="flex flex-col sm:flex-row gap-4 justify-center">
              <a
                href="/contact"
                className="inline-flex items-center justify-center px-6 py-3 border border-transparent text-base font-medium rounded-md text-white bg-primary-600 hover:bg-primary-700"
              >
                Contact Compliance Team
              </a>
              <a
                href="mailto:compliance@dependablecalls.com"
                className="inline-flex items-center justify-center px-6 py-3 border border-gray-300 text-base font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50"
              >
                compliance@dependablecalls.com
              </a>
            </div>
          </div>
        </section>
      </div>
    </div>
  )
}
</file>

<file path="src/pages/legal/PrivacyPage.tsx">
export default function PrivacyPage() {
  return (
    <div className="bg-white">
      <div className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-12">
        <h1 className="text-4xl font-extrabold text-gray-900 mb-8">Privacy Policy</h1>
        
        <div className="prose prose-lg text-gray-600 max-w-none">
          <p className="text-sm text-gray-500 mb-8">Last updated: January 20, 2025</p>

          <section className="mb-8">
            <h2 className="text-2xl font-bold text-gray-900 mb-4">1. Introduction</h2>
            <p>
              DependableCalls ("we," "our," or "us") is committed to protecting your privacy. This Privacy Policy explains how we collect, 
              use, disclose, and safeguard your information when you use our pay-per-call platform and related services.
            </p>
          </section>

          <section className="mb-8">
            <h2 className="text-2xl font-bold text-gray-900 mb-4">2. Information We Collect</h2>
            <h3 className="text-xl font-semibold text-gray-900 mb-2">Personal Information</h3>
            <ul className="list-disc pl-6 mb-4">
              <li>Name and contact information (email, phone number, address)</li>
              <li>Business information (company name, role, industry)</li>
              <li>Payment and billing information</li>
              <li>Account credentials</li>
            </ul>

            <h3 className="text-xl font-semibold text-gray-900 mb-2">Call Data</h3>
            <ul className="list-disc pl-6 mb-4">
              <li>Call recordings and transcriptions</li>
              <li>Caller phone numbers and geographic data</li>
              <li>Call duration and quality metrics</li>
              <li>Campaign performance data</li>
            </ul>

            <h3 className="text-xl font-semibold text-gray-900 mb-2">Technical Information</h3>
            <ul className="list-disc pl-6 mb-4">
              <li>IP addresses and device information</li>
              <li>Browser type and operating system</li>
              <li>Usage data and analytics</li>
              <li>Cookies and similar tracking technologies</li>
            </ul>
          </section>

          <section className="mb-8">
            <h2 className="text-2xl font-bold text-gray-900 mb-4">3. How We Use Your Information</h2>
            <p className="mb-4">We use the collected information for various purposes:</p>
            <ul className="list-disc pl-6">
              <li>To provide and maintain our services</li>
              <li>To process transactions and manage billing</li>
              <li>To detect and prevent fraud</li>
              <li>To improve our platform and user experience</li>
              <li>To communicate with you about services and updates</li>
              <li>To comply with legal obligations</li>
              <li>To protect our rights and the rights of our users</li>
            </ul>
          </section>

          <section className="mb-8">
            <h2 className="text-2xl font-bold text-gray-900 mb-4">4. Information Sharing and Disclosure</h2>
            <p className="mb-4">We may share your information in the following circumstances:</p>
            <ul className="list-disc pl-6">
              <li>With your consent or at your direction</li>
              <li>With our service providers and business partners</li>
              <li>To comply with legal requirements or respond to legal process</li>
              <li>To protect our rights, property, or safety</li>
              <li>In connection with a business transaction (merger, acquisition, etc.)</li>
            </ul>
          </section>

          <section className="mb-8">
            <h2 className="text-2xl font-bold text-gray-900 mb-4">5. Data Security</h2>
            <p>
              We implement appropriate technical and organizational measures to protect your information against unauthorized access, 
              alteration, disclosure, or destruction. These measures include encryption, access controls, and regular security audits.
            </p>
          </section>

          <section className="mb-8">
            <h2 className="text-2xl font-bold text-gray-900 mb-4">6. Your Rights and Choices</h2>
            <p className="mb-4">You have certain rights regarding your personal information:</p>
            <ul className="list-disc pl-6">
              <li>Access and receive a copy of your data</li>
              <li>Update or correct inaccurate information</li>
              <li>Request deletion of your data</li>
              <li>Object to or restrict certain processing</li>
              <li>Data portability</li>
              <li>Withdraw consent</li>
            </ul>
          </section>

          <section className="mb-8">
            <h2 className="text-2xl font-bold text-gray-900 mb-4">7. Cookies and Tracking</h2>
            <p>
              We use cookies and similar tracking technologies to improve your experience on our platform. You can control cookie 
              preferences through your browser settings, though some features may not function properly without cookies.
            </p>
          </section>

          <section className="mb-8">
            <h2 className="text-2xl font-bold text-gray-900 mb-4">8. Third-Party Links</h2>
            <p>
              Our services may contain links to third-party websites. We are not responsible for the privacy practices of these 
              external sites and encourage you to review their privacy policies.
            </p>
          </section>

          <section className="mb-8">
            <h2 className="text-2xl font-bold text-gray-900 mb-4">9. Children's Privacy</h2>
            <p>
              Our services are not intended for individuals under the age of 18. We do not knowingly collect personal information 
              from children.
            </p>
          </section>

          <section className="mb-8">
            <h2 className="text-2xl font-bold text-gray-900 mb-4">10. Changes to This Privacy Policy</h2>
            <p>
              We may update this Privacy Policy from time to time. We will notify you of any changes by posting the new Privacy 
              Policy on this page and updating the "Last updated" date.
            </p>
          </section>

          <section className="mb-8">
            <h2 className="text-2xl font-bold text-gray-900 mb-4">11. Contact Us</h2>
            <p>If you have questions about this Privacy Policy, please contact us at:</p>
            <div className="mt-4 bg-gray-50 p-4 rounded-lg">
              <p className="font-semibold">DependableCalls</p>
              <p>Email: privacy@dependablecalls.com</p>
              <p>Phone: +1 (555) 123-4567</p>
              <p>Address: 123 Business Center, Suite 400, San Francisco, CA 94105</p>
            </div>
          </section>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/pages/legal/TermsPage.tsx">
export default function TermsPage() {
  return (
    <div className="bg-white">
      <div className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-12">
        <h1 className="text-4xl font-extrabold text-gray-900 mb-8">Terms of Service</h1>
        
        <div className="prose prose-lg text-gray-600 max-w-none">
          <p className="text-sm text-gray-500 mb-8">Effective Date: January 20, 2025</p>

          <section className="mb-8">
            <h2 className="text-2xl font-bold text-gray-900 mb-4">1. Agreement to Terms</h2>
            <p>
              By accessing or using the DependableCalls platform ("Service"), you agree to be bound by these Terms of Service 
              ("Terms"). If you disagree with any part of these terms, you may not access the Service.
            </p>
          </section>

          <section className="mb-8">
            <h2 className="text-2xl font-bold text-gray-900 mb-4">2. Description of Service</h2>
            <p>
              DependableCalls provides a pay-per-call platform that connects traffic suppliers with advertisers. Our Service includes 
              call tracking, routing, fraud detection, analytics, and payment processing for qualifying phone calls.
            </p>
          </section>

          <section className="mb-8">
            <h2 className="text-2xl font-bold text-gray-900 mb-4">3. User Accounts</h2>
            <h3 className="text-xl font-semibold text-gray-900 mb-2">Account Registration</h3>
            <ul className="list-disc pl-6 mb-4">
              <li>You must provide accurate, current, and complete information</li>
              <li>You are responsible for maintaining account security</li>
              <li>You must notify us immediately of any unauthorized access</li>
              <li>One person or entity may not maintain multiple accounts</li>
            </ul>

            <h3 className="text-xl font-semibold text-gray-900 mb-2">Account Types</h3>
            <ul className="list-disc pl-6">
              <li><strong>Suppliers:</strong> Traffic providers sending calls to the platform</li>
              <li><strong>Buyers:</strong> Advertisers receiving and paying for qualified calls</li>
              <li><strong>Admin:</strong> Platform administrators with full access</li>
            </ul>
          </section>

          <section className="mb-8">
            <h2 className="text-2xl font-bold text-gray-900 mb-4">4. Acceptable Use</h2>
            <p className="mb-4">You agree not to:</p>
            <ul className="list-disc pl-6">
              <li>Violate any laws or regulations</li>
              <li>Submit fraudulent or misleading information</li>
              <li>Generate artificial or fraudulent calls</li>
              <li>Interfere with or disrupt the Service</li>
              <li>Attempt to gain unauthorized access to any systems</li>
              <li>Use the Service for any illegal or unauthorized purpose</li>
              <li>Violate the intellectual property rights of others</li>
            </ul>
          </section>

          <section className="mb-8">
            <h2 className="text-2xl font-bold text-gray-900 mb-4">5. Payment Terms</h2>
            <h3 className="text-xl font-semibold text-gray-900 mb-2">For Buyers</h3>
            <ul className="list-disc pl-6 mb-4">
              <li>Payment is due for all qualified calls as determined by our system</li>
              <li>Prices are set per campaign and may vary</li>
              <li>Invoices are generated weekly/monthly based on your agreement</li>
              <li>Late payments may result in service suspension</li>
            </ul>

            <h3 className="text-xl font-semibold text-gray-900 mb-2">For Suppliers</h3>
            <ul className="list-disc pl-6">
              <li>Payments are made for qualified calls only</li>
              <li>Payout schedules vary (daily, weekly, or monthly)</li>
              <li>Minimum payout thresholds may apply</li>
              <li>We reserve the right to withhold payment for fraudulent activity</li>
            </ul>
          </section>

          <section className="mb-8">
            <h2 className="text-2xl font-bold text-gray-900 mb-4">6. Call Quality and Fraud</h2>
            <p className="mb-4">
              We employ advanced fraud detection systems to ensure call quality. We reserve the right to:
            </p>
            <ul className="list-disc pl-6">
              <li>Reject calls that don't meet quality standards</li>
              <li>Investigate suspicious activity</li>
              <li>Suspend or terminate accounts engaged in fraud</li>
              <li>Withhold payments for fraudulent calls</li>
              <li>Report illegal activities to law enforcement</li>
            </ul>
          </section>

          <section className="mb-8">
            <h2 className="text-2xl font-bold text-gray-900 mb-4">7. Intellectual Property</h2>
            <p>
              The Service and its original content, features, and functionality are owned by DependableCalls and are protected by 
              international copyright, trademark, patent, trade secret, and other intellectual property laws.
            </p>
          </section>

          <section className="mb-8">
            <h2 className="text-2xl font-bold text-gray-900 mb-4">8. Privacy and Data Protection</h2>
            <p>
              Your use of the Service is also governed by our Privacy Policy. By using the Service, you consent to the collection 
              and use of information as detailed in the Privacy Policy.
            </p>
          </section>

          <section className="mb-8">
            <h2 className="text-2xl font-bold text-gray-900 mb-4">9. Disclaimers and Limitations</h2>
            <h3 className="text-xl font-semibold text-gray-900 mb-2">Service Availability</h3>
            <p className="mb-4">
              The Service is provided "as is" and "as available" without warranties of any kind. We do not guarantee uninterrupted 
              or error-free operation of the Service.
            </p>

            <h3 className="text-xl font-semibold text-gray-900 mb-2">Limitation of Liability</h3>
            <p>
              To the maximum extent permitted by law, DependableCalls shall not be liable for any indirect, incidental, special, 
              consequential, or punitive damages resulting from your use of the Service.
            </p>
          </section>

          <section className="mb-8">
            <h2 className="text-2xl font-bold text-gray-900 mb-4">10. Indemnification</h2>
            <p>
              You agree to indemnify and hold harmless DependableCalls, its officers, directors, employees, and agents from any 
              claims, damages, losses, liabilities, and expenses arising from your use of the Service or violation of these Terms.
            </p>
          </section>

          <section className="mb-8">
            <h2 className="text-2xl font-bold text-gray-900 mb-4">11. Termination</h2>
            <p>
              We may terminate or suspend your account immediately, without prior notice or liability, for any reason, including 
              breach of these Terms. Upon termination, your right to use the Service will cease immediately.
            </p>
          </section>

          <section className="mb-8">
            <h2 className="text-2xl font-bold text-gray-900 mb-4">12. Governing Law</h2>
            <p>
              These Terms shall be governed by and construed in accordance with the laws of California, United States, without 
              regard to its conflict of law provisions.
            </p>
          </section>

          <section className="mb-8">
            <h2 className="text-2xl font-bold text-gray-900 mb-4">13. Changes to Terms</h2>
            <p>
              We reserve the right to modify or replace these Terms at any time. If a revision is material, we will provide at 
              least 30 days notice prior to any new terms taking effect.
            </p>
          </section>

          <section className="mb-8">
            <h2 className="text-2xl font-bold text-gray-900 mb-4">14. Contact Information</h2>
            <p>If you have any questions about these Terms, please contact us at:</p>
            <div className="mt-4 bg-gray-50 p-4 rounded-lg">
              <p className="font-semibold">DependableCalls Legal Department</p>
              <p>Email: legal@dependablecalls.com</p>
              <p>Phone: +1 (555) 123-4567</p>
              <p>Address: 123 Business Center, Suite 400, San Francisco, CA 94105</p>
            </div>
          </section>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/pages/public/AboutPage.tsx">
import {
  PhoneIcon,
  ChartBarIcon,
  UsersIcon,
  ShieldCheckIcon,
  CurrencyDollarIcon,
  BoltIcon,
} from '@heroicons/react/24/outline'

const values = [
  {
    name: 'Transparency',
    description: 'Complete visibility into all call metrics, pricing, and performance data.',
    icon: ChartBarIcon,
  },
  {
    name: 'Reliability',
    description: '99.9% uptime SLA with redundant systems and 24/7 monitoring.',
    icon: BoltIcon,
  },
  {
    name: 'Security',
    description: 'Industry-leading fraud detection and data protection standards.',
    icon: ShieldCheckIcon,
  },
  {
    name: 'Partnership',
    description: 'We succeed when our clients succeed. Your growth is our priority.',
    icon: UsersIcon,
  },
]

const team = [
  {
    name: 'Sarah Johnson',
    role: 'CEO & Founder',
    experience: '15+ years in performance marketing and telecommunications',
  },
  {
    name: 'Michael Chen',
    role: 'CTO',
    experience: '12+ years building scalable call tracking platforms',
  },
  {
    name: 'Emily Rodriguez',
    role: 'VP of Sales',
    experience: '10+ years in affiliate marketing and lead generation',
  },
  {
    name: 'David Kim',
    role: 'Head of Fraud Prevention',
    experience: '8+ years in cybersecurity and machine learning',
  },
]

const milestones = [
  { year: '2020', event: 'Company founded with mission to eliminate call fraud' },
  { year: '2021', event: 'Processed first 1 million calls with 99.2% quality score' },
  { year: '2022', event: 'Launched real-time analytics dashboard and API' },
  { year: '2023', event: 'Expanded to international markets and multi-language support' },
  { year: '2024', event: 'Introduced AI-powered fraud detection and call scoring' },
]

export default function AboutPage() {
  return (
    <div>
      {/* Hero Section */}
      <div className="bg-gradient-to-br from-primary-600 to-primary-800 text-white">
        <div className="max-w-7xl mx-auto px-4 py-24 sm:px-6 lg:px-8">
          <div className="text-center">
            <h1 className="text-4xl font-extrabold sm:text-5xl md:text-6xl">
              About DependableCalls
            </h1>
            <p className="mt-6 text-xl max-w-3xl mx-auto">
              Since 2020, we've been the trusted partner for performance marketers seeking
              transparency, quality, and results in pay-per-call advertising.
            </p>
          </div>
        </div>
      </div>

      {/* Mission Section */}
      <div className="py-16 bg-white">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="lg:text-center">
            <h2 className="text-base text-primary-600 font-semibold tracking-wide uppercase">
              Our Mission
            </h2>
            <p className="mt-2 text-3xl leading-8 font-extrabold tracking-tight text-gray-900 sm:text-4xl">
              Building trust in performance marketing
            </p>
          </div>

          <div className="mt-10">
            <div className="space-y-10 md:space-y-0 md:grid md:grid-cols-2 md:gap-x-8 md:gap-y-10">
              <div className="bg-primary-50 rounded-lg p-8">
                <div className="flex items-center justify-center h-12 w-12 rounded-md bg-primary-500 text-white mb-4">
                  <PhoneIcon className="h-6 w-6" />
                </div>
                <h3 className="text-lg font-medium text-gray-900">Quality First</h3>
                <p className="mt-2 text-base text-gray-500">
                  Every call is monitored, scored, and verified to ensure you only pay for genuine,
                  high-intent leads that drive real business value.
                </p>
              </div>

              <div className="bg-primary-50 rounded-lg p-8">
                <div className="flex items-center justify-center h-12 w-12 rounded-md bg-primary-500 text-white mb-4">
                  <CurrencyDollarIcon className="h-6 w-6" />
                </div>
                <h3 className="text-lg font-medium text-gray-900">Fair Pricing</h3>
                <p className="mt-2 text-base text-gray-500">
                  Transparent pricing with no hidden fees. You see exactly what you're paying for
                  and can track ROI in real-time across all campaigns.
                </p>
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* Values Section */}
      <div className="py-16 bg-gray-50">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="lg:text-center">
            <h2 className="text-base text-primary-600 font-semibold tracking-wide uppercase">
              Our Values
            </h2>
            <p className="mt-2 text-3xl leading-8 font-extrabold tracking-tight text-gray-900 sm:text-4xl">
              What drives us every day
            </p>
          </div>

          <div className="mt-10">
            <div className="space-y-10 md:space-y-0 md:grid md:grid-cols-2 lg:grid-cols-4 md:gap-x-8 md:gap-y-10">
              {values.map((value) => (
                <div key={value.name} className="text-center">
                  <div className="flex items-center justify-center h-12 w-12 rounded-md bg-primary-500 text-white mx-auto">
                    <value.icon className="h-6 w-6" />
                  </div>
                  <h3 className="mt-4 text-lg font-medium text-gray-900">{value.name}</h3>
                  <p className="mt-2 text-base text-gray-500">{value.description}</p>
                </div>
              ))}
            </div>
          </div>
        </div>
      </div>

      {/* Timeline Section */}
      <div className="py-16 bg-white">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="lg:text-center">
            <h2 className="text-base text-primary-600 font-semibold tracking-wide uppercase">
              Our Journey
            </h2>
            <p className="mt-2 text-3xl leading-8 font-extrabold tracking-tight text-gray-900 sm:text-4xl">
              Key milestones
            </p>
          </div>

          <div className="mt-10">
            <div className="space-y-8">
              {milestones.map((milestone) => (
                <div key={milestone.year} className="flex">
                  <div className="flex-shrink-0">
                    <div className="flex items-center justify-center h-12 w-12 rounded-full bg-primary-500 text-white font-semibold">
                      {milestone.year}
                    </div>
                  </div>
                  <div className="ml-4">
                    <div className="text-lg font-medium text-gray-900">{milestone.year}</div>
                    <div className="mt-1 text-base text-gray-500">{milestone.event}</div>
                  </div>
                </div>
              ))}
            </div>
          </div>
        </div>
      </div>

      {/* Team Section */}
      <div className="py-16 bg-gray-50">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="lg:text-center">
            <h2 className="text-base text-primary-600 font-semibold tracking-wide uppercase">
              Leadership Team
            </h2>
            <p className="mt-2 text-3xl leading-8 font-extrabold tracking-tight text-gray-900 sm:text-4xl">
              Industry experts you can trust
            </p>
          </div>

          <div className="mt-10">
            <div className="space-y-8 md:space-y-0 md:grid md:grid-cols-2 lg:grid-cols-4 md:gap-8">
              {team.map((member) => (
                <div key={member.name} className="bg-white rounded-lg shadow-sm p-6">
                  <div className="text-center">
                    <div className="h-20 w-20 bg-gradient-to-br from-primary-500 to-primary-600 rounded-full mx-auto mb-4 flex items-center justify-center">
                      <span className="text-white font-bold text-xl">
                        {member.name
                          .split(' ')
                          .map((n) => n[0])
                          .join('')}
                      </span>
                    </div>
                    <h3 className="text-lg font-medium text-gray-900">{member.name}</h3>
                    <p className="text-sm text-primary-600 font-semibold">{member.role}</p>
                    <p className="mt-2 text-sm text-gray-500">{member.experience}</p>
                  </div>
                </div>
              ))}
            </div>
          </div>
        </div>
      </div>

      {/* Stats Section */}
      <div className="py-16 bg-primary-600">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="text-center">
            <h2 className="text-3xl font-extrabold text-white sm:text-4xl">By the numbers</h2>
            <p className="mt-4 text-xl text-primary-200">Our track record speaks for itself</p>
          </div>

          <div className="mt-10 grid grid-cols-2 gap-4 md:grid-cols-4">
            <div className="text-center">
              <p className="text-4xl font-extrabold text-white">$50M+</p>
              <p className="mt-2 text-base text-primary-200">Revenue Generated</p>
            </div>
            <div className="text-center">
              <p className="text-4xl font-extrabold text-white">2.5M+</p>
              <p className="mt-2 text-base text-primary-200">Calls Per Month</p>
            </div>
            <div className="text-center">
              <p className="text-4xl font-extrabold text-white">94%</p>
              <p className="mt-2 text-base text-primary-200">Average Quality Score</p>
            </div>
            <div className="text-center">
              <p className="text-4xl font-extrabold text-white">99.9%</p>
              <p className="mt-2 text-base text-primary-200">Uptime SLA</p>
            </div>
          </div>
        </div>
      </div>

      {/* CTA Section */}
      <div className="bg-white">
        <div className="max-w-7xl mx-auto py-12 px-4 sm:px-6 lg:py-16 lg:px-8 lg:flex lg:items-center lg:justify-between">
          <h2 className="text-3xl font-extrabold tracking-tight text-gray-900 sm:text-4xl">
            <span className="block">Ready to work with us?</span>
            <span className="block text-primary-600">Let's discuss your needs.</span>
          </h2>
          <div className="mt-8 flex lg:mt-0 lg:flex-shrink-0">
            <div className="inline-flex rounded-md shadow">
              <a
                href="/contact"
                className="inline-flex items-center justify-center px-5 py-3 border border-transparent text-base font-medium rounded-md text-white bg-primary-600 hover:bg-primary-700"
              >
                Contact us
              </a>
            </div>
            <div className="ml-3 inline-flex rounded-md shadow">
              <a
                href="/register"
                className="inline-flex items-center justify-center px-5 py-3 border border-transparent text-base font-medium rounded-md text-primary-600 bg-white hover:bg-primary-50"
              >
                Get started
              </a>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/pages/public/BlogPostPage.tsx">
import { useParams, Link, Navigate } from 'react-router-dom'
import { CalendarIcon, UserIcon, ClockIcon, ArrowLeftIcon } from '@heroicons/react/24/outline'
import { blogPosts } from '../../data/blogPosts'

export default function BlogPostPage() {
  const { slug } = useParams<{ slug: string }>()

  // Find the blog post by slug
  const post = blogPosts.find((p) => p.slug === slug)

  // If post not found, redirect to blog page
  if (!post) {
    return <Navigate to="/blog" replace />
  }

  return (
    <div className="bg-white min-h-screen">
      {/* Back to Blog */}
      <div className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 pt-8">
        <Link
          to="/blog"
          className="inline-flex items-center text-primary-600 hover:text-primary-700 font-medium"
        >
          <ArrowLeftIcon className="h-5 w-5 mr-2" />
          Back to Blog
        </Link>
      </div>

      {/* Article Header */}
      <article className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <header className="mb-8">
          <div className="mb-4">
            <span className="bg-primary-100 text-primary-800 text-sm font-medium px-3 py-1 rounded-full">
              {post.category}
            </span>
          </div>

          <h1 className="text-4xl font-bold text-gray-900 mb-6 leading-tight">{post.title}</h1>

          <div className="flex items-center text-sm text-gray-500 space-x-6 mb-6">
            <div className="flex items-center">
              <UserIcon className="h-5 w-5 mr-2" />
              {post.author}
            </div>
            <div className="flex items-center">
              <CalendarIcon className="h-5 w-5 mr-2" />
              {post.date}
            </div>
            <div className="flex items-center">
              <ClockIcon className="h-5 w-5 mr-2" />
              {post.readTime}
            </div>
          </div>

          <p className="text-xl text-gray-600 leading-relaxed">{post.excerpt}</p>
        </header>

        {/* Article Content */}
        <div className="prose prose-lg prose-primary max-w-none">
          <div
            dangerouslySetInnerHTML={{
              __html: post.content
                .split('\n')
                .map((line) => {
                  if (line.startsWith('# ')) {
                    return `<h1 class="text-3xl font-bold text-gray-900 mt-8 mb-4">${line.substring(2)}</h1>`
                  }
                  if (line.startsWith('## ')) {
                    return `<h2 class="text-2xl font-semibold text-gray-900 mt-8 mb-4">${line.substring(3)}</h2>`
                  }
                  if (line.startsWith('### ')) {
                    return `<h3 class="text-xl font-semibold text-gray-900 mt-6 mb-3">${line.substring(4)}</h3>`
                  }
                  if (line.startsWith('**') && line.endsWith('**')) {
                    return `<p class="font-semibold text-gray-900 mt-4 mb-2">${line.substring(2, line.length - 2)}</p>`
                  }
                  if (line.includes('**') && line.includes(':**')) {
                    const parts = line.split('**')
                    if (parts.length >= 3) {
                      return `<p class="mt-4 mb-2"><strong class="font-semibold text-gray-900">${parts[1]}:</strong> ${parts[2]}</p>`
                    }
                  }
                  if (line.startsWith('- ')) {
                    return `<li class="mb-1">${line.substring(2)}</li>`
                  }
                  if (line.trim() === '') {
                    return '<br>'
                  }
                  if (line.startsWith('```')) {
                    if (line.length > 3) {
                      return `<div class="bg-gray-100 rounded-lg p-4 my-4 font-mono text-sm">${line.substring(3)}</div>`
                    }
                    return '<pre class="bg-gray-100 rounded-lg p-4 my-4 font-mono text-sm overflow-x-auto">'
                  }
                  return `<p class="mb-4 leading-relaxed">${line}</p>`
                })
                .join('')
                .replace(
                  /<li class="mb-1">/g,
                  '<ul class="list-disc list-inside space-y-1 mb-4"><li class="mb-1">'
                )
                .replace(/<\/li>(\s*<p|$)/g, '</li></ul>$1'),
            }}
          />
        </div>

        {/* Article Footer */}
        <footer className="mt-12 pt-8 border-t border-gray-200">
          <div className="flex items-center justify-between">
            <div className="text-sm text-gray-500">
              Published on {post.date} by {post.author}
            </div>
            <Link
              to="/blog"
              className="inline-flex items-center text-primary-600 hover:text-primary-700 font-medium"
            >
              Read more articles
            </Link>
          </div>
        </footer>
      </article>

      {/* Related Articles */}
      <div className="bg-gray-50">
        <div className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-12">
          <h2 className="text-2xl font-bold text-gray-900 mb-8">Related Articles</h2>
          <div className="grid gap-6 md:grid-cols-2">
            {blogPosts
              .filter((p) => p.id !== post.id && p.category === post.category)
              .slice(0, 2)
              .map((relatedPost) => (
                <div key={relatedPost.id} className="bg-white rounded-lg shadow-md p-6">
                  <div className="mb-3">
                    <span className="bg-primary-100 text-primary-800 text-xs font-medium px-2.5 py-0.5 rounded">
                      {relatedPost.category}
                    </span>
                  </div>
                  <h3 className="text-lg font-semibold text-gray-900 mb-2">
                    <Link to={`/blog/${relatedPost.slug}`} className="hover:text-primary-600">
                      {relatedPost.title}
                    </Link>
                  </h3>
                  <p className="text-gray-600 text-sm mb-3">{relatedPost.excerpt}</p>
                  <div className="flex items-center text-xs text-gray-500 space-x-4">
                    <span>{relatedPost.author}</span>
                    <span>{relatedPost.readTime}</span>
                  </div>
                </div>
              ))}
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/pages/public/CareersPage.tsx">
import { Link } from 'react-router-dom'
import { BriefcaseIcon, MapPinIcon, CurrencyDollarIcon, ClockIcon } from '@heroicons/react/24/outline'

const jobOpenings = [
  {
    id: 1,
    title: 'Senior Full Stack Developer',
    department: 'Engineering',
    location: 'San Francisco, CA (Remote OK)',
    type: 'Full-time',
    salary: '$140k - $180k',
    description: 'We are looking for an experienced full stack developer to help build and scale our platform.',
    requirements: [
      '5+ years of experience with React and Node.js',
      'Strong understanding of database design and optimization',
      'Experience with real-time systems and WebSockets',
      'Knowledge of fraud detection systems is a plus',
    ],
  },
  {
    id: 2,
    title: 'Account Manager',
    department: 'Sales',
    location: 'Los Angeles, CA',
    type: 'Full-time',
    salary: '$70k - $90k + Commission',
    description: 'Join our sales team to manage and grow relationships with key advertisers and traffic partners.',
    requirements: [
      '3+ years of account management experience',
      'Experience in digital marketing or pay-per-call industry',
      'Strong communication and negotiation skills',
      'Ability to manage multiple client relationships',
    ],
  },
  {
    id: 3,
    title: 'Data Analyst',
    department: 'Analytics',
    location: 'Remote',
    type: 'Full-time',
    salary: '$90k - $120k',
    description: 'Help us make data-driven decisions by analyzing campaign performance and identifying trends.',
    requirements: [
      'Strong SQL and data visualization skills',
      'Experience with Python or R for data analysis',
      'Understanding of digital marketing metrics',
      'Ability to communicate insights to non-technical stakeholders',
    ],
  },
]

const benefits = [
  {
    title: 'Health & Wellness',
    items: ['100% covered health insurance', 'Dental and vision coverage', 'Mental health support', 'Gym membership reimbursement'],
  },
  {
    title: 'Work-Life Balance',
    items: ['Flexible working hours', 'Remote work options', 'Unlimited PTO policy', 'Paid parental leave'],
  },
  {
    title: 'Growth & Development',
    items: ['Learning & development budget', 'Conference attendance', 'Mentorship programs', 'Career advancement opportunities'],
  },
  {
    title: 'Compensation & Perks',
    items: ['Competitive salaries', 'Equity options', 'Performance bonuses', 'Company retreats'],
  },
]

export default function CareersPage() {
  return (
    <div className="bg-white">
      {/* Header */}
      <div className="bg-gray-50">
        <div className="max-w-7xl mx-auto py-12 px-4 sm:px-6 lg:py-16 lg:px-8">
          <div className="text-center">
            <h1 className="text-4xl font-extrabold text-gray-900 sm:text-5xl">
              Join Our Team
            </h1>
            <p className="mt-4 text-xl text-gray-500 max-w-2xl mx-auto">
              Help us build the future of pay-per-call marketing. We're always looking for talented individuals to join our growing team.
            </p>
          </div>
        </div>
      </div>

      {/* Company Culture */}
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-12">
        <div className="text-center mb-12">
          <h2 className="text-3xl font-extrabold text-gray-900">Why Work at DependableCalls?</h2>
          <p className="mt-4 text-lg text-gray-500 max-w-3xl mx-auto">
            We're a fast-growing company with a mission to revolutionize the pay-per-call industry. 
            Our team is passionate about building great products and delivering exceptional value to our partners.
          </p>
        </div>

        {/* Benefits Grid */}
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-8 mb-16">
          {benefits.map((benefit, index) => (
            <div key={index} className="bg-gray-50 rounded-lg p-6">
              <h3 className="text-lg font-semibold text-gray-900 mb-4">{benefit.title}</h3>
              <ul className="space-y-2">
                {benefit.items.map((item, itemIndex) => (
                  <li key={itemIndex} className="flex items-start">
                    <span className="text-green-500 mr-2">âœ“</span>
                    <span className="text-gray-600 text-sm">{item}</span>
                  </li>
                ))}
              </ul>
            </div>
          ))}
        </div>

        {/* Open Positions */}
        <div>
          <h2 className="text-3xl font-extrabold text-gray-900 text-center mb-8">Open Positions</h2>
          <div className="space-y-6">
            {jobOpenings.map((job) => (
              <div key={job.id} className="bg-white border border-gray-200 rounded-lg shadow-sm hover:shadow-md transition-shadow">
                <div className="p-6">
                  <div className="flex justify-between items-start">
                    <div>
                      <h3 className="text-xl font-semibold text-gray-900">{job.title}</h3>
                      <div className="mt-2 flex flex-wrap gap-4 text-sm text-gray-500">
                        <div className="flex items-center">
                          <BriefcaseIcon className="h-4 w-4 mr-1" />
                          {job.department}
                        </div>
                        <div className="flex items-center">
                          <MapPinIcon className="h-4 w-4 mr-1" />
                          {job.location}
                        </div>
                        <div className="flex items-center">
                          <ClockIcon className="h-4 w-4 mr-1" />
                          {job.type}
                        </div>
                        <div className="flex items-center">
                          <CurrencyDollarIcon className="h-4 w-4 mr-1" />
                          {job.salary}
                        </div>
                      </div>
                    </div>
                    <Link
                      to="/contact"
                      className="px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 text-sm font-medium"
                    >
                      Apply Now
                    </Link>
                  </div>
                  <p className="mt-4 text-gray-600">{job.description}</p>
                  <div className="mt-4">
                    <h4 className="text-sm font-semibold text-gray-900 mb-2">Requirements:</h4>
                    <ul className="list-disc list-inside space-y-1">
                      {job.requirements.map((req, index) => (
                        <li key={index} className="text-sm text-gray-600">{req}</li>
                      ))}
                    </ul>
                  </div>
                </div>
              </div>
            ))}
          </div>
        </div>

        {/* Application CTA */}
        <div className="mt-16 bg-primary-50 rounded-lg p-8 text-center">
          <h3 className="text-2xl font-bold text-gray-900 mb-4">
            Don't see a position that fits?
          </h3>
          <p className="text-lg text-gray-600 mb-6">
            We're always interested in meeting talented people. Send us your resume and let us know how you can contribute to our team.
          </p>
          <Link
            to="/contact"
            className="inline-flex items-center justify-center px-6 py-3 border border-transparent text-base font-medium rounded-md text-white bg-primary-600 hover:bg-primary-700"
          >
            Get in Touch
          </Link>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/pages/public/CLAUDE.md">
# Public Pages

# Page Structure
- `HomePage.tsx` - Main landing page
- `AboutPage.tsx` - Company information
- `FeaturesPage.tsx` - Platform features overview
- `PricingPage.tsx` - Pricing plans and comparison
- `ContactPage.tsx` - Contact form and information
- `PrivacyPage.tsx` - Privacy policy
- `TermsPage.tsx` - Terms of service

# Home Page Implementation
```tsx
export function HomePage() {
  const navigate = useNavigate();
  const { user } = useAuth();
  
  // Redirect authenticated users to dashboard
  useEffect(() => {
    if (user) {
      navigate('/dashboard');
    }
  }, [user, navigate]);
  
  return (
    <PublicLayout>
      <div className="home-page">
        <HeroSection />
        <FeaturesSection />
        <HowItWorksSection />
        <TestimonialsSection />
        <StatsSection />
        <CTASection />
      </div>
    </PublicLayout>
  );
}
```

# Hero Section
```tsx
export function HeroSection() {
  const [videoModalOpen, setVideoModalOpen] = useState(false);
  
  return (
    <section className="hero-section">
      <div className="hero-content">
        <div className="hero-text">
          <h1 className="hero-title">
            Connect Quality Traffic with
            <span className="text-primary"> High-Value Buyers</span>
          </h1>
          <p className="hero-description">
            DCE Platform is the premium pay-per-call network that matches 
            traffic suppliers with advertisers seeking high-quality leads. 
            Maximize your revenue with our advanced fraud detection and 
            real-time tracking.
          </p>
          
          <div className="hero-actions">
            <div className="action-buttons">
              <Button
                size="lg"
                onClick={() => navigate('/auth/register?type=supplier')}
              >
                Start as Supplier
              </Button>
              <Button
                size="lg"
                variant="outline"
                onClick={() => navigate('/auth/register?type=buyer')}
              >
                Start as Buyer
              </Button>
            </div>
            
            <button
              className="video-trigger"
              onClick={() => setVideoModalOpen(true)}
            >
              <PlayIcon className="h-6 w-6" />
              Watch How It Works
            </button>
          </div>
        </div>
        
        <div className="hero-visual">
          <img
            src="/images/hero-dashboard.png"
            alt="DCE Platform Dashboard"
            className="hero-image"
          />
        </div>
      </div>
      
      {videoModalOpen && (
        <VideoModal
          videoUrl="https://www.youtube.com/embed/demo-video"
          onClose={() => setVideoModalOpen(false)}
        />
      )}
    </section>
  );
}
```

# Features Overview
```tsx
interface Feature {
  icon: React.ComponentType<{ className?: string }>;
  title: string;
  description: string;
  benefits: string[];
}

const FEATURES: Feature[] = [
  {
    icon: ShieldCheckIcon,
    title: 'Advanced Fraud Detection',
    description: 'AI-powered fraud detection protects your campaigns and ensures quality traffic.',
    benefits: [
      'Real-time call analysis',
      'Duplicate detection',
      'Geographic validation',
      'Quality scoring'
    ],
  },
  {
    icon: ChartBarIcon,
    title: 'Real-Time Analytics',
    description: 'Monitor performance with live dashboards and detailed reporting.',
    benefits: [
      'Live call tracking',
      'Performance metrics',
      'ROI analysis',
      'Custom reports'
    ],
  },
  {
    icon: CurrencyDollarIcon,
    title: 'Flexible Payouts',
    description: 'Choose from multiple payout options with transparent pricing.',
    benefits: [
      'Weekly payouts',
      'Multiple payment methods',
      'Transparent fees',
      'Instant notifications'
    ],
  },
];

export function FeaturesSection() {
  return (
    <section className="features-section">
      <div className="section-header">
        <h2>Everything You Need to Succeed</h2>
        <p>Powerful tools designed for both traffic suppliers and buyers</p>
      </div>
      
      <div className="features-grid">
        {FEATURES.map((feature, index) => (
          <FeatureCard key={index} feature={feature} />
        ))}
      </div>
    </section>
  );
}
```

# Pricing Page
```tsx
interface PricingTier {
  name: string;
  description: string;
  price: string;
  period: string;
  features: string[];
  highlighted?: boolean;
  ctaText: string;
}

const PRICING_TIERS: PricingTier[] = [
  {
    name: 'Starter',
    description: 'Perfect for new suppliers getting started',
    price: '0',
    period: 'Setup Fee',
    features: [
      'Up to 100 calls/month',
      'Basic analytics',
      'Email support',
      'Standard fraud protection',
    ],
    ctaText: 'Get Started Free',
  },
  {
    name: 'Professional',
    description: 'Best for growing businesses',
    price: '299',
    period: 'per month',
    features: [
      'Up to 1,000 calls/month',
      'Advanced analytics',
      'Priority support',
      'Enhanced fraud detection',
      'Custom reporting',
      'API access',
    ],
    highlighted: true,
    ctaText: 'Start Free Trial',
  },
  {
    name: 'Enterprise',
    description: 'For high-volume operations',
    price: 'Custom',
    period: 'pricing',
    features: [
      'Unlimited calls',
      'White-label solution',
      'Dedicated account manager',
      'Custom integrations',
      'SLA guarantees',
      '24/7 phone support',
    ],
    ctaText: 'Contact Sales',
  },
];

export function PricingPage() {
  const [billingPeriod, setBillingPeriod] = useState<'monthly' | 'yearly'>('monthly');
  
  return (
    <PublicLayout>
      <div className="pricing-page">
        <PageHeader
          title="Simple, Transparent Pricing"
          subtitle="Choose the plan that's right for your business"
        />
        
        <div className="billing-toggle">
          <SegmentedControl
            options={[
              { value: 'monthly', label: 'Monthly' },
              { value: 'yearly', label: 'Yearly (20% off)' },
            ]}
            value={billingPeriod}
            onChange={setBillingPeriod}
          />
        </div>
        
        <div className="pricing-grid">
          {PRICING_TIERS.map((tier, index) => (
            <PricingCard
              key={index}
              tier={tier}
              billingPeriod={billingPeriod}
              onSelect={() => handlePlanSelect(tier)}
            />
          ))}
        </div>
        
        <PricingFAQ />
        <PricingComparison />
      </div>
    </PublicLayout>
  );
}
```

# Contact Page
```tsx
export function ContactPage() {
  const form = useForm<ContactFormData>({
    resolver: zodResolver(contactFormSchema),
  });
  
  const handleSubmit = async (data: ContactFormData) => {
    try {
      await contactService.submitInquiry(data);
      toast.success('Thank you! We\'ll get back to you within 24 hours.');
      form.reset();
    } catch (error) {
      toast.error('Failed to send message. Please try again.');
    }
  };
  
  return (
    <PublicLayout>
      <div className="contact-page">
        <PageHeader
          title="Get in Touch"
          subtitle="Have questions? We'd love to hear from you."
        />
        
        <div className="contact-content">
          <div className="contact-info">
            <h3>Contact Information</h3>
            
            <div className="contact-methods">
              <div className="contact-method">
                <EnvelopeIcon className="h-6 w-6" />
                <div>
                  <h4>Email Us</h4>
                  <p>support@dependablecalls.com</p>
                  <p>Response within 4 hours</p>
                </div>
              </div>
              
              <div className="contact-method">
                <PhoneIcon className="h-6 w-6" />
                <div>
                  <h4>Call Us</h4>
                  <p>+1 (555) 123-4567</p>
                  <p>Mon-Fri 9AM-6PM PST</p>
                </div>
              </div>
              
              <div className="contact-method">
                <ChatBubbleLeftIcon className="h-6 w-6" />
                <div>
                  <h4>Live Chat</h4>
                  <p>Available 24/7</p>
                  <Button size="sm" onClick={() => openLiveChat()}>
                    Start Chat
                  </Button>
                </div>
              </div>
            </div>
          </div>
          
          <div className="contact-form">
            <form onSubmit={form.handleSubmit(handleSubmit)}>
              <h3>Send us a Message</h3>
              
              <div className="form-grid">
                <Input
                  {...form.register('firstName')}
                  label="First Name"
                  error={form.formState.errors.firstName?.message}
                />
                <Input
                  {...form.register('lastName')}
                  label="Last Name"
                  error={form.formState.errors.lastName?.message}
                />
              </div>
              
              <Input
                {...form.register('email')}
                type="email"
                label="Email Address"
                error={form.formState.errors.email?.message}
              />
              
              <Input
                {...form.register('company')}
                label="Company (Optional)"
                error={form.formState.errors.company?.message}
              />
              
              <Select
                {...form.register('inquiryType')}
                label="Inquiry Type"
                options={[
                  { value: 'general', label: 'General Question' },
                  { value: 'sales', label: 'Sales Inquiry' },
                  { value: 'support', label: 'Technical Support' },
                  { value: 'partnership', label: 'Partnership' },
                ]}
                error={form.formState.errors.inquiryType?.message}
              />
              
              <Textarea
                {...form.register('message')}
                label="Message"
                rows={6}
                error={form.formState.errors.message?.message}
              />
              
              <Button
                type="submit"
                loading={form.formState.isSubmitting}
                className="w-full"
              >
                Send Message
              </Button>
            </form>
          </div>
        </div>
      </div>
    </PublicLayout>
  );
}
```

# About Page
```tsx
export function AboutPage() {
  return (
    <PublicLayout>
      <div className="about-page">
        <section className="about-hero">
          <div className="hero-content">
            <h1>About DCE Platform</h1>
            <p className="hero-subtitle">
              We're building the future of performance marketing by connecting 
              quality traffic providers with serious advertisers.
            </p>
          </div>
        </section>
        
        <section className="mission-section">
          <div className="mission-content">
            <h2>Our Mission</h2>
            <p>
              To create a transparent, fraud-free marketplace where traffic 
              suppliers and advertisers can build mutually beneficial 
              relationships based on quality and performance.
            </p>
          </div>
        </section>
        
        <section className="values-section">
          <h2>Our Values</h2>
          <div className="values-grid">
            <ValueCard
              icon={ShieldCheckIcon}
              title="Transparency"
              description="Open, honest relationships with all our partners"
            />
            <ValueCard
              icon={TrendingUpIcon}
              title="Quality First"
              description="We prioritize quality over quantity in every transaction"
            />
            <ValueCard
              icon={UserGroupIcon}
              title="Partnership"
              description="Your success is our success - we grow together"
            />
          </div>
        </section>
        
        <section className="team-section">
          <h2>Leadership Team</h2>
          <div className="team-grid">
            {TEAM_MEMBERS.map(member => (
              <TeamMemberCard key={member.id} member={member} />
            ))}
          </div>
        </section>
        
        <section className="stats-section">
          <div className="stats-grid">
            <StatCard title="$50M+" subtitle="Revenue Generated" />
            <StatCard title="10,000+" subtitle="Successful Campaigns" />
            <StatCard title="500+" subtitle="Active Partners" />
            <StatCard title="99.9%" subtitle="Uptime Guarantee" />
          </div>
        </section>
      </div>
    </PublicLayout>
  );
}
```

# SEO Optimization
```tsx
// SEO component for public pages
export function SEOHead({ page }: { page: string }) {
  const seoData = getSEOData(page);
  
  useEffect(() => {
    // Update document title
    document.title = seoData.title;
    
    // Update meta tags
    updateMetaTag('description', seoData.description);
    updateMetaTag('keywords', seoData.keywords);
    
    // Update Open Graph tags
    updateMetaTag('og:title', seoData.title);
    updateMetaTag('og:description', seoData.description);
    updateMetaTag('og:image', seoData.image);
    updateMetaTag('og:url', window.location.href);
    
    // Update Twitter Card tags
    updateMetaTag('twitter:card', 'summary_large_image');
    updateMetaTag('twitter:title', seoData.title);
    updateMetaTag('twitter:description', seoData.description);
    updateMetaTag('twitter:image', seoData.image);
  }, [seoData]);
  
  return null;
}

function updateMetaTag(property: string, content: string) {
  let element = document.querySelector(`meta[name="${property}"], meta[property="${property}"]`);
  
  if (!element) {
    element = document.createElement('meta');
    if (property.startsWith('og:') || property.startsWith('twitter:')) {
      element.setAttribute('property', property);
    } else {
      element.setAttribute('name', property);
    }
    document.head.appendChild(element);
  }
  
  element.setAttribute('content', content);
}
```

# Performance Optimization
- Lazy loading for images and components
- Code splitting by route
- CDN optimization for static assets
- Critical CSS inlining
- Preload key resources

# Analytics Integration
```tsx
export function usePageAnalytics(pageName: string) {
  useEffect(() => {
    // Track page view
    analytics.page(pageName, {
      path: window.location.pathname,
      title: document.title,
      url: window.location.href,
    });
    
    // Track time on page
    const startTime = Date.now();
    
    return () => {
      const timeOnPage = Date.now() - startTime;
      analytics.track('Page Time', {
        page: pageName,
        duration: timeOnPage,
      });
    };
  }, [pageName]);
}
```

# Conversion Tracking
- Lead form submissions
- Registration completions
- Contact form submissions
- Download tracking
- Video engagement

# Mobile Optimization
- Touch-friendly navigation
- Responsive images
- Mobile-specific CTAs
- Faster mobile loading
- App-like experience

# CRITICAL RULES
- NO regex in public pages
- NO any types in page interfaces
- ALWAYS optimize for SEO
- ALWAYS ensure fast loading times
- IMPLEMENT proper analytics
- TEST across all devices
- ENSURE accessibility compliance
- MAINTAIN consistent branding
</file>

<file path="src/pages/reports/CLAUDE.md">
# Reports Pages

# Page Structure
- `ReportsOverview.tsx` - Main reports dashboard
- `PerformanceReports.tsx` - Campaign and call performance
- `FinancialReports.tsx` - Revenue and payout reports
- `QualityReports.tsx` - Call quality and fraud analysis
- `CustomReports.tsx` - User-defined report builder
- `ScheduledReports.tsx` - Automated report management

# Reports Overview Dashboard
```tsx
export function ReportsOverview() {
  const { user } = useAuth();
  const { data: reportSummary, loading } = useReportSummary(user?.id);
  const { data: recentReports } = useRecentReports(user?.id, 5);
  
  return (
    <AppLayout>
      <div className="reports-overview">
        <PageHeader
          title="Reports & Analytics"
          subtitle="Comprehensive insights into your performance"
          action={
            <Button onClick={() => navigate('/reports/custom/create')}>
              <DocumentPlusIcon className="h-4 w-4" />
              Create Report
            </Button>
          }
        />
        
        <div className="report-categories">
          <ReportCategoryCard
            title="Performance Reports"
            description="Campaign metrics, call volume, and conversion rates"
            icon={ChartBarIcon}
            href="/reports/performance"
            stats={reportSummary.performance}
          />
          <ReportCategoryCard
            title="Financial Reports"
            description="Revenue, payouts, and financial analytics"
            icon={CurrencyDollarIcon}
            href="/reports/financial"
            stats={reportSummary.financial}
          />
          <ReportCategoryCard
            title="Quality Reports"
            description="Call quality, fraud detection, and compliance"
            icon={ShieldCheckIcon}
            href="/reports/quality"
            stats={reportSummary.quality}
          />
          <ReportCategoryCard
            title="Custom Reports"
            description="Build and schedule custom reports"
            icon={CogIcon}
            href="/reports/custom"
            stats={reportSummary.custom}
          />
        </div>
        
        <div className="reports-content">
          <div className="recent-reports">
            <h3>Recent Reports</h3>
            <ReportsList reports={recentReports} />
          </div>
          
          <div className="quick-insights">
            <QuickInsightsPanel data={reportSummary.insights} />
          </div>
        </div>
      </div>
    </AppLayout>
  );
}
```

# Performance Reports
```tsx
export function PerformanceReports() {
  const [dateRange, setDateRange] = useState<DateRange>({
    start: startOfMonth(new Date()),
    end: new Date(),
  });
  const [filters, setFilters] = useState<PerformanceFilters>({});
  
  const { data: performanceData, loading } = usePerformanceData(dateRange, filters);
  
  return (
    <AppLayout>
      <div className="performance-reports">
        <PageHeader
          title="Performance Reports"
          breadcrumbs={[
            { label: 'Reports', href: '/reports' },
            { label: 'Performance' },
          ]}
        />
        
        <div className="report-controls">
          <DateRangePicker
            value={dateRange}
            onChange={setDateRange}
            presets={[
              { label: 'Last 7 days', range: { start: subDays(new Date(), 7), end: new Date() } },
              { label: 'Last 30 days', range: { start: subDays(new Date(), 30), end: new Date() } },
              { label: 'This month', range: { start: startOfMonth(new Date()), end: new Date() } },
            ]}
          />
          
          <PerformanceFilters
            filters={filters}
            onChange={setFilters}
          />
          
          <ExportButton
            data={performanceData}
            filename={`performance-report-${format(new Date(), 'yyyy-MM-dd')}`}
            formats={['csv', 'xlsx', 'pdf']}
          />
        </div>
        
        {loading ? (
          <ReportSkeleton />
        ) : (
          <div className="performance-content">
            <div className="performance-summary">
              <MetricCard
                title="Total Calls"
                value={performanceData.totalCalls}
                change={performanceData.callsChange}
                icon={PhoneIcon}
              />
              <MetricCard
                title="Conversion Rate"
                value={`${performanceData.conversionRate}%`}
                change={performanceData.conversionChange}
                icon={TrendingUpIcon}
              />
              <MetricCard
                title="Avg Call Duration"
                value={formatDuration(performanceData.avgDuration)}
                change={performanceData.durationChange}
                icon={ClockIcon}
              />
              <MetricCard
                title="Quality Score"
                value={performanceData.qualityScore}
                change={performanceData.qualityChange}
                icon={StarIcon}
              />
            </div>
            
            <div className="performance-charts">
              <div className="chart-container">
                <h3>Call Volume Trends</h3>
                <LineChart
                  data={performanceData.callTrends}
                  xKey="date"
                  yKey="calls"
                  height={300}
                />
              </div>
              
              <div className="chart-container">
                <h3>Conversion Rate by Source</h3>
                <BarChart
                  data={performanceData.conversionBySource}
                  xKey="source"
                  yKey="rate"
                  height={300}
                />
              </div>
            </div>
            
            <div className="performance-table">
              <h3>Campaign Performance Details</h3>
              <DataTable
                data={performanceData.campaignDetails}
                columns={[
                  { key: 'campaign_name', label: 'Campaign' },
                  { key: 'calls', label: 'Calls' },
                  { key: 'conversions', label: 'Conversions' },
                  { key: 'conversion_rate', label: 'Conv. Rate', render: (rate) => `${rate}%` },
                  { key: 'quality_score', label: 'Quality Score' },
                  { key: 'revenue', label: 'Revenue', render: (revenue) => formatCurrency(revenue) },
                ]}
                sortable
                searchable
              />
            </div>
          </div>
        )}
      </div>
    </AppLayout>
  );
}
```

# Financial Reports
```tsx
export function FinancialReports() {
  const { user } = useAuth();
  const [reportType, setReportType] = useState<'revenue' | 'payouts' | 'transactions'>('revenue');
  const [dateRange, setDateRange] = useState<DateRange>({
    start: startOfMonth(new Date()),
    end: new Date(),
  });
  
  const { data: financialData, loading } = useFinancialData(reportType, dateRange);
  
  return (
    <AppLayout>
      <div className="financial-reports">
        <PageHeader
          title="Financial Reports"
          breadcrumbs={[
            { label: 'Reports', href: '/reports' },
            { label: 'Financial' },
          ]}
        />
        
        <div className="financial-controls">
          <SegmentedControl
            options={[
              { value: 'revenue', label: 'Revenue' },
              { value: 'payouts', label: 'Payouts' },
              { value: 'transactions', label: 'Transactions' },
            ]}
            value={reportType}
            onChange={setReportType}
          />
          
          <DateRangePicker
            value={dateRange}
            onChange={setDateRange}
          />
          
          <Button
            variant="outline"
            onClick={() => generateTaxReport(dateRange)}
          >
            <DocumentTextIcon className="h-4 w-4" />
            Tax Report
          </Button>
        </div>
        
        {loading ? (
          <ReportSkeleton />
        ) : (
          <div className="financial-content">
            {reportType === 'revenue' && (
              <RevenueReportSection data={financialData} dateRange={dateRange} />
            )}
            {reportType === 'payouts' && (
              <PayoutsReportSection data={financialData} dateRange={dateRange} />
            )}
            {reportType === 'transactions' && (
              <TransactionsReportSection data={financialData} dateRange={dateRange} />
            )}
          </div>
        )}
      </div>
    </AppLayout>
  );
}
```

# Quality Reports
```tsx
export function QualityReports() {
  const [selectedMetric, setSelectedMetric] = useState<QualityMetric>('overall_quality');
  const { data: qualityData, loading } = useQualityData(selectedMetric);
  const { data: fraudData } = useFraudData();
  
  return (
    <AppLayout>
      <div className="quality-reports">
        <PageHeader
          title="Quality & Fraud Reports"
          breadcrumbs={[
            { label: 'Reports', href: '/reports' },
            { label: 'Quality' },
          ]}
        />
        
        <div className="quality-overview">
          <QualityScoreCard
            title="Overall Quality Score"
            score={qualityData.overallScore}
            trend={qualityData.scoreTrend}
          />
          <FraudRateCard
            title="Fraud Detection Rate"
            rate={fraudData.detectionRate}
            blocked={fraudData.blockedCalls}
          />
          <QualityDistributionCard
            title="Quality Distribution"
            distribution={qualityData.distribution}
          />
        </div>
        
        <div className="quality-analysis">
          <div className="quality-trends">
            <h3>Quality Score Trends</h3>
            <QualityTrendsChart
              data={qualityData.trends}
              metric={selectedMetric}
            />
          </div>
          
          <div className="fraud-analysis">
            <h3>Fraud Detection Analysis</h3>
            <FraudAnalysisChart
              data={fraudData.analysis}
              onRuleClick={handleFraudRuleClick}
            />
          </div>
        </div>
        
        <div className="quality-details">
          <Tabs defaultValue="quality-factors">
            <TabsList>
              <TabsTrigger value="quality-factors">Quality Factors</TabsTrigger>
              <TabsTrigger value="fraud-rules">Fraud Rules</TabsTrigger>
              <TabsTrigger value="low-quality-calls">Low Quality Calls</TabsTrigger>
            </TabsList>
            
            <TabsContent value="quality-factors">
              <QualityFactorsTable data={qualityData.factors} />
            </TabsContent>
            
            <TabsContent value="fraud-rules">
              <FraudRulesTable data={fraudData.rules} />
            </TabsContent>
            
            <TabsContent value="low-quality-calls">
              <LowQualityCallsTable data={qualityData.lowQualityCalls} />
            </TabsContent>
          </Tabs>
        </div>
      </div>
    </AppLayout>
  );
}
```

# Custom Report Builder
```tsx
export function CustomReports() {
  const [reports, setReports] = useState<CustomReport[]>([]);
  const [showBuilder, setShowBuilder] = useState(false);
  
  return (
    <AppLayout>
      <div className="custom-reports">
        <PageHeader
          title="Custom Reports"
          breadcrumbs={[
            { label: 'Reports', href: '/reports' },
            { label: 'Custom' },
          ]}
          action={
            <Button onClick={() => setShowBuilder(true)}>
              <PlusIcon className="h-4 w-4" />
              Create Report
            </Button>
          }
        />
        
        <div className="custom-reports-grid">
          {reports.map(report => (
            <CustomReportCard
              key={report.id}
              report={report}
              onRun={() => runCustomReport(report.id)}
              onEdit={() => editCustomReport(report.id)}
              onDelete={() => deleteCustomReport(report.id)}
            />
          ))}
        </div>
        
        {reports.length === 0 && (
          <EmptyState
            icon={DocumentChartBarIcon}
            title="No custom reports yet"
            description="Create your first custom report to get specific insights"
            action={
              <Button onClick={() => setShowBuilder(true)}>
                Create Report
              </Button>
            }
          />
        )}
        
        {showBuilder && (
          <ReportBuilderModal
            onClose={() => setShowBuilder(false)}
            onSave={(report) => {
              setReports(prev => [...prev, report]);
              setShowBuilder(false);
            }}
          />
        )}
      </div>
    </AppLayout>
  );
}
```

# Report Builder Interface
```tsx
interface ReportBuilderModalProps {
  onClose: () => void;
  onSave: (report: CustomReport) => void;
  initialReport?: CustomReport;
}

export function ReportBuilderModal({ onClose, onSave, initialReport }: ReportBuilderModalProps) {
  const [reportConfig, setReportConfig] = useState<ReportConfig>({
    name: initialReport?.name || '',
    description: initialReport?.description || '',
    type: initialReport?.type || 'table',
    dimensions: initialReport?.dimensions || [],
    metrics: initialReport?.metrics || [],
    filters: initialReport?.filters || [],
    scheduling: initialReport?.scheduling || null,
  });
  
  const [previewData, setPreviewData] = useState<ReportData | null>(null);
  const [previewLoading, setPreviewLoading] = useState(false);
  
  const generatePreview = async () => {
    setPreviewLoading(true);
    try {
      const data = await reportService.generatePreview(reportConfig);
      setPreviewData(data);
    } catch (error) {
      toast.error('Failed to generate preview');
    } finally {
      setPreviewLoading(false);
    }
  };
  
  const handleSave = async () => {
    try {
      const report = await reportService.saveCustomReport(reportConfig);
      onSave(report);
    } catch (error) {
      toast.error('Failed to save report');
    }
  };
  
  return (
    <Modal size="xl" onClose={onClose}>
      <div className="report-builder">
        <div className="builder-sidebar">
          <div className="config-section">
            <h3>Report Configuration</h3>
            
            <div className="form-group">
              <label>Report Name</label>
              <Input
                value={reportConfig.name}
                onChange={(e) => setReportConfig(prev => ({
                  ...prev,
                  name: e.target.value,
                }))}
                placeholder="Enter report name"
              />
            </div>
            
            <div className="form-group">
              <label>Description</label>
              <Textarea
                value={reportConfig.description}
                onChange={(e) => setReportConfig(prev => ({
                  ...prev,
                  description: e.target.value,
                }))}
                placeholder="Describe what this report shows"
              />
            </div>
            
            <div className="form-group">
              <label>Report Type</label>
              <Select
                value={reportConfig.type}
                onChange={(value) => setReportConfig(prev => ({
                  ...prev,
                  type: value as ReportType,
                }))}
                options={[
                  { value: 'table', label: 'Data Table' },
                  { value: 'chart', label: 'Chart' },
                  { value: 'dashboard', label: 'Dashboard' },
                ]}
              />
            </div>
          </div>
          
          <DimensionsSelector
            selected={reportConfig.dimensions}
            onChange={(dimensions) => setReportConfig(prev => ({
              ...prev,
              dimensions,
            }))}
          />
          
          <MetricsSelector
            selected={reportConfig.metrics}
            onChange={(metrics) => setReportConfig(prev => ({
              ...prev,
              metrics,
            }))}
          />
          
          <FiltersBuilder
            filters={reportConfig.filters}
            onChange={(filters) => setReportConfig(prev => ({
              ...prev,
              filters,
            }))}
          />
        </div>
        
        <div className="builder-preview">
          <div className="preview-header">
            <h3>Preview</h3>
            <Button
              onClick={generatePreview}
              loading={previewLoading}
              disabled={!reportConfig.metrics.length}
            >
              Generate Preview
            </Button>
          </div>
          
          <div className="preview-content">
            {previewLoading ? (
              <ReportPreviewSkeleton />
            ) : previewData ? (
              <ReportPreview data={previewData} config={reportConfig} />
            ) : (
              <EmptyState
                title="No preview available"
                description="Add metrics and generate a preview"
              />
            )}
          </div>
        </div>
        
        <div className="builder-actions">
          <Button variant="outline" onClick={onClose}>
            Cancel
          </Button>
          <Button
            onClick={handleSave}
            disabled={!reportConfig.name || !reportConfig.metrics.length}
          >
            Save Report
          </Button>
        </div>
      </div>
    </Modal>
  );
}
```

# Scheduled Reports
```tsx
export function ScheduledReports() {
  const { data: scheduledReports, loading } = useScheduledReports();
  const [showScheduler, setShowScheduler] = useState(false);
  
  return (
    <div className="scheduled-reports">
      <div className="section-header">
        <h3>Scheduled Reports</h3>
        <Button onClick={() => setShowScheduler(true)}>
          Schedule Report
        </Button>
      </div>
      
      <div className="scheduled-list">
        {scheduledReports.map(report => (
          <ScheduledReportCard
            key={report.id}
            report={report}
            onToggle={() => toggleScheduledReport(report.id)}
            onEdit={() => editScheduledReport(report.id)}
            onDelete={() => deleteScheduledReport(report.id)}
          />
        ))}
      </div>
      
      {showScheduler && (
        <ReportSchedulerModal
          onClose={() => setShowScheduler(false)}
          onSave={handleScheduleReport}
        />
      )}
    </div>
  );
}
```

# Report Export Features
- Multiple export formats (PDF, Excel, CSV)
- Automated email delivery
- Branded report templates
- Data visualization export
- Scheduled report generation

# Real-time Report Updates
- Live data refresh
- Real-time notifications
- Streaming data updates
- Background report generation
- Progressive data loading

# Report Sharing
- Shareable report links
- Team collaboration
- Report templates
- Public dashboards
- Embed capabilities

# CRITICAL RULES
- NO regex in report generation
- NO any types in report interfaces
- ALWAYS validate report data
- ALWAYS handle large datasets efficiently
- IMPLEMENT proper error handling
- TEST report accuracy thoroughly
- OPTIMIZE query performance
- ENSURE data privacy compliance
</file>

<file path="src/pages/reports/ReportsPage.tsx">
export default function ReportsPage() {
  return (
    <div className="py-6">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <h1 className="text-2xl font-semibold text-gray-900">Reports</h1>
        <p className="mt-1 text-sm text-gray-600">
          Generate and view analytics reports.
        </p>
        
        <div className="mt-8">
          <div className="bg-white shadow overflow-hidden sm:rounded-md p-6">
            <p className="text-gray-500">Reporting interface coming soon...</p>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/pages/settings/CLAUDE.md">
# Settings Pages

# Page Structure
- `SettingsOverview.tsx` - Main settings dashboard
- `ProfileSettings.tsx` - User profile management
- `AccountSettings.tsx` - Account preferences
- `NotificationSettings.tsx` - Notification preferences
- `SecuritySettings.tsx` - Password and 2FA
- `IntegrationSettings.tsx` - API keys and webhooks
- `BillingSettings.tsx` - Payment and billing preferences

# Settings Overview
```tsx
export function SettingsOverview() {
  const { user } = useAuth();
  const navigate = useNavigate();
  
  const settingsCategories = [
    {
      id: 'profile',
      title: 'Profile Settings',
      description: 'Manage your personal information and company details',
      icon: UserIcon,
      href: '/settings/profile',
    },
    {
      id: 'account',
      title: 'Account Preferences',
      description: 'Configure your account settings and preferences',
      icon: CogIcon,
      href: '/settings/account',
    },
    {
      id: 'notifications',
      title: 'Notifications',
      description: 'Control how and when you receive notifications',
      icon: BellIcon,
      href: '/settings/notifications',
    },
    {
      id: 'security',
      title: 'Security',
      description: 'Manage your password and two-factor authentication',
      icon: ShieldCheckIcon,
      href: '/settings/security',
    },
    {
      id: 'integrations',
      title: 'Integrations',
      description: 'API keys, webhooks, and third-party integrations',
      icon: CommandLineIcon,
      href: '/settings/integrations',
    },
    {
      id: 'billing',
      title: 'Billing',
      description: 'Payment methods and billing preferences',
      icon: CreditCardIcon,
      href: '/settings/billing',
    },
  ];
  
  return (
    <AppLayout>
      <div className="settings-overview">
        <PageHeader
          title="Settings"
          subtitle="Manage your account and preferences"
        />
        
        <div className="settings-grid">
          {settingsCategories.map(category => (
            <SettingsCard
              key={category.id}
              {...category}
              onClick={() => navigate(category.href)}
            />
          ))}
        </div>
        
        <div className="account-summary">
          <AccountSummaryCard user={user} />
        </div>
      </div>
    </AppLayout>
  );
}
```

# Profile Settings
```tsx
export function ProfileSettings() {
  const { user, updateUser } = useAuth();
  const [isEditing, setIsEditing] = useState(false);
  
  const form = useForm({
    resolver: zodResolver(profileSettingsSchema),
    defaultValues: {
      firstName: user?.first_name || '',
      lastName: user?.last_name || '',
      email: user?.email || '',
      phone: user?.phone || '',
      company: user?.profile?.company || '',
      title: user?.profile?.title || '',
      bio: user?.profile?.bio || '',
      website: user?.profile?.website || '',
      timezone: user?.profile?.timezone || Intl.DateTimeFormat().resolvedOptions().timeZone,
    },
  });
  
  const handleSave = async (data: ProfileFormData) => {
    try {
      await updateUser({
        first_name: data.firstName,
        last_name: data.lastName,
        phone: data.phone,
        profile: {
          company: data.company,
          title: data.title,
          bio: data.bio,
          website: data.website,
          timezone: data.timezone,
        },
      });
      
      setIsEditing(false);
      toast.success('Profile updated successfully');
    } catch (error) {
      toast.error('Failed to update profile');
    }
  };
  
  return (
    <AppLayout>
      <div className="profile-settings">
        <PageHeader
          title="Profile Settings"
          breadcrumbs={[
            { label: 'Settings', href: '/settings' },
            { label: 'Profile' },
          ]}
          action={
            <Button
              onClick={() => setIsEditing(!isEditing)}
              variant={isEditing ? 'outline' : 'default'}
            >
              {isEditing ? 'Cancel' : 'Edit Profile'}
            </Button>
          }
        />
        
        <div className="profile-content">
          <div className="profile-avatar">
            <AvatarUpload
              currentAvatar={user?.profile?.avatar_url}
              onUpload={handleAvatarUpload}
              disabled={!isEditing}
            />
          </div>
          
          <form onSubmit={form.handleSubmit(handleSave)}>
            <div className="profile-form">
              <div className="form-section">
                <h3>Personal Information</h3>
                
                <div className="form-grid">
                  <Input
                    {...form.register('firstName')}
                    label="First Name"
                    disabled={!isEditing}
                    error={form.formState.errors.firstName?.message}
                  />
                  <Input
                    {...form.register('lastName')}
                    label="Last Name"
                    disabled={!isEditing}
                    error={form.formState.errors.lastName?.message}
                  />
                </div>
                
                <Input
                  {...form.register('email')}
                  type="email"
                  label="Email Address"
                  disabled // Email cannot be changed
                  error={form.formState.errors.email?.message}
                />
                
                <Input
                  {...form.register('phone')}
                  type="tel"
                  label="Phone Number"
                  disabled={!isEditing}
                  error={form.formState.errors.phone?.message}
                />
              </div>
              
              <div className="form-section">
                <h3>Company Information</h3>
                
                <Input
                  {...form.register('company')}
                  label="Company Name"
                  disabled={!isEditing}
                  error={form.formState.errors.company?.message}
                />
                
                <Input
                  {...form.register('title')}
                  label="Job Title"
                  disabled={!isEditing}
                  error={form.formState.errors.title?.message}
                />
                
                <Textarea
                  {...form.register('bio')}
                  label="Bio"
                  placeholder="Tell us about yourself..."
                  rows={4}
                  disabled={!isEditing}
                  error={form.formState.errors.bio?.message}
                />
                
                <Input
                  {...form.register('website')}
                  type="url"
                  label="Website"
                  placeholder="https://"
                  disabled={!isEditing}
                  error={form.formState.errors.website?.message}
                />
              </div>
              
              <div className="form-section">
                <h3>Preferences</h3>
                
                <Select
                  {...form.register('timezone')}
                  label="Timezone"
                  options={TIMEZONE_OPTIONS}
                  disabled={!isEditing}
                  error={form.formState.errors.timezone?.message}
                />
              </div>
              
              {isEditing && (
                <div className="form-actions">
                  <Button
                    type="button"
                    variant="outline"
                    onClick={() => {
                      form.reset();
                      setIsEditing(false);
                    }}
                  >
                    Cancel
                  </Button>
                  <Button
                    type="submit"
                    loading={form.formState.isSubmitting}
                  >
                    Save Changes
                  </Button>
                </div>
              )}
            </div>
          </form>
        </div>
      </div>
    </AppLayout>
  );
}
```

# Notification Settings
```tsx
export function NotificationSettings() {
  const { data: settings, loading } = useNotificationSettings();
  const [preferences, setPreferences] = useState<NotificationPreferences>({});
  
  useEffect(() => {
    if (settings) {
      setPreferences(settings);
    }
  }, [settings]);
  
  const handleToggle = async (type: NotificationType, method: NotificationMethod, enabled: boolean) => {
    const updated = {
      ...preferences,
      [type]: {
        ...preferences[type],
        [method]: enabled,
      },
    };
    
    setPreferences(updated);
    
    try {
      await notificationService.updatePreferences(updated);
      toast.success('Notification preferences updated');
    } catch (error) {
      toast.error('Failed to update preferences');
      // Revert on error
      setPreferences(preferences);
    }
  };
  
  if (loading) return <SettingsSkeleton />;
  
  const notificationTypes: NotificationTypeConfig[] = [
    {
      id: 'new_calls',
      title: 'New Calls',
      description: 'Notifications when you receive new calls',
      methods: ['email', 'push', 'sms'],
    },
    {
      id: 'call_completed',
      title: 'Call Completed',
      description: 'Notifications when calls are completed',
      methods: ['email', 'push'],
    },
    {
      id: 'fraud_detected',
      title: 'Fraud Detected',
      description: 'Alerts when fraud is detected on your campaigns',
      methods: ['email', 'push', 'sms'],
      priority: 'high',
    },
    {
      id: 'payout_processed',
      title: 'Payout Processed',
      description: 'Notifications when payouts are processed',
      methods: ['email', 'push'],
    },
    {
      id: 'budget_alerts',
      title: 'Budget Alerts',
      description: 'Alerts when campaign budgets are running low',
      methods: ['email', 'push'],
    },
    {
      id: 'system_updates',
      title: 'System Updates',
      description: 'Important platform updates and maintenance notifications',
      methods: ['email'],
    },
  ];
  
  return (
    <AppLayout>
      <div className="notification-settings">
        <PageHeader
          title="Notification Settings"
          subtitle="Choose how and when you want to be notified"
          breadcrumbs={[
            { label: 'Settings', href: '/settings' },
            { label: 'Notifications' },
          ]}
        />
        
        <div className="notification-preferences">
          <div className="preferences-header">
            <div className="header-labels">
              <span>Notification Type</span>
              <div className="method-labels">
                <span>Email</span>
                <span>Push</span>
                <span>SMS</span>
              </div>
            </div>
          </div>
          
          <div className="preferences-list">
            {notificationTypes.map(type => (
              <NotificationPreferenceRow
                key={type.id}
                type={type}
                preferences={preferences[type.id] || {}}
                onToggle={(method, enabled) => handleToggle(type.id, method, enabled)}
              />
            ))}
          </div>
          
          <div className="quiet-hours">
            <h3>Quiet Hours</h3>
            <p>Set hours when you don't want to receive notifications</p>
            
            <QuietHoursSelector
              value={preferences.quietHours}
              onChange={(quietHours) => setPreferences(prev => ({
                ...prev,
                quietHours,
              }))}
            />
          </div>
        </div>
      </div>
    </AppLayout>
  );
}
```

# Security Settings
```tsx
export function SecuritySettings() {
  const { user } = useAuth();
  const [showPasswordForm, setShowPasswordForm] = useState(false);
  const [show2FASetup, setShow2FASetup] = useState(false);
  const { data: securityInfo } = useSecurityInfo();
  
  const handlePasswordChange = async (data: PasswordChangeData) => {
    try {
      await authService.changePassword(data.currentPassword, data.newPassword);
      setShowPasswordForm(false);
      toast.success('Password changed successfully');
    } catch (error) {
      toast.error('Failed to change password');
    }
  };
  
  const handle2FAToggle = async (enabled: boolean) => {
    if (enabled) {
      setShow2FASetup(true);
    } else {
      try {
        await authService.disable2FA();
        toast.success('Two-factor authentication disabled');
      } catch (error) {
        toast.error('Failed to disable 2FA');
      }
    }
  };
  
  return (
    <AppLayout>
      <div className="security-settings">
        <PageHeader
          title="Security Settings"
          subtitle="Manage your account security and authentication"
          breadcrumbs={[
            { label: 'Settings', href: '/settings' },
            { label: 'Security' },
          ]}
        />
        
        <div className="security-sections">
          <div className="security-section">
            <div className="section-header">
              <h3>Password</h3>
              <p>Change your account password</p>
            </div>
            
            <div className="section-content">
              <div className="password-info">
                <span>Last changed: {formatDate(securityInfo.passwordLastChanged)}</span>
                <Button
                  variant="outline"
                  onClick={() => setShowPasswordForm(true)}
                >
                  Change Password
                </Button>
              </div>
            </div>
            
            {showPasswordForm && (
              <PasswordChangeForm
                onSubmit={handlePasswordChange}
                onCancel={() => setShowPasswordForm(false)}
              />
            )}
          </div>
          
          <div className="security-section">
            <div className="section-header">
              <h3>Two-Factor Authentication</h3>
              <p>Add an extra layer of security to your account</p>
            </div>
            
            <div className="section-content">
              <div className="2fa-status">
                <div className="status-info">
                  <div className={`status-indicator ${securityInfo.twoFactorEnabled ? 'enabled' : 'disabled'}`} />
                  <span>
                    {securityInfo.twoFactorEnabled ? 'Enabled' : 'Disabled'}
                  </span>
                </div>
                
                <Switch
                  checked={securityInfo.twoFactorEnabled}
                  onChange={handle2FAToggle}
                />
              </div>
              
              {securityInfo.twoFactorEnabled && (
                <div className="2fa-details">
                  <p>Configured on: {formatDate(securityInfo.twoFactorSetupDate)}</p>
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => setShow2FASetup(true)}
                  >
                    Reconfigure
                  </Button>
                </div>
              )}
            </div>
          </div>
          
          <div className="security-section">
            <div className="section-header">
              <h3>Login History</h3>
              <p>Recent login activity on your account</p>
            </div>
            
            <div className="section-content">
              <LoginHistoryTable data={securityInfo.loginHistory} />
            </div>
          </div>
          
          <div className="security-section">
            <div className="section-header">
              <h3>Active Sessions</h3>
              <p>Devices and browsers currently signed in</p>
            </div>
            
            <div className="section-content">
              <ActiveSessionsList
                sessions={securityInfo.activeSessions}
                onTerminate={handleTerminateSession}
              />
            </div>
          </div>
        </div>
        
        {show2FASetup && (
          <TwoFactorSetupModal
            onClose={() => setShow2FASetup(false)}
            onComplete={() => {
              setShow2FASetup(false);
              toast.success('Two-factor authentication enabled');
            }}
          />
        )}
      </div>
    </AppLayout>
  );
}
```

# Integration Settings
```tsx
export function IntegrationSettings() {
  const { data: apiKeys, loading } = useAPIKeys();
  const { data: webhooks } = useWebhooks();
  const [showKeyGenerator, setShowKeyGenerator] = useState(false);
  const [showWebhookForm, setShowWebhookForm] = useState(false);
  
  const handleGenerateKey = async (keyData: APIKeyData) => {
    try {
      const newKey = await apiService.generateKey(keyData);
      toast.success('API key generated successfully');
      setShowKeyGenerator(false);
    } catch (error) {
      toast.error('Failed to generate API key');
    }
  };
  
  const handleRevokeKey = async (keyId: string) => {
    try {
      await apiService.revokeKey(keyId);
      toast.success('API key revoked');
    } catch (error) {
      toast.error('Failed to revoke API key');
    }
  };
  
  return (
    <AppLayout>
      <div className="integration-settings">
        <PageHeader
          title="Integration Settings"
          subtitle="Manage API keys, webhooks, and third-party integrations"
          breadcrumbs={[
            { label: 'Settings', href: '/settings' },
            { label: 'Integrations' },
          ]}
        />
        
        <div className="integration-sections">
          <div className="integration-section">
            <div className="section-header">
              <h3>API Keys</h3>
              <p>Manage API keys for programmatic access</p>
              <Button onClick={() => setShowKeyGenerator(true)}>
                Generate New Key
              </Button>
            </div>
            
            <div className="api-keys-list">
              {apiKeys?.map(key => (
                <APIKeyCard
                  key={key.id}
                  apiKey={key}
                  onRevoke={() => handleRevokeKey(key.id)}
                  onEdit={() => editAPIKey(key.id)}
                />
              ))}
            </div>
          </div>
          
          <div className="integration-section">
            <div className="section-header">
              <h3>Webhooks</h3>
              <p>Configure webhook endpoints for real-time notifications</p>
              <Button onClick={() => setShowWebhookForm(true)}>
                Add Webhook
              </Button>
            </div>
            
            <div className="webhooks-list">
              {webhooks?.map(webhook => (
                <WebhookCard
                  key={webhook.id}
                  webhook={webhook}
                  onTest={() => testWebhook(webhook.id)}
                  onEdit={() => editWebhook(webhook.id)}
                  onDelete={() => deleteWebhook(webhook.id)}
                />
              ))}
            </div>
          </div>
          
          <div className="integration-section">
            <div className="section-header">
              <h3>Third-Party Integrations</h3>
              <p>Connect with external services and platforms</p>
            </div>
            
            <div className="integrations-grid">
              <IntegrationCard
                name="Zapier"
                description="Automate workflows with 5000+ apps"
                status={getIntegrationStatus('zapier')}
                onConnect={() => connectIntegration('zapier')}
              />
              <IntegrationCard
                name="Salesforce"
                description="Sync leads with your CRM"
                status={getIntegrationStatus('salesforce')}
                onConnect={() => connectIntegration('salesforce')}
              />
              <IntegrationCard
                name="HubSpot"
                description="Import leads to your marketing platform"
                status={getIntegrationStatus('hubspot')}
                onConnect={() => connectIntegration('hubspot')}
              />
            </div>
          </div>
        </div>
        
        {showKeyGenerator && (
          <APIKeyGeneratorModal
            onClose={() => setShowKeyGenerator(false)}
            onGenerate={handleGenerateKey}
          />
        )}
        
        {showWebhookForm && (
          <WebhookFormModal
            onClose={() => setShowWebhookForm(false)}
            onSave={handleWebhookSave}
          />
        )}
      </div>
    </AppLayout>
  );
}
```

# Account Settings
```tsx
export function AccountSettings() {
  const { user, deleteAccount } = useAuth();
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const { data: accountData } = useAccountData();
  
  const handleDeleteAccount = async () => {
    try {
      await deleteAccount();
      navigate('/auth/login');
    } catch (error) {
      toast.error('Failed to delete account');
    }
  };
  
  return (
    <AppLayout>
      <div className="account-settings">
        <PageHeader
          title="Account Settings"
          subtitle="Manage your account preferences and data"
          breadcrumbs={[
            { label: 'Settings', href: '/settings' },
            { label: 'Account' },
          ]}
        />
        
        <div className="account-sections">
          <div className="account-section">
            <h3>Account Information</h3>
            <div className="account-info">
              <div className="info-item">
                <label>Account Type</label>
                <span className="account-type">{user?.role}</span>
              </div>
              <div className="info-item">
                <label>Member Since</label>
                <span>{formatDate(user?.created_at)}</span>
              </div>
              <div className="info-item">
                <label>Account Status</label>
                <StatusBadge status={accountData.status} />
              </div>
            </div>
          </div>
          
          <div className="account-section">
            <h3>Data Export</h3>
            <p>Download all your account data</p>
            <Button
              variant="outline"
              onClick={() => exportAccountData()}
            >
              <ArrowDownTrayIcon className="h-4 w-4" />
              Export Data
            </Button>
          </div>
          
          <div className="account-section danger-section">
            <h3>Delete Account</h3>
            <p>Permanently delete your account and all associated data</p>
            <Button
              variant="destructive"
              onClick={() => setShowDeleteDialog(true)}
            >
              Delete Account
            </Button>
          </div>
        </div>
        
        {showDeleteDialog && (
          <DeleteAccountDialog
            onConfirm={handleDeleteAccount}
            onCancel={() => setShowDeleteDialog(false)}
          />
        )}
      </div>
    </AppLayout>
  );
}
```

# Settings Navigation
- Sidebar navigation for settings sections
- Breadcrumb navigation
- Search functionality
- Settings categories
- Quick access shortcuts

# Form Validation
- Real-time validation feedback
- Zod schema validation
- Error message handling
- Field-level validation
- Form state management

# Security Features
- Session management
- Activity logging
- 2FA setup and management
- API key security
- Data encryption

# CRITICAL RULES
- NO regex in settings validation
- NO any types in settings interfaces
- ALWAYS validate sensitive operations
- ALWAYS confirm destructive actions
- IMPLEMENT proper access controls
- TEST security features thoroughly
- ENSURE data privacy compliance
- MAINTAIN audit trails
</file>

<file path="src/pages/settings/SettingsPage.tsx">
export default function SettingsPage() {
  return (
    <div className="py-6">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <h1 className="text-2xl font-semibold text-gray-900">Settings</h1>
        <p className="mt-1 text-sm text-gray-600">
          Manage your account settings and preferences.
        </p>
        
        <div className="mt-8">
          <div className="bg-white shadow overflow-hidden sm:rounded-md p-6">
            <p className="text-gray-500">Settings interface coming soon...</p>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/pages/CLAUDE.md">
# Page Structure Patterns

# File Naming
- PascalCase with "Page" suffix: `DashboardPage.tsx`
- Group by feature: `/auth/LoginPage.tsx`
- One page component per file

# Page Component Template
```tsx
import { useEffect } from 'react';
import { useAuth } from '@/hooks/useAuth';

interface PageNamePageProps {
  // Props if needed
}

export function PageNamePage({ }: PageNamePageProps) {
  // Page-specific logic
  
  return (
    <div className="page-container">
      {/* Page content */}
    </div>
  );
}
```

# Data Fetching Patterns
- React Query for server state
- Zustand for global client state
- Local useState for page-only state
- Supabase real-time subscriptions for live data

# Route Organization
```
/auth/           # Authentication pages
/dashboard/      # User dashboards
/campaigns/      # Campaign management
/calls/          # Call tracking
/reports/        # Analytics/reporting
/billing/        # Payment/billing
/settings/       # User settings
/public/         # Public landing pages
```

# Page Layout Structure
```tsx
<PageLayout>
  <PageHeader title="Page Title" />
  <PageContent>
    {/* Main content */}
  </PageContent>
  <PageFooter />
</PageLayout>
```

# SEO Considerations
- Document title updates with `useEffect`
- Meta descriptions for public pages
- OpenGraph tags for social sharing
- Structured data where applicable

# Error Handling
- Error boundaries for page-level errors
- Loading states during data fetching
- Empty states for no data
- User-friendly error messages

# Authentication Patterns
- Protected routes with auth checks
- Role-based access control (Supplier/Buyer/Admin)
- Redirect to login for unauthenticated users
- Session management with Supabase Auth

# Performance Optimization
- Lazy load pages with React.lazy
- Preload critical data on route enter
- Optimize images with proper sizing
- Minimize bundle size per route

# DCE-Specific Pages
- Supplier Dashboard: Traffic overview, campaign selection
- Buyer Dashboard: Campaign management, lead quality
- Call Tracking: Real-time call monitoring
- Billing: Payment processing, payout management
- Reports: Analytics and performance metrics

# Form Pages
- React Hook Form for all forms
- Zod validation schemas
- Optimistic updates where appropriate
- Proper error handling and user feedback

# Real-time Features
- Supabase subscriptions for live updates
- Call status indicators
- Campaign performance metrics
- Fraud detection alerts

# CRITICAL RULES
- NO regex in page components
- NO any types in page props
- ALWAYS handle auth states
- ALWAYS implement loading/error states
- ALWAYS optimize for mobile-first design
</file>

<file path="src/pages/ErrorDemo.tsx">
import { ErrorBoundaryDemo } from '../components/demo/ErrorBoundaryDemo'

export default function ErrorDemoPage() {
  return <ErrorBoundaryDemo />
}
</file>

<file path="src/services/CLAUDE.md">
# Service Layer Patterns

# Service Structure

```
services/
â”œâ”€â”€ api/           # External API services
â”œâ”€â”€ auth/          # Authentication services
â”œâ”€â”€ billing/       # Payment processing
â”œâ”€â”€ campaigns/     # Campaign management
â”œâ”€â”€ calls/         # Call tracking
â”œâ”€â”€ analytics/     # Analytics and reporting
â””â”€â”€ fraud/         # Fraud detection
```

# Service Class Pattern

```tsx
export class CampaignService {
  constructor(
    private supabase: SupabaseClient,
    private stripe: Stripe
  ) {}

  async createCampaign(data: CreateCampaignDTO): Promise<Campaign> {
    // Validate input
    const validated = campaignSchema.parse(data)

    // Business logic
    const campaign = await this.supabase.from('campaigns').insert(validated).select().single()

    if (campaign.error) throw new ServiceError(campaign.error.message)

    // Side effects (analytics, notifications)
    await this.trackCampaignCreation(campaign.data)

    return campaign.data
  }
}
```

# Error Handling

```tsx
export class ServiceError extends Error {
  constructor(
    message: string,
    public code: string,
    public statusCode = 400
  ) {
    super(message)
    this.name = 'ServiceError'
  }
}

export function handleServiceError(error: unknown): ServiceError {
  if (error instanceof ServiceError) return error

  if (error instanceof Error) {
    return new ServiceError(error.message, 'UNKNOWN_ERROR', 500)
  }

  return new ServiceError('Unknown error', 'UNKNOWN_ERROR', 500)
}
```

# Authentication Service

```tsx
export class AuthService {
  async login(email: string, password: string): Promise<AuthResponse> {
    const { data, error } = await supabase.auth.signInWithPassword({
      email,
      password,
    })

    if (error) throw new ServiceError(error.message, 'AUTH_FAILED', 401)

    // Additional business logic (logging, analytics)
    await this.logUserActivity('login', data.user.id)

    return data
  }

  async validateSession(): Promise<User | null> {
    const {
      data: { user },
    } = await supabase.auth.getUser()
    return user
  }
}
```

# Billing Service

```tsx
export class BillingService {
  async processPayment(
    amount: number,
    paymentMethodId: string,
    userId: string
  ): Promise<PaymentResult> {
    // Create payment intent
    const intent = await this.stripe.paymentIntents.create({
      amount: Math.round(amount * 100),
      currency: 'usd',
      payment_method: paymentMethodId,
      confirm: true,
      metadata: { userId },
    })

    // Record transaction
    await this.recordTransaction(intent, userId)

    return {
      success: intent.status === 'succeeded',
      transactionId: intent.id,
    }
  }
}
```

# Call Tracking Service

```tsx
export class CallTrackingService {
  async startCall(campaignId: string, supplierId: string, callerNumber: string): Promise<Call> {
    // Generate tracking number
    const trackingNumber = await this.generateTrackingNumber()

    // Create call record
    const call = await this.supabase
      .from('calls')
      .insert({
        campaign_id: campaignId,
        supplier_id: supplierId,
        caller_number: callerNumber,
        tracking_number: trackingNumber,
        status: 'active',
      })
      .select()
      .single()

    // Set up real-time monitoring
    await this.initializeCallMonitoring(call.data.id)

    return call.data
  }

  private async generateTrackingNumber(): Promise<string> {
    // Implementation for unique tracking number
    return `1800${Date.now().toString().slice(-7)}`
  }
}
```

# Analytics Service

```tsx
export class AnalyticsService {
  async getCampaignMetrics(campaignId: string, dateRange: DateRange): Promise<CampaignMetrics> {
    const [calls, conversions, revenue] = await Promise.all([
      this.getCallVolume(campaignId, dateRange),
      this.getConversions(campaignId, dateRange),
      this.getRevenue(campaignId, dateRange),
    ])

    return {
      totalCalls: calls.count,
      conversionRate: (conversions / calls.count) * 100,
      revenue,
      costPerAcquisition: revenue / conversions,
    }
  }
}
```

# Fraud Detection Service

```tsx
export class FraudDetectionService {
  async analyzeCall(callId: string): Promise<FraudScore> {
    const call = await this.getCallDetails(callId)

    const checks = await Promise.all([
      this.checkDuplicateCaller(call.caller_number),
      this.checkCallPattern(call),
      this.checkGeographicAnomaly(call),
      this.checkCallDuration(call.duration),
    ])

    const score = this.calculateFraudScore(checks)

    if (score > FRAUD_THRESHOLD) {
      await this.flagCall(callId, score)
    }

    return score
  }
}
```

# Service Registration Pattern

```tsx
// services/index.ts
export class ServiceRegistry {
  private static instance: ServiceRegistry

  authService: AuthService
  billingService: BillingService
  campaignService: CampaignService
  callService: CallTrackingService
  analyticsService: AnalyticsService
  fraudService: FraudDetectionService

  private constructor() {
    this.authService = new AuthService()
    this.billingService = new BillingService(stripe)
    this.campaignService = new CampaignService(supabase, stripe)
    this.callService = new CallTrackingService()
    this.analyticsService = new AnalyticsService()
    this.fraudService = new FraudDetectionService()
  }

  static getInstance(): ServiceRegistry {
    if (!ServiceRegistry.instance) {
      ServiceRegistry.instance = new ServiceRegistry()
    }
    return ServiceRegistry.instance
  }
}
```

# Service Testing

```tsx
describe('CampaignService', () => {
  let service: CampaignService

  beforeEach(() => {
    service = new CampaignService(mockSupabase, mockStripe)
  })

  it('should create campaign successfully', async () => {
    const campaign = await service.createCampaign({
      name: 'Test Campaign',
      vertical: 'insurance',
      target_cpa: 50,
    })

    expect(campaign).toBeDefined()
    expect(campaign.name).toBe('Test Campaign')
  })
})
```

# Caching Strategy

```tsx
export class CachedService {
  private cache = new Map<string, CacheEntry>()

  async getCachedData<T>(
    key: string,
    fetcher: () => Promise<T>,
    ttl = 300000 // 5 minutes
  ): Promise<T> {
    const cached = this.cache.get(key)

    if (cached && Date.now() - cached.timestamp < ttl) {
      return cached.data as T
    }

    const data = await fetcher()
    this.cache.set(key, { data, timestamp: Date.now() })

    return data
  }
}
```

# Transaction Management

```tsx
export async function withTransaction<T>(operation: () => Promise<T>): Promise<T> {
  const client = await supabase.rpc('begin_transaction')

  try {
    const result = await operation()
    await supabase.rpc('commit_transaction')
    return result
  } catch (error) {
    await supabase.rpc('rollback_transaction')
    throw error
  }
}
```

# DCE-Specific Services

- Real-time call quality monitoring
- Dynamic campaign routing
- Supplier performance scoring
- Automated payout calculations
- Lead quality validation
- Commission rate optimization

# CRITICAL RULES

- NO regex in service logic
- NO any types in service methods
- ALWAYS validate inputs with Zod
- ALWAYS handle errors explicitly
- ALWAYS use transactions for multi-step operations
- ALWAYS log service operations
- NEVER expose internal errors to clients
- USE dependency injection for testing
- IMPLEMENT proper retry logic
- CACHE expensive operations appropriately
</file>

<file path="src/store/buyerStore.ts">
import { create } from 'zustand'
import { devtools, persist } from 'zustand/middleware'
import { supabase } from '@/lib/supabase'
import type { Database } from '@/types/database'

type Campaign = Database['public']['Tables']['buyer_campaigns']['Row']

interface BuyerStore {
  // State
  currentBalance: number
  creditLimit: number
  campaigns: Campaign[]
  isLoading: boolean
  error: string | null

  // Actions
  fetchBalance: (buyerId: string) => Promise<void>
  updateBalance: (newBalance: number) => void
  fetchCampaigns: (buyerId: string) => Promise<void>
  updateCampaign: (campaignId: string, updates: Partial<Campaign>) => void
  clearError: () => void
  reset: () => void
}

const initialState = {
  currentBalance: 0,
  creditLimit: 0,
  campaigns: [],
  isLoading: false,
  error: null,
}

export const useBuyerStore = create<BuyerStore>()(
  devtools(
    persist(
      (set) => ({
        ...initialState,

        fetchBalance: async (buyerId: string) => {
          set({ isLoading: true, error: null })

          try {
            const { data, error } = await supabase
              .from('buyers')
              .select('current_balance, credit_limit')
              .eq('id', buyerId)
              .single()

            if (error) throw error

            set({
              currentBalance: data.current_balance || 0,
              creditLimit: data.credit_limit || 0,
              isLoading: false,
            })
          } catch (error) {
            const message = error instanceof Error ? error.message : 'Failed to fetch balance'
            set({ error: message, isLoading: false })
          }
        },

        updateBalance: (newBalance: number) => {
          set({ currentBalance: newBalance })
        },

        fetchCampaigns: async (buyerId: string) => {
          set({ isLoading: true, error: null })

          try {
            const { data, error } = await supabase
              .from('buyer_campaigns')
              .select('*')
              .eq('buyer_id', buyerId)
              .order('created_at', { ascending: false })

            if (error) throw error

            set({
              campaigns: data || [],
              isLoading: false,
            })
          } catch (error) {
            const message = error instanceof Error ? error.message : 'Failed to fetch campaigns'
            set({ error: message, isLoading: false })
          }
        },

        updateCampaign: (campaignId: string, updates: Partial<Campaign>) => {
          set((state) => ({
            campaigns: state.campaigns.map((campaign) =>
              campaign.id === campaignId ? { ...campaign, ...updates } : campaign
            ),
          }))
        },

        clearError: () => set({ error: null }),

        reset: () => set(initialState),
      }),
      {
        name: 'buyer-store',
      }
    )
  )
)
</file>

<file path="src/store/CLAUDE.md">
# Zustand State Management Patterns

# Store File Structure
```
store/
â”œâ”€â”€ authStore.ts        # Authentication state
â”œâ”€â”€ campaignStore.ts    # Campaign management
â”œâ”€â”€ callStore.ts        # Call tracking state
â”œâ”€â”€ billingStore.ts     # Billing/payment state
â”œâ”€â”€ uiStore.ts          # UI state (modals, etc.)
â””â”€â”€ index.ts            # Store exports
```

# Basic Store Pattern
```tsx
import { create } from 'zustand';
import { subscribeWithSelector } from 'zustand/middleware';

interface StoreState {
  // State properties
  data: DataType[];
  isLoading: boolean;
  error: string | null;
  
  // Actions
  setData: (data: DataType[]) => void;
  setLoading: (loading: boolean) => void;
  setError: (error: string | null) => void;
  reset: () => void;
}

export const useStore = create<StoreState>()(
  subscribeWithSelector((set, get) => ({
    // Initial state
    data: [],
    isLoading: false,
    error: null,
    
    // Actions
    setData: (data) => set({ data }),
    setLoading: (isLoading) => set({ isLoading }),
    setError: (error) => set({ error }),
    reset: () => set({ data: [], isLoading: false, error: null }),
  }))
);
```

# TypeScript Requirements
- ALL stores must have proper interfaces
- NO any types in state or actions
- Use proper generic types for flexible stores
- Export store types for component usage

# Async Actions Pattern
```tsx
// Async actions with proper error handling
const useDataStore = create<DataStore>((set, get) => ({
  data: [],
  isLoading: false,
  error: null,
  
  fetchData: async () => {
    set({ isLoading: true, error: null });
    try {
      const data = await api.getData();
      set({ data, isLoading: false });
    } catch (error) {
      set({ 
        error: handleApiError(error), 
        isLoading: false 
      });
    }
  },
}));
```

# Computed Values
```tsx
// Use selectors for computed values
export const useUserStats = () => {
  return useAuthStore((state) => ({
    totalCalls: state.calls.length,
    activeCallsCount: state.calls.filter(c => c.status === 'active').length,
    conversionRate: state.calls.length > 0 
      ? (state.conversions / state.calls.length) * 100 
      : 0,
  }));
};
```

# Persistence Patterns
```tsx
import { persist } from 'zustand/middleware';

// Persist auth state
export const useAuthStore = create<AuthState>()(
  persist(
    (set, get) => ({
      user: null,
      token: null,
      // ... other state and actions
    }),
    {
      name: 'auth-storage',
      partialize: (state) => ({
        user: state.user,
        token: state.token,
      }),
    }
  )
);
```

# Subscriptions for Real-time
```tsx
// Subscribe to Supabase real-time changes
export const useCallStore = create<CallState>((set, get) => ({
  calls: [],
  
  subscribeToRealTimeUpdates: () => {
    return supabase
      .channel('calls')
      .on('postgres_changes', 
        { event: '*', schema: 'public', table: 'calls' },
        (payload) => {
          // Update store based on real-time changes
          set((state) => ({
            calls: updateCallsArray(state.calls, payload)
          }));
        }
      )
      .subscribe();
  },
}));
```

# Performance Optimization
```tsx
// Use shallow equality for object selections
import { shallow } from 'zustand/shallow';

const Component = () => {
  const { user, isLoading } = useAuthStore(
    (state) => ({ user: state.user, isLoading: state.isLoading }),
    shallow
  );
};

// Or use specific selectors
const user = useAuthStore(state => state.user);
const isLoading = useAuthStore(state => state.isLoading);
```

# DCE-Specific Stores

## Auth Store
- User authentication state
- Role-based permissions (Supplier/Buyer/Admin)
- Session management

## Campaign Store
- Campaign CRUD operations
- Real-time campaign status
- Performance metrics

## Call Store
- Live call tracking
- Call history and analytics
- Real-time status updates

## Billing Store
- Payment processing state
- Payout calculations
- Transaction history

# Store Testing
```tsx
// Test stores in isolation
describe('AuthStore', () => {
  beforeEach(() => {
    useAuthStore.getState().reset();
  });
  
  it('should login user correctly', async () => {
    const { login } = useAuthStore.getState();
    await login('user@test.com', 'password');
    
    expect(useAuthStore.getState().user).toBeDefined();
    expect(useAuthStore.getState().isAuthenticated).toBe(true);
  });
});
```

# CRITICAL RULES
- NO regex in store logic
- NO any types in store interfaces
- ALWAYS handle async errors properly
- ALWAYS reset state when needed
- ALWAYS use TypeScript strictly
- ALWAYS test store actions
- NO direct state mutations (use set function)
</file>

<file path="src/test/providers.tsx">
import React from 'react'
import { BrowserRouter } from 'react-router-dom'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'

interface ProvidersProps {
  children: React.ReactNode
  queryClient?: QueryClient
}

export function AllTheProviders({
  children,
  queryClient = new QueryClient({
    defaultOptions: {
      queries: { retry: false },
      mutations: { retry: false },
    },
  }),
}: ProvidersProps) {
  return (
    <QueryClientProvider client={queryClient}>
      <BrowserRouter>{children}</BrowserRouter>
    </QueryClientProvider>
  )
}
</file>

<file path="src/types/CLAUDE.md">
# TypeScript Conventions

# File Organization
```
types/
â”œâ”€â”€ database.ts       # Supabase generated types
â”œâ”€â”€ api.ts           # API request/response types
â”œâ”€â”€ auth.ts          # Authentication types
â”œâ”€â”€ billing.ts       # Payment/billing types
â”œâ”€â”€ campaign.ts      # Campaign management types
â”œâ”€â”€ call.ts          # Call tracking types
â”œâ”€â”€ common.ts        # Shared/utility types
â””â”€â”€ index.ts         # Export all types
```

# Database Type Generation
- Use Supabase CLI to generate types
- NEVER manually write database types
- Regenerate after schema changes

```bash
# Generate database types
npx supabase gen types typescript --project-id=your-project > src/types/database.ts
```

# Type Definition Patterns
```tsx
// Base entity interface
interface BaseEntity {
  id: string;
  created_at: string;
  updated_at: string;
}

// Extend base for specific entities
interface User extends BaseEntity {
  email: string;
  role: UserRole;
  profile: UserProfile;
}

// Union types for enums
type UserRole = 'supplier' | 'buyer' | 'admin';
type CallStatus = 'pending' | 'active' | 'completed' | 'failed';
```

# API Response Types
```tsx
// Generic API response wrapper
interface ApiResponse<T> {
  data: T;
  message?: string;
  success: boolean;
}

// Paginated response
interface PaginatedResponse<T> {
  data: T[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  };
}

// Error response
interface ApiError {
  message: string;
  code?: string;
  field?: string;
}
```

# Form & Validation Types
```tsx
// Form data types
interface LoginFormData {
  email: string;
  password: string;
}

// Validation schemas with Zod
import { z } from 'zod';

export const loginSchema = z.object({
  email: z.string().email('Invalid email'),
  password: z.string().min(8, 'Password must be at least 8 characters'),
});

export type LoginFormData = z.infer<typeof loginSchema>;
```

# Utility Types
```tsx
// Make specific fields optional
type PartialUser = Partial<Pick<User, 'name' | 'phone'>>;

// Omit sensitive fields
type PublicUser = Omit<User, 'password' | 'apiKey'>;

// Extract enum values from const objects
const CALL_STATUSES = {
  PENDING: 'pending',
  ACTIVE: 'active',
  COMPLETED: 'completed',
} as const;

type CallStatus = typeof CALL_STATUSES[keyof typeof CALL_STATUSES];
```

# React Component Types
```tsx
// Props interface
interface ComponentProps {
  title: string;
  isVisible?: boolean;
  onClose: () => void;
  children: React.ReactNode;
}

// Event handlers
type ClickHandler = (event: React.MouseEvent<HTMLButtonElement>) => void;
type ChangeHandler = (event: React.ChangeEvent<HTMLInputElement>) => void;

// Ref types
type InputRef = React.RefObject<HTMLInputElement>;
```

# Hook Return Types
```tsx
// Custom hook return types
interface UseApiResult<T> {
  data: T | null;
  loading: boolean;
  error: string | null;
  refetch: () => Promise<void>;
}

// Generic hook type
type UseApiHook<T> = (endpoint: string) => UseApiResult<T>;
```

# DCE-Specific Types

## Campaign Types
```tsx
interface Campaign extends BaseEntity {
  name: string;
  buyer_id: string;
  status: CampaignStatus;
  target_cpa: number;
  daily_budget: number;
  filters: CampaignFilters;
}

interface CampaignFilters {
  states?: string[];
  age_range?: [number, number];
  time_restrictions?: TimeRestriction[];
}
```

## Call Types
```tsx
interface Call extends BaseEntity {
  campaign_id: string;
  supplier_id: string;
  phone_number: string;
  duration: number;
  status: CallStatus;
  quality_score: number;
  payout_amount: number;
}
```

## Billing Types
```tsx
interface Transaction extends BaseEntity {
  amount: number;
  currency: string;
  type: TransactionType;
  status: PaymentStatus;
  stripe_payment_intent_id?: string;
}

type TransactionType = 'payout' | 'charge' | 'refund';
type PaymentStatus = 'pending' | 'succeeded' | 'failed';
```

# Type Guards
```tsx
// Runtime type checking
export function isUser(obj: unknown): obj is User {
  return (
    typeof obj === 'object' &&
    obj !== null &&
    'id' in obj &&
    'email' in obj &&
    'role' in obj
  );
}

// API response type guards
export function isApiError(response: unknown): response is ApiError {
  return (
    typeof response === 'object' &&
    response !== null &&
    'message' in response
  );
}
```

# Environment Variable Types
```tsx
interface ImportMetaEnv {
  readonly VITE_SUPABASE_URL: string;
  readonly VITE_SUPABASE_ANON_KEY: string;
  readonly VITE_STRIPE_PUBLIC_KEY: string;
  readonly VITE_SENTRY_DSN: string;
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}
```

# Type Export Strategy
```tsx
// index.ts - Central type exports
export type { User, UserRole } from './auth';
export type { Campaign, CampaignFilters } from './campaign';
export type { Call, CallStatus } from './call';
export type { ApiResponse, PaginatedResponse } from './api';

// Re-export database types
export type { Database } from './database';
```

# CRITICAL RULES
- NO any types anywhere
- NO regex in type definitions
- ALWAYS use strict TypeScript settings
- ALWAYS generate database types
- NEVER use unknown without type guards
- ALWAYS export types for reuse
- ALWAYS use proper generic constraints
- STRICT null checks enabled
- NO implicit any allowed
- USE exact types, avoid loose objects
</file>

<file path="src/utils/CLAUDE.md">
# Utility Functions

# File Organization

```
utils/
â”œâ”€â”€ format.ts       # Data formatting utilities
â”œâ”€â”€ validate.ts     # Validation helpers
â”œâ”€â”€ date.ts        # Date/time utilities
â”œâ”€â”€ string.ts      # String manipulation
â”œâ”€â”€ number.ts      # Number utilities
â”œâ”€â”€ crypto.ts      # Encryption/hashing
â”œâ”€â”€ storage.ts     # Local/session storage
â””â”€â”€ index.ts       # Export all utilities
```

# Formatting Utilities

```tsx
// format.ts
export function formatPhoneNumber(phone: string): string {
  const cleaned = phone.replace(/\D/g, '')
  if (cleaned.length !== 10) return phone

  return `(${cleaned.slice(0, 3)}) ${cleaned.slice(3, 6)}-${cleaned.slice(6)}`
}

export function formatCurrency(amount: number, currency = 'USD', locale = 'en-US'): string {
  return new Intl.NumberFormat(locale, {
    style: 'currency',
    currency,
  }).format(amount)
}

export function formatPercentage(value: number, decimals = 2): string {
  return `${(value * 100).toFixed(decimals)}%`
}
```

# Validation Helpers

```tsx
// validate.ts - NO REGEX ALLOWED
import { z } from 'zod'

export const phoneValidator = z
  .string()
  .transform((val) => val.replace(/\D/g, ''))
  .refine((val) => val.length === 10, {
    message: 'Phone number must be 10 digits',
  })

export const emailValidator = z.string().email()

export const urlValidator = z.string().url()

export function isValidPhone(phone: string): boolean {
  return phoneValidator.safeParse(phone).success
}

export function isValidEmail(email: string): boolean {
  return emailValidator.safeParse(email).success
}
```

# Date Utilities

```tsx
// date.ts
export function formatDate(
  date: Date | string,
  format: 'short' | 'long' | 'iso' = 'short'
): string {
  const d = new Date(date)

  switch (format) {
    case 'short':
      return d.toLocaleDateString('en-US')
    case 'long':
      return d.toLocaleDateString('en-US', {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric',
      })
    case 'iso':
      return d.toISOString()
  }
}

export function addDays(date: Date, days: number): Date {
  const result = new Date(date)
  result.setDate(result.getDate() + days)
  return result
}

export function getDateRange(period: 'today' | 'week' | 'month' | 'year'): {
  start: Date
  end: Date
} {
  const end = new Date()
  const start = new Date()

  switch (period) {
    case 'today':
      start.setHours(0, 0, 0, 0)
      break
    case 'week':
      start.setDate(start.getDate() - 7)
      break
    case 'month':
      start.setMonth(start.getMonth() - 1)
      break
    case 'year':
      start.setFullYear(start.getFullYear() - 1)
      break
  }

  return { start, end }
}
```

# String Utilities

```tsx
// string.ts - NO REGEX ALLOWED
export function truncate(str: string, maxLength: number): string {
  if (str.length <= maxLength) return str
  return str.slice(0, maxLength - 3) + '...'
}

export function capitalize(str: string): string {
  if (!str) return ''
  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase()
}

export function slugify(str: string): string {
  return str
    .toLowerCase()
    .trim()
    .replace(/\s+/g, '-')
    .replace(/[^\w\-]+/g, '')
    .replace(/\-\-+/g, '-')
}

export function extractInitials(name: string): string {
  return name
    .split(' ')
    .map((part) => part.charAt(0))
    .join('')
    .toUpperCase()
    .slice(0, 2)
}
```

# Number Utilities

```tsx
// number.ts
export function clamp(value: number, min: number, max: number): number {
  return Math.min(Math.max(value, min), max)
}

export function roundTo(value: number, decimals: number): number {
  const factor = Math.pow(10, decimals)
  return Math.round(value * factor) / factor
}

export function randomBetween(min: number, max: number): number {
  return Math.floor(Math.random() * (max - min + 1)) + min
}

export function calculatePercentage(value: number, total: number): number {
  if (total === 0) return 0
  return (value / total) * 100
}
```

# Crypto Utilities

```tsx
// crypto.ts
export async function hashValue(value: string): Promise<string> {
  const encoder = new TextEncoder()
  const data = encoder.encode(value)
  const hash = await crypto.subtle.digest('SHA-256', data)

  return Array.from(new Uint8Array(hash))
    .map((b) => b.toString(16).padStart(2, '0'))
    .join('')
}

export function generateId(): string {
  return crypto.randomUUID()
}

export function generateSecureToken(length = 32): string {
  const array = new Uint8Array(length)
  crypto.getRandomValues(array)

  return Array.from(array)
    .map((b) => b.toString(16).padStart(2, '0'))
    .join('')
}
```

# Storage Utilities

```tsx
// storage.ts
export const storage = {
  get<T>(key: string, defaultValue?: T): T | null {
    try {
      const item = localStorage.getItem(key)
      return item ? JSON.parse(item) : (defaultValue ?? null)
    } catch {
      return defaultValue ?? null
    }
  },

  set<T>(key: string, value: T): void {
    try {
      localStorage.setItem(key, JSON.stringify(value))
    } catch (error) {
      console.error('Storage error:', error)
    }
  },

  remove(key: string): void {
    localStorage.removeItem(key)
  },

  clear(): void {
    localStorage.clear()
  },
}

export const sessionStorage = {
  get<T>(key: string): T | null {
    try {
      const item = window.sessionStorage.getItem(key)
      return item ? JSON.parse(item) : null
    } catch {
      return null
    }
  },

  set<T>(key: string, value: T): void {
    window.sessionStorage.setItem(key, JSON.stringify(value))
  },
}
```

# Array Utilities

```tsx
export function groupBy<T, K extends keyof any>(array: T[], key: (item: T) => K): Record<K, T[]> {
  return array.reduce(
    (groups, item) => {
      const group = key(item)
      if (!groups[group]) groups[group] = []
      groups[group].push(item)
      return groups
    },
    {} as Record<K, T[]>
  )
}

export function unique<T>(array: T[]): T[] {
  return [...new Set(array)]
}

export function chunk<T>(array: T[], size: number): T[][] {
  const chunks: T[][] = []
  for (let i = 0; i < array.length; i += size) {
    chunks.push(array.slice(i, i + size))
  }
  return chunks
}
```

# DCE-Specific Utilities

## Call Duration Formatting

```tsx
export function formatCallDuration(seconds: number): string {
  const hours = Math.floor(seconds / 3600)
  const minutes = Math.floor((seconds % 3600) / 60)
  const secs = seconds % 60

  if (hours > 0) {
    return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`
  }
  return `${minutes}:${secs.toString().padStart(2, '0')}`
}
```

## Commission Calculation

```tsx
export function calculateCommission(amount: number, rate: number, minCommission = 0): number {
  const commission = amount * (rate / 100)
  return Math.max(commission, minCommission)
}
```

## Quality Score Calculation

```tsx
export function calculateQualityScore(
  duration: number,
  converted: boolean,
  fraudScore: number
): number {
  let score = 50 // Base score

  // Duration bonus
  if (duration > 120) score += 20
  else if (duration > 60) score += 10

  // Conversion bonus
  if (converted) score += 30

  // Fraud penalty
  score -= fraudScore * 10

  return clamp(score, 0, 100)
}
```

# Error Utilities

```tsx
export function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message
  if (typeof error === 'string') return error
  return 'An unknown error occurred'
}

export function isNetworkError(error: unknown): boolean {
  return (
    error instanceof Error && (error.message.includes('network') || error.message.includes('fetch'))
  )
}
```

# Type Guards

```tsx
export function isNotNull<T>(value: T | null): value is T {
  return value !== null
}

export function isDefined<T>(value: T | undefined): value is T {
  return value !== undefined
}

export function isString(value: unknown): value is string {
  return typeof value === 'string'
}

export function isNumber(value: unknown): value is number {
  return typeof value === 'number' && !isNaN(value)
}
```

# CRITICAL RULES

- NO regex patterns anywhere
- NO any types in utility functions
- ALWAYS use Zod for validation
- ALWAYS handle edge cases
- ALWAYS provide TypeScript types
- ALWAYS document complex utilities
- TEST all utility functions
- USE native APIs when available
- OPTIMIZE for performance
- KEEP utilities pure and side-effect free
</file>

<file path="src/utils/environment.ts">
/**
 * Environment detection utilities for the DCE Platform
 * Provides helper functions to determine the current environment
 * and control feature visibility based on environment
 */

/**
 * Check if the application is running in development mode
 * @returns true if in development mode
 */
export function isDevelopment(): boolean {
  return import.meta.env.DEV
}

/**
 * Check if the application is running in production mode
 * @returns true if in production mode
 */
export function isProduction(): boolean {
  return import.meta.env.PROD
}

/**
 * Check if the application is running in test mode
 * @returns true if in test mode
 */
export function isTest(): boolean {
  return import.meta.env.MODE === 'test'
}

/**
 * Check if the application is running in staging mode
 * @returns true if in staging mode
 */
export function isStaging(): boolean {
  return import.meta.env.VITE_ENV === 'staging'
}

/**
 * Determine if technical error details should be shown
 * @returns true if technical details should be displayed
 */
export function shouldShowTechnicalDetails(): boolean {
  // Show technical details in development and staging, hide in production
  return isDevelopment() || isStaging()
}

/**
 * Get the appropriate error display level based on environment
 * @returns 'full' | 'minimal' | 'user-friendly'
 */
export function getErrorDisplayLevel(): 'full' | 'minimal' | 'user-friendly' {
  if (isDevelopment()) {
    return 'full' // Show everything: stack traces, component stacks, etc.
  }

  if (isStaging()) {
    return 'minimal' // Show error messages but not full stack traces
  }

  return 'user-friendly' // Production: show only user-friendly messages
}

/**
 * Check if debug mode is enabled
 * @returns true if debug mode is enabled
 */
export function isDebugEnabled(): boolean {
  return import.meta.env.VITE_DEBUG === 'true' || isDevelopment()
}

/**
 * Get the current environment name
 * @returns environment name as string
 */
export function getEnvironmentName(): string {
  if (isDevelopment()) return 'development'
  if (isStaging()) return 'staging'
  if (isProduction()) return 'production'
  if (isTest()) return 'test'
  return 'unknown'
}

/**
 * Check if we should log errors to console
 * @returns true if errors should be logged to console
 */
export function shouldLogToConsole(): boolean {
  // Always log in development, optionally in staging based on debug flag
  return isDevelopment() || (isStaging() && isDebugEnabled())
}

/**
 * Check if we should send errors to monitoring service (e.g., Sentry)
 * @returns true if errors should be sent to monitoring
 */
export function shouldSendToMonitoring(): boolean {
  // Send to monitoring in production and staging, not in development
  return isProduction() || isStaging()
}

/**
 * Get environment-specific error message
 * @param error - The error object
 * @param fallbackMessage - Fallback message for production
 * @returns Appropriate error message based on environment
 */
export function getEnvironmentErrorMessage(
  error: Error | unknown,
  fallbackMessage = 'An unexpected error occurred. Please try again.'
): string {
  if (shouldShowTechnicalDetails() && error instanceof Error) {
    return error.message
  }
  return fallbackMessage
}

/**
 * Environment configuration object
 */
export const environment = {
  isDevelopment: isDevelopment(),
  isProduction: isProduction(),
  isTest: isTest(),
  isStaging: isStaging(),
  showTechnicalDetails: shouldShowTechnicalDetails(),
  errorDisplayLevel: getErrorDisplayLevel(),
  debugEnabled: isDebugEnabled(),
  name: getEnvironmentName(),
  logToConsole: shouldLogToConsole(),
  sendToMonitoring: shouldSendToMonitoring(),
} as const

export default environment
</file>

<file path="src/utils/format.ts">
/**
 * Utility functions for formatting data display
 * NO REGEX - Uses proper string methods and libraries
 */

/**
 * Format currency amounts
 */
export const formatCurrency = (
  amount: number,
  currency: string = 'USD',
  locale: string = 'en-US'
): string => {
  try {
    return new Intl.NumberFormat(locale, {
      style: 'currency',
      currency: currency.toUpperCase(),
      minimumFractionDigits: 2,
      maximumFractionDigits: 2,
    }).format(amount)
  } catch {
    // Fallback for invalid currency codes
    return `$${amount.toFixed(2)}`
  }
}

/**
 * Format numbers with proper locale formatting
 */
export const formatNumber = (
  value: number,
  options: {
    minimumFractionDigits?: number
    maximumFractionDigits?: number
    useGrouping?: boolean
  } = {},
  locale: string = 'en-US'
): string => {
  return new Intl.NumberFormat(locale, {
    minimumFractionDigits: options.minimumFractionDigits ?? 0,
    maximumFractionDigits: options.maximumFractionDigits ?? 3,
    useGrouping: options.useGrouping ?? true,
  }).format(value)
}

/**
 * Format percentage values
 */
export const formatPercentage = (
  value: number,
  decimals: number = 1,
  locale: string = 'en-US'
): string => {
  return new Intl.NumberFormat(locale, {
    style: 'percent',
    minimumFractionDigits: decimals,
    maximumFractionDigits: decimals,
  }).format(value / 100)
}

/**
 * Format dates with various options
 */
export const formatDate = (
  date: Date,
  options: Intl.DateTimeFormatOptions = {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
  },
  locale: string = 'en-US'
): string => {
  return new Intl.DateTimeFormat(locale, options).format(date)
}

/**
 * Format time
 */
export const formatTime = (
  date: Date,
  options: Intl.DateTimeFormatOptions = {
    hour: '2-digit',
    minute: '2-digit',
  },
  locale: string = 'en-US'
): string => {
  return new Intl.DateTimeFormat(locale, options).format(date)
}

/**
 * Format datetime
 */
export const formatDateTime = (date: Date, locale: string = 'en-US'): string => {
  return new Intl.DateTimeFormat(locale, {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
  }).format(date)
}

/**
 * Format relative time (e.g., "2 hours ago")
 */
export const formatRelativeTime = (date: Date, locale: string = 'en-US'): string => {
  const now = new Date()
  const diffInSeconds = Math.floor((now.getTime() - date.getTime()) / 1000)

  // Use Intl.RelativeTimeFormat for proper localization
  const rtf = new Intl.RelativeTimeFormat(locale, { numeric: 'auto' })

  if (diffInSeconds < 60) {
    return rtf.format(-diffInSeconds, 'second')
  } else if (diffInSeconds < 3600) {
    return rtf.format(-Math.floor(diffInSeconds / 60), 'minute')
  } else if (diffInSeconds < 86400) {
    return rtf.format(-Math.floor(diffInSeconds / 3600), 'hour')
  } else if (diffInSeconds < 2592000) {
    return rtf.format(-Math.floor(diffInSeconds / 86400), 'day')
  } else if (diffInSeconds < 31536000) {
    return rtf.format(-Math.floor(diffInSeconds / 2592000), 'month')
  } else {
    return rtf.format(-Math.floor(diffInSeconds / 31536000), 'year')
  }
}

/**
 * Format file sizes
 */
export const formatFileSize = (bytes: number, decimals: number = 2): string => {
  if (bytes === 0) return '0 Bytes'

  const k = 1024
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB']
  const i = Math.floor(Math.log(bytes) / Math.log(k))

  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(decimals))} ${sizes[i]}`
}

/**
 * Format duration in seconds to human readable format
 */
export const formatDuration = (seconds: number): string => {
  const hours = Math.floor(seconds / 3600)
  const minutes = Math.floor((seconds % 3600) / 60)
  const remainingSeconds = seconds % 60

  const parts: string[] = []

  if (hours > 0) {
    parts.push(`${hours}h`)
  }
  if (minutes > 0) {
    parts.push(`${minutes}m`)
  }
  if (remainingSeconds > 0 || parts.length === 0) {
    parts.push(`${remainingSeconds}s`)
  }

  return parts.join(' ')
}

/**
 * Format phone numbers using basic string manipulation (no regex)
 */
export const formatPhoneNumber = (phoneNumber: string): string => {
  // Remove all non-digit characters
  const digits = phoneNumber
    .split('')
    .filter((char) => {
      return char >= '0' && char <= '9'
    })
    .join('')

  // Format US phone numbers
  if (digits.length === 10) {
    return `(${digits.substring(0, 3)}) ${digits.substring(3, 6)}-${digits.substring(6)}`
  } else if (digits.length === 11 && digits.startsWith('1')) {
    return `+1 (${digits.substring(1, 4)}) ${digits.substring(4, 7)}-${digits.substring(7)}`
  }

  // Return original if can't format
  return phoneNumber
}

/**
 * Truncate text with ellipsis
 */
export const truncateText = (text: string, maxLength: number): string => {
  if (text.length <= maxLength) {
    return text
  }
  return text.substring(0, maxLength - 3) + '...'
}

/**
 * Capitalize first letter of each word
 */
export const titleCase = (str: string): string => {
  return str
    .toLowerCase()
    .split(' ')
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ')
}

/**
 * Format call duration in MM:SS format
 */
export const formatCallDuration = (seconds: number): string => {
  const minutes = Math.floor(seconds / 60)
  const remainingSeconds = seconds % 60
  return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`
}

/**
 * Format conversion rate as percentage
 */
export const formatConversionRate = (
  conversions: number,
  total: number,
  decimals: number = 2
): string => {
  if (total === 0) return '0%'
  const rate = (conversions / total) * 100
  return `${rate.toFixed(decimals)}%`
}

/**
 * Format campaign status for display
 */
export const formatCampaignStatus = (status: string): string => {
  const statusMap: Record<string, string> = {
    active: 'Active',
    paused: 'Paused',
    draft: 'Draft',
    completed: 'Completed',
    archived: 'Archived',
  }
  return statusMap[status] || titleCase(status)
}

/**
 * Format API response status
 */
export const formatApiStatus = (status: number): string => {
  if (status >= 200 && status < 300) return 'Success'
  if (status >= 300 && status < 400) return 'Redirect'
  if (status >= 400 && status < 500) return 'Client Error'
  if (status >= 500) return 'Server Error'
  return 'Unknown'
}

/**
 * Format bandwidth usage
 */
export const formatBandwidth = (bytes: number): string => {
  return formatFileSize(bytes)
}

/**
 * Format call quality score
 */
export const formatQualityScore = (score: number): string => {
  if (score >= 0.9) return 'Excellent'
  if (score >= 0.8) return 'Good'
  if (score >= 0.7) return 'Fair'
  if (score >= 0.6) return 'Poor'
  return 'Very Poor'
}

/**
 * Format geographic location
 */
export const formatLocation = (city?: string, state?: string, country?: string): string => {
  const parts = [city, state, country].filter(Boolean)
  return parts.join(', ')
}

/**
 * Format tracking number for display
 */
export const formatTrackingNumber = (trackingNumber: string): string => {
  // Add spaces for readability without using regex
  if (trackingNumber.length === 10) {
    return `(${trackingNumber.substring(0, 3)}) ${trackingNumber.substring(3, 6)}-${trackingNumber.substring(6)}`
  }
  return trackingNumber
}
</file>

<file path="src/utils/navigation.ts">
/**
 * Scroll to element with smooth behavior and proper offset
 * @param elementId - The ID of the element to scroll to (without #)
 */
export function scrollToElement(elementId: string): void {
  const element = document.getElementById(elementId)
  if (element) {
    const offset = 80 // Account for fixed header
    const elementPosition = element.getBoundingClientRect().top + window.pageYOffset
    const offsetPosition = elementPosition - offset

    window.scrollTo({
      top: offsetPosition,
      behavior: 'smooth',
    })
  }
}

/**
 * Handle hash change events for smooth scrolling
 */
export function handleHashChange(): void {
  const hash = window.location.hash
  if (hash) {
    const elementId = hash.substring(1) // Remove the #
    // Small delay to ensure the page has rendered
    setTimeout(() => {
      scrollToElement(elementId)
    }, 100)
  }
}

/**
 * Navigate to homepage section with smooth scrolling
 * @param sectionId - The section ID to scroll to
 */
export function navigateToHomeSection(sectionId: string): void {
  // If we're not on the homepage, navigate there first
  if (window.location.pathname !== '/') {
    window.location.href = `/#${sectionId}`
    return
  }

  // If we're already on the homepage, just scroll
  scrollToElement(sectionId)
}
</file>

<file path="src/CLAUDE.md">
# CRITICAL RULES (NON-NEGOTIABLE)
- **NEVER** use regex (no /pattern/, no new RegExp) - use validator.js or zod
- **NEVER** use 'any' type - always specify proper types  
- **ALWAYS** use flat ESLint config (eslint.config.js)
- **ALWAYS** fix TypeScript/ESLint errors immediately
- **ALWAYS** commit work every 30 minutes

## Source Code Directory

This directory contains the main application source code for the DCE platform.

### Key Subdirectories
- `components/` - React components organized by feature
- `pages/` - Page components for routing
- `hooks/` - Custom React hooks
- `lib/` - Shared utilities and Supabase client
- `integrations/` - Third-party service integrations
- `store/` - Zustand state management
- `types/` - TypeScript type definitions
- `utils/` - Utility functions

### Code Standards
- Use TypeScript strict mode
- Follow existing patterns in each directory
- Implement proper error boundaries
- Use Zod for all validation (NO REGEX)
- Replace all 'any' with proper types or 'unknown'
</file>

<file path="supabase/functions/create-payment-intent/index.ts">
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts'
import Stripe from 'https://esm.sh/stripe@14.21.0?target=deno'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.39.3'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

interface PaymentIntentRequest {
  amount: number
  currency?: string
  customerId?: string
  invoiceId?: string
  buyerId?: string
  metadata?: Record<string, string>
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  if (req.method !== 'POST') {
    return new Response('Method not allowed', {
      status: 405,
      headers: corsHeaders,
    })
  }

  try {
    const stripe = new Stripe(Deno.env.get('STRIPE_SECRET_KEY') ?? '', {
      apiVersion: '2023-10-16',
    })

    const supabase = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    )

    // Get the authorization header to verify the user
    const authHeader = req.headers.get('Authorization')
    if (!authHeader) {
      return new Response('Missing authorization header', {
        status: 401,
        headers: corsHeaders,
      })
    }

    // Parse request body
    const {
      amount,
      currency = 'usd',
      customerId,
      invoiceId,
      buyerId,
      metadata = {},
    }: PaymentIntentRequest = await req.json()

    // Validate required parameters
    if (!amount || amount <= 0) {
      return new Response('Invalid amount', {
        status: 400,
        headers: corsHeaders,
      })
    }

    // Convert amount to cents for Stripe
    const amountInCents = Math.round(amount * 100)

    // Verify user authorization with Supabase
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser(authHeader.replace('Bearer ', ''))

    if (authError || !user) {
      return new Response('Unauthorized', {
        status: 401,
        headers: corsHeaders,
      })
    }

    // Create customer if needed
    let stripeCustomerId = customerId
    if (!stripeCustomerId && user.email) {
      const customer = await stripe.customers.create({
        email: user.email,
        metadata: {
          user_id: user.id,
          buyer_id: buyerId || '',
        },
      })
      stripeCustomerId = customer.id

      // Update buyer record with Stripe customer ID
      if (buyerId) {
        await supabase
          .from('buyers')
          .update({
            settings: { stripe_customer_id: customer.id },
          })
          .eq('id', buyerId)
      }
    }

    // Create payment intent
    const paymentIntent = await stripe.paymentIntents.create({
      amount: amountInCents,
      currency,
      customer: stripeCustomerId,
      automatic_payment_methods: {
        enabled: true,
      },
      metadata: {
        user_id: user.id,
        buyer_id: buyerId || '',
        invoice_id: invoiceId || '',
        platform: 'dependablecalls',
        ...metadata,
      },
    })

    // Update invoice with payment intent ID if provided
    if (invoiceId) {
      const { error: updateError } = await supabase
        .from('invoices')
        .update({
          stripe_payment_intent_id: paymentIntent.id,
          status: 'open',
        })
        .eq('id', invoiceId)
        .eq('buyer_id', buyerId)

      if (updateError) {
        console.error('Failed to update invoice:', updateError)
        // Don't fail the payment intent creation for this
      }
    }

    console.log(`Created payment intent ${paymentIntent.id} for user ${user.id}`)

    return new Response(
      JSON.stringify({
        id: paymentIntent.id,
        client_secret: paymentIntent.client_secret,
        amount: paymentIntent.amount,
        currency: paymentIntent.currency,
        status: paymentIntent.status,
      }),
      {
        headers: {
          ...corsHeaders,
          'Content-Type': 'application/json',
        },
        status: 200,
      }
    )
  } catch (error) {
    console.error('Payment intent creation error:', error)

    // Handle Stripe-specific errors
    if (error instanceof Stripe.errors.StripeError) {
      return new Response(
        JSON.stringify({
          error: 'Payment processing error',
          code: error.code,
          message: error.message,
        }),
        {
          headers: {
            ...corsHeaders,
            'Content-Type': 'application/json',
          },
          status: 400,
        }
      )
    }

    return new Response(
      JSON.stringify({
        error: 'Internal server error',
        message: error.message,
      }),
      {
        headers: {
          ...corsHeaders,
          'Content-Type': 'application/json',
        },
        status: 500,
      }
    )
  }
})
</file>

<file path="supabase/functions/process-payouts/index.ts">
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts'
import Stripe from 'https://esm.sh/stripe@14.21.0?target=deno'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.39.3'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

const MINIMUM_PAYOUT_AMOUNT = 25.0 // $25 minimum payout

interface PayoutRequest {
  supplierId?: string
  forceProcess?: boolean
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  if (req.method !== 'POST') {
    return new Response('Method not allowed', {
      status: 405,
      headers: corsHeaders,
    })
  }

  try {
    const stripe = new Stripe(Deno.env.get('STRIPE_SECRET_KEY') ?? '', {
      apiVersion: '2023-10-16',
    })

    const supabase = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    )

    // Parse request body
    const { supplierId, forceProcess = false }: PayoutRequest = await req.json()

    const results: Array<{
      supplier_id: string
      success: boolean
      amount?: number
      transfer_id?: string
      error?: string
    }> = []

    // Get suppliers eligible for payout
    let suppliersQuery = supabase
      .from('suppliers')
      .select(
        `
        id,
        user_id,
        company_name,
        settings,
        credit_balance
      `
      )
      .eq('status', 'active')
      .gte('credit_balance', forceProcess ? 0.01 : MINIMUM_PAYOUT_AMOUNT)

    if (supplierId) {
      suppliersQuery = suppliersQuery.eq('id', supplierId)
    }

    const { data: suppliers, error: suppliersError } = await suppliersQuery

    if (suppliersError) {
      throw new Error(`Failed to fetch suppliers: ${suppliersError.message}`)
    }

    if (!suppliers || suppliers.length === 0) {
      return new Response(
        JSON.stringify({
          message: 'No suppliers eligible for payout',
          results: [],
        }),
        {
          headers: {
            ...corsHeaders,
            'Content-Type': 'application/json',
          },
          status: 200,
        }
      )
    }

    // Process each supplier
    for (const supplier of suppliers) {
      try {
        const stripeAccountId = supplier.settings?.stripe_account_id

        if (!stripeAccountId) {
          results.push({
            supplier_id: supplier.id,
            success: false,
            error: 'No Stripe connected account',
          })
          continue
        }

        // Verify account can receive payouts
        const account = await stripe.accounts.retrieve(stripeAccountId)
        if (!account.payouts_enabled) {
          results.push({
            supplier_id: supplier.id,
            success: false,
            error: 'Payouts not enabled for connected account',
          })
          continue
        }

        const payoutAmount = supplier.credit_balance
        if (payoutAmount < MINIMUM_PAYOUT_AMOUNT && !forceProcess) {
          results.push({
            supplier_id: supplier.id,
            success: false,
            error: `Amount below minimum payout ($${MINIMUM_PAYOUT_AMOUNT})`,
          })
          continue
        }

        // Create transfer to connected account
        const transfer = await stripe.transfers.create({
          amount: Math.round(payoutAmount * 100), // Convert to cents
          currency: 'usd',
          destination: stripeAccountId,
          metadata: {
            supplier_id: supplier.id,
            company_name: supplier.company_name || '',
            payout_period: getCurrentPayoutPeriod(),
            platform: 'dependablecalls',
          },
        })

        // Record payout in database
        const { error: payoutError } = await supabase.from('payouts').insert({
          supplier_id: supplier.id,
          amount: payoutAmount,
          fee_amount: 0, // Stripe handles fees separately
          net_amount: payoutAmount,
          status: 'processing',
          period_start: getPayoutPeriodStart(),
          period_end: getPayoutPeriodEnd(),
          payment_method: 'stripe',
          transaction_id: transfer.id,
          payment_details: {
            stripe_transfer_id: transfer.id,
            stripe_account_id: stripeAccountId,
            currency: transfer.currency,
            created: transfer.created,
          },
        })

        if (payoutError) {
          console.error(`Failed to record payout for supplier ${supplier.id}:`, payoutError)
          // Continue processing other suppliers
        }

        // Update supplier credit balance (reset to 0)
        const { error: balanceError } = await supabase
          .from('suppliers')
          .update({ credit_balance: 0 })
          .eq('id', supplier.id)

        if (balanceError) {
          console.error(`Failed to update balance for supplier ${supplier.id}:`, balanceError)
        }

        results.push({
          supplier_id: supplier.id,
          success: true,
          amount: payoutAmount,
          transfer_id: transfer.id,
        })

        console.log(
          `Created payout transfer ${transfer.id} for supplier ${supplier.id}: $${payoutAmount}`
        )
      } catch (error) {
        console.error(`Error processing payout for supplier ${supplier.id}:`, error)

        let errorMessage = 'Unknown error'
        if (error instanceof Stripe.errors.StripeError) {
          errorMessage = error.message
        } else if (error instanceof Error) {
          errorMessage = error.message
        }

        results.push({
          supplier_id: supplier.id,
          success: false,
          error: errorMessage,
        })
      }
    }

    const successCount = results.filter((r) => r.success).length
    const totalAmount = results
      .filter((r) => r.success && r.amount)
      .reduce((sum, r) => sum + (r.amount || 0), 0)

    return new Response(
      JSON.stringify({
        message: `Processed ${successCount} payouts totaling $${totalAmount.toFixed(2)}`,
        total_suppliers: suppliers.length,
        successful_payouts: successCount,
        total_amount: totalAmount,
        results,
      }),
      {
        headers: {
          ...corsHeaders,
          'Content-Type': 'application/json',
        },
        status: 200,
      }
    )
  } catch (error) {
    console.error('Payout processing error:', error)

    return new Response(
      JSON.stringify({
        error: 'Internal server error',
        message: error.message,
      }),
      {
        headers: {
          ...corsHeaders,
          'Content-Type': 'application/json',
        },
        status: 500,
      }
    )
  }
})

// Helper functions
function getCurrentPayoutPeriod(): string {
  const now = new Date()
  const year = now.getFullYear()
  const month = String(now.getMonth() + 1).padStart(2, '0')
  const week = Math.ceil(now.getDate() / 7)
  return `${year}-${month}-W${week}`
}

function getPayoutPeriodStart(): string {
  const now = new Date()
  const lastWeek = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)
  return lastWeek.toISOString().split('T')[0]
}

function getPayoutPeriodEnd(): string {
  const now = new Date()
  return now.toISOString().split('T')[0]
}
</file>

<file path="supabase/functions/setup-connected-account/index.ts">
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts'
import Stripe from 'https://esm.sh/stripe@14.21.0?target=deno'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.39.3'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

interface ConnectedAccountRequest {
  supplierId: string
  companyName?: string
  email?: string
  refreshUrl: string
  returnUrl: string
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  if (req.method !== 'POST') {
    return new Response('Method not allowed', {
      status: 405,
      headers: corsHeaders,
    })
  }

  try {
    const stripe = new Stripe(Deno.env.get('STRIPE_SECRET_KEY') ?? '', {
      apiVersion: '2023-10-16',
    })

    const supabase = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    )

    // Get authorization header
    const authHeader = req.headers.get('Authorization')
    if (!authHeader) {
      return new Response('Missing authorization header', {
        status: 401,
        headers: corsHeaders,
      })
    }

    // Verify user authorization
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser(authHeader.replace('Bearer ', ''))

    if (authError || !user) {
      return new Response('Unauthorized', {
        status: 401,
        headers: corsHeaders,
      })
    }

    // Parse request body
    const { supplierId, companyName, email, refreshUrl, returnUrl }: ConnectedAccountRequest =
      await req.json()

    // Validate required parameters
    if (!supplierId || !refreshUrl || !returnUrl) {
      return new Response('Missing required parameters', {
        status: 400,
        headers: corsHeaders,
      })
    }

    // Verify supplier ownership
    const { data: supplier, error: supplierError } = await supabase
      .from('suppliers')
      .select('*')
      .eq('id', supplierId)
      .eq('user_id', user.id)
      .single()

    if (supplierError || !supplier) {
      return new Response('Supplier not found or access denied', {
        status: 404,
        headers: corsHeaders,
      })
    }

    // Check if supplier already has a connected account
    const existingStripeAccountId = supplier.settings?.stripe_account_id
    let account: Stripe.Account

    if (existingStripeAccountId) {
      // Retrieve existing account
      try {
        account = await stripe.accounts.retrieve(existingStripeAccountId)
      } catch (error) {
        // If account doesn't exist, create a new one
        if (error.code === 'resource_missing') {
          account = await createNewAccount()
        } else {
          throw error
        }
      }
    } else {
      // Create new account
      account = await createNewAccount()
    }

    async function createNewAccount(): Promise<Stripe.Account> {
      const account = await stripe.accounts.create({
        type: 'express',
        country: 'US',
        email: email || user.email,
        capabilities: {
          card_payments: { requested: true },
          transfers: { requested: true },
        },
        metadata: {
          supplier_id: supplierId,
          user_id: user.id,
          company_name: companyName || supplier.company_name || '',
          platform: 'dependablecalls',
        },
      })

      // Update supplier record with Stripe account ID
      const { error: updateError } = await supabase
        .from('suppliers')
        .update({
          settings: {
            ...supplier.settings,
            stripe_account_id: account.id,
            stripe_onboarding_started: new Date().toISOString(),
          },
        })
        .eq('id', supplierId)

      if (updateError) {
        throw new Error(`Failed to update supplier: ${updateError.message}`)
      }

      return account
    }

    // Create account link for onboarding
    const accountLink = await stripe.accountLinks.create({
      account: account.id,
      refresh_url: refreshUrl,
      return_url: returnUrl,
      type: 'account_onboarding',
    })

    console.log(`Created account link for supplier ${supplierId}, account ${account.id}`)

    return new Response(
      JSON.stringify({
        account_id: account.id,
        onboarding_url: accountLink.url,
        expires_at: accountLink.expires_at,
        charges_enabled: account.charges_enabled,
        payouts_enabled: account.payouts_enabled,
        details_submitted: account.details_submitted,
        requirements: account.requirements,
      }),
      {
        headers: {
          ...corsHeaders,
          'Content-Type': 'application/json',
        },
        status: 200,
      }
    )
  } catch (error) {
    console.error('Connected account setup error:', error)

    // Handle Stripe-specific errors
    if (error instanceof Stripe.errors.StripeError) {
      return new Response(
        JSON.stringify({
          error: 'Account setup error',
          code: error.code,
          message: error.message,
        }),
        {
          headers: {
            ...corsHeaders,
            'Content-Type': 'application/json',
          },
          status: 400,
        }
      )
    }

    return new Response(
      JSON.stringify({
        error: 'Internal server error',
        message: error.message,
      }),
      {
        headers: {
          ...corsHeaders,
          'Content-Type': 'application/json',
        },
        status: 500,
      }
    )
  }
})
</file>

<file path="supabase/functions/stripe-webhook/index.ts">
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts'
import Stripe from 'https://esm.sh/stripe@14.21.0?target=deno'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.39.3'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers':
    'authorization, x-client-info, apikey, content-type, stripe-signature',
}

interface Database {
  public: {
    Tables: {
      invoices: {
        Row: {
          id: string
          buyer_id: string
          status: string
          paid_at: string | null
          stripe_payment_intent_id: string | null
        }
        Insert: {
          status?: string
          paid_at?: string | null
          stripe_payment_intent_id?: string | null
        }
        Update: {
          status?: string
          paid_at?: string | null
          stripe_payment_intent_id?: string | null
        }
      }
      buyers: {
        Row: {
          id: string
          current_balance: number
        }
        Update: {
          current_balance?: number
        }
      }
      buyer_campaigns: {
        Row: {
          id: string
          buyer_id: string
          status: string
        }
        Update: {
          status?: string
        }
      }
      suppliers: {
        Row: {
          id: string
          user_id: string
          status: string
          settings: unknown
        }
        Update: {
          status?: string
          settings?: unknown
        }
      }
      payouts: {
        Row: {
          id: string
          supplier_id: string
          status: string
          transaction_id: string
        }
        Insert: {
          supplier_id: string
          amount: number
          fee_amount?: number
          net_amount: number
          status?: string
          period_start: string
          period_end: string
          payment_method?: string
          transaction_id?: string
          payment_details?: unknown
        }
        Update: {
          status?: string
          paid_at?: string
          processed_at?: string
          notes?: string
        }
      }
      disputes: {
        Insert: {
          call_id?: string
          raised_by?: string
          dispute_type: string
          reason: string
          description?: string
          amount_disputed?: number
          status?: string
          priority?: string
          evidence?: unknown
        }
      }
    }
  }
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    const stripe = new Stripe(Deno.env.get('STRIPE_SECRET_KEY') ?? '', {
      apiVersion: '2023-10-16',
    })

    const supabase = createClient<Database>(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    )

    const signature = req.headers.get('stripe-signature')
    if (!signature) {
      return new Response('Missing stripe-signature header', {
        status: 400,
        headers: corsHeaders,
      })
    }

    const body = await req.text()
    const webhookSecret = Deno.env.get('STRIPE_WEBHOOK_SECRET')

    if (!webhookSecret) {
      console.error('STRIPE_WEBHOOK_SECRET not configured')
      return new Response('Webhook secret not configured', {
        status: 500,
        headers: corsHeaders,
      })
    }

    let event: Stripe.Event
    try {
      event = stripe.webhooks.constructEvent(body, signature, webhookSecret)
    } catch (err) {
      console.error('Webhook signature verification failed:', err)
      return new Response(`Webhook Error: ${err.message}`, {
        status: 400,
        headers: corsHeaders,
      })
    }

    console.log(`Processing webhook event: ${event.type}`)

    switch (event.type) {
      case 'payment_intent.succeeded': {
        const paymentIntent = event.data.object as Stripe.PaymentIntent
        console.log('Payment succeeded:', paymentIntent.id)

        // Update invoice status
        const { error: invoiceError } = await supabase
          .from('invoices')
          .update({
            status: 'paid',
            paid_at: new Date().toISOString(),
            stripe_payment_intent_id: paymentIntent.id,
          })
          .eq('stripe_payment_intent_id', paymentIntent.id)

        if (invoiceError) {
          console.error('Failed to update invoice:', invoiceError)
          break
        }

        // Update buyer balance if buyer_id is in metadata
        const buyerId = paymentIntent.metadata.buyer_id
        if (buyerId) {
          const { error: balanceError } = await supabase.rpc('update_buyer_balance', {
            buyer_uuid: buyerId,
            amount_to_add: paymentIntent.amount / 100,
          })

          if (balanceError) {
            console.error('Failed to update buyer balance:', balanceError)
          }
        }
        break
      }

      case 'payment_intent.payment_failed': {
        const paymentIntent = event.data.object as Stripe.PaymentIntent
        console.error('Payment failed:', paymentIntent.id)

        // Mark invoice as overdue
        const { error } = await supabase
          .from('invoices')
          .update({
            status: 'overdue',
          })
          .eq('stripe_payment_intent_id', paymentIntent.id)

        if (error) {
          console.error('Failed to update invoice status:', error)
          break
        }

        // Check for recurring failures and pause campaigns if needed
        const buyerId = paymentIntent.metadata.buyer_id
        if (buyerId) {
          const { data: recentFailures } = await supabase
            .from('invoices')
            .select('id')
            .eq('buyer_id', buyerId)
            .eq('status', 'overdue')
            .gte('created_at', new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString())

          if (recentFailures && recentFailures.length >= 3) {
            await supabase
              .from('buyer_campaigns')
              .update({ status: 'paused' })
              .eq('buyer_id', buyerId)
              .eq('status', 'active')

            console.log(`Paused campaigns for buyer ${buyerId} due to recurring payment failures`)
          }
        }
        break
      }

      case 'charge.dispute.created': {
        const dispute = event.data.object as Stripe.Dispute
        console.warn('Dispute created:', dispute.id)

        const { error } = await supabase.from('disputes').insert({
          call_id: dispute.metadata.call_id,
          raised_by: dispute.metadata.buyer_id,
          dispute_type: 'billing',
          reason: `Stripe dispute: ${dispute.reason}`,
          description: `Dispute created for charge ${dispute.charge}. Reason: ${dispute.reason}`,
          amount_disputed: dispute.amount / 100,
          status: 'open',
          priority: 'high',
          evidence: [
            {
              type: 'stripe_dispute',
              dispute_id: dispute.id,
              reason: dispute.reason,
              evidence_details: dispute.evidence_details,
            },
          ],
        })

        if (error) {
          console.error('Failed to create dispute record:', error)
        }
        break
      }

      case 'account.updated': {
        const account = event.data.object as Stripe.Account
        console.log('Connected account updated:', account.id)

        // Find supplier with this Stripe account
        const { data: supplier, error: findError } = await supabase
          .from('suppliers')
          .select('id, user_id')
          .contains('settings', { stripe_account_id: account.id })
          .single()

        if (findError || !supplier) {
          console.error('Could not find supplier for account:', account.id)
          break
        }

        // Update supplier status based on account capabilities
        const canReceivePayouts = account.charges_enabled && account.payouts_enabled
        const requiresAction =
          account.requirements?.currently_due && account.requirements.currently_due.length > 0

        const { error: updateError } = await supabase
          .from('suppliers')
          .update({
            status: canReceivePayouts && !requiresAction ? 'active' : 'pending',
            settings: {
              stripe_account_status: {
                charges_enabled: account.charges_enabled,
                payouts_enabled: account.payouts_enabled,
                details_submitted: account.details_submitted,
                requirements_due: account.requirements?.currently_due || [],
              },
            },
          })
          .eq('id', supplier.id)

        if (updateError) {
          console.error('Failed to update supplier status:', updateError)
        }
        break
      }

      case 'payout.created': {
        const payout = event.data.object as Stripe.Payout
        console.log('Payout created:', payout.id)

        const { error } = await supabase.from('payouts').insert({
          supplier_id: payout.metadata.supplier_id,
          amount: payout.amount / 100,
          fee_amount: 0,
          net_amount: payout.amount / 100,
          status: 'processing',
          period_start: payout.metadata.period_start,
          period_end: payout.metadata.period_end,
          payment_method: 'stripe',
          transaction_id: payout.id,
          payment_details: {
            stripe_payout_id: payout.id,
            currency: payout.currency,
            method: payout.method,
            bank_account: payout.destination,
          },
        })

        if (error) {
          console.error('Failed to create payout record:', error)
        }
        break
      }

      case 'payout.paid': {
        const payout = event.data.object as Stripe.Payout
        console.log('Payout completed:', payout.id)

        const { error } = await supabase
          .from('payouts')
          .update({
            status: 'completed',
            paid_at: new Date().toISOString(),
            processed_at: new Date().toISOString(),
          })
          .eq('transaction_id', payout.id)

        if (error) {
          console.error('Failed to update payout status:', error)
        }
        break
      }

      case 'payout.failed': {
        const payout = event.data.object as Stripe.Payout
        console.error('Payout failed:', payout.id)

        const { error } = await supabase
          .from('payouts')
          .update({
            status: 'failed',
            notes: `Payout failed: ${payout.failure_message || 'Unknown error'}`,
          })
          .eq('transaction_id', payout.id)

        if (error) {
          console.error('Failed to update payout status:', error)
        }
        break
      }

      case 'transfer.reversed': {
        const transfer = event.data.object as Stripe.Transfer
        console.warn('Transfer reversed:', transfer.id)

        const { error } = await supabase
          .from('payouts')
          .update({
            status: 'cancelled',
            notes: `Transfer reversed: ${transfer.reversal_details?.reason || 'Unknown reason'}`,
          })
          .eq('transaction_id', transfer.id)

        if (error) {
          console.error('Failed to update payout for reversed transfer:', error)
        }
        break
      }

      default:
        console.log(`Unhandled webhook event type: ${event.type}`)
    }

    return new Response(JSON.stringify({ received: true }), {
      headers: {
        ...corsHeaders,
        'Content-Type': 'application/json',
      },
      status: 200,
    })
  } catch (error) {
    console.error('Webhook handler error:', error)
    return new Response(
      JSON.stringify({
        error: error.message,
        received: false,
      }),
      {
        headers: {
          ...corsHeaders,
          'Content-Type': 'application/json',
        },
        status: 500,
      }
    )
  }
})
</file>

<file path="supabase/migrations/001_initial_schema.sql">
-- DCE Platform Initial Schema Migration
-- Creates core tables for the pay-per-call network platform

-- Enable required extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- Create enum types for better data integrity
CREATE TYPE user_status AS ENUM ('pending', 'active', 'suspended', 'banned');
CREATE TYPE campaign_status AS ENUM ('draft', 'active', 'paused', 'completed', 'cancelled');
CREATE TYPE call_status AS ENUM ('initiated', 'ringing', 'connected', 'completed', 'failed', 'rejected');
CREATE TYPE payout_status AS ENUM ('pending', 'processing', 'completed', 'failed', 'cancelled');
CREATE TYPE invoice_status AS ENUM ('draft', 'open', 'paid', 'overdue', 'cancelled');
CREATE TYPE dispute_status AS ENUM ('open', 'investigating', 'resolved', 'closed');

-- Core users table (extends Supabase auth.users)
CREATE TABLE users (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email VARCHAR(255) UNIQUE NOT NULL,
    phone VARCHAR(20),
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    avatar_url TEXT,
    metadata JSONB DEFAULT '{}',
    status user_status DEFAULT 'pending',
    is_active BOOLEAN DEFAULT true,
    last_login TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Create admins table
CREATE TABLE admins (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    role VARCHAR(50) DEFAULT 'admin',
    permissions JSONB DEFAULT '{}',
    is_active BOOLEAN DEFAULT true,
    appointed_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(user_id)
);

-- Suppliers table - traffic providers
CREATE TABLE suppliers (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    company_name VARCHAR(255) NOT NULL,
    business_type VARCHAR(100),
    tax_id VARCHAR(50),
    website_url TEXT,
    credit_balance DECIMAL(12,2) DEFAULT 0.00,
    minimum_payout DECIMAL(10,2) DEFAULT 50.00,
    payout_frequency VARCHAR(20) DEFAULT 'weekly', -- weekly, biweekly, monthly
    verification_data JSONB DEFAULT '{}',
    status user_status DEFAULT 'pending',
    settings JSONB DEFAULT '{}',
    approved_at TIMESTAMP WITH TIME ZONE,
    approved_by UUID REFERENCES admins(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(user_id)
);

-- Buyers table - advertisers
CREATE TABLE buyers (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    company_name VARCHAR(255) NOT NULL,
    business_type VARCHAR(100),
    tax_id VARCHAR(50),
    website_url TEXT,
    credit_limit DECIMAL(12,2) DEFAULT 0.00,
    current_balance DECIMAL(12,2) DEFAULT 0.00,
    auto_recharge_enabled BOOLEAN DEFAULT false,
    auto_recharge_threshold DECIMAL(10,2) DEFAULT 100.00,
    auto_recharge_amount DECIMAL(10,2) DEFAULT 500.00,
    verification_data JSONB DEFAULT '{}',
    status user_status DEFAULT 'pending',
    settings JSONB DEFAULT '{}',
    approved_at TIMESTAMP WITH TIME ZONE,
    approved_by UUID REFERENCES admins(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(user_id)
);

-- Campaigns table - supplier traffic campaigns
CREATE TABLE campaigns (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    supplier_id UUID REFERENCES suppliers(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    category VARCHAR(100),
    vertical VARCHAR(100),
    targeting JSONB DEFAULT '{}', -- geographic, demographic, time-based targeting
    routing_rules JSONB DEFAULT '{}', -- call routing configuration
    bid_floor DECIMAL(8,2) NOT NULL DEFAULT 0.00,
    max_concurrent_calls INTEGER DEFAULT 10,
    daily_cap INTEGER,
    monthly_cap INTEGER,
    tracking_numbers JSONB DEFAULT '[]',
    schedule JSONB DEFAULT '{}', -- operating hours and days
    status campaign_status DEFAULT 'draft',
    quality_threshold INTEGER DEFAULT 70, -- minimum quality score (1-100)
    fraud_detection_enabled BOOLEAN DEFAULT true,
    recording_enabled BOOLEAN DEFAULT true,
    call_timeout_seconds INTEGER DEFAULT 30,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Buyer campaigns table - buyer's purchasing criteria
CREATE TABLE buyer_campaigns (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    buyer_id UUID REFERENCES buyers(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    targeting_criteria JSONB DEFAULT '{}', -- what they want to buy
    max_bid DECIMAL(8,2) NOT NULL,
    daily_budget DECIMAL(10,2),
    monthly_budget DECIMAL(10,2),
    daily_cap INTEGER,
    monthly_cap INTEGER,
    schedule JSONB DEFAULT '{}', -- when they want calls
    quality_requirements JSONB DEFAULT '{}', -- minimum quality standards
    exclude_suppliers UUID[] DEFAULT '{}', -- blacklisted suppliers
    preferred_suppliers UUID[] DEFAULT '{}', -- preferred suppliers
    status campaign_status DEFAULT 'draft',
    auto_approval_enabled BOOLEAN DEFAULT false,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Tracking numbers table
CREATE TABLE tracking_numbers (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    campaign_id UUID REFERENCES campaigns(id) ON DELETE CASCADE,
    number VARCHAR(20) NOT NULL UNIQUE,
    display_number VARCHAR(20), -- formatted display version
    country_code VARCHAR(5) DEFAULT 'US',
    area_code VARCHAR(5),
    is_active BOOLEAN DEFAULT true,
    assigned_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Calls table - core transaction records
CREATE TABLE calls (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    campaign_id UUID REFERENCES campaigns(id) ON DELETE SET NULL,
    buyer_campaign_id UUID REFERENCES buyer_campaigns(id) ON DELETE SET NULL,
    tracking_number VARCHAR(20) NOT NULL,
    caller_number VARCHAR(20) NOT NULL,
    destination_number VARCHAR(20),
    caller_location JSONB, -- geo data from caller
    started_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    answered_at TIMESTAMP WITH TIME ZONE,
    ended_at TIMESTAMP WITH TIME ZONE,
    duration_seconds INTEGER DEFAULT 0,
    billable_seconds INTEGER DEFAULT 0,
    payout_amount DECIMAL(8,2) DEFAULT 0.00,
    charge_amount DECIMAL(8,2) DEFAULT 0.00,
    margin_amount DECIMAL(8,2) DEFAULT 0.00,
    status call_status DEFAULT 'initiated',
    disposition VARCHAR(50), -- outcome classification
    quality_score INTEGER, -- 1-100 quality rating
    fraud_score INTEGER, -- 1-100 fraud risk rating
    metadata JSONB DEFAULT '{}', -- additional call data
    recording_url TEXT,
    recording_duration INTEGER,
    call_flow JSONB DEFAULT '[]', -- step-by-step call progression
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Call logs table - detailed call events
CREATE TABLE call_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    call_id UUID REFERENCES calls(id) ON DELETE CASCADE,
    event_type VARCHAR(50) NOT NULL, -- dial, ring, answer, hangup, etc.
    event_data JSONB DEFAULT '{}',
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Financial tables
CREATE TABLE payouts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    supplier_id UUID REFERENCES suppliers(id) ON DELETE CASCADE,
    amount DECIMAL(12,2) NOT NULL,
    fee_amount DECIMAL(10,2) DEFAULT 0.00,
    net_amount DECIMAL(12,2) NOT NULL,
    status payout_status DEFAULT 'pending',
    period_start DATE NOT NULL,
    period_end DATE NOT NULL,
    payment_method VARCHAR(50), -- bank_transfer, paypal, check
    payment_details JSONB DEFAULT '{}',
    transaction_id VARCHAR(255),
    reference_number VARCHAR(100),
    notes TEXT,
    processed_at TIMESTAMP WITH TIME ZONE,
    paid_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    created_by UUID REFERENCES users(id)
);

CREATE TABLE invoices (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    buyer_id UUID REFERENCES buyers(id) ON DELETE CASCADE,
    invoice_number VARCHAR(50) UNIQUE NOT NULL,
    amount DECIMAL(12,2) NOT NULL,
    tax_amount DECIMAL(10,2) DEFAULT 0.00,
    total_amount DECIMAL(12,2) NOT NULL,
    status invoice_status DEFAULT 'draft',
    period_start DATE NOT NULL,
    period_end DATE NOT NULL,
    due_date DATE NOT NULL,
    payment_terms INTEGER DEFAULT 30, -- days
    stripe_invoice_id VARCHAR(255),
    stripe_payment_intent_id VARCHAR(255),
    payment_method VARCHAR(50),
    paid_at TIMESTAMP WITH TIME ZONE,
    notes TEXT,
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Invoice line items
CREATE TABLE invoice_line_items (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    invoice_id UUID REFERENCES invoices(id) ON DELETE CASCADE,
    description TEXT NOT NULL,
    quantity INTEGER DEFAULT 1,
    unit_price DECIMAL(10,4) NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    call_id UUID REFERENCES calls(id), -- reference to source call if applicable
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Quality and compliance tables
CREATE TABLE call_quality_scores (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    call_id UUID REFERENCES calls(id) ON DELETE CASCADE,
    duration_score INTEGER, -- 1-100 based on call duration
    intent_score INTEGER, -- 1-100 based on intent detection
    content_score INTEGER, -- 1-100 based on conversation analysis
    technical_score INTEGER, -- 1-100 based on audio quality
    overall_score INTEGER, -- weighted average
    scoring_model VARCHAR(50) DEFAULT 'v1.0',
    flags JSONB DEFAULT '[]', -- quality issues detected
    notes TEXT,
    reviewed_by UUID REFERENCES users(id),
    reviewed_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE disputes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    call_id UUID REFERENCES calls(id) ON DELETE CASCADE,
    raised_by UUID REFERENCES users(id) ON DELETE SET NULL,
    dispute_type VARCHAR(50) NOT NULL, -- quality, fraud, billing, etc.
    reason VARCHAR(255) NOT NULL,
    description TEXT,
    evidence JSONB DEFAULT '[]', -- supporting documents/data
    amount_disputed DECIMAL(8,2),
    status dispute_status DEFAULT 'open',
    priority VARCHAR(20) DEFAULT 'normal', -- low, normal, high, urgent
    assigned_to UUID REFERENCES users(id),
    resolution TEXT,
    resolution_notes TEXT,
    resolved_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    resolved_at TIMESTAMP WITH TIME ZONE
);

-- Analytics and reporting tables
CREATE TABLE campaign_stats (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    campaign_id UUID REFERENCES campaigns(id) ON DELETE CASCADE,
    date DATE NOT NULL,
    hour INTEGER, -- 0-23, null for daily stats
    calls_count INTEGER DEFAULT 0,
    connected_calls INTEGER DEFAULT 0,
    completed_calls INTEGER DEFAULT 0,
    total_duration INTEGER DEFAULT 0, -- seconds
    avg_duration DECIMAL(8,2) DEFAULT 0.00,
    total_payout DECIMAL(10,2) DEFAULT 0.00,
    avg_payout DECIMAL(8,2) DEFAULT 0.00,
    quality_score_avg DECIMAL(5,2),
    conversion_rate DECIMAL(5,4), -- percentage as decimal
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(campaign_id, date, hour)
);

CREATE TABLE buyer_campaign_stats (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    buyer_campaign_id UUID REFERENCES buyer_campaigns(id) ON DELETE CASCADE,
    date DATE NOT NULL,
    hour INTEGER, -- 0-23, null for daily stats
    calls_received INTEGER DEFAULT 0,
    calls_accepted INTEGER DEFAULT 0,
    calls_completed INTEGER DEFAULT 0,
    total_cost DECIMAL(10,2) DEFAULT 0.00,
    avg_cost DECIMAL(8,2) DEFAULT 0.00,
    total_duration INTEGER DEFAULT 0, -- seconds
    avg_duration DECIMAL(8,2) DEFAULT 0.00,
    conversions INTEGER DEFAULT 0,
    conversion_rate DECIMAL(5,4), -- percentage as decimal
    quality_score_avg DECIMAL(5,2),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(buyer_campaign_id, date, hour)
);

-- System audit log
CREATE TABLE audit_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    table_name VARCHAR(100) NOT NULL,
    operation VARCHAR(20) NOT NULL, -- INSERT, UPDATE, DELETE
    user_id UUID REFERENCES users(id) ON DELETE SET NULL,
    record_id UUID,
    old_data JSONB,
    new_data JSONB,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Create updated_at trigger function
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Apply updated_at triggers to relevant tables
CREATE TRIGGER update_users_updated_at 
    BEFORE UPDATE ON users 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_suppliers_updated_at 
    BEFORE UPDATE ON suppliers 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_buyers_updated_at 
    BEFORE UPDATE ON buyers 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_campaigns_updated_at 
    BEFORE UPDATE ON campaigns 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_buyer_campaigns_updated_at 
    BEFORE UPDATE ON buyer_campaigns 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_calls_updated_at 
    BEFORE UPDATE ON calls 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_invoices_updated_at 
    BEFORE UPDATE ON invoices 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_disputes_updated_at 
    BEFORE UPDATE ON disputes 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_campaign_stats_updated_at 
    BEFORE UPDATE ON campaign_stats 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_buyer_campaign_stats_updated_at 
    BEFORE UPDATE ON buyer_campaign_stats 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Create invoice number generation function
CREATE OR REPLACE FUNCTION generate_invoice_number()
RETURNS TRIGGER AS $$
DECLARE
    year_part TEXT;
    sequence_part TEXT;
BEGIN
    IF NEW.invoice_number IS NULL THEN
        year_part := EXTRACT(YEAR FROM NOW())::TEXT;
        
        SELECT LPAD(
            (COALESCE(MAX(
                CAST(
                    REGEXP_REPLACE(
                        invoice_number, 
                        '^INV-' || year_part || '-(\d+)$', 
                        '\1'
                    ) AS INTEGER
                )
            ), 0) + 1)::TEXT, 
            6, 
            '0'
        ) INTO sequence_part
        FROM invoices 
        WHERE invoice_number LIKE 'INV-' || year_part || '-%';
        
        NEW.invoice_number := 'INV-' || year_part || '-' || sequence_part;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Apply invoice number generation trigger
CREATE TRIGGER generate_invoice_number_trigger
    BEFORE INSERT ON invoices
    FOR EACH ROW EXECUTE FUNCTION generate_invoice_number();

-- Comments for documentation
COMMENT ON TABLE users IS 'Core user accounts that extend Supabase auth.users';
COMMENT ON TABLE suppliers IS 'Traffic providers who generate calls';
COMMENT ON TABLE buyers IS 'Advertisers who purchase call leads';
COMMENT ON TABLE campaigns IS 'Supplier traffic campaigns with targeting and routing';
COMMENT ON TABLE buyer_campaigns IS 'Buyer purchasing criteria and budgets';
COMMENT ON TABLE calls IS 'Core call transaction records with billing data';
COMMENT ON TABLE payouts IS 'Supplier payment records';
COMMENT ON TABLE invoices IS 'Buyer billing records';
COMMENT ON TABLE call_quality_scores IS 'Quality assessment for each call';
COMMENT ON TABLE disputes IS 'Quality and billing disputes';
COMMENT ON TABLE campaign_stats IS 'Hourly and daily campaign performance metrics';
COMMENT ON TABLE buyer_campaign_stats IS 'Hourly and daily buyer campaign performance';
COMMENT ON TABLE audit_logs IS 'System audit trail for compliance';
</file>

<file path="supabase/migrations/002_security_policies.sql">
-- DCE Platform Row Level Security Policies
-- Implements comprehensive RLS policies for data security and privacy

-- Enable RLS on all tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE admins ENABLE ROW LEVEL SECURITY;
ALTER TABLE suppliers ENABLE ROW LEVEL SECURITY;
ALTER TABLE buyers ENABLE ROW LEVEL SECURITY;
ALTER TABLE campaigns ENABLE ROW LEVEL SECURITY;
ALTER TABLE buyer_campaigns ENABLE ROW LEVEL SECURITY;
ALTER TABLE tracking_numbers ENABLE ROW LEVEL SECURITY;
ALTER TABLE calls ENABLE ROW LEVEL SECURITY;
ALTER TABLE call_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE payouts ENABLE ROW LEVEL SECURITY;
ALTER TABLE invoices ENABLE ROW LEVEL SECURITY;
ALTER TABLE invoice_line_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE call_quality_scores ENABLE ROW LEVEL SECURITY;
ALTER TABLE disputes ENABLE ROW LEVEL SECURITY;
ALTER TABLE campaign_stats ENABLE ROW LEVEL SECURITY;
ALTER TABLE buyer_campaign_stats ENABLE ROW LEVEL SECURITY;
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;

-- Helper function to check if user is admin
CREATE OR REPLACE FUNCTION is_admin(user_uuid UUID DEFAULT auth.uid())
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM admins 
        WHERE user_id = user_uuid AND is_active = true
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Helper function to check if user is supplier
CREATE OR REPLACE FUNCTION is_supplier(user_uuid UUID DEFAULT auth.uid())
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM suppliers 
        WHERE user_id = user_uuid AND status = 'active'
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Helper function to check if user is buyer
CREATE OR REPLACE FUNCTION is_buyer(user_uuid UUID DEFAULT auth.uid())
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM buyers 
        WHERE user_id = user_uuid AND status = 'active'
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Helper function to get supplier ID for current user
CREATE OR REPLACE FUNCTION get_supplier_id(user_uuid UUID DEFAULT auth.uid())
RETURNS UUID AS $$
BEGIN
    RETURN (
        SELECT id FROM suppliers 
        WHERE user_id = user_uuid AND status = 'active'
        LIMIT 1
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Helper function to get buyer ID for current user
CREATE OR REPLACE FUNCTION get_buyer_id(user_uuid UUID DEFAULT auth.uid())
RETURNS UUID AS $$
BEGIN
    RETURN (
        SELECT id FROM buyers 
        WHERE user_id = user_uuid AND status = 'active'
        LIMIT 1
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ================================
-- USERS TABLE POLICIES
-- ================================

-- Users can view their own profile and basic info of others (for collaboration)
CREATE POLICY "users_select_policy" ON users
    FOR SELECT USING (
        auth.uid() = id OR -- Own profile
        is_admin() OR -- Admins can see all
        EXISTS ( -- Users involved in same calls can see basic info
            SELECT 1 FROM calls c
            JOIN campaigns camp ON c.campaign_id = camp.id
            JOIN suppliers s ON camp.supplier_id = s.id
            WHERE s.user_id = users.id OR c.buyer_campaign_id IN (
                SELECT bc.id FROM buyer_campaigns bc
                JOIN buyers b ON bc.buyer_id = b.id
                WHERE b.user_id = auth.uid()
            )
        )
    );

-- Users can only update their own profile
CREATE POLICY "users_update_policy" ON users
    FOR UPDATE USING (auth.uid() = id);

-- ================================
-- ADMIN TABLE POLICIES
-- ================================

-- Only admins can see admin records
CREATE POLICY "admins_select_policy" ON admins
    FOR SELECT USING (is_admin());

-- Only super admins can modify admin records
CREATE POLICY "admins_modify_policy" ON admins
    FOR ALL USING (
        is_admin() AND EXISTS (
            SELECT 1 FROM admins 
            WHERE user_id = auth.uid() 
            AND (permissions->>'super_admin')::boolean = true
        )
    );

-- ================================
-- SUPPLIERS TABLE POLICIES
-- ================================

-- Suppliers can see their own profile, buyers can see suppliers they work with
CREATE POLICY "suppliers_select_policy" ON suppliers
    FOR SELECT USING (
        user_id = auth.uid() OR -- Own profile
        is_admin() OR -- Admin access
        (is_buyer() AND EXISTS ( -- Buyers can see suppliers they've received calls from
            SELECT 1 FROM calls c
            JOIN campaigns camp ON c.campaign_id = camp.id
            WHERE camp.supplier_id = suppliers.id
            AND c.buyer_campaign_id IN (
                SELECT bc.id FROM buyer_campaigns bc
                WHERE bc.buyer_id = get_buyer_id()
            )
        ))
    );

-- Suppliers can update their own profile
CREATE POLICY "suppliers_update_policy" ON suppliers
    FOR UPDATE USING (user_id = auth.uid());

-- Admins can insert/delete suppliers
CREATE POLICY "suppliers_admin_policy" ON suppliers
    FOR ALL USING (is_admin());

-- ================================
-- BUYERS TABLE POLICIES
-- ================================

-- Buyers can see their own profile, suppliers can see buyers they work with
CREATE POLICY "buyers_select_policy" ON buyers
    FOR SELECT USING (
        user_id = auth.uid() OR -- Own profile
        is_admin() OR -- Admin access
        (is_supplier() AND EXISTS ( -- Suppliers can see buyers who've received their calls
            SELECT 1 FROM calls c
            JOIN buyer_campaigns bc ON c.buyer_campaign_id = bc.id
            WHERE bc.buyer_id = buyers.id
            AND c.campaign_id IN (
                SELECT camp.id FROM campaigns camp
                WHERE camp.supplier_id = get_supplier_id()
            )
        ))
    );

-- Buyers can update their own profile
CREATE POLICY "buyers_update_policy" ON buyers
    FOR UPDATE USING (user_id = auth.uid());

-- Admins can insert/delete buyers
CREATE POLICY "buyers_admin_policy" ON buyers
    FOR ALL USING (is_admin());

-- ================================
-- CAMPAIGNS TABLE POLICIES
-- ================================

-- Suppliers see their own campaigns, buyers see campaigns they can bid on or have worked with
CREATE POLICY "campaigns_select_policy" ON campaigns
    FOR SELECT USING (
        (is_supplier() AND supplier_id = get_supplier_id()) OR -- Own campaigns
        is_admin() OR -- Admin access
        (is_buyer() AND ( -- Buyers can see active campaigns or those they've worked with
            (status = 'active' AND EXISTS (
                SELECT 1 FROM buyer_campaigns bc
                WHERE bc.buyer_id = get_buyer_id()
                AND bc.status = 'active'
            )) OR
            EXISTS (
                SELECT 1 FROM calls c
                JOIN buyer_campaigns bc ON c.buyer_campaign_id = bc.id
                WHERE c.campaign_id = campaigns.id
                AND bc.buyer_id = get_buyer_id()
            )
        ))
    );

-- Suppliers can modify their own campaigns
CREATE POLICY "campaigns_modify_policy" ON campaigns
    FOR ALL USING (
        (is_supplier() AND supplier_id = get_supplier_id()) OR
        is_admin()
    );

-- ================================
-- BUYER CAMPAIGNS TABLE POLICIES
-- ================================

-- Buyers see their own campaigns, suppliers see campaigns that match their traffic
CREATE POLICY "buyer_campaigns_select_policy" ON buyer_campaigns
    FOR SELECT USING (
        (is_buyer() AND buyer_id = get_buyer_id()) OR -- Own campaigns
        is_admin() OR -- Admin access
        (is_supplier() AND ( -- Suppliers can see active buyer campaigns they could match
            status = 'active' OR
            EXISTS (
                SELECT 1 FROM calls c
                JOIN campaigns camp ON c.campaign_id = camp.id
                WHERE c.buyer_campaign_id = buyer_campaigns.id
                AND camp.supplier_id = get_supplier_id()
            )
        ))
    );

-- Buyers can modify their own campaigns
CREATE POLICY "buyer_campaigns_modify_policy" ON buyer_campaigns
    FOR ALL USING (
        (is_buyer() AND buyer_id = get_buyer_id()) OR
        is_admin()
    );

-- ================================
-- TRACKING NUMBERS TABLE POLICIES
-- ================================

-- Access tied to campaign ownership
CREATE POLICY "tracking_numbers_policy" ON tracking_numbers
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM campaigns c
            WHERE c.id = tracking_numbers.campaign_id
            AND ((is_supplier() AND c.supplier_id = get_supplier_id()) OR is_admin())
        )
    );

-- ================================
-- CALLS TABLE POLICIES
-- ================================

-- Most complex policy - suppliers see their calls, buyers see calls they received
CREATE POLICY "calls_select_policy" ON calls
    FOR SELECT USING (
        is_admin() OR -- Admin access
        EXISTS (
            SELECT 1 FROM campaigns camp
            WHERE camp.id = calls.campaign_id
            AND camp.supplier_id = get_supplier_id()
        ) OR -- Supplier's calls
        EXISTS (
            SELECT 1 FROM buyer_campaigns bc
            WHERE bc.id = calls.buyer_campaign_id
            AND bc.buyer_id = get_buyer_id()
        ) -- Buyer's calls
    );

-- System can insert calls, admins can modify
CREATE POLICY "calls_insert_policy" ON calls
    FOR INSERT WITH CHECK (true); -- Allow system inserts

CREATE POLICY "calls_update_policy" ON calls
    FOR UPDATE USING (
        is_admin() OR
        EXISTS (
            SELECT 1 FROM campaigns camp
            WHERE camp.id = calls.campaign_id
            AND camp.supplier_id = get_supplier_id()
        ) OR
        EXISTS (
            SELECT 1 FROM buyer_campaigns bc
            WHERE bc.id = calls.buyer_campaign_id
            AND bc.buyer_id = get_buyer_id()
        )
    );

-- ================================
-- CALL LOGS TABLE POLICIES
-- ================================

-- Access based on call ownership
CREATE POLICY "call_logs_policy" ON call_logs
    FOR ALL USING (
        is_admin() OR
        EXISTS (
            SELECT 1 FROM calls c
            JOIN campaigns camp ON c.campaign_id = camp.id
            WHERE c.id = call_logs.call_id
            AND camp.supplier_id = get_supplier_id()
        ) OR
        EXISTS (
            SELECT 1 FROM calls c
            JOIN buyer_campaigns bc ON c.buyer_campaign_id = bc.id
            WHERE c.id = call_logs.call_id
            AND bc.buyer_id = get_buyer_id()
        )
    );

-- ================================
-- FINANCIAL TABLE POLICIES
-- ================================

-- Payouts - suppliers see their own, admins see all
CREATE POLICY "payouts_select_policy" ON payouts
    FOR SELECT USING (
        (is_supplier() AND supplier_id = get_supplier_id()) OR
        is_admin()
    );

CREATE POLICY "payouts_admin_policy" ON payouts
    FOR ALL USING (is_admin());

-- Invoices - buyers see their own, admins see all
CREATE POLICY "invoices_select_policy" ON invoices
    FOR SELECT USING (
        (is_buyer() AND buyer_id = get_buyer_id()) OR
        is_admin()
    );

CREATE POLICY "invoices_admin_policy" ON invoices
    FOR ALL USING (is_admin());

-- Invoice line items - tied to invoice access
CREATE POLICY "invoice_line_items_policy" ON invoice_line_items
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM invoices i
            WHERE i.id = invoice_line_items.invoice_id
            AND ((is_buyer() AND i.buyer_id = get_buyer_id()) OR is_admin())
        )
    );

-- ================================
-- QUALITY & COMPLIANCE POLICIES
-- ================================

-- Quality scores - tied to call access
CREATE POLICY "call_quality_scores_select_policy" ON call_quality_scores
    FOR SELECT USING (
        is_admin() OR
        EXISTS (
            SELECT 1 FROM calls c
            JOIN campaigns camp ON c.campaign_id = camp.id
            WHERE c.id = call_quality_scores.call_id
            AND camp.supplier_id = get_supplier_id()
        ) OR
        EXISTS (
            SELECT 1 FROM calls c
            JOIN buyer_campaigns bc ON c.buyer_campaign_id = bc.id
            WHERE c.id = call_quality_scores.call_id
            AND bc.buyer_id = get_buyer_id()
        )
    );

-- Admin and system can modify quality scores
CREATE POLICY "call_quality_scores_modify_policy" ON call_quality_scores
    FOR ALL USING (is_admin());

-- Disputes - parties involved can see/create, admins manage
CREATE POLICY "disputes_select_policy" ON disputes
    FOR SELECT USING (
        raised_by = auth.uid() OR -- Dispute creator
        assigned_to = auth.uid() OR -- Assigned handler
        is_admin() OR -- Admin access
        EXISTS (
            SELECT 1 FROM calls c
            JOIN campaigns camp ON c.campaign_id = camp.id
            WHERE c.id = disputes.call_id
            AND camp.supplier_id = get_supplier_id()
        ) OR
        EXISTS (
            SELECT 1 FROM calls c
            JOIN buyer_campaigns bc ON c.buyer_campaign_id = bc.id
            WHERE c.id = disputes.call_id
            AND bc.buyer_id = get_buyer_id()
        )
    );

-- Users can create disputes for their calls
CREATE POLICY "disputes_insert_policy" ON disputes
    FOR INSERT WITH CHECK (
        raised_by = auth.uid() AND
        EXISTS (
            SELECT 1 FROM calls c
            WHERE c.id = call_id
            AND (
                EXISTS (
                    SELECT 1 FROM campaigns camp
                    WHERE camp.id = c.campaign_id
                    AND camp.supplier_id = get_supplier_id()
                ) OR
                EXISTS (
                    SELECT 1 FROM buyer_campaigns bc
                    WHERE bc.id = c.buyer_campaign_id
                    AND bc.buyer_id = get_buyer_id()
                )
            )
        )
    );

-- Admins can update disputes
CREATE POLICY "disputes_update_policy" ON disputes
    FOR UPDATE USING (is_admin());

-- ================================
-- ANALYTICS TABLE POLICIES
-- ================================

-- Campaign stats - tied to campaign ownership
CREATE POLICY "campaign_stats_policy" ON campaign_stats
    FOR ALL USING (
        is_admin() OR
        EXISTS (
            SELECT 1 FROM campaigns c
            WHERE c.id = campaign_stats.campaign_id
            AND c.supplier_id = get_supplier_id()
        )
    );

-- Buyer campaign stats - tied to buyer campaign ownership
CREATE POLICY "buyer_campaign_stats_policy" ON buyer_campaign_stats
    FOR ALL USING (
        is_admin() OR
        EXISTS (
            SELECT 1 FROM buyer_campaigns bc
            WHERE bc.id = buyer_campaign_stats.buyer_campaign_id
            AND bc.buyer_id = get_buyer_id()
        )
    );

-- ================================
-- AUDIT LOG POLICIES
-- ================================

-- Audit logs - users can see their own actions, admins see all
CREATE POLICY "audit_logs_select_policy" ON audit_logs
    FOR SELECT USING (
        user_id = auth.uid() OR
        is_admin()
    );

-- System can insert audit logs
CREATE POLICY "audit_logs_insert_policy" ON audit_logs
    FOR INSERT WITH CHECK (true);

-- Only admins can modify audit logs
CREATE POLICY "audit_logs_admin_policy" ON audit_logs
    FOR UPDATE USING (is_admin());

-- No deletion of audit logs
CREATE POLICY "audit_logs_no_delete" ON audit_logs
    FOR DELETE USING (false);

-- ================================
-- FUNCTION SECURITY
-- ================================

-- Grant execute permissions to authenticated users
GRANT EXECUTE ON FUNCTION is_admin(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION is_supplier(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION is_buyer(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION get_supplier_id(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION get_buyer_id(UUID) TO authenticated;

-- Comments for documentation
COMMENT ON FUNCTION is_admin IS 'Check if user has admin privileges';
COMMENT ON FUNCTION is_supplier IS 'Check if user is an active supplier';
COMMENT ON FUNCTION is_buyer IS 'Check if user is an active buyer';
COMMENT ON FUNCTION get_supplier_id IS 'Get supplier ID for user';
COMMENT ON FUNCTION get_buyer_id IS 'Get buyer ID for user';
</file>

<file path="supabase/migrations/003_functions.sql">
-- DCE Platform Database Functions
-- Business logic functions for calculations, validations, and data processing

-- ================================
-- BALANCE CALCULATION FUNCTIONS
-- ================================

-- Function to calculate supplier balance
CREATE OR REPLACE FUNCTION calculate_supplier_balance(supplier_uuid UUID)
RETURNS DECIMAL AS $$
DECLARE
    total_earnings DECIMAL;
    total_payouts DECIMAL;
BEGIN
    -- Sum all completed call payouts
    SELECT COALESCE(SUM(payout_amount), 0) INTO total_earnings
    FROM calls c
    JOIN campaigns camp ON c.campaign_id = camp.id
    WHERE camp.supplier_id = supplier_uuid 
    AND c.status = 'completed';
    
    -- Sum all completed payouts
    SELECT COALESCE(SUM(amount), 0) INTO total_payouts
    FROM payouts
    WHERE supplier_id = supplier_uuid 
    AND status = 'completed';
    
    RETURN total_earnings - total_payouts;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to calculate buyer balance (credit remaining)
CREATE OR REPLACE FUNCTION calculate_buyer_balance(buyer_uuid UUID)
RETURNS DECIMAL AS $$
DECLARE
    credit_limit DECIMAL;
    total_charges DECIMAL;
    total_payments DECIMAL;
BEGIN
    -- Get credit limit
    SELECT buyers.credit_limit INTO credit_limit
    FROM buyers
    WHERE id = buyer_uuid;
    
    -- Sum all completed call charges
    SELECT COALESCE(SUM(charge_amount), 0) INTO total_charges
    FROM calls c
    JOIN buyer_campaigns bc ON c.buyer_campaign_id = bc.id
    WHERE bc.buyer_id = buyer_uuid 
    AND c.status = 'completed';
    
    -- Sum all paid invoices
    SELECT COALESCE(SUM(total_amount), 0) INTO total_payments
    FROM invoices
    WHERE buyer_id = buyer_uuid 
    AND status = 'paid';
    
    RETURN credit_limit + total_payments - total_charges;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ================================
-- QUALITY SCORING FUNCTIONS
-- ================================

-- Function to calculate call quality score
CREATE OR REPLACE FUNCTION calculate_quality_score(
    call_duration INTEGER,
    call_metadata JSONB DEFAULT '{}'
)
RETURNS INTEGER AS $$
DECLARE
    duration_score INTEGER := 0;
    intent_score INTEGER := 70; -- default
    technical_score INTEGER := 85; -- default
    overall_score INTEGER;
BEGIN
    -- Duration scoring (0-100)
    CASE 
        WHEN call_duration >= 120 THEN duration_score := 100; -- 2+ minutes
        WHEN call_duration >= 60 THEN duration_score := 80;   -- 1-2 minutes
        WHEN call_duration >= 30 THEN duration_score := 60;   -- 30-60 seconds
        WHEN call_duration >= 15 THEN duration_score := 40;   -- 15-30 seconds
        ELSE duration_score := 20; -- under 15 seconds
    END CASE;
    
    -- Extract scores from metadata if available
    IF call_metadata ? 'intent_score' THEN
        intent_score := (call_metadata->>'intent_score')::INTEGER;
    END IF;
    
    IF call_metadata ? 'technical_score' THEN
        technical_score := (call_metadata->>'technical_score')::INTEGER;
    END IF;
    
    -- Weighted average: duration 40%, intent 40%, technical 20%
    overall_score := ROUND(
        (duration_score * 0.4 + intent_score * 0.4 + technical_score * 0.2)
    );
    
    -- Ensure score is within bounds
    overall_score := GREATEST(0, LEAST(100, overall_score));
    
    RETURN overall_score;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to detect fraud indicators
CREATE OR REPLACE FUNCTION detect_fraud_indicators(
    caller_number VARCHAR(20),
    call_duration INTEGER,
    caller_location JSONB DEFAULT '{}',
    call_metadata JSONB DEFAULT '{}'
)
RETURNS JSONB AS $$
DECLARE
    fraud_flags JSONB := '[]';
    fraud_score INTEGER := 0;
    recent_calls INTEGER;
BEGIN
    -- Check for rapid repeat calls from same number
    SELECT COUNT(*) INTO recent_calls
    FROM calls
    WHERE caller_number = detect_fraud_indicators.caller_number
    AND started_at > NOW() - INTERVAL '1 hour';
    
    IF recent_calls > 5 THEN
        fraud_flags := fraud_flags || '["rapid_repeat_calls"]'::jsonb;
        fraud_score := fraud_score + 30;
    END IF;
    
    -- Check for very short call duration
    IF call_duration < 10 THEN
        fraud_flags := fraud_flags || '["extremely_short_duration"]'::jsonb;
        fraud_score := fraud_score + 25;
    END IF;
    
    -- Check for suspicious geographic patterns
    IF caller_location ? 'country' AND (caller_location->>'country') != 'US' THEN
        fraud_flags := fraud_flags || '["international_caller"]'::jsonb;
        fraud_score := fraud_score + 20;
    END IF;
    
    -- Check for invalid phone number patterns
    IF caller_number ~ '^1?(000|111|222|333|444|555|666|777|888|999)' THEN
        fraud_flags := fraud_flags || '["suspicious_number_pattern"]'::jsonb;
        fraud_score := fraud_score + 40;
    END IF;
    
    -- Return fraud analysis
    RETURN jsonb_build_object(
        'fraud_score', LEAST(100, fraud_score),
        'flags', fraud_flags,
        'suspicious', fraud_score > 50
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ================================
-- CAMPAIGN MATCHING FUNCTIONS
-- ================================

-- Function to find matching buyer campaigns for a call
CREATE OR REPLACE FUNCTION find_matching_buyer_campaigns(
    supplier_campaign_id UUID,
    caller_location JSONB DEFAULT '{}',
    call_time TIMESTAMP WITH TIME ZONE DEFAULT NOW()
)
RETURNS TABLE(
    buyer_campaign_id UUID,
    buyer_id UUID,
    max_bid DECIMAL,
    match_score INTEGER
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        bc.id as buyer_campaign_id,
        bc.buyer_id,
        bc.max_bid,
        100 as match_score -- Simplified scoring, can be enhanced
    FROM buyer_campaigns bc
    JOIN buyers b ON bc.buyer_id = b.id
    JOIN campaigns c ON c.id = supplier_campaign_id
    WHERE bc.status = 'active'
    AND b.status = 'active'
    AND bc.max_bid >= c.bid_floor
    -- Add time-based matching
    AND (
        bc.schedule IS NULL OR
        (bc.schedule->>'enabled')::boolean = false OR
        (
            EXTRACT(hour FROM call_time) >= (bc.schedule->>'start_hour')::integer AND
            EXTRACT(hour FROM call_time) <= (bc.schedule->>'end_hour')::integer
        )
    )
    -- Add budget checks
    AND (
        bc.daily_budget IS NULL OR
        COALESCE((
            SELECT SUM(charge_amount)
            FROM calls calls_today
            WHERE calls_today.buyer_campaign_id = bc.id
            AND calls_today.started_at::date = call_time::date
        ), 0) + bc.max_bid <= bc.daily_budget
    )
    ORDER BY bc.max_bid DESC, match_score DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ================================
-- BILLING CALCULATION FUNCTIONS
-- ================================

-- Function to calculate call billing amounts
CREATE OR REPLACE FUNCTION calculate_call_billing(
    campaign_id UUID,
    buyer_campaign_id UUID,
    call_duration INTEGER,
    quality_score INTEGER
)
RETURNS JSONB AS $$
DECLARE
    bid_floor DECIMAL;
    max_bid DECIMAL;
    payout_amount DECIMAL;
    charge_amount DECIMAL;
    margin_amount DECIMAL;
    quality_multiplier DECIMAL := 1.0;
BEGIN
    -- Get campaign bid floor and buyer max bid
    SELECT c.bid_floor INTO bid_floor
    FROM campaigns c WHERE c.id = campaign_id;
    
    SELECT bc.max_bid INTO max_bid
    FROM buyer_campaigns bc WHERE bc.id = buyer_campaign_id;
    
    -- Apply quality score multiplier
    CASE 
        WHEN quality_score >= 90 THEN quality_multiplier := 1.1;  -- 10% bonus
        WHEN quality_score >= 80 THEN quality_multiplier := 1.0;  -- full amount
        WHEN quality_score >= 70 THEN quality_multiplier := 0.9;  -- 10% reduction
        WHEN quality_score >= 60 THEN quality_multiplier := 0.8;  -- 20% reduction
        ELSE quality_multiplier := 0.5; -- 50% reduction for poor quality
    END CASE;
    
    -- Calculate amounts
    payout_amount := bid_floor * quality_multiplier;
    charge_amount := max_bid * quality_multiplier;
    margin_amount := charge_amount - payout_amount;
    
    -- Ensure positive amounts
    payout_amount := GREATEST(0, payout_amount);
    charge_amount := GREATEST(payout_amount, charge_amount);
    margin_amount := charge_amount - payout_amount;
    
    RETURN jsonb_build_object(
        'payout_amount', payout_amount,
        'charge_amount', charge_amount,
        'margin_amount', margin_amount,
        'quality_multiplier', quality_multiplier
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ================================
-- STATS AGGREGATION FUNCTIONS
-- ================================

-- Function to process hourly campaign stats
CREATE OR REPLACE FUNCTION process_hourly_stats(target_hour TIMESTAMP WITH TIME ZONE DEFAULT DATE_TRUNC('hour', NOW() - INTERVAL '1 hour'))
RETURNS void AS $$
BEGIN
    -- Update campaign stats
    INSERT INTO campaign_stats (
        campaign_id, date, hour, calls_count, connected_calls, 
        completed_calls, total_duration, avg_duration, total_payout, avg_payout, quality_score_avg
    )
    SELECT 
        campaign_id,
        target_hour::date as date,
        EXTRACT(HOUR FROM target_hour)::integer as hour,
        COUNT(*) as calls_count,
        COUNT(CASE WHEN status IN ('connected', 'completed') THEN 1 END) as connected_calls,
        COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_calls,
        COALESCE(SUM(duration_seconds), 0) as total_duration,
        COALESCE(AVG(duration_seconds), 0) as avg_duration,
        COALESCE(SUM(payout_amount), 0) as total_payout,
        COALESCE(AVG(payout_amount), 0) as avg_payout,
        AVG(quality_score) as quality_score_avg
    FROM calls
    WHERE started_at >= target_hour 
    AND started_at < target_hour + INTERVAL '1 hour'
    AND campaign_id IS NOT NULL
    GROUP BY campaign_id
    ON CONFLICT (campaign_id, date, hour) 
    DO UPDATE SET
        calls_count = EXCLUDED.calls_count,
        connected_calls = EXCLUDED.connected_calls,
        completed_calls = EXCLUDED.completed_calls,
        total_duration = EXCLUDED.total_duration,
        avg_duration = EXCLUDED.avg_duration,
        total_payout = EXCLUDED.total_payout,
        avg_payout = EXCLUDED.avg_payout,
        quality_score_avg = EXCLUDED.quality_score_avg,
        updated_at = NOW();
    
    -- Update buyer campaign stats
    INSERT INTO buyer_campaign_stats (
        buyer_campaign_id, date, hour, calls_received, calls_accepted, 
        calls_completed, total_cost, avg_cost, total_duration, avg_duration, quality_score_avg
    )
    SELECT 
        buyer_campaign_id,
        target_hour::date as date,
        EXTRACT(HOUR FROM target_hour)::integer as hour,
        COUNT(*) as calls_received,
        COUNT(CASE WHEN status IN ('connected', 'completed') THEN 1 END) as calls_accepted,
        COUNT(CASE WHEN status = 'completed' THEN 1 END) as calls_completed,
        COALESCE(SUM(charge_amount), 0) as total_cost,
        COALESCE(AVG(charge_amount), 0) as avg_cost,
        COALESCE(SUM(duration_seconds), 0) as total_duration,
        COALESCE(AVG(duration_seconds), 0) as avg_duration,
        AVG(quality_score) as quality_score_avg
    FROM calls
    WHERE started_at >= target_hour 
    AND started_at < target_hour + INTERVAL '1 hour'
    AND buyer_campaign_id IS NOT NULL
    GROUP BY buyer_campaign_id
    ON CONFLICT (buyer_campaign_id, date, hour) 
    DO UPDATE SET
        calls_received = EXCLUDED.calls_received,
        calls_accepted = EXCLUDED.calls_accepted,
        calls_completed = EXCLUDED.calls_completed,
        total_cost = EXCLUDED.total_cost,
        avg_cost = EXCLUDED.avg_cost,
        total_duration = EXCLUDED.total_duration,
        avg_duration = EXCLUDED.avg_duration,
        quality_score_avg = EXCLUDED.quality_score_avg,
        updated_at = NOW();
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to get campaign performance summary
CREATE OR REPLACE FUNCTION get_campaign_performance(
    campaign_uuid UUID,
    start_date DATE DEFAULT CURRENT_DATE - INTERVAL '30 days',
    end_date DATE DEFAULT CURRENT_DATE
)
RETURNS JSONB AS $$
DECLARE
    result JSONB;
BEGIN
    SELECT jsonb_build_object(
        'total_calls', COALESCE(SUM(calls_count), 0),
        'connected_calls', COALESCE(SUM(connected_calls), 0),
        'completed_calls', COALESCE(SUM(completed_calls), 0),
        'total_duration', COALESCE(SUM(total_duration), 0),
        'total_payout', COALESCE(SUM(total_payout), 0),
        'avg_quality_score', COALESCE(AVG(quality_score_avg), 0),
        'connection_rate', CASE 
            WHEN SUM(calls_count) > 0 THEN 
                ROUND((SUM(connected_calls)::decimal / SUM(calls_count)) * 100, 2)
            ELSE 0 
        END,
        'completion_rate', CASE 
            WHEN SUM(calls_count) > 0 THEN 
                ROUND((SUM(completed_calls)::decimal / SUM(calls_count)) * 100, 2)
            ELSE 0 
        END
    ) INTO result
    FROM campaign_stats
    WHERE campaign_id = campaign_uuid
    AND date BETWEEN start_date AND end_date;
    
    RETURN COALESCE(result, '{}'::jsonb);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ================================
-- VALIDATION FUNCTIONS
-- ================================

-- Function to validate phone number format
CREATE OR REPLACE FUNCTION validate_phone_number(phone_number VARCHAR(20))
RETURNS BOOLEAN AS $$
BEGIN
    -- Basic US phone number validation (can be enhanced for international)
    RETURN phone_number ~ '^\+?1?[2-9][0-8][0-9][2-9][0-9]{2}[0-9]{4}$';
END;
$$ LANGUAGE plpgsql IMMUTABLE SECURITY DEFINER;

-- Function to validate campaign targeting
CREATE OR REPLACE FUNCTION validate_campaign_targeting(targeting JSONB)
RETURNS BOOLEAN AS $$
BEGIN
    -- Basic validation - ensure required fields exist
    IF NOT (targeting ? 'geographic' AND targeting ? 'schedule') THEN
        RETURN false;
    END IF;
    
    -- Validate geographic targeting
    IF NOT (targeting->'geographic' ? 'states' OR targeting->'geographic' ? 'regions') THEN
        RETURN false;
    END IF;
    
    RETURN true;
END;
$$ LANGUAGE plpgsql IMMUTABLE SECURITY DEFINER;

-- ================================
-- UTILITY FUNCTIONS
-- ================================

-- Function to generate unique tracking number
CREATE OR REPLACE FUNCTION generate_tracking_number(campaign_uuid UUID)
RETURNS VARCHAR(20) AS $$
DECLARE
    base_number VARCHAR(10);
    area_code VARCHAR(3) := '800'; -- Default toll-free area code
    sequence_num INTEGER;
    tracking_number VARCHAR(20);
BEGIN
    -- Get next sequence number for this campaign
    SELECT COALESCE(MAX(
        CAST(
            SUBSTRING(number FROM '[0-9]{4}$') AS INTEGER
        )
    ), 0) + 1 INTO sequence_num
    FROM tracking_numbers
    WHERE campaign_id = campaign_uuid;
    
    -- Generate the tracking number
    tracking_number := area_code || LPAD(
        (EXTRACT(epoch FROM NOW())::bigint % 1000)::text, 3, '0'
    ) || LPAD(sequence_num::text, 4, '0');
    
    RETURN tracking_number;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to clean up old audit logs (for maintenance)
CREATE OR REPLACE FUNCTION cleanup_audit_logs(retention_days INTEGER DEFAULT 90)
RETURNS INTEGER AS $$
DECLARE
    deleted_count INTEGER;
BEGIN
    DELETE FROM audit_logs
    WHERE created_at < NOW() - (retention_days || ' days')::INTERVAL;
    
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    
    RETURN deleted_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ================================
-- GRANT PERMISSIONS
-- ================================

-- Grant execute permissions to authenticated users for business functions
GRANT EXECUTE ON FUNCTION calculate_supplier_balance(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION calculate_buyer_balance(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION calculate_quality_score(INTEGER, JSONB) TO authenticated;
GRANT EXECUTE ON FUNCTION detect_fraud_indicators(VARCHAR, INTEGER, JSONB, JSONB) TO authenticated;
GRANT EXECUTE ON FUNCTION find_matching_buyer_campaigns(UUID, JSONB, TIMESTAMP WITH TIME ZONE) TO authenticated;
GRANT EXECUTE ON FUNCTION calculate_call_billing(UUID, UUID, INTEGER, INTEGER) TO authenticated;
GRANT EXECUTE ON FUNCTION get_campaign_performance(UUID, DATE, DATE) TO authenticated;
GRANT EXECUTE ON FUNCTION validate_phone_number(VARCHAR) TO authenticated;
GRANT EXECUTE ON FUNCTION validate_campaign_targeting(JSONB) TO authenticated;

-- Grant to service role for system functions
GRANT EXECUTE ON FUNCTION process_hourly_stats(TIMESTAMP WITH TIME ZONE) TO service_role;
GRANT EXECUTE ON FUNCTION generate_tracking_number(UUID) TO service_role;
GRANT EXECUTE ON FUNCTION cleanup_audit_logs(INTEGER) TO service_role;

-- Comments for documentation
COMMENT ON FUNCTION calculate_supplier_balance IS 'Calculate supplier available balance from completed calls minus payouts';
COMMENT ON FUNCTION calculate_buyer_balance IS 'Calculate buyer remaining credit balance';
COMMENT ON FUNCTION calculate_quality_score IS 'Calculate call quality score based on duration and metadata';
COMMENT ON FUNCTION detect_fraud_indicators IS 'Analyze call data for fraud indicators and return risk assessment';
COMMENT ON FUNCTION find_matching_buyer_campaigns IS 'Find active buyer campaigns that match supplier traffic';
COMMENT ON FUNCTION calculate_call_billing IS 'Calculate payout, charge, and margin amounts for a call';
COMMENT ON FUNCTION process_hourly_stats IS 'Process and aggregate hourly campaign statistics';
COMMENT ON FUNCTION get_campaign_performance IS 'Get performance summary for a campaign over date range';
COMMENT ON FUNCTION validate_phone_number IS 'Validate phone number format';
COMMENT ON FUNCTION validate_campaign_targeting IS 'Validate campaign targeting configuration';
COMMENT ON FUNCTION generate_tracking_number IS 'Generate unique tracking number for campaign';
COMMENT ON FUNCTION cleanup_audit_logs IS 'Clean up old audit log entries for maintenance';
</file>

<file path="supabase/migrations/004_triggers.sql">
-- DCE Platform Database Triggers
-- Automated processes, audit logging, and data validation triggers

-- ================================
-- AUDIT LOGGING TRIGGERS
-- ================================

-- Enhanced audit trigger function with more context
CREATE OR REPLACE FUNCTION audit_trigger()
RETURNS TRIGGER AS $$
DECLARE
    user_uuid UUID;
    user_ip INET;
    user_agent TEXT;
BEGIN
    -- Get current user info
    user_uuid := auth.uid();
    
    -- Try to get additional context (may not always be available)
    BEGIN
        user_ip := inet(current_setting('request.headers')::json->>'x-forwarded-for');
    EXCEPTION WHEN OTHERS THEN
        user_ip := NULL;
    END;
    
    BEGIN
        user_agent := current_setting('request.headers')::json->>'user-agent';
    EXCEPTION WHEN OTHERS THEN
        user_agent := NULL;
    END;
    
    INSERT INTO audit_logs (
        table_name,
        operation,
        user_id,
        record_id,
        old_data,
        new_data,
        ip_address,
        user_agent
    ) VALUES (
        TG_TABLE_NAME,
        TG_OP,
        user_uuid,
        CASE 
            WHEN TG_OP = 'DELETE' THEN (OLD.id)::UUID
            ELSE (NEW.id)::UUID
        END,
        CASE WHEN TG_OP = 'DELETE' OR TG_OP = 'UPDATE' THEN row_to_json(OLD) ELSE NULL END,
        CASE WHEN TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN row_to_json(NEW) ELSE NULL END,
        user_ip,
        user_agent
    );
    
    RETURN CASE WHEN TG_OP = 'DELETE' THEN OLD ELSE NEW END;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Apply audit triggers to sensitive tables
CREATE TRIGGER audit_users_trigger
    AFTER INSERT OR UPDATE OR DELETE ON users
    FOR EACH ROW EXECUTE FUNCTION audit_trigger();

CREATE TRIGGER audit_suppliers_trigger
    AFTER INSERT OR UPDATE OR DELETE ON suppliers
    FOR EACH ROW EXECUTE FUNCTION audit_trigger();

CREATE TRIGGER audit_buyers_trigger
    AFTER INSERT OR UPDATE OR DELETE ON buyers
    FOR EACH ROW EXECUTE FUNCTION audit_trigger();

CREATE TRIGGER audit_campaigns_trigger
    AFTER INSERT OR UPDATE OR DELETE ON campaigns
    FOR EACH ROW EXECUTE FUNCTION audit_trigger();

CREATE TRIGGER audit_buyer_campaigns_trigger
    AFTER INSERT OR UPDATE OR DELETE ON buyer_campaigns
    FOR EACH ROW EXECUTE FUNCTION audit_trigger();

CREATE TRIGGER audit_calls_trigger
    AFTER INSERT OR UPDATE OR DELETE ON calls
    FOR EACH ROW EXECUTE FUNCTION audit_trigger();

CREATE TRIGGER audit_payouts_trigger
    AFTER INSERT OR UPDATE OR DELETE ON payouts
    FOR EACH ROW EXECUTE FUNCTION audit_trigger();

CREATE TRIGGER audit_invoices_trigger
    AFTER INSERT OR UPDATE OR DELETE ON invoices
    FOR EACH ROW EXECUTE FUNCTION audit_trigger();

CREATE TRIGGER audit_disputes_trigger
    AFTER INSERT OR UPDATE OR DELETE ON disputes
    FOR EACH ROW EXECUTE FUNCTION audit_trigger();

-- ================================
-- BUSINESS LOGIC TRIGGERS
-- ================================

-- Trigger to automatically process call quality and billing
CREATE OR REPLACE FUNCTION process_call_completion()
RETURNS TRIGGER AS $$
DECLARE
    quality_result JSONB;
    fraud_result JSONB;
    billing_result JSONB;
    call_quality_score INTEGER;
BEGIN
    -- Only process when call status changes to completed
    IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN
        
        -- Calculate quality score
        call_quality_score := calculate_quality_score(NEW.duration_seconds, NEW.metadata);
        
        -- Detect fraud indicators
        fraud_result := detect_fraud_indicators(
            NEW.caller_number, 
            NEW.duration_seconds, 
            NEW.caller_location, 
            NEW.metadata
        );
        
        -- Calculate billing amounts if not already set
        IF NEW.payout_amount = 0 AND NEW.charge_amount = 0 AND NEW.campaign_id IS NOT NULL AND NEW.buyer_campaign_id IS NOT NULL THEN
            billing_result := calculate_call_billing(
                NEW.campaign_id, 
                NEW.buyer_campaign_id, 
                NEW.duration_seconds, 
                call_quality_score
            );
            
            NEW.payout_amount := (billing_result->>'payout_amount')::DECIMAL;
            NEW.charge_amount := (billing_result->>'charge_amount')::DECIMAL;
            NEW.margin_amount := (billing_result->>'margin_amount')::DECIMAL;
        END IF;
        
        -- Update quality and fraud scores
        NEW.quality_score := call_quality_score;
        NEW.fraud_score := (fraud_result->>'fraud_score')::INTEGER;
        
        -- Add fraud flags to metadata
        IF fraud_result->>'suspicious' = 'true' THEN
            NEW.metadata := NEW.metadata || jsonb_build_object('fraud_flags', fraud_result->'flags');
        END IF;
        
        -- Insert detailed quality score record
        INSERT INTO call_quality_scores (
            call_id,
            duration_score,
            overall_score,
            flags,
            scoring_model
        ) VALUES (
            NEW.id,
            CASE 
                WHEN NEW.duration_seconds >= 120 THEN 100
                WHEN NEW.duration_seconds >= 60 THEN 80
                WHEN NEW.duration_seconds >= 30 THEN 60
                WHEN NEW.duration_seconds >= 15 THEN 40
                ELSE 20
            END,
            call_quality_score,
            fraud_result->'flags',
            'v1.0'
        );
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Apply call completion trigger
CREATE TRIGGER process_call_completion_trigger
    BEFORE UPDATE ON calls
    FOR EACH ROW EXECUTE FUNCTION process_call_completion();

-- ================================
-- BALANCE MANAGEMENT TRIGGERS
-- ================================

-- Trigger to update supplier balance when calls are completed or payouts processed
CREATE OR REPLACE FUNCTION update_supplier_balance()
RETURNS TRIGGER AS $$
BEGIN
    -- Update supplier credit balance
    IF TG_TABLE_NAME = 'calls' AND NEW.status = 'completed' THEN
        UPDATE suppliers 
        SET credit_balance = calculate_supplier_balance(
            (SELECT supplier_id FROM campaigns WHERE id = NEW.campaign_id)
        )
        WHERE id = (SELECT supplier_id FROM campaigns WHERE id = NEW.campaign_id);
        
    ELSIF TG_TABLE_NAME = 'payouts' AND NEW.status = 'completed' THEN
        UPDATE suppliers 
        SET credit_balance = calculate_supplier_balance(NEW.supplier_id)
        WHERE id = NEW.supplier_id;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Apply balance update triggers
CREATE TRIGGER update_supplier_balance_calls_trigger
    AFTER UPDATE ON calls
    FOR EACH ROW EXECUTE FUNCTION update_supplier_balance();

CREATE TRIGGER update_supplier_balance_payouts_trigger
    AFTER UPDATE ON payouts
    FOR EACH ROW EXECUTE FUNCTION update_supplier_balance();

-- Trigger to update buyer balance when calls are charged or invoices are paid
CREATE OR REPLACE FUNCTION update_buyer_balance()
RETURNS TRIGGER AS $$
BEGIN
    -- Update buyer current balance
    IF TG_TABLE_NAME = 'calls' AND NEW.status = 'completed' THEN
        UPDATE buyers 
        SET current_balance = calculate_buyer_balance(
            (SELECT buyer_id FROM buyer_campaigns WHERE id = NEW.buyer_campaign_id)
        )
        WHERE id = (SELECT buyer_id FROM buyer_campaigns WHERE id = NEW.buyer_campaign_id);
        
    ELSIF TG_TABLE_NAME = 'invoices' AND NEW.status = 'paid' THEN
        UPDATE buyers 
        SET current_balance = calculate_buyer_balance(NEW.buyer_id)
        WHERE id = NEW.buyer_id;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Apply buyer balance update triggers
CREATE TRIGGER update_buyer_balance_calls_trigger
    AFTER UPDATE ON calls
    FOR EACH ROW EXECUTE FUNCTION update_buyer_balance();

CREATE TRIGGER update_buyer_balance_invoices_trigger
    AFTER UPDATE ON invoices
    FOR EACH ROW EXECUTE FUNCTION update_buyer_balance();

-- ================================
-- VALIDATION TRIGGERS
-- ================================

-- Trigger to validate campaign data before insert/update
CREATE OR REPLACE FUNCTION validate_campaign_data()
RETURNS TRIGGER AS $$
BEGIN
    -- Validate bid floor is positive
    IF NEW.bid_floor < 0 THEN
        RAISE EXCEPTION 'Bid floor must be positive';
    END IF;
    
    -- Validate targeting configuration
    IF NOT validate_campaign_targeting(NEW.targeting) THEN
        RAISE EXCEPTION 'Invalid campaign targeting configuration';
    END IF;
    
    -- Validate tracking numbers if provided
    IF NEW.tracking_numbers IS NOT NULL THEN
        DECLARE
            number_item JSONB;
        BEGIN
            FOR number_item IN SELECT jsonb_array_elements(NEW.tracking_numbers)
            LOOP
                IF NOT validate_phone_number(number_item->>'number') THEN
                    RAISE EXCEPTION 'Invalid tracking number format: %', number_item->>'number';
                END IF;
            END LOOP;
        END;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Apply campaign validation trigger
CREATE TRIGGER validate_campaign_data_trigger
    BEFORE INSERT OR UPDATE ON campaigns
    FOR EACH ROW EXECUTE FUNCTION validate_campaign_data();

-- Trigger to validate buyer campaign data
CREATE OR REPLACE FUNCTION validate_buyer_campaign_data()
RETURNS TRIGGER AS $$
BEGIN
    -- Validate max bid is positive
    IF NEW.max_bid <= 0 THEN
        RAISE EXCEPTION 'Max bid must be positive';
    END IF;
    
    -- Validate budget constraints
    IF NEW.daily_budget IS NOT NULL AND NEW.daily_budget <= 0 THEN
        RAISE EXCEPTION 'Daily budget must be positive';
    END IF;
    
    IF NEW.monthly_budget IS NOT NULL AND NEW.monthly_budget <= 0 THEN
        RAISE EXCEPTION 'Monthly budget must be positive';
    END IF;
    
    -- Ensure daily budget doesn't exceed monthly budget
    IF NEW.daily_budget IS NOT NULL AND NEW.monthly_budget IS NOT NULL THEN
        IF NEW.daily_budget * 31 > NEW.monthly_budget THEN
            RAISE EXCEPTION 'Daily budget would exceed monthly budget';
        END IF;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Apply buyer campaign validation trigger
CREATE TRIGGER validate_buyer_campaign_data_trigger
    BEFORE INSERT OR UPDATE ON buyer_campaigns
    FOR EACH ROW EXECUTE FUNCTION validate_buyer_campaign_data();

-- ================================
-- NOTIFICATION TRIGGERS
-- ================================

-- Trigger to send real-time notifications for important events
CREATE OR REPLACE FUNCTION send_realtime_notifications()
RETURNS TRIGGER AS $$
BEGIN
    -- Send notifications for different events
    CASE TG_TABLE_NAME
        WHEN 'calls' THEN
            IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN
                PERFORM pg_notify(
                    'call_completed',
                    json_build_object(
                        'call_id', NEW.id,
                        'campaign_id', NEW.campaign_id,
                        'buyer_campaign_id', NEW.buyer_campaign_id,
                        'payout_amount', NEW.payout_amount,
                        'charge_amount', NEW.charge_amount,
                        'quality_score', NEW.quality_score
                    )::text
                );
            END IF;
            
        WHEN 'disputes' THEN
            IF TG_OP = 'INSERT' THEN
                PERFORM pg_notify(
                    'dispute_created',
                    json_build_object(
                        'dispute_id', NEW.id,
                        'call_id', NEW.call_id,
                        'raised_by', NEW.raised_by,
                        'dispute_type', NEW.dispute_type,
                        'reason', NEW.reason
                    )::text
                );
            END IF;
            
        WHEN 'payouts' THEN
            IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN
                PERFORM pg_notify(
                    'payout_completed',
                    json_build_object(
                        'payout_id', NEW.id,
                        'supplier_id', NEW.supplier_id,
                        'amount', NEW.amount,
                        'transaction_id', NEW.transaction_id
                    )::text
                );
            END IF;
    END CASE;
    
    RETURN CASE WHEN TG_OP = 'DELETE' THEN OLD ELSE NEW END;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Apply notification triggers
CREATE TRIGGER send_call_notifications_trigger
    AFTER INSERT OR UPDATE ON calls
    FOR EACH ROW EXECUTE FUNCTION send_realtime_notifications();

CREATE TRIGGER send_dispute_notifications_trigger
    AFTER INSERT OR UPDATE ON disputes
    FOR EACH ROW EXECUTE FUNCTION send_realtime_notifications();

CREATE TRIGGER send_payout_notifications_trigger
    AFTER INSERT OR UPDATE ON payouts
    FOR EACH ROW EXECUTE FUNCTION send_realtime_notifications();

-- ================================
-- DATA INTEGRITY TRIGGERS
-- ================================

-- Trigger to ensure tracking numbers are unique and properly formatted
CREATE OR REPLACE FUNCTION manage_tracking_numbers()
RETURNS TRIGGER AS $$
BEGIN
    -- Auto-generate tracking number if not provided
    IF NEW.number IS NULL OR NEW.number = '' THEN
        NEW.number := generate_tracking_number(NEW.campaign_id);
    END IF;
    
    -- Validate number format
    IF NOT validate_phone_number(NEW.number) THEN
        RAISE EXCEPTION 'Invalid tracking number format: %', NEW.number;
    END IF;
    
    -- Set display number (formatted version)
    NEW.display_number := CASE 
        WHEN LENGTH(NEW.number) = 11 AND LEFT(NEW.number, 1) = '1' THEN
            '(' || SUBSTRING(NEW.number, 2, 3) || ') ' || 
            SUBSTRING(NEW.number, 5, 3) || '-' || 
            SUBSTRING(NEW.number, 8, 4)
        WHEN LENGTH(NEW.number) = 10 THEN
            '(' || LEFT(NEW.number, 3) || ') ' || 
            SUBSTRING(NEW.number, 4, 3) || '-' || 
            RIGHT(NEW.number, 4)
        ELSE NEW.number
    END;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Apply tracking number management trigger
CREATE TRIGGER manage_tracking_numbers_trigger
    BEFORE INSERT OR UPDATE ON tracking_numbers
    FOR EACH ROW EXECUTE FUNCTION manage_tracking_numbers();

-- ================================
-- AUTOMATIC STATS PROCESSING
-- ================================

-- Schedule hourly stats processing (requires pg_cron extension)
-- This would typically be set up separately in production
-- SELECT cron.schedule('process-hourly-stats', '0 * * * *', 'SELECT process_hourly_stats();');

-- Alternative: Trigger-based stats processing for real-time updates
CREATE OR REPLACE FUNCTION update_campaign_stats_realtime()
RETURNS TRIGGER AS $$
BEGIN
    -- Update daily stats when call is completed
    IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN
        
        -- Update campaign stats
        INSERT INTO campaign_stats (
            campaign_id, date, calls_count, connected_calls, 
            completed_calls, total_duration, total_payout
        )
        SELECT 
            NEW.campaign_id,
            NEW.started_at::date,
            1, 1, 1,
            NEW.duration_seconds,
            NEW.payout_amount
        WHERE NEW.campaign_id IS NOT NULL
        ON CONFLICT (campaign_id, date, hour)
        WHERE hour IS NULL
        DO UPDATE SET
            calls_count = campaign_stats.calls_count + 1,
            connected_calls = campaign_stats.connected_calls + 1,
            completed_calls = campaign_stats.completed_calls + 1,
            total_duration = campaign_stats.total_duration + NEW.duration_seconds,
            total_payout = campaign_stats.total_payout + NEW.payout_amount,
            updated_at = NOW();
        
        -- Update buyer campaign stats
        INSERT INTO buyer_campaign_stats (
            buyer_campaign_id, date, calls_received, calls_accepted,
            calls_completed, total_cost, total_duration
        )
        SELECT 
            NEW.buyer_campaign_id,
            NEW.started_at::date,
            1, 1, 1,
            NEW.charge_amount,
            NEW.duration_seconds
        WHERE NEW.buyer_campaign_id IS NOT NULL
        ON CONFLICT (buyer_campaign_id, date, hour)
        WHERE hour IS NULL
        DO UPDATE SET
            calls_received = buyer_campaign_stats.calls_received + 1,
            calls_accepted = buyer_campaign_stats.calls_accepted + 1,
            calls_completed = buyer_campaign_stats.calls_completed + 1,
            total_cost = buyer_campaign_stats.total_cost + NEW.charge_amount,
            total_duration = buyer_campaign_stats.total_duration + NEW.duration_seconds,
            updated_at = NOW();
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Apply real-time stats trigger
CREATE TRIGGER update_campaign_stats_realtime_trigger
    AFTER UPDATE ON calls
    FOR EACH ROW EXECUTE FUNCTION update_campaign_stats_realtime();

-- Comments for documentation
COMMENT ON FUNCTION audit_trigger IS 'Comprehensive audit logging for sensitive table changes';
COMMENT ON FUNCTION process_call_completion IS 'Automated quality scoring and billing calculation for completed calls';
COMMENT ON FUNCTION update_supplier_balance IS 'Maintain accurate supplier balance based on calls and payouts';
COMMENT ON FUNCTION update_buyer_balance IS 'Maintain accurate buyer balance based on charges and payments';
COMMENT ON FUNCTION validate_campaign_data IS 'Validate campaign configuration before save';
COMMENT ON FUNCTION validate_buyer_campaign_data IS 'Validate buyer campaign configuration before save';
COMMENT ON FUNCTION send_realtime_notifications IS 'Send real-time notifications for important events';
COMMENT ON FUNCTION manage_tracking_numbers IS 'Auto-generate and format tracking numbers';
COMMENT ON FUNCTION update_campaign_stats_realtime IS 'Real-time campaign statistics updates';
</file>

<file path="supabase/migrations/CLAUDE.md">
# Database Migrations

# Migration Structure
- Sequential numbered migrations: `20241215000001_initial_schema.sql`
- Descriptive naming convention
- Up and down migration support
- Production-safe migration practices

# Migration Best Practices
```sql
-- Migration: 20241215000001_create_users_table.sql
-- Description: Create users table with role-based access

BEGIN;

-- Create users table
CREATE TABLE IF NOT EXISTS public.users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email TEXT UNIQUE NOT NULL,
  first_name TEXT NOT NULL,
  last_name TEXT NOT NULL,
  phone TEXT,
  role TEXT NOT NULL CHECK (role IN ('supplier', 'buyer', 'admin')),
  status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'inactive', 'suspended')),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Create indexes
CREATE INDEX idx_users_email ON public.users(email);
CREATE INDEX idx_users_role ON public.users(role);
CREATE INDEX idx_users_status ON public.users(status);

-- Enable RLS
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;

-- Create RLS policies
CREATE POLICY "Users can view own profile" ON public.users
  FOR SELECT USING (auth.uid() = id);

CREATE POLICY "Users can update own profile" ON public.users
  FOR UPDATE USING (auth.uid() = id);

COMMIT;
```

# Core Schema Migrations

## User Management
```sql
-- Migration: 20241215000002_create_user_profiles.sql
BEGIN;

CREATE TABLE IF NOT EXISTS public.user_profiles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  company TEXT,
  title TEXT,
  bio TEXT,
  website TEXT,
  avatar_url TEXT,
  timezone TEXT DEFAULT 'UTC',
  preferences JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Unique constraint on user_id
ALTER TABLE public.user_profiles ADD CONSTRAINT unique_user_profile UNIQUE (user_id);

-- Enable RLS
ALTER TABLE public.user_profiles ENABLE ROW LEVEL SECURITY;

-- RLS policies
CREATE POLICY "Users can manage own profile" ON public.user_profiles
  FOR ALL USING (auth.uid() = user_id);

COMMIT;
```

## Campaign Management
```sql
-- Migration: 20241215000003_create_campaigns.sql
BEGIN;

CREATE TABLE IF NOT EXISTS public.campaigns (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  buyer_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  description TEXT,
  status TEXT NOT NULL DEFAULT 'draft' CHECK (status IN ('draft', 'active', 'paused', 'completed', 'cancelled')),
  bid_amount DECIMAL(10,2) NOT NULL CHECK (bid_amount > 0),
  daily_budget DECIMAL(10,2),
  monthly_budget DECIMAL(10,2),
  
  -- Targeting configuration
  geo_targeting JSONB DEFAULT '{}',
  time_targeting JSONB DEFAULT '{}',
  device_targeting JSONB DEFAULT '{}',
  filters JSONB DEFAULT '{}',
  
  -- Quality settings
  quality_threshold INTEGER DEFAULT 70 CHECK (quality_threshold BETWEEN 0 AND 100),
  fraud_detection_enabled BOOLEAN DEFAULT true,
  
  -- Timestamps
  start_date TIMESTAMPTZ,
  end_date TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_campaigns_buyer_id ON public.campaigns(buyer_id);
CREATE INDEX idx_campaigns_status ON public.campaigns(status);
CREATE INDEX idx_campaigns_created_at ON public.campaigns(created_at);

-- Enable RLS
ALTER TABLE public.campaigns ENABLE ROW LEVEL SECURITY;

-- RLS policies
CREATE POLICY "Buyers can manage own campaigns" ON public.campaigns
  FOR ALL USING (auth.uid() = buyer_id);

CREATE POLICY "Suppliers can view active campaigns" ON public.campaigns
  FOR SELECT USING (status = 'active' AND start_date <= NOW() AND (end_date IS NULL OR end_date >= NOW()));

COMMIT;
```

## Call Tracking
```sql
-- Migration: 20241215000004_create_calls.sql
BEGIN;

CREATE TABLE IF NOT EXISTS public.calls (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  campaign_id UUID NOT NULL REFERENCES public.campaigns(id) ON DELETE CASCADE,
  supplier_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  
  -- Call details
  caller_number TEXT NOT NULL,
  duration INTEGER, -- in seconds
  status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'completed', 'failed', 'fraud', 'disputed')),
  
  -- Quality and fraud scoring
  quality_score INTEGER CHECK (quality_score BETWEEN 0 AND 100),
  fraud_score DECIMAL(3,2) CHECK (fraud_score BETWEEN 0 AND 1),
  quality_metrics JSONB DEFAULT '{}',
  fraud_analysis JSONB DEFAULT '{}',
  
  -- Financial
  bid_amount DECIMAL(10,2) NOT NULL,
  payout_amount DECIMAL(10,2) DEFAULT 0,
  payout_status TEXT DEFAULT 'pending' CHECK (payout_status IN ('pending', 'approved', 'paid', 'rejected')),
  
  -- Timestamps
  call_started_at TIMESTAMPTZ,
  call_ended_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_calls_campaign_id ON public.calls(campaign_id);
CREATE INDEX idx_calls_supplier_id ON public.calls(supplier_id);
CREATE INDEX idx_calls_status ON public.calls(status);
CREATE INDEX idx_calls_created_at ON public.calls(created_at);
CREATE INDEX idx_calls_caller_number ON public.calls(caller_number);

-- Enable RLS
ALTER TABLE public.calls ENABLE ROW LEVEL SECURITY;

-- RLS policies
CREATE POLICY "Suppliers can view own calls" ON public.calls
  FOR SELECT USING (auth.uid() = supplier_id);

CREATE POLICY "Buyers can view campaign calls" ON public.calls
  FOR SELECT USING (
    auth.uid() IN (
      SELECT buyer_id FROM public.campaigns WHERE id = campaign_id
    )
  );

COMMIT;
```

# Financial Migrations
```sql
-- Migration: 20241215000005_create_transactions.sql
BEGIN;

CREATE TABLE IF NOT EXISTS public.transactions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  call_id UUID REFERENCES public.calls(id) ON DELETE SET NULL,
  
  -- Transaction details
  type TEXT NOT NULL CHECK (type IN ('charge', 'payout', 'refund', 'fee')),
  amount DECIMAL(10,2) NOT NULL,
  currency TEXT NOT NULL DEFAULT 'USD',
  status TEXT NOT NULL CHECK (status IN ('pending', 'processing', 'succeeded', 'failed', 'cancelled')),
  
  -- External references
  stripe_payment_intent_id TEXT,
  stripe_transfer_id TEXT,
  
  -- Metadata
  description TEXT,
  metadata JSONB DEFAULT '{}',
  
  -- Timestamps
  processed_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_transactions_user_id ON public.transactions(user_id);
CREATE INDEX idx_transactions_type ON public.transactions(type);
CREATE INDEX idx_transactions_status ON public.transactions(status);
CREATE INDEX idx_transactions_created_at ON public.transactions(created_at);
CREATE INDEX idx_transactions_stripe_payment_intent ON public.transactions(stripe_payment_intent_id);

-- Enable RLS
ALTER TABLE public.transactions ENABLE ROW LEVEL SECURITY;

-- RLS policies
CREATE POLICY "Users can view own transactions" ON public.transactions
  FOR SELECT USING (auth.uid() = user_id);

COMMIT;
```

# Audit and Logging
```sql
-- Migration: 20241215000006_create_audit_log.sql
BEGIN;

CREATE TABLE IF NOT EXISTS public.audit_log (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES public.users(id) ON DELETE SET NULL,
  
  -- Event details
  event_type TEXT NOT NULL,
  table_name TEXT,
  record_id UUID,
  
  -- Change tracking
  old_values JSONB,
  new_values JSONB,
  
  -- Context
  ip_address INET,
  user_agent TEXT,
  request_id TEXT,
  
  -- Timestamp
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_audit_log_user_id ON public.audit_log(user_id);
CREATE INDEX idx_audit_log_event_type ON public.audit_log(event_type);
CREATE INDEX idx_audit_log_table_name ON public.audit_log(table_name);
CREATE INDEX idx_audit_log_created_at ON public.audit_log(created_at);

-- Enable RLS
ALTER TABLE public.audit_log ENABLE ROW LEVEL SECURITY;

-- Only admins can view audit logs
CREATE POLICY "Admins can view audit logs" ON public.audit_log
  FOR SELECT USING (
    auth.uid() IN (
      SELECT id FROM public.users WHERE role = 'admin'
    )
  );

COMMIT;
```

# Trigger Functions
```sql
-- Migration: 20241215000007_create_trigger_functions.sql
BEGIN;

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ language 'plpgsql';

-- Apply updated_at triggers to all tables
CREATE TRIGGER update_users_updated_at
  BEFORE UPDATE ON public.users
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_user_profiles_updated_at
  BEFORE UPDATE ON public.user_profiles
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_campaigns_updated_at
  BEFORE UPDATE ON public.campaigns
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_calls_updated_at
  BEFORE UPDATE ON public.calls
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_transactions_updated_at
  BEFORE UPDATE ON public.transactions
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

-- Audit trigger function
CREATE OR REPLACE FUNCTION public.audit_trigger_function()
RETURNS TRIGGER AS $$
BEGIN
  IF TG_OP = 'DELETE' THEN
    INSERT INTO public.audit_log (event_type, table_name, record_id, old_values)
    VALUES (TG_OP, TG_TABLE_NAME, OLD.id, row_to_json(OLD));
    RETURN OLD;
  ELSIF TG_OP = 'UPDATE' THEN
    INSERT INTO public.audit_log (event_type, table_name, record_id, old_values, new_values)
    VALUES (TG_OP, TG_TABLE_NAME, NEW.id, row_to_json(OLD), row_to_json(NEW));
    RETURN NEW;
  ELSIF TG_OP = 'INSERT' THEN
    INSERT INTO public.audit_log (event_type, table_name, record_id, new_values)
    VALUES (TG_OP, TG_TABLE_NAME, NEW.id, row_to_json(NEW));
    RETURN NEW;
  END IF;
  RETURN NULL;
END;
$$ language 'plpgsql';

COMMIT;
```

# Real-time Subscriptions
```sql
-- Migration: 20241215000008_enable_realtime.sql
BEGIN;

-- Enable realtime for key tables
ALTER PUBLICATION supabase_realtime ADD TABLE public.calls;
ALTER PUBLICATION supabase_realtime ADD TABLE public.campaigns;
ALTER PUBLICATION supabase_realtime ADD TABLE public.transactions;

-- Create real-time metrics view
CREATE OR REPLACE VIEW public.real_time_metrics AS
SELECT 
  COUNT(*) FILTER (WHERE status = 'completed' AND DATE(created_at) = CURRENT_DATE) as calls_today,
  COUNT(*) FILTER (WHERE status = 'pending') as active_calls,
  AVG(duration) FILTER (WHERE status = 'completed' AND DATE(created_at) = CURRENT_DATE) as avg_duration_today,
  SUM(payout_amount) FILTER (WHERE status = 'completed' AND DATE(created_at) = CURRENT_DATE) as revenue_today
FROM public.calls;

-- Enable RLS on view
ALTER VIEW public.real_time_metrics ENABLE ROW LEVEL SECURITY;

COMMIT;
```

# Data Seeding
```sql
-- Migration: 20241215000009_seed_initial_data.sql
BEGIN;

-- Insert system admin user (only in development)
INSERT INTO public.users (id, email, first_name, last_name, role)
VALUES (
  '00000000-0000-0000-0000-000000000000',
  'admin@dependablecalls.com',
  'System',
  'Administrator',
  'admin'
) ON CONFLICT (email) DO NOTHING;

-- Insert sample fraud detection rules
INSERT INTO public.fraud_rules (name, description, rule_type, configuration, enabled)
VALUES 
  ('Duplicate Caller Detection', 'Flags multiple calls from same number', 'duplicate_caller', '{"time_window": 3600, "max_calls": 3}', true),
  ('Short Call Duration', 'Flags unusually short calls', 'duration_check', '{"min_duration": 30}', true),
  ('Geographic Anomaly', 'Detects calls from unexpected locations', 'geo_validation', '{"strict_mode": false}', true)
ON CONFLICT (name) DO NOTHING;

COMMIT;
```

# Migration Testing
```sql
-- Test migration rollback capability
-- Migration: 20241215000010_test_rollback.sql
BEGIN;

-- Create temporary test table
CREATE TABLE IF NOT EXISTS public.migration_test (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  test_data TEXT
);

-- Insert test data
INSERT INTO public.migration_test (test_data) VALUES ('migration_test');

-- Verify data exists
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM public.migration_test WHERE test_data = 'migration_test') THEN
    RAISE EXCEPTION 'Migration test failed: test data not found';
  END IF;
END $$;

-- Clean up test table
DROP TABLE public.migration_test;

COMMIT;
```

# Performance Optimizations
```sql
-- Migration: 20241215000011_performance_optimizations.sql
BEGIN;

-- Create composite indexes for common queries
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_calls_campaign_status_created 
  ON public.calls(campaign_id, status, created_at);

CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_calls_supplier_payout_status 
  ON public.calls(supplier_id, payout_status, created_at);

-- Partial indexes for active data
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_active_campaigns 
  ON public.campaigns(buyer_id, created_at) 
  WHERE status = 'active';

CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_pending_calls 
  ON public.calls(created_at) 
  WHERE status = 'pending';

-- Create materialized view for dashboard metrics
CREATE MATERIALIZED VIEW IF NOT EXISTS public.dashboard_metrics AS
SELECT 
  u.id as user_id,
  u.role,
  COUNT(c.id) as total_calls,
  COUNT(c.id) FILTER (WHERE c.status = 'completed') as completed_calls,
  SUM(c.payout_amount) as total_earnings,
  AVG(c.quality_score) as avg_quality_score
FROM public.users u
LEFT JOIN public.calls c ON (u.role = 'supplier' AND c.supplier_id = u.id) 
                        OR (u.role = 'buyer' AND c.campaign_id IN (SELECT id FROM public.campaigns WHERE buyer_id = u.id))
GROUP BY u.id, u.role;

-- Create unique index for materialized view
CREATE UNIQUE INDEX ON public.dashboard_metrics(user_id);

-- Refresh materialized view function
CREATE OR REPLACE FUNCTION public.refresh_dashboard_metrics()
RETURNS void AS $$
BEGIN
  REFRESH MATERIALIZED VIEW CONCURRENTLY public.dashboard_metrics;
END;
$$ LANGUAGE plpgsql;

COMMIT;
```

# Migration Deployment
```bash
#!/bin/bash
# deploy-migrations.sh

set -e

echo "Deploying database migrations..."

# Run migrations
supabase db push

# Verify migration status
supabase migration list

# Run post-migration tests
psql $DATABASE_URL -f tests/migration_tests.sql

echo "Migrations deployed successfully!"
```

# CRITICAL RULES
- NO regex in SQL migrations
- NO direct user data in migrations (use seeds)
- ALWAYS use transactions (BEGIN/COMMIT)
- ALWAYS create indexes CONCURRENTLY in production
- ALWAYS test migrations in staging first
- IMPLEMENT proper RLS policies
- VALIDATE data integrity after migrations
- MAINTAIN backward compatibility
- DOCUMENT all schema changes
- BACKUP before major migrations
</file>

<file path="supabase/.gitignore">
# Supabase
.branches
.temp

# dotenvx
.env.keys
.env.local
.env.*.local
</file>

<file path="supabase/CLAUDE.md">
# Supabase Database Patterns

# Migration Structure
```
supabase/
â”œâ”€â”€ migrations/           # SQL migration files
â”œâ”€â”€ config.toml          # Local dev configuration
â”œâ”€â”€ functions/           # Edge functions
â””â”€â”€ seed.sql            # Development seed data
```

# Migration File Naming
- `001_initial_schema.sql` - Core database schema
- `002_security_policies.sql` - Row Level Security (RLS)
- `003_functions.sql` - Database functions and triggers
- `004_feature_specific.sql` - Feature additions

# Migration Best Practices
```sql
-- Always check if objects exist before creating
CREATE TABLE IF NOT EXISTS users (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Use proper foreign key constraints
ALTER TABLE campaigns
ADD CONSTRAINT fk_campaigns_buyer_id 
FOREIGN KEY (buyer_id) REFERENCES users(id) ON DELETE CASCADE;

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_calls_campaign_id ON calls(campaign_id);
CREATE INDEX IF NOT EXISTS idx_calls_status ON calls(status);
```

# Row Level Security (RLS) Patterns
```sql
-- Enable RLS on all tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE campaigns ENABLE ROW LEVEL SECURITY;
ALTER TABLE calls ENABLE ROW LEVEL SECURITY;

-- User can only access their own data
CREATE POLICY "Users can view own profile" ON users
  FOR SELECT USING (auth.uid() = id);

-- Role-based access for campaigns
CREATE POLICY "Buyers can manage their campaigns" ON campaigns
  FOR ALL USING (
    auth.uid() = buyer_id AND 
    (SELECT role FROM users WHERE id = auth.uid()) = 'buyer'
  );

-- Suppliers can view active campaigns
CREATE POLICY "Suppliers can view active campaigns" ON campaigns
  FOR SELECT USING (
    status = 'active' AND
    (SELECT role FROM users WHERE id = auth.uid()) = 'supplier'
  );
```

# Database Functions
```sql
-- Function to update timestamps
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger for auto-updating timestamps
CREATE TRIGGER update_users_updated_at
  BEFORE UPDATE ON users
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();
```

# Real-time Subscriptions Setup
```sql
-- Enable real-time for specific tables
ALTER PUBLICATION supabase_realtime 
ADD TABLE calls, campaigns, users;

-- Create real-time policies
CREATE POLICY "Real-time calls for campaign owners" ON calls
  FOR SELECT USING (
    campaign_id IN (
      SELECT id FROM campaigns 
      WHERE buyer_id = auth.uid()
    )
  );
```

# DCE-Specific Schema Patterns

## Users Table
```sql
CREATE TABLE users (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  email TEXT UNIQUE NOT NULL,
  role user_role NOT NULL DEFAULT 'supplier',
  profile JSONB DEFAULT '{}',
  is_verified BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TYPE user_role AS ENUM ('supplier', 'buyer', 'admin');
```

## Campaigns Table
```sql
CREATE TABLE campaigns (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  buyer_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  vertical campaign_vertical NOT NULL,
  status campaign_status DEFAULT 'draft',
  target_cpa DECIMAL(10,2),
  daily_budget DECIMAL(10,2),
  filters JSONB DEFAULT '{}',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TYPE campaign_status AS ENUM ('draft', 'active', 'paused', 'completed');
CREATE TYPE campaign_vertical AS ENUM ('insurance', 'home_services', 'legal', 'medical');
```

## Calls Table
```sql
CREATE TABLE calls (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  campaign_id UUID NOT NULL REFERENCES campaigns(id) ON DELETE CASCADE,
  supplier_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  tracking_number TEXT UNIQUE NOT NULL,
  caller_number TEXT,
  duration INTEGER DEFAULT 0,
  status call_status DEFAULT 'pending',
  quality_score INTEGER CHECK (quality_score >= 1 AND quality_score <= 10),
  payout_amount DECIMAL(10,2),
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TYPE call_status AS ENUM ('pending', 'active', 'completed', 'failed', 'fraud');
```

# Edge Functions Structure
```typescript
// supabase/functions/webhook-stripe/index.ts
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { corsHeaders } from '../_shared/cors.ts';

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    const signature = req.headers.get('stripe-signature')!;
    const body = await req.text();
    
    // Verify webhook signature
    // Process webhook data
    
    return new Response(
      JSON.stringify({ received: true }),
      { 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      },
    );
  } catch (error) {
    return new Response(
      JSON.stringify({ error: error.message }),
      { 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 400,
      },
    );
  }
});
```

# Local Development Setup
```toml
# config.toml
[api]
port = 54321
schemas = ["public", "auth", "storage", "realtime"]
extra_search_path = ["public", "extensions"]

[db]
port = 54322
major_version = 15

[studio]
port = 54323

[auth]
enable_signup = true
```

# Data Seeding
```sql
-- seed.sql
INSERT INTO users (id, email, role, is_verified) VALUES
  ('11111111-1111-1111-1111-111111111111', 'supplier@test.com', 'supplier', true),
  ('22222222-2222-2222-2222-222222222222', 'buyer@test.com', 'buyer', true);

INSERT INTO campaigns (buyer_id, name, vertical, status, target_cpa, daily_budget) VALUES
  ('22222222-2222-2222-2222-222222222222', 'Test Insurance Campaign', 'insurance', 'active', 50.00, 1000.00);
```

# Performance Optimization
```sql
-- Indexes for common queries
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_calls_created_at ON calls(created_at);
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_campaigns_buyer_id_status ON campaigns(buyer_id, status);

-- Partial indexes for active records
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_active_calls 
ON calls(campaign_id, created_at) WHERE status = 'active';
```

# Backup and Migrations
```bash
# Create migration
supabase migration new feature_name

# Apply migrations
supabase db push

# Reset local database
supabase db reset

# Generate TypeScript types
supabase gen types typescript --local > src/types/database.ts
```

# Testing Database
```sql
-- Create test-specific data
BEGIN;
  -- Insert test data
  INSERT INTO users ...;
  -- Run tests
ROLLBACK; -- Cleanup
```

# CRITICAL RULES
- NO regex in SQL queries or functions
- ALWAYS use RLS policies for data security
- ALWAYS create proper indexes for performance
- NEVER store sensitive data in JSONB fields
- ALWAYS use transactions for multi-table operations
- ENABLE real-time only for necessary tables
- TEST all migrations before deploying
- USE proper foreign key constraints
- IMPLEMENT audit trails for sensitive operations
- VALIDATE all user inputs at database level
</file>

<file path="supabase/README.md">
# DCE Platform Supabase Backend Setup

This directory contains the complete Supabase backend implementation for the Dependable Call Exchange platform.

## ðŸ—ï¸ Database Architecture

### Core Tables
- **users** - User accounts (extends auth.users)
- **suppliers** - Traffic providers
- **buyers** - Advertisers purchasing leads
- **campaigns** - Supplier traffic campaigns
- **buyer_campaigns** - Buyer purchasing criteria
- **calls** - Core call transaction records
- **tracking_numbers** - Phone numbers for call routing

### Supporting Tables
- **payouts** - Supplier payments
- **invoices** - Buyer billing
- **call_quality_scores** - Quality assessment
- **disputes** - Quality/billing disputes
- **campaign_stats** - Performance analytics
- **audit_logs** - System audit trail

## ðŸ” Security Features

### Row Level Security (RLS)
- **Suppliers** can only access their own campaigns and calls
- **Buyers** can only access their campaigns and received calls
- **Admins** have broader access with role-based permissions
- **Audit logging** for all sensitive operations

### Data Protection
- All sensitive data encrypted at rest and in transit
- PII fields use field-level encryption where needed
- Comprehensive audit trail for compliance

## ðŸ“ File Structure

```
supabase/
â”œâ”€â”€ migrations/
â”‚   â”œâ”€â”€ 001_initial_schema.sql      # Core database schema
â”‚   â”œâ”€â”€ 002_security_policies.sql   # Row Level Security policies
â”‚   â”œâ”€â”€ 003_functions.sql           # Business logic functions
â”‚   â”œâ”€â”€ 004_triggers.sql            # Automated processes
â”‚   â””â”€â”€ 005_indexes.sql             # Performance indexes
â”œâ”€â”€ functions/                      # Edge functions (to be added)
â”œâ”€â”€ config.toml                     # Supabase configuration
â”œâ”€â”€ seed.sql                        # Development test data
â””â”€â”€ README.md                       # This file
```

## ðŸš€ Quick Start

### Prerequisites
- Docker Desktop installed and running
- Node.js 18+ 
- Supabase CLI installed (`npm i -g supabase`)

### Local Development Setup

1. **Start Supabase locally:**
   ```bash
   supabase start
   ```

2. **Apply migrations:**
   ```bash
   supabase db reset
   ```

3. **View local dashboard:**
   ```bash
   # API: http://localhost:54321
   # Studio: http://localhost:54323
   # Inbucket (emails): http://localhost:54324
   ```

4. **Generate TypeScript types:**
   ```bash
   supabase gen types typescript --local > ../src/types/database.ts
   ```

### Environment Setup

Copy `.env.local` values to your environment:

```bash
# For local development
VITE_SUPABASE_URL=http://127.0.0.1:54321
VITE_SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZS1kZW1vIiwicm9sZSI6ImFub24iLCJleHAiOjE5ODM4MTI5OTZ9.CRXP1A7WOeoJeXxjNni43kdQwgnWNReilDMblYTn_I0
```

## ðŸ“Š Database Functions

### Balance Calculations
- `calculate_supplier_balance(supplier_id)` - Get supplier available balance
- `calculate_buyer_balance(buyer_id)` - Get buyer remaining credit

### Quality Scoring
- `calculate_quality_score(duration, metadata)` - Score call quality (1-100)
- `detect_fraud_indicators(caller_data)` - Analyze fraud risk

### Campaign Matching  
- `find_matching_buyer_campaigns(campaign_id)` - Real-time call routing
- `calculate_call_billing(campaign_id, buyer_campaign_id)` - Billing amounts

### Analytics
- `process_hourly_stats()` - Aggregate campaign performance
- `get_campaign_performance(campaign_id, date_range)` - Performance summaries

## ðŸ”§ Key Features

### Real-time Capabilities
- Live call updates via Supabase Realtime
- Campaign status changes
- Payment notifications
- System alerts

### Automated Processes
- Quality scoring on call completion
- Fraud detection and flagging
- Balance updates on transactions
- Hourly stats aggregation
- Audit logging for all changes

### Performance Optimizations
- Comprehensive indexing strategy
- Partial indexes for active records only
- JSONB indexes for metadata queries
- Full-text search capabilities

## ðŸ§ª Test Data

The `seed.sql` file includes:
- Admin, supplier, and buyer test accounts
- Sample campaigns (insurance and legal verticals)
- Test calls with quality scores
- Invoice and payout examples
- Campaign performance statistics

### Test User Accounts
- **Admin**: admin@dce-platform.com
- **Supplier**: supplier@test.com (Test Traffic Co)
- **Buyer 1**: buyer@test.com (Insurance Plus LLC)
- **Buyer 2**: buyer2@test.com (Premium Legal Services)

## ðŸ” Monitoring & Debugging

### Query Performance
```sql
-- Check slow queries
SELECT query, mean_time, calls 
FROM pg_stat_statements 
ORDER BY mean_time DESC 
LIMIT 10;

-- Check index usage
SELECT schemaname, tablename, attname, n_distinct, correlation
FROM pg_stats
WHERE schemaname = 'public'
ORDER BY n_distinct DESC;
```

### Audit Trail Queries
```sql
-- User activity tracking
SELECT table_name, operation, created_at, new_data
FROM audit_logs
WHERE user_id = 'user-uuid'
ORDER BY created_at DESC;

-- Table change history
SELECT operation, old_data, new_data, created_at
FROM audit_logs
WHERE table_name = 'campaigns' AND record_id = 'campaign-uuid'
ORDER BY created_at DESC;
```

## ðŸš¢ Production Deployment

### Supabase Project Setup
1. Create new Supabase project
2. Configure custom domain (optional)
3. Set up database backups
4. Configure auth providers
5. Set environment variables

### Migration Deployment
```bash
# Link to remote project
supabase link --project-ref your-project-ref

# Push migrations
supabase db push

# Deploy edge functions
supabase functions deploy
```

### Environment Variables
```bash
# Production environment
VITE_SUPABASE_URL=https://your-project.supabase.co
VITE_SUPABASE_ANON_KEY=your-anon-key
```

## ðŸ›¡ï¸ Security Checklist

- [ ] RLS enabled on all tables
- [ ] Proper role-based access policies
- [ ] Audit logging configured
- [ ] Rate limiting enabled
- [ ] API keys properly secured
- [ ] Database backups scheduled
- [ ] Monitoring alerts configured

## ðŸ”§ Troubleshooting

### Common Issues

**Migration errors:**
```bash
# Reset local database
supabase db reset

# Check migration status
supabase migration list
```

**RLS policy issues:**
```sql
-- Test policy as specific user
SET ROLE authenticated;
SET request.jwt.claim.sub TO 'user-uuid';
SELECT * FROM campaigns; -- Should respect RLS
```

**Performance issues:**
```sql
-- Analyze query performance
EXPLAIN ANALYZE SELECT * FROM calls 
WHERE campaign_id = 'uuid' 
ORDER BY started_at DESC;
```

## ðŸ“š Additional Resources

- [Supabase Documentation](https://supabase.com/docs)
- [PostgreSQL Documentation](https://www.postgresql.org/docs/)
- [Row Level Security Guide](https://supabase.com/docs/guides/auth/row-level-security)
- [Real-time Subscriptions](https://supabase.com/docs/guides/realtime)

## ðŸ¤ Contributing

When adding new features:
1. Create a new migration file
2. Update RLS policies if needed
3. Add appropriate indexes
4. Update seed data for testing
5. Add audit logging for sensitive operations
6. Document any new functions or procedures
</file>

<file path="tests/e2e/auth/example.spec.ts">
import { test, expect } from '@playwright/test'

// Example E2E test - remove this once real auth tests are implemented
test.describe('Authentication Example', () => {
  test('should display Vite React app homepage', async ({ page }) => {
    await page.goto('/')
    
    // This is just an example test to verify E2E setup
    // Replace with actual authentication tests once the auth system is implemented
    await expect(page).toHaveTitle(/Vite \+ React \+ TS/)
  })
  
  test('should load React app content', async ({ page }) => {
    await page.goto('/')
    
    // Example test to verify the basic Vite React app loads
    // Update with actual application content tests once implemented
    await expect(page).toHaveTitle(/Vite \+ React \+ TS/)
    await expect(page.locator('body')).toBeVisible()
  })
})
</file>

<file path="tests/e2e/CLAUDE.md">
# End-to-End Test Patterns

# Test File Organization
```
e2e/
â”œâ”€â”€ auth/          # Authentication flows
â”œâ”€â”€ campaigns/     # Campaign management
â”œâ”€â”€ calls/         # Call tracking
â”œâ”€â”€ billing/       # Payment processing
â””â”€â”€ shared/        # Shared utilities and fixtures
```

# Playwright Configuration
- Multi-browser testing (Chromium, Firefox, Safari)
- Mobile viewport testing
- Network conditions simulation
- Video recording on failures
- Screenshot comparison

# Basic Test Template
```ts
import { test, expect } from '@playwright/test';

test.describe('Feature Name', () => {
  test.beforeEach(async ({ page }) => {
    // Setup before each test
    await page.goto('/');
  });

  test('should perform user action', async ({ page }) => {
    // Test implementation
    await page.click('[data-testid="button"]');
    await expect(page.locator('[data-testid="result"]')).toBeVisible();
  });
});
```

# Authentication Flow Tests
```ts
import { test, expect } from '@playwright/test';
import { loginAsSupplier, loginAsBuyer } from './helpers/auth';

test.describe('Authentication', () => {
  test('should login as supplier', async ({ page }) => {
    await page.goto('/login');
    
    await page.fill('[name="email"]', 'supplier@test.com');
    await page.fill('[name="password"]', 'password123');
    await page.click('[type="submit"]');
    
    await expect(page).toHaveURL('/dashboard');
    await expect(page.locator('[data-testid="supplier-dashboard"]')).toBeVisible();
  });

  test('should redirect to login for protected routes', async ({ page }) => {
    await page.goto('/dashboard');
    await expect(page).toHaveURL('/login');
  });
});
```

# Page Object Pattern
```ts
// pages/LoginPage.ts
export class LoginPage {
  constructor(private page: Page) {}

  async navigate() {
    await this.page.goto('/login');
  }

  async login(email: string, password: string) {
    await this.page.fill('[name="email"]', email);
    await this.page.fill('[name="password"]', password);
    await this.page.click('[type="submit"]');
  }

  async getErrorMessage() {
    return await this.page.textContent('[data-testid="error-message"]');
  }
}

// Usage in test
test('should show error for invalid credentials', async ({ page }) => {
  const loginPage = new LoginPage(page);
  await loginPage.navigate();
  await loginPage.login('invalid@test.com', 'wrongpassword');
  
  const error = await loginPage.getErrorMessage();
  expect(error).toBe('Invalid credentials');
});
```

# Data Attributes for Testing
```tsx
// Use data-testid for reliable element selection
<button data-testid="create-campaign-button">
  Create Campaign
</button>

// Access in tests
await page.click('[data-testid="create-campaign-button"]');
```

# API Mocking and Fixtures
```ts
import { test, expect } from '@playwright/test';

test('should handle API responses', async ({ page }) => {
  // Mock API response
  await page.route('/api/campaigns', (route) => {
    route.fulfill({
      status: 200,
      contentType: 'application/json',
      body: JSON.stringify({
        campaigns: [
          { id: '1', name: 'Test Campaign', status: 'active' }
        ]
      })
    });
  });

  await page.goto('/campaigns');
  await expect(page.locator('[data-testid="campaign-1"]')).toBeVisible();
});
```

# Real-time Feature Testing
```ts
test('should update call status in real-time', async ({ page, context }) => {
  await page.goto('/calls');
  
  // Simulate real-time update
  await page.evaluate(() => {
    window.dispatchEvent(new CustomEvent('callStatusUpdate', {
      detail: { callId: '123', status: 'completed' }
    }));
  });
  
  await expect(page.locator('[data-testid="call-123-status"]'))
    .toContainText('completed');
});
```

# Multi-User Testing
```ts
test('should handle multiple users simultaneously', async ({ browser }) => {
  const supplierContext = await browser.newContext();
  const buyerContext = await browser.newContext();
  
  const supplierPage = await supplierContext.newPage();
  const buyerPage = await buyerContext.newPage();
  
  // Login as different users
  await loginAsSupplier(supplierPage);
  await loginAsBuyer(buyerPage);
  
  // Test interactions between users
  await supplierPage.click('[data-testid="start-call"]');
  await expect(buyerPage.locator('[data-testid="incoming-call"]'))
    .toBeVisible({ timeout: 5000 });
});
```

# Form Testing
```ts
test('should validate form inputs', async ({ page }) => {
  await page.goto('/campaigns/create');
  
  // Test required field validation
  await page.click('[type="submit"]');
  await expect(page.locator('[data-testid="name-error"]'))
    .toContainText('Campaign name is required');
  
  // Test successful form submission
  await page.fill('[name="name"]', 'New Campaign');
  await page.selectOption('[name="category"]', 'insurance');
  await page.fill('[name="budget"]', '1000');
  
  await page.click('[type="submit"]');
  await expect(page).toHaveURL('/campaigns');
});
```

# Mobile Responsiveness Testing
```ts
test.describe('Mobile Tests', () => {
  test.use({ viewport: { width: 375, height: 667 } });

  test('should be mobile responsive', async ({ page }) => {
    await page.goto('/dashboard');
    
    // Check mobile navigation
    await page.click('[data-testid="mobile-menu-button"]');
    await expect(page.locator('[data-testid="mobile-nav"]')).toBeVisible();
  });
});
```

# Performance Testing
```ts
test('should load page within acceptable time', async ({ page }) => {
  const startTime = Date.now();
  
  await page.goto('/dashboard');
  await page.waitForLoadState('networkidle');
  
  const loadTime = Date.now() - startTime;
  expect(loadTime).toBeLessThan(3000); // 3 second threshold
});
```

# Visual Regression Testing
```ts
test('should match visual snapshot', async ({ page }) => {
  await page.goto('/dashboard');
  await page.waitForLoadState('networkidle');
  
  await expect(page).toHaveScreenshot('dashboard.png');
});
```

# Error Handling Tests
```ts
test('should handle network errors gracefully', async ({ page }) => {
  // Simulate network failure
  await page.route('/api/**', (route) => {
    route.abort('failed');
  });
  
  await page.goto('/dashboard');
  await expect(page.locator('[data-testid="error-message"]'))
    .toContainText('Unable to load data');
});
```

# DCE-Specific E2E Scenarios

## Supplier Journey
```ts
test('supplier complete journey', async ({ page }) => {
  await loginAsSupplier(page);
  
  // Browse available campaigns
  await page.goto('/campaigns');
  await page.click('[data-testid="campaign-1-select"]');
  
  // Generate tracking number
  await page.click('[data-testid="get-tracking-number"]');
  const trackingNumber = await page.textContent('[data-testid="tracking-number"]');
  
  // Simulate call completion
  await page.click('[data-testid="mark-call-complete"]');
  
  // Check payout calculation
  await expect(page.locator('[data-testid="payout-amount"]'))
    .toContainText('$');
});
```

## Buyer Journey
```ts
test('buyer complete journey', async ({ page }) => {
  await loginAsBuyer(page);
  
  // Create new campaign
  await page.goto('/campaigns/create');
  await page.fill('[name="name"]', 'Insurance Campaign');
  await page.selectOption('[name="vertical"]', 'insurance');
  await page.fill('[name="target_cpa"]', '50');
  await page.click('[type="submit"]');
  
  // Monitor campaign performance
  await page.goto('/campaigns');
  await page.click('[data-testid="campaign-analytics"]');
  
  await expect(page.locator('[data-testid="call-volume"]')).toBeVisible();
  await expect(page.locator('[data-testid="conversion-rate"]')).toBeVisible();
});
```

# Test Data Management
```ts
// fixtures/campaigns.ts
export const testCampaign = {
  name: 'Test Campaign',
  vertical: 'insurance',
  target_cpa: 50,
  daily_budget: 1000,
};

// Use in tests
import { testCampaign } from '../fixtures/campaigns';

test('should create campaign', async ({ page }) => {
  await fillCampaignForm(page, testCampaign);
});
```

# Accessibility Testing
```ts
import { injectAxe, checkA11y } from 'axe-playwright';

test('should be accessible', async ({ page }) => {
  await page.goto('/dashboard');
  await injectAxe(page);
  await checkA11y(page);
});
```

# CRITICAL RULES
- NO regex in E2E test code
- USE data-testid attributes for element selection
- ALWAYS wait for elements to be ready
- TEST real user scenarios end-to-end
- MOCK external APIs appropriately
- TEST across multiple browsers and devices
- VERIFY accessibility compliance
- CHECK performance thresholds
- CLEAN up test data after runs
- USE page object pattern for complex workflows
</file>

<file path="tests/fixtures/calls.ts">
export interface TestCall {
  id: string
  campaignId: string
  supplierId: string
  buyerId: string
  phoneNumber: string
  callerNumber: string
  status: 'ringing' | 'connected' | 'completed' | 'failed' | 'qualified' | 'rejected'
  duration: number
  startTime: string
  endTime?: string
  recordingUrl?: string
  transcription?: string
  qualificationNotes?: string
  payout?: number
  metadata: {
    userAgent?: string
    referrer?: string
    ip?: string
    location?: {
      city: string
      state: string
      country: string
    }
  }
  fraudScore: number
  createdAt: string
  updatedAt: string
}

export interface TestCallWithTracking extends TestCall {
  tracking: {
    events: Array<{
      type: 'dial' | 'ring' | 'connect' | 'disconnect' | 'qualify' | 'reject'
      timestamp: string
      data?: Record<string, unknown>
    }>
    qualityMetrics: {
      audioQuality: number
      connectionStability: number
      backgroundNoise: number
    }
  }
}

export const createTestCall = (overrides: Partial<TestCall> = {}): TestCall => ({
  id: `call_${Math.random().toString(36).substr(2, 9)}`,
  campaignId: `campaign_${Math.random().toString(36).substr(2, 9)}`,
  supplierId: `supplier_${Math.random().toString(36).substr(2, 9)}`,
  buyerId: `buyer_${Math.random().toString(36).substr(2, 9)}`,
  phoneNumber: '+1-555-CAMPAIGN',
  callerNumber: '+1-555-' + Math.floor(Math.random() * 10000).toString().padStart(4, '0'),
  status: 'completed',
  duration: 180,
  startTime: new Date(Date.now() - 300000).toISOString(),
  endTime: new Date().toISOString(),
  payout: 25.00,
  metadata: {
    userAgent: 'Mozilla/5.0 (compatible; TestBot/1.0)',
    referrer: 'https://example.com',
    ip: '192.168.1.100',
    location: {
      city: 'San Francisco',
      state: 'CA',
      country: 'US',
    },
  },
  fraudScore: 0.1,
  createdAt: new Date(Date.now() - 300000).toISOString(),
  updatedAt: new Date().toISOString(),
  ...overrides,
})

export const createTestCallWithTracking = (
  overrides: Partial<TestCallWithTracking> = {}
): TestCallWithTracking => ({
  ...createTestCall(),
  tracking: {
    events: [
      { type: 'dial', timestamp: new Date(Date.now() - 300000).toISOString() },
      { type: 'ring', timestamp: new Date(Date.now() - 295000).toISOString() },
      { type: 'connect', timestamp: new Date(Date.now() - 290000).toISOString() },
      { type: 'disconnect', timestamp: new Date().toISOString() },
    ],
    qualityMetrics: {
      audioQuality: 0.9,
      connectionStability: 0.95,
      backgroundNoise: 0.1,
    },
  },
  ...overrides,
})

export const testCalls = {
  qualifiedCall: createTestCall({
    status: 'qualified',
    duration: 240,
    payout: 35.00,
    qualificationNotes: 'Customer expressed strong interest, scheduled follow-up',
  }),
  rejectedCall: createTestCall({
    status: 'rejected',
    duration: 45,
    payout: 0,
    qualificationNotes: 'Not interested in service',
  }),
  fraudulentCall: createTestCall({
    status: 'rejected',
    duration: 15,
    payout: 0,
    fraudScore: 0.9,
    qualificationNotes: 'Suspected fraud - very short duration, high fraud score',
  }),
  longCall: createTestCall({
    status: 'qualified',
    duration: 600,
    payout: 50.00,
    qualificationNotes: 'Extended conversation, high purchase intent',
  }),
  failedCall: createTestCall({
    status: 'failed',
    duration: 0,
    payout: 0,
    endTime: undefined,
    qualificationNotes: 'Call failed to connect',
  }),
}
</file>

<file path="tests/fixtures/campaigns.ts">
export interface TestCampaign {
  id: string
  name: string
  buyerId: string
  status: 'active' | 'paused' | 'ended' | 'draft'
  payout: number
  category: string
  description: string
  requirements: {
    minCallDuration: number
    allowedStates: string[]
    workingHours: {
      start: string
      end: string
      timezone: string
    }
    blacklistedPhones: string[]
  }
  budget: {
    daily: number
    total: number
    spent: number
  }
  createdAt: string
  updatedAt: string
}

export interface TestCampaignWithMetrics extends TestCampaign {
  metrics: {
    totalCalls: number
    qualifiedCalls: number
    conversionRate: number
    avgCallDuration: number
    totalSpent: number
  }
}

export const createTestCampaign = (overrides: Partial<TestCampaign> = {}): TestCampaign => ({
  id: `campaign_${Math.random().toString(36).substr(2, 9)}`,
  name: `Test Campaign ${Math.random().toString(36).substr(2, 4).toUpperCase()}`,
  buyerId: `buyer_${Math.random().toString(36).substr(2, 9)}`,
  status: 'active',
  payout: 25.00,
  category: 'Home Services',
  description: 'High-quality leads for home improvement services',
  requirements: {
    minCallDuration: 60,
    allowedStates: ['CA', 'NY', 'TX', 'FL'],
    workingHours: {
      start: '08:00',
      end: '18:00',
      timezone: 'America/New_York',
    },
    blacklistedPhones: [],
  },
  budget: {
    daily: 1000,
    total: 10000,
    spent: 0,
  },
  createdAt: new Date().toISOString(),
  updatedAt: new Date().toISOString(),
  ...overrides,
})

export const createTestCampaignWithMetrics = (
  overrides: Partial<TestCampaignWithMetrics> = {}
): TestCampaignWithMetrics => ({
  ...createTestCampaign(),
  metrics: {
    totalCalls: 150,
    qualifiedCalls: 120,
    conversionRate: 0.8,
    avgCallDuration: 180,
    totalSpent: 3000,
  },
  ...overrides,
})

export const testCampaigns = {
  activeCampaign: createTestCampaign({
    name: 'Premium Home Services',
    payout: 35.00,
    status: 'active',
    category: 'Home Services',
  }),
  pausedCampaign: createTestCampaign({
    name: 'Auto Insurance Leads',
    payout: 45.00,
    status: 'paused',
    category: 'Insurance',
  }),
  draftCampaign: createTestCampaign({
    name: 'Solar Installation',
    payout: 75.00,
    status: 'draft',
    category: 'Energy',
  }),
  highPayoutCampaign: createTestCampaign({
    name: 'Legal Services',
    payout: 125.00,
    status: 'active',
    category: 'Legal',
  }),
}
</file>

<file path="tests/fixtures/CLAUDE.md">
# Test Fixtures & Data

# Fixture Organization

```
fixtures/
â”œâ”€â”€ users.ts        # User test data
â”œâ”€â”€ campaigns.ts    # Campaign fixtures
â”œâ”€â”€ calls.ts        # Call tracking data
â”œâ”€â”€ billing.ts      # Payment test data
â”œâ”€â”€ auth.ts         # Authentication fixtures
â””â”€â”€ index.ts        # Export all fixtures
```

# User Fixtures

```tsx
// users.ts
export const testUsers = {
  supplier: {
    id: '11111111-1111-1111-1111-111111111111',
    email: 'supplier@test.com',
    password: 'Test123!@#',
    role: 'supplier' as const,
    profile: {
      company: 'Test Traffic Co',
      phone: '5551234567',
    },
  },
  buyer: {
    id: '22222222-2222-2222-2222-222222222222',
    email: 'buyer@test.com',
    password: 'Test123!@#',
    role: 'buyer' as const,
    profile: {
      company: 'Test Buyer Inc',
      phone: '5559876543',
    },
  },
  admin: {
    id: '33333333-3333-3333-3333-333333333333',
    email: 'admin@test.com',
    password: 'Admin123!@#',
    role: 'admin' as const,
  },
}

export const invalidUsers = {
  noEmail: { password: 'Test123!@#' },
  noPassword: { email: 'test@example.com' },
  invalidEmail: { email: 'not-an-email', password: 'Test123!@#' },
  shortPassword: { email: 'test@example.com', password: '123' },
}
```

# Campaign Fixtures

```tsx
// campaigns.ts
export const testCampaigns = {
  active: {
    id: 'camp-001',
    buyer_id: testUsers.buyer.id,
    name: 'Insurance Leads - National',
    vertical: 'insurance' as const,
    status: 'active' as const,
    target_cpa: 50.0,
    daily_budget: 1000.0,
    filters: {
      states: ['CA', 'TX', 'FL'],
      age_range: [25, 65],
      time_restrictions: [
        {
          days: ['MON', 'TUE', 'WED', 'THU', 'FRI'],
          start_hour: 9,
          end_hour: 17,
        },
      ],
    },
  },
  paused: {
    id: 'camp-002',
    buyer_id: testUsers.buyer.id,
    name: 'Home Services - Regional',
    vertical: 'home_services' as const,
    status: 'paused' as const,
    target_cpa: 75.0,
    daily_budget: 500.0,
  },
  completed: {
    id: 'camp-003',
    buyer_id: testUsers.buyer.id,
    name: 'Legal Leads - Test',
    vertical: 'legal' as const,
    status: 'completed' as const,
    target_cpa: 100.0,
    daily_budget: 2000.0,
  },
}

export function createCampaign(overrides = {}) {
  return {
    ...testCampaigns.active,
    id: `camp-${Date.now()}`,
    ...overrides,
  }
}
```

# Call Fixtures

```tsx
// calls.ts
export const testCalls = {
  completed: {
    id: 'call-001',
    campaign_id: testCampaigns.active.id,
    supplier_id: testUsers.supplier.id,
    tracking_number: '18005551234',
    caller_number: '4155551234',
    duration: 180, // 3 minutes
    status: 'completed' as const,
    quality_score: 8,
    payout_amount: 45.0,
    created_at: new Date(Date.now() - 3600000).toISOString(),
  },
  active: {
    id: 'call-002',
    campaign_id: testCampaigns.active.id,
    supplier_id: testUsers.supplier.id,
    tracking_number: '18005551235',
    caller_number: '4155551235',
    duration: 0,
    status: 'active' as const,
    created_at: new Date().toISOString(),
  },
  failed: {
    id: 'call-003',
    campaign_id: testCampaigns.active.id,
    supplier_id: testUsers.supplier.id,
    tracking_number: '18005551236',
    caller_number: '4155551236',
    duration: 5,
    status: 'failed' as const,
    quality_score: 0,
    payout_amount: 0,
  },
}

export function generateCallBatch(count: number, status = 'completed') {
  return Array.from({ length: count }, (_, i) => ({
    ...testCalls.completed,
    id: `call-batch-${i}`,
    tracking_number: `1800555${(2000 + i).toString().padStart(4, '0')}`,
    status,
    created_at: new Date(Date.now() - i * 3600000).toISOString(),
  }))
}
```

# Billing Fixtures

```tsx
// billing.ts
export const testPaymentMethods = {
  card: {
    id: 'pm_test_card',
    type: 'card',
    card: {
      brand: 'visa',
      last4: '4242',
      exp_month: 12,
      exp_year: 2025,
    },
  },
  bank: {
    id: 'pm_test_bank',
    type: 'us_bank_account',
    us_bank_account: {
      bank_name: 'Test Bank',
      last4: '6789',
      account_type: 'checking',
    },
  },
}

export const testTransactions = {
  payout: {
    id: 'txn-001',
    amount: 1250.5,
    currency: 'usd',
    type: 'payout' as const,
    status: 'succeeded' as const,
    user_id: testUsers.supplier.id,
    stripe_payout_id: 'po_test_123',
    created_at: new Date(Date.now() - 86400000).toISOString(),
  },
  charge: {
    id: 'txn-002',
    amount: 500.0,
    currency: 'usd',
    type: 'charge' as const,
    status: 'succeeded' as const,
    user_id: testUsers.buyer.id,
    stripe_payment_intent_id: 'pi_test_456',
    created_at: new Date(Date.now() - 172800000).toISOString(),
  },
}
```

# Authentication Fixtures

```tsx
// auth.ts
export const authTokens = {
  valid: {
    access_token: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',
    refresh_token: 'refresh_token_123',
    expires_in: 3600,
    token_type: 'bearer',
  },
  expired: {
    access_token: 'expired_token',
    refresh_token: 'expired_refresh',
    expires_in: -1,
    token_type: 'bearer',
  },
}

export const authSessions = {
  supplier: {
    user: testUsers.supplier,
    session: authTokens.valid,
  },
  buyer: {
    user: testUsers.buyer,
    session: authTokens.valid,
  },
}
```

# Mock API Responses

```tsx
export const mockApiResponses = {
  success: <T>(data: T) => ({
    data,
    error: null,
    status: 200,
  }),
  error: (message: string, code = 400) => ({
    data: null,
    error: { message, code },
    status: code,
  }),
  paginated: <T>(data: T[], page = 1, limit = 10) => ({
    data,
    pagination: {
      page,
      limit,
      total: data.length,
      totalPages: Math.ceil(data.length / limit),
    },
    error: null,
    status: 200,
  }),
};
```

# Date/Time Fixtures

```tsx
export const testDates = {
  today: new Date(),
  yesterday: new Date(Date.now() - 86400000),
  lastWeek: new Date(Date.now() - 604800000),
  lastMonth: new Date(Date.now() - 2592000000),
  nextWeek: new Date(Date.now() + 604800000),
}

export const testTimeRanges = {
  today: {
    start: new Date(new Date().setHours(0, 0, 0, 0)),
    end: new Date(new Date().setHours(23, 59, 59, 999)),
  },
  thisWeek: {
    start: new Date(Date.now() - 604800000),
    end: new Date(),
  },
  thisMonth: {
    start: new Date(new Date().getFullYear(), new Date().getMonth(), 1),
    end: new Date(new Date().getFullYear(), new Date().getMonth() + 1, 0),
  },
}
```

# Form Data Fixtures

```tsx
export const testFormData = {
  validCampaign: {
    name: 'Test Campaign',
    vertical: 'insurance',
    target_cpa: '50',
    daily_budget: '1000',
    description: 'Test campaign description',
  },
  invalidCampaign: {
    name: '', // Required field
    vertical: 'invalid_vertical',
    target_cpa: '-10', // Negative value
    daily_budget: 'not a number',
  },
  validRegistration: {
    email: 'newuser@test.com',
    password: 'SecurePass123!',
    confirmPassword: 'SecurePass123!',
    company: 'Test Company',
    phone: '5551234567',
    role: 'supplier',
  },
}
```

# Analytics Fixtures

```tsx
export const testAnalytics = {
  campaignMetrics: {
    totalCalls: 1250,
    conversionRate: 12.5,
    averageCallDuration: 145,
    revenue: 15625.5,
    costPerAcquisition: 45.75,
    qualityScore: 7.8,
  },
  supplierStats: {
    totalCalls: 3450,
    acceptedCalls: 3105,
    rejectedCalls: 345,
    totalEarnings: 45678.9,
    averageQuality: 8.2,
    fraudScore: 0.02,
  },
}
```

# Error Fixtures

```tsx
export const testErrors = {
  networkError: new Error('Network request failed'),
  validationError: {
    field: 'email',
    message: 'Invalid email format',
  },
  authError: {
    code: 'auth/invalid-credentials',
    message: 'Invalid email or password',
  },
  serverError: {
    status: 500,
    message: 'Internal server error',
  },
}
```

# Fixture Utilities

```tsx
export function seedDatabase() {
  // Utility to seed test database
  return {
    users: Object.values(testUsers),
    campaigns: Object.values(testCampaigns),
    calls: generateCallBatch(100),
  }
}

export function resetFixtures() {
  // Reset all fixtures to original state
  Object.keys(testUsers).forEach((key) => {
    testUsers[key].id = testUsers[key].id
  })
}

export function generateMockData(type: string, count: number) {
  switch (type) {
    case 'calls':
      return generateCallBatch(count)
    case 'campaigns':
      return Array.from({ length: count }, () => createCampaign())
    default:
      throw new Error(`Unknown fixture type: ${type}`)
  }
}
```

# CRITICAL RULES

- NO production data in fixtures
- NO real API keys or secrets
- ALWAYS use consistent IDs
- ALWAYS provide edge case data
- ALWAYS include error scenarios
- USE factories for dynamic data
- KEEP fixtures maintainable
- UPDATE fixtures when schema changes
- TEST both valid and invalid data
- DOCUMENT complex fixture relationships
</file>

<file path="tests/fixtures/index.ts">
export * from './users'
export * from './campaigns'
export * from './calls'

// Factory helper to create multiple instances
export const createMany = <T>(factory: () => T, count: number): T[] => {
  return Array.from({ length: count }, factory)
}

// Utility to create test data with relationships
export const createTestScenario = () => {
  const supplier = createTestSupplier({ email: 'supplier@scenario.com' })
  const buyer = createTestBuyer({ email: 'buyer@scenario.com' })
  const campaign = createTestCampaign({ buyerId: buyer.id })
  const calls = createMany(() => createTestCall({ 
    campaignId: campaign.id,
    supplierId: supplier.id,
    buyerId: buyer.id 
  }), 5)
  
  return { supplier, buyer, campaign, calls }
}

// Re-export specific test data sets
export { testUsers } from './users'
export { testCampaigns } from './campaigns'  
export { testCalls } from './calls'
</file>

<file path="tests/fixtures/users.ts">
export interface TestUser {
  id: string
  email: string
  password: string
  firstName: string
  lastName: string
  userType: 'supplier' | 'buyer' | 'admin'
  isActive: boolean
  createdAt: string
}

export interface TestSupplier extends TestUser {
  userType: 'supplier'
  company: string
  trafficSources: string[]
  phoneNumbers: string[]
  payoutMethods: string[]
}

export interface TestBuyer extends TestUser {
  userType: 'buyer'
  company: string
  industry: string
  creditLimit: number
  paymentMethods: string[]
}

export interface TestAdmin extends TestUser {
  userType: 'admin'
  permissions: string[]
  lastLoginAt: string
}

export const createTestUser = (overrides: Partial<TestUser> = {}): TestUser => ({
  id: `user_${Math.random().toString(36).substr(2, 9)}`,
  email: `test${Math.random().toString(36).substr(2, 5)}@example.com`,
  password: 'TestPassword123!',
  firstName: 'Test',
  lastName: 'User',
  userType: 'supplier',
  isActive: true,
  createdAt: new Date().toISOString(),
  ...overrides,
})

export const createTestSupplier = (overrides: Partial<TestSupplier> = {}): TestSupplier => ({
  ...createTestUser({ userType: 'supplier' }),
  company: 'Test Traffic Co',
  trafficSources: ['Google Ads', 'Facebook', 'SEO'],
  phoneNumbers: ['+1-555-0123'],
  payoutMethods: ['ACH', 'PayPal'],
  ...overrides,
})

export const createTestBuyer = (overrides: Partial<TestBuyer> = {}): TestBuyer => ({
  ...createTestUser({ userType: 'buyer' }),
  company: 'Test Business Inc',
  industry: 'Home Services',
  creditLimit: 10000,
  paymentMethods: ['Credit Card', 'ACH'],
  ...overrides,
})

export const createTestAdmin = (overrides: Partial<TestAdmin> = {}): TestAdmin => ({
  ...createTestUser({ userType: 'admin' }),
  permissions: ['manage_users', 'manage_campaigns', 'view_reports'],
  lastLoginAt: new Date().toISOString(),
  ...overrides,
})

export const testUsers = {
  activeSupplier: createTestSupplier({
    email: 'supplier@test.com',
    firstName: 'Sarah',
    lastName: 'Supplier',
    company: 'Quality Leads LLC',
  }),
  activeBuyer: createTestBuyer({
    email: 'buyer@test.com',
    firstName: 'Bob',
    lastName: 'Buyer',
    company: 'Home Services Pro',
  }),
  admin: createTestAdmin({
    email: 'admin@test.com',
    firstName: 'Alice',
    lastName: 'Admin',
  }),
}
</file>

<file path="tests/integration/CLAUDE.md">
# Integration Test Patterns

# Test Structure

```
integration/
â”œâ”€â”€ api/           # API endpoint tests
â”œâ”€â”€ database/      # Database operation tests
â”œâ”€â”€ workflows/     # Multi-step process tests
â”œâ”€â”€ webhooks/      # Webhook handler tests
â””â”€â”€ services/      # Service integration tests
```

# API Integration Tests

```tsx
// api/campaigns.test.ts
import { describe, it, expect, beforeAll } from 'vitest'
import { createTestClient } from '../helpers/test-client'
import { testUsers, testCampaigns } from '@/tests/fixtures'

describe('Campaign API Integration', () => {
  let client: TestClient
  let authToken: string

  beforeAll(async () => {
    client = createTestClient()
    authToken = await client.authenticate(testUsers.buyer)
  })

  describe('POST /api/campaigns', () => {
    it('should create campaign with valid data', async () => {
      const response = await client.post('/api/campaigns', {
        headers: { Authorization: `Bearer ${authToken}` },
        body: testCampaigns.active,
      })

      expect(response.status).toBe(201)
      expect(response.data).toMatchObject({
        name: testCampaigns.active.name,
        status: 'draft', // New campaigns start as draft
      })
    })

    it('should validate required fields', async () => {
      const response = await client.post('/api/campaigns', {
        headers: { Authorization: `Bearer ${authToken}` },
        body: { name: '' }, // Missing required fields
      })

      expect(response.status).toBe(400)
      expect(response.error).toContain('validation')
    })
  })
})
```

# Database Integration Tests

```tsx
// database/user-operations.test.ts
import { describe, it, expect, beforeEach } from 'vitest'
import { supabase } from '@/lib/supabase'
import { testUsers } from '@/tests/fixtures'

describe('User Database Operations', () => {
  beforeEach(async () => {
    // Clean up test data
    await supabase.from('users').delete().eq('email', 'integration@test.com')
  })

  it('should create user with profile', async () => {
    const { data, error } = await supabase
      .from('users')
      .insert({
        email: 'integration@test.com',
        role: 'supplier',
        profile: {
          company: 'Integration Test Co',
          phone: '5551234567',
        },
      })
      .select()
      .single()

    expect(error).toBeNull()
    expect(data).toMatchObject({
      email: 'integration@test.com',
      role: 'supplier',
    })
  })

  it('should enforce unique email constraint', async () => {
    // Insert first user
    await supabase.from('users').insert({
      email: 'duplicate@test.com',
      role: 'buyer',
    })

    // Try to insert duplicate
    const { error } = await supabase.from('users').insert({
      email: 'duplicate@test.com',
      role: 'supplier',
    })

    expect(error).toBeDefined()
    expect(error?.code).toBe('23505') // Unique violation
  })
})
```

# Workflow Integration Tests

```tsx
// workflows/call-lifecycle.test.ts
describe('Call Lifecycle Workflow', () => {
  it('should complete full call workflow', async () => {
    // 1. Supplier logs in
    const supplier = await authService.login(testUsers.supplier.email, testUsers.supplier.password)

    // 2. Get tracking number
    const tracking = await callService.generateTrackingNumber(
      testCampaigns.active.id,
      supplier.user.id
    )

    // 3. Start call
    const call = await callService.startCall({
      tracking_number: tracking.number,
      caller_number: '4155551234',
    })

    // 4. Simulate call duration
    await new Promise((resolve) => setTimeout(resolve, 2000))

    // 5. End call
    const completed = await callService.endCall(call.id, {
      duration: 120,
      quality_score: 8,
    })

    // 6. Verify payout calculation
    expect(completed.payout_amount).toBeGreaterThan(0)
    expect(completed.status).toBe('completed')

    // 7. Check analytics update
    const analytics = await analyticsService.getCampaignMetrics(testCampaigns.active.id)
    expect(analytics.totalCalls).toBeGreaterThanOrEqual(1)
  })
})
```

# Service Integration Tests

```tsx
// services/stripe-integration.test.ts
import { describe, it, expect, vi } from 'vitest'
import { BillingService } from '@/services/billing'
import { stripe } from '@/integrations/stripe'

describe('Stripe Integration', () => {
  let billingService: BillingService

  beforeEach(() => {
    billingService = new BillingService(stripe)
  })

  it('should create payment intent', async () => {
    const result = await billingService.createPaymentIntent({
      amount: 100.0,
      currency: 'usd',
      customer_id: 'cus_test_123',
    })

    expect(result.id).toMatch(/^pi_/)
    expect(result.amount).toBe(10000) // Cents
    expect(result.currency).toBe('usd')
  })

  it('should handle payment failures', async () => {
    // Mock failed payment
    vi.spyOn(stripe.paymentIntents, 'create').mockRejectedValue(new Error('Card declined'))

    await expect(
      billingService.processPayment({
        amount: 100.0,
        payment_method: 'pm_card_declined',
      })
    ).rejects.toThrow('Card declined')
  })
})
```

# Webhook Integration Tests

```tsx
// webhooks/stripe-webhooks.test.ts
import { describe, it, expect } from 'vitest'
import { handleStripeWebhook } from '@/api/webhooks/stripe'
import { stripe } from '@/integrations/stripe'

describe('Stripe Webhook Integration', () => {
  it('should handle payment success webhook', async () => {
    const payload = {
      id: 'evt_test_123',
      type: 'payment_intent.succeeded',
      data: {
        object: {
          id: 'pi_test_123',
          amount: 5000,
          currency: 'usd',
          metadata: {
            user_id: testUsers.buyer.id,
            campaign_id: testCampaigns.active.id,
          },
        },
      },
    }

    const signature = stripe.webhooks.generateTestHeaderString({
      payload: JSON.stringify(payload),
      secret: process.env.STRIPE_WEBHOOK_SECRET!,
    })

    const response = await handleStripeWebhook(JSON.stringify(payload), signature)

    expect(response.success).toBe(true)

    // Verify transaction was recorded
    const { data: transaction } = await supabase
      .from('transactions')
      .select()
      .eq('stripe_payment_intent_id', 'pi_test_123')
      .single()

    expect(transaction).toBeDefined()
    expect(transaction.status).toBe('succeeded')
  })
})
```

# Real-time Integration Tests

```tsx
// integration/realtime-updates.test.ts
describe('Real-time Updates', () => {
  it('should receive call status updates', async () => {
    const updates: any[] = []

    // Subscribe to updates
    const channel = supabase
      .channel('test-calls')
      .on(
        'postgres_changes',
        {
          event: 'UPDATE',
          schema: 'public',
          table: 'calls',
        },
        (payload) => {
          updates.push(payload)
        }
      )
      .subscribe()

    // Wait for subscription
    await new Promise((resolve) => setTimeout(resolve, 1000))

    // Create and update call
    const { data: call } = await supabase
      .from('calls')
      .insert({
        campaign_id: testCampaigns.active.id,
        supplier_id: testUsers.supplier.id,
        tracking_number: '18005559999',
        status: 'active',
      })
      .select()
      .single()

    // Update call status
    await supabase.from('calls').update({ status: 'completed' }).eq('id', call.id)

    // Wait for update
    await new Promise((resolve) => setTimeout(resolve, 1000))

    // Verify update received
    expect(updates).toHaveLength(1)
    expect(updates[0].new.status).toBe('completed')

    // Cleanup
    supabase.removeChannel(channel)
  })
})
```

# Multi-Service Integration

```tsx
// integration/campaign-creation-flow.test.ts
describe('Campaign Creation Flow', () => {
  it('should create campaign with all integrations', async () => {
    // 1. Create campaign in database
    const campaign = await campaignService.create({
      name: 'Integration Test Campaign',
      buyer_id: testUsers.buyer.id,
      vertical: 'insurance',
      target_cpa: 50,
      daily_budget: 1000,
    })

    // 2. Set up Stripe billing
    const subscription = await billingService.createCampaignSubscription({
      campaign_id: campaign.id,
      plan: 'pro',
      payment_method: 'pm_test_123',
    })

    // 3. Initialize analytics
    await analyticsService.initializeCampaignMetrics(campaign.id)

    // 4. Configure fraud detection
    await fraudService.setupCampaignRules(campaign.id, {
      duplicate_threshold: 3,
      min_call_duration: 30,
    })

    // 5. Verify all integrations
    const fullCampaign = await campaignService.getWithIntegrations(campaign.id)

    expect(fullCampaign).toMatchObject({
      id: campaign.id,
      subscription: { status: 'active' },
      analytics: { totalCalls: 0 },
      fraud_rules: { duplicate_threshold: 3 },
    })
  })
})
```

# Error Handling Integration

```tsx
describe('Error Handling Across Services', () => {
  it('should rollback on partial failure', async () => {
    // Mock stripe failure
    vi.spyOn(stripe.subscriptions, 'create').mockRejectedValue(new Error('Payment failed'))

    await expect(
      campaignService.createWithBilling({
        campaign: testCampaigns.active,
        payment_method: 'pm_card_declined',
      })
    ).rejects.toThrow()

    // Verify campaign was not created
    const { data: campaigns } = await supabase
      .from('campaigns')
      .select()
      .eq('name', testCampaigns.active.name)

    expect(campaigns).toHaveLength(0)
  })
})
```

# Performance Integration Tests

```tsx
describe('Integration Performance', () => {
  it('should handle concurrent operations', async () => {
    const operations = Array.from({ length: 10 }, (_, i) =>
      callService.startCall({
        campaign_id: testCampaigns.active.id,
        supplier_id: testUsers.supplier.id,
        caller_number: `415555${i.toString().padStart(4, '0')}`,
      })
    )

    const start = performance.now()
    const results = await Promise.all(operations)
    const duration = performance.now() - start

    expect(results).toHaveLength(10)
    expect(duration).toBeLessThan(5000) // Should complete within 5s
  })
})
```

# Test Helpers

```tsx
// helpers/test-client.ts
export class TestClient {
  constructor(private baseURL = 'http://localhost:3000') {}

  async authenticate(user: TestUser): Promise<string> {
    const response = await fetch(`${this.baseURL}/api/auth/login`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        email: user.email,
        password: user.password,
      }),
    })

    const data = await response.json()
    return data.access_token
  }

  async post(endpoint: string, options: RequestOptions) {
    return this.request('POST', endpoint, options)
  }

  private async request(method: string, endpoint: string, options: RequestOptions) {
    const response = await fetch(`${this.baseURL}${endpoint}`, {
      method,
      headers: {
        'Content-Type': 'application/json',
        ...options.headers,
      },
      body: JSON.stringify(options.body),
    })

    const data = await response.json()
    return {
      status: response.status,
      data: response.ok ? data : null,
      error: !response.ok ? data : null,
    }
  }
}
```

# Environment Setup

```tsx
// setup.ts
import { beforeAll, afterAll } from 'vitest'

beforeAll(async () => {
  // Set up test database
  await setupTestDatabase()

  // Initialize test services
  await initializeServices()

  // Mock external APIs if needed
  mockExternalAPIs()
})

afterAll(async () => {
  // Clean up test data
  await cleanupTestData()

  // Close connections
  await closeConnections()
})
```

# CRITICAL RULES

- NO regex in integration tests
- NO any types in test code
- ALWAYS clean up test data
- ALWAYS use test database
- ALWAYS mock external services
- ALWAYS test error scenarios
- ALWAYS verify side effects
- TEST real integration points
- ISOLATE tests from each other
- MONITOR test execution time
</file>

<file path="tests/performance/CLAUDE.md">
# Performance Test Patterns

# Test Structure

```
performance/
â”œâ”€â”€ load/          # Load testing scenarios
â”œâ”€â”€ stress/        # Stress testing limits
â”œâ”€â”€ benchmarks/    # Performance benchmarks
â””â”€â”€ profiling/     # Performance profiling
```

# Load Testing Patterns

```tsx
// load/concurrent-users.test.ts
import { describe, it, expect } from 'vitest'
import { loadTest } from '../helpers/load-test'

describe('Concurrent User Load Tests', () => {
  it('should handle 100 concurrent users', async () => {
    const results = await loadTest({
      virtualUsers: 100,
      duration: '30s',
      scenario: async (userId) => {
        // Simulate user journey
        await login(`user${userId}@test.com`, 'password')
        await browseCampaigns()
        await viewCampaignDetails()
        await generateTrackingNumber()
      },
    })

    expect(results.successRate).toBeGreaterThan(0.95) // 95% success
    expect(results.avgResponseTime).toBeLessThan(1000) // Under 1s
    expect(results.p95ResponseTime).toBeLessThan(2000) // 95th percentile under 2s
  })
})
```

# API Performance Tests

```tsx
// load/api-endpoints.test.ts
describe('API Endpoint Performance', () => {
  const endpoints = [
    { path: '/api/campaigns', method: 'GET' },
    { path: '/api/calls', method: 'GET' },
    { path: '/api/analytics/dashboard', method: 'GET' },
  ]

  endpoints.forEach(({ path, method }) => {
    it(`should handle load on ${method} ${path}`, async () => {
      const results = await loadTest({
        virtualUsers: 50,
        duration: '1m',
        scenario: async () => {
          const start = performance.now()
          const response = await fetch(path, { method })
          const duration = performance.now() - start

          return {
            status: response.status,
            duration,
          }
        },
      })

      expect(results.errorRate).toBeLessThan(0.01) // Less than 1% errors
      expect(results.avgResponseTime).toBeLessThan(500) // Under 500ms avg
    })
  })
})
```

# Database Performance Tests

```tsx
// performance/database-queries.test.ts
describe('Database Query Performance', () => {
  it('should execute campaign queries efficiently', async () => {
    const queries = [
      // Complex join query
      async () => {
        const start = performance.now()
        const { data } = await supabase
          .from('campaigns')
          .select(
            `
            *,
            calls (count),
            transactions (sum(amount))
          `
          )
          .eq('status', 'active')
          .limit(50)
        return performance.now() - start
      },

      // Aggregation query
      async () => {
        const start = performance.now()
        const { data } = await supabase.rpc('get_campaign_analytics', {
          campaign_id: testCampaigns.active.id,
          date_from: '2024-01-01',
          date_to: '2024-12-31',
        })
        return performance.now() - start
      },
    ]

    const durations = await Promise.all(queries.map((q) => q()))

    durations.forEach((duration) => {
      expect(duration).toBeLessThan(100) // Each query under 100ms
    })
  })
})
```

# Real-time Performance Tests

```tsx
// performance/realtime-subscriptions.test.ts
describe('Real-time Subscription Performance', () => {
  it('should handle multiple simultaneous subscriptions', async () => {
    const subscriptionCount = 100
    const channels: RealtimeChannel[] = []
    const messageReceived: number[] = []

    // Create subscriptions
    const startSubscribe = performance.now()
    for (let i = 0; i < subscriptionCount; i++) {
      const channel = supabase
        .channel(`test-channel-${i}`)
        .on('broadcast', { event: 'test' }, () => {
          messageReceived.push(performance.now())
        })
        .subscribe()

      channels.push(channel)
    }
    const subscribeTime = performance.now() - startSubscribe

    // Wait for all subscriptions
    await new Promise((resolve) => setTimeout(resolve, 2000))

    // Broadcast message
    const broadcastStart = performance.now()
    await supabase.channel('test-broadcast').send({
      type: 'broadcast',
      event: 'test',
      payload: { message: 'test' },
    })

    // Wait for messages
    await new Promise((resolve) => setTimeout(resolve, 1000))

    // Calculate latencies
    const latencies = messageReceived.map((time) => time - broadcastStart)
    const avgLatency = latencies.reduce((a, b) => a + b, 0) / latencies.length

    expect(subscribeTime).toBeLessThan(5000) // Subscribe all within 5s
    expect(avgLatency).toBeLessThan(100) // Avg latency under 100ms
    expect(messageReceived.length).toBeGreaterThan(90) // 90% delivery

    // Cleanup
    channels.forEach((ch) => supabase.removeChannel(ch))
  })
})
```

# Frontend Performance Tests

```tsx
// performance/rendering.test.ts
import { render } from '@testing-library/react'
import { measureRender } from '../helpers/performance'

describe('Component Rendering Performance', () => {
  it('should render dashboard efficiently', async () => {
    const metrics = await measureRender(() => {
      render(<DashboardPage />)
    })

    expect(metrics.renderTime).toBeLessThan(50) // Initial render under 50ms
    expect(metrics.layoutTime).toBeLessThan(20) // Layout under 20ms
  })

  it('should handle large lists efficiently', async () => {
    const largeData = generateCallBatch(1000)

    const metrics = await measureRender(() => {
      render(<CallList calls={largeData} />)
    })

    expect(metrics.renderTime).toBeLessThan(200) // Under 200ms for 1000 items
    expect(metrics.memoryUsage).toBeLessThan(50 * 1024 * 1024) // Under 50MB
  })
})
```

# Memory Performance Tests

```tsx
// performance/memory-usage.test.ts
describe('Memory Usage Tests', () => {
  it('should not leak memory during operations', async () => {
    const initialMemory = performance.memory.usedJSHeapSize

    // Perform operations that might leak
    for (let i = 0; i < 100; i++) {
      const calls = generateCallBatch(100)
      const processed = calls.map((call) => ({
        ...call,
        formatted: formatCallDuration(call.duration),
        quality: calculateQualityScore(call),
      }))

      // Simulate component mounting/unmounting
      const { unmount } = render(<CallList calls={processed} />)
      unmount()
    }

    // Force garbage collection if available
    if (global.gc) global.gc()

    await new Promise((resolve) => setTimeout(resolve, 1000))

    const finalMemory = performance.memory.usedJSHeapSize
    const memoryIncrease = finalMemory - initialMemory

    // Allow for some memory increase but not excessive
    expect(memoryIncrease).toBeLessThan(10 * 1024 * 1024) // Less than 10MB increase
  })
})
```

# Stress Testing

```tsx
// stress/system-limits.test.ts
describe('System Stress Tests', () => {
  it('should handle burst traffic', async () => {
    const results = await stressTest({
      pattern: 'burst',
      peakUsers: 500,
      duration: '10s',
      rampUp: '1s',
    })

    expect(results.crashPoint).toBeUndefined() // System shouldn't crash
    expect(results.degradationPoint).toBeGreaterThan(300) // Handle 300+ users
  })

  it('should recover from overload', async () => {
    // Overload system
    await stressTest({
      virtualUsers: 1000,
      duration: '30s',
    })

    // Wait for recovery
    await new Promise((resolve) => setTimeout(resolve, 5000))

    // Test normal operation
    const recoveryTest = await loadTest({
      virtualUsers: 10,
      duration: '10s',
      scenario: async () => {
        const response = await fetch('/api/health')
        return response.status
      },
    })

    expect(recoveryTest.successRate).toBe(1) // Full recovery
  })
})
```

# Call Volume Performance

```tsx
// performance/call-volume.test.ts
describe('High Call Volume Performance', () => {
  it('should process high call volume', async () => {
    const callsPerSecond = 50
    const duration = 60 // 1 minute
    const totalCalls = callsPerSecond * duration

    const start = performance.now()
    const results = []

    for (let second = 0; second < duration; second++) {
      const batch = Array.from({ length: callsPerSecond }, () =>
        callService.startCall({
          campaign_id: testCampaigns.active.id,
          supplier_id: testUsers.supplier.id,
          caller_number: generatePhoneNumber(),
        })
      )

      const batchStart = performance.now()
      const batchResults = await Promise.allSettled(batch)
      const batchDuration = performance.now() - batchStart

      results.push({
        second,
        processed: batchResults.filter((r) => r.status === 'fulfilled').length,
        failed: batchResults.filter((r) => r.status === 'rejected').length,
        duration: batchDuration,
      })

      // Wait for next second
      const elapsed = performance.now() - start
      const waitTime = Math.max(0, (second + 1) * 1000 - elapsed)
      await new Promise((resolve) => setTimeout(resolve, waitTime))
    }

    const totalProcessed = results.reduce((sum, r) => sum + r.processed, 0)
    const avgDuration = results.reduce((sum, r) => sum + r.duration, 0) / results.length

    expect(totalProcessed / totalCalls).toBeGreaterThan(0.95) // 95% processed
    expect(avgDuration).toBeLessThan(1000) // Process batch within 1s
  })
})
```

# Performance Benchmarks

```tsx
// benchmarks/operations.bench.ts
import { bench, describe } from 'vitest'

describe('Operation Benchmarks', () => {
  bench('format phone number', () => {
    formatPhoneNumber('4155551234')
  })

  bench('calculate quality score', () => {
    calculateQualityScore(180, true, 0.1)
  })

  bench('validate campaign data', () => {
    campaignSchema.parse(testCampaigns.active)
  })

  bench('generate tracking number', () => {
    generateTrackingNumber()
  })
})
```

# Performance Monitoring

```tsx
// helpers/performance-monitor.ts
export class PerformanceMonitor {
  private metrics: Map<string, number[]> = new Map()

  measure<T>(name: string, fn: () => T): T {
    const start = performance.now()
    const result = fn()
    const duration = performance.now() - start

    if (!this.metrics.has(name)) {
      this.metrics.set(name, [])
    }
    this.metrics.get(name)!.push(duration)

    return result
  }

  getStats(name: string) {
    const measurements = this.metrics.get(name) || []
    if (measurements.length === 0) return null

    const sorted = [...measurements].sort((a, b) => a - b)
    return {
      min: sorted[0],
      max: sorted[sorted.length - 1],
      avg: sorted.reduce((a, b) => a + b, 0) / sorted.length,
      p50: sorted[Math.floor(sorted.length * 0.5)],
      p95: sorted[Math.floor(sorted.length * 0.95)],
      p99: sorted[Math.floor(sorted.length * 0.99)],
    }
  }
}
```

# Performance Test Configuration

```tsx
// performance.config.ts
export const performanceThresholds = {
  api: {
    avgResponseTime: 500, // ms
    p95ResponseTime: 1000,
    p99ResponseTime: 2000,
    errorRate: 0.01, // 1%
  },
  database: {
    queryTime: 100, // ms
    connectionPoolSize: 20,
  },
  frontend: {
    initialRender: 100, // ms
    reRender: 50,
    bundleSize: 500 * 1024, // 500KB
  },
  realtime: {
    subscriptionTime: 1000, // ms
    messageLatency: 100,
    deliveryRate: 0.99, // 99%
  },
}
```

# Performance Utilities

```tsx
// helpers/load-test.ts
export async function loadTest(options: LoadTestOptions) {
  const results = {
    totalRequests: 0,
    successfulRequests: 0,
    failedRequests: 0,
    durations: [] as number[],
  }

  const promises = []
  for (let i = 0; i < options.virtualUsers; i++) {
    promises.push(runScenario(options.scenario, i, results))
  }

  await Promise.all(promises)

  return calculateMetrics(results)
}

function calculateMetrics(results: TestResults) {
  const sorted = [...results.durations].sort((a, b) => a - b)
  return {
    successRate: results.successfulRequests / results.totalRequests,
    errorRate: results.failedRequests / results.totalRequests,
    avgResponseTime: sorted.reduce((a, b) => a + b, 0) / sorted.length,
    p95ResponseTime: sorted[Math.floor(sorted.length * 0.95)],
    p99ResponseTime: sorted[Math.floor(sorted.length * 0.99)],
  }
}
```

# CRITICAL RULES

- NO regex in performance tests
- NO any types in test code
- ALWAYS establish baselines first
- ALWAYS test under realistic conditions
- ALWAYS measure before optimizing
- ALWAYS clean up after tests
- TEST both average and worst cases
- MONITOR memory usage
- PROFILE hot code paths
- DOCUMENT performance requirements
</file>

<file path="tests/unit/components/payments/PaymentModal.test.tsx">
import { render, screen, fireEvent, waitFor } from '@testing-library/react'
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { PaymentModal } from '@/components/payments/PaymentModal'

// Mock the payment components
type QuickTopUpProps = { 
  onSuccess: (paymentId: string, amount: number) => void; 
  onCancel: () => void 
}

type PaymentFormProps = { 
  onSuccess: (paymentId: string) => void 
}

vi.mock('@/components/payments/QuickTopUpForm', () => ({
  default: ({ onSuccess, onCancel }: QuickTopUpProps) => (
    <div data-testid="quick-topup-form">
      <button onClick={() => onSuccess('pi_test123', 100)}>Complete Payment</button>
      <button onClick={onCancel}>Cancel</button>
    </div>
  ),
}))

vi.mock('@/components/payments/PaymentForm', () => ({
  default: ({ onSuccess }: PaymentFormProps) => (
    <div data-testid="payment-form">
      <button onClick={() => onSuccess('pi_invoice123')}>Pay Invoice</button>
    </div>
  ),
}))

describe('PaymentModal', () => {
  const defaultProps = {
    isOpen: true,
    onClose: vi.fn(),
    type: 'topup' as const,
    onSuccess: vi.fn(),
  }

  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('should render topup form when type is topup', () => {
    render(<PaymentModal {...defaultProps} />)
    
    expect(screen.getByText('Add Funds')).toBeInTheDocument()
    expect(screen.getByTestId('quick-topup-form')).toBeInTheDocument()
  })

  it('should render payment form when type is invoice with invoice data', () => {
    const invoiceProps = {
      ...defaultProps,
      type: 'invoice' as const,
      invoiceData: {
        amount: 10000,
        invoiceId: 'inv_123',
        description: 'Test Invoice',
        billingPeriod: '2024-01',
      },
    }

    render(<PaymentModal {...invoiceProps} />)
    
    expect(screen.getByText('Pay Invoice')).toBeInTheDocument()
    expect(screen.getByTestId('payment-form')).toBeInTheDocument()
  })

  it('should show error message when invoice type but no invoice data', () => {
    const invoiceProps = {
      ...defaultProps,
      type: 'invoice' as const,
      invoiceData: undefined,
    }

    render(<PaymentModal {...invoiceProps} />)
    
    expect(screen.getByText('No invoice data provided')).toBeInTheDocument()
  })

  it('should call onClose when close button is clicked', () => {
    render(<PaymentModal {...defaultProps} />)
    
    const closeButton = screen.getByRole('button', { name: /close/i })
    fireEvent.click(closeButton)
    
    expect(defaultProps.onClose).toHaveBeenCalled()
  })

  it('should call onSuccess and close modal after successful payment', async () => {
    render(<PaymentModal {...defaultProps} />)
    
    const completeButton = screen.getByText('Complete Payment')
    fireEvent.click(completeButton)
    
    expect(defaultProps.onSuccess).toHaveBeenCalledWith('pi_test123', 100)
    
    // Modal should close after 2 seconds
    await waitFor(
      () => {
        expect(defaultProps.onClose).toHaveBeenCalled()
      },
      { timeout: 3000 }
    )
  })

  it('should not render when isOpen is false', () => {
    const closedProps = { ...defaultProps, isOpen: false }
    const { container } = render(<PaymentModal {...closedProps} />)
    
    // Check that modal content is not visible
    expect(container.querySelector('[role="dialog"]')).not.toBeInTheDocument()
  })

  it('should handle cancel action in topup form', () => {
    render(<PaymentModal {...defaultProps} />)
    
    const cancelButton = screen.getByText('Cancel')
    fireEvent.click(cancelButton)
    
    expect(defaultProps.onClose).toHaveBeenCalled()
  })

  it('should pass correct invoice data to payment form', () => {
    const invoiceData = {
      amount: 15000,
      invoiceId: 'inv_456',
      description: 'Monthly subscription',
      billingPeriod: '2024-02',
    }

    render(
      <PaymentModal
        {...defaultProps}
        type="invoice"
        invoiceData={invoiceData}
      />
    )

    // Verify the payment form is rendered (mocked component)
    expect(screen.getByTestId('payment-form')).toBeInTheDocument()
  })
})
</file>

<file path="tests/unit/components/payments/QuickTopUpForm.test.tsx">
import { render, screen, fireEvent, waitFor } from '@testing-library/react'
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { QuickTopUpForm } from '@/components/payments/QuickTopUpForm'

// Mock dependencies
vi.mock('@/hooks/useAuth', () => ({
  useAuth: () => ({
    user: {
      id: 'user_123',
      email: 'test@example.com',
      stripe_customer_id: 'cus_test123',
    },
  }),
}))

vi.mock('@/store/buyerStore', () => ({
  useBuyerStore: () => ({
    currentBalance: 500.00,
    updateBalance: vi.fn(),
  }),
}))

vi.mock('@/integrations/stripe/payments', () => ({
  createPaymentIntent: vi.fn().mockResolvedValue({
    id: 'pi_test123',
    client_secret: 'pi_test123_secret',
    amount: 10000,
    currency: 'usd',
  }),
}))

// Mock Stripe Elements
vi.mock('@stripe/react-stripe-js', async () => {
  const actual = await vi.importActual('@stripe/react-stripe-js')
  return {
    ...actual,
    PaymentElement: () => <div data-testid="payment-element">Payment Element</div>,
    useStripe: () => ({
      confirmPayment: vi.fn().mockResolvedValue({
        paymentIntent: {
          id: 'pi_test123',
          status: 'succeeded',
        },
      }),
    }),
    useElements: () => ({}),
  }
})

describe('QuickTopUpForm', () => {
  const defaultProps = {
    onSuccess: vi.fn(),
    onCancel: vi.fn(),
  }

  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('should render with default amount selected', async () => {
    render(<QuickTopUpForm {...defaultProps} />)
    
    await waitFor(() => {
      expect(screen.getByText('Quick Top-Up')).toBeInTheDocument()
      expect(screen.getByText('Current Balance')).toBeInTheDocument()
      expect(screen.getByText('$500.00')).toBeInTheDocument()
    })
  })

  it('should display quick amount buttons', async () => {
    render(<QuickTopUpForm {...defaultProps} />)
    
    await waitFor(() => {
      expect(screen.getByText('$100')).toBeInTheDocument()
      expect(screen.getByText('$250')).toBeInTheDocument()
      expect(screen.getByText('$500')).toBeInTheDocument()
      expect(screen.getByText('$1000')).toBeInTheDocument()
    })
  })

  it('should allow selecting different quick amounts', async () => {
    render(<QuickTopUpForm {...defaultProps} />)
    
    await waitFor(() => {
      const button500 = screen.getByText('$500')
      fireEvent.click(button500)
      
      // Check that the button has the selected style (by checking class)
      expect(button500.className).toContain('border-blue-600')
    })
  })

  it('should allow entering custom amount', async () => {
    render(<QuickTopUpForm {...defaultProps} />)
    
    await waitFor(() => {
      const customInput = screen.getByPlaceholderText('Enter custom amount')
      fireEvent.change(customInput, { target: { value: '750.50' } })
      
      expect(customInput).toHaveValue('750.50')
    })
  })

  it('should validate minimum amount', async () => {
    render(<QuickTopUpForm {...defaultProps} />)
    
    await waitFor(() => {
      const customInput = screen.getByPlaceholderText('Enter custom amount')
      fireEvent.change(customInput, { target: { value: '5' } })
      fireEvent.focus(customInput)
    })

    // Note: In the real component, validation happens on submit
    // This test would need to be extended to test the actual validation
  })

  it('should only allow numeric input for custom amount', async () => {
    render(<QuickTopUpForm {...defaultProps} />)
    
    await waitFor(() => {
      const customInput = screen.getByPlaceholderText('Enter custom amount')
      
      // Try to enter non-numeric characters
      fireEvent.change(customInput, { target: { value: 'abc' } })
      expect(customInput).toHaveValue('')
      
      // Allow numeric input
      fireEvent.change(customInput, { target: { value: '123.45' } })
      expect(customInput).toHaveValue('123.45')
    })
  })

  it('should show loading state while creating payment intent', () => {
    render(<QuickTopUpForm {...defaultProps} />)
    
    expect(screen.getByText('Setting up payment...')).toBeInTheDocument()
  })

  it('should handle payment intent creation error', async () => {
    const createPaymentIntent = vi.fn().mockRejectedValue(new Error('Network error'))
    vi.doMock('@/integrations/stripe/payments', () => ({
      createPaymentIntent,
    }))

    render(<QuickTopUpForm {...defaultProps} />)
    
    await waitFor(() => {
      expect(screen.getByText(/Network error/i)).toBeInTheDocument()
      expect(screen.getByText('Try again')).toBeInTheDocument()
    })
  })

  it('should call onCancel when cancel button is clicked', async () => {
    render(<QuickTopUpForm {...defaultProps} />)
    
    await waitFor(() => {
      const cancelButton = screen.getByText('Cancel')
      fireEvent.click(cancelButton)
      
      expect(defaultProps.onCancel).toHaveBeenCalled()
    })
  })

  it('should handle successful payment submission', async () => {
    // This would require more complex mocking of Stripe Elements
    // and the payment flow, which is typically done in integration tests
  })

  it('should display success message after payment', async () => {
    // This test would need to simulate the full payment flow
    // including mocking the Stripe confirmPayment response
  })

  it('should calculate and display correct amount with custom input', async () => {
    render(<QuickTopUpForm {...defaultProps} />)
    
    await waitFor(() => {
      const customInput = screen.getByPlaceholderText('Enter custom amount')
      fireEvent.change(customInput, { target: { value: '299.99' } })
      fireEvent.focus(customInput)
      
      // The submit button should show the custom amount
      const submitButton = screen.getByRole('button', { name: /add \$299.99/i })
      expect(submitButton).toBeInTheDocument()
    })
  })
})
</file>

<file path="tests/unit/components/ErrorBoundary.test.tsx">
import React from 'react'
import { render, screen, fireEvent } from '@testing-library/react'
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import ErrorBoundary, {
  withErrorBoundary,
  useErrorHandler,
  ErrorFallbackProps,
} from '../../../src/components/common/ErrorBoundary'

// Mock the monitoring module
vi.mock('../../../src/lib/monitoring', () => ({
  captureError: vi.fn(),
  addBreadcrumb: vi.fn(),
}))

// Mock console methods to avoid noise in tests
const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {})
const consoleGroupSpy = vi.spyOn(console, 'group').mockImplementation(() => {})
const consoleGroupEndSpy = vi.spyOn(console, 'groupEnd').mockImplementation(() => {})

// Test component that throws an error
const ThrowError: React.FC<{ shouldThrow?: boolean; message?: string }> = ({
  shouldThrow = false,
  message = 'Test error',
}) => {
  if (shouldThrow) {
    throw new Error(message)
  }
  return <div>No error</div>
}

// Custom fallback component for testing
const CustomFallback: React.FC<ErrorFallbackProps> = ({ error, resetError, level }) => (
  <div data-testid="custom-fallback">
    <span>Custom fallback - Level: {level}</span>
    <span>Error: {error.message}</span>
    <button onClick={resetError} data-testid="custom-reset">
      Custom Reset
    </button>
  </div>
)

describe('ErrorBoundary', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  afterEach(() => {
    consoleSpy.mockClear()
    consoleGroupSpy.mockClear()
    consoleGroupEndSpy.mockClear()
  })

  describe('Normal rendering', () => {
    it('renders children when no error occurs', () => {
      render(
        <ErrorBoundary>
          <div data-testid="child">Child component</div>
        </ErrorBoundary>
      )

      expect(screen.getByTestId('child')).toBeInTheDocument()
      expect(screen.getByText('Child component')).toBeInTheDocument()
    })

    it('renders multiple children correctly', () => {
      render(
        <ErrorBoundary>
          <div data-testid="child1">Child 1</div>
          <div data-testid="child2">Child 2</div>
        </ErrorBoundary>
      )

      expect(screen.getByTestId('child1')).toBeInTheDocument()
      expect(screen.getByTestId('child2')).toBeInTheDocument()
    })
  })

  describe('Error handling', () => {
    it('catches errors and displays default fallback UI', () => {
      render(
        <ErrorBoundary level="component">
          <ThrowError shouldThrow message="Test error message" />
        </ErrorBoundary>
      )

      expect(screen.getByRole('alert')).toBeInTheDocument()
      expect(screen.getByText('Component Error')).toBeInTheDocument()
      expect(
        screen.getByText('This component encountered an error and cannot be displayed.')
      ).toBeInTheDocument()
      expect(screen.getByText('Try Again')).toBeInTheDocument()
    })

    it('displays different messages based on level prop', () => {
      const { rerender } = render(
        <ErrorBoundary level="page">
          <ThrowError shouldThrow />
        </ErrorBoundary>
      )

      expect(screen.getByText('Page Error')).toBeInTheDocument()
      expect(
        screen.getByText('An unexpected error occurred while loading this page.')
      ).toBeInTheDocument()

      rerender(
        <ErrorBoundary level="section">
          <ThrowError shouldThrow />
        </ErrorBoundary>
      )

      expect(screen.getByText('Section Error')).toBeInTheDocument()
      expect(screen.getByText('An error occurred in this section of the page.')).toBeInTheDocument()
    })

    it('shows reload button for page-level errors', () => {
      render(
        <ErrorBoundary level="page">
          <ThrowError shouldThrow />
        </ErrorBoundary>
      )

      expect(screen.getByText('Try Again')).toBeInTheDocument()
      expect(screen.getByText('Reload Page')).toBeInTheDocument()
    })

    it('does not show reload button for component-level errors', () => {
      render(
        <ErrorBoundary level="component">
          <ThrowError shouldThrow />
        </ErrorBoundary>
      )

      expect(screen.getByText('Try Again')).toBeInTheDocument()
      expect(screen.queryByText('Reload Page')).not.toBeInTheDocument()
    })
  })

  describe('Custom fallback component', () => {
    it('renders custom fallback component when provided', () => {
      render(
        <ErrorBoundary fallback={CustomFallback} level="section">
          <ThrowError shouldThrow message="Custom test error" />
        </ErrorBoundary>
      )

      expect(screen.getByTestId('custom-fallback')).toBeInTheDocument()
      expect(screen.getByText('Custom fallback - Level: section')).toBeInTheDocument()
      expect(screen.getByText('Error: Custom test error')).toBeInTheDocument()
      expect(screen.getByTestId('custom-reset')).toBeInTheDocument()
    })
  })

  describe('Error reset functionality', () => {
    it('resets error state when reset button is clicked', () => {
      const { rerender } = render(
        <ErrorBoundary>
          <ThrowError shouldThrow />
        </ErrorBoundary>
      )

      // Error should be displayed
      expect(screen.getByRole('alert')).toBeInTheDocument()

      // Click reset button
      fireEvent.click(screen.getByText('Try Again'))

      // Rerender with non-throwing component
      rerender(
        <ErrorBoundary>
          <ThrowError shouldThrow={false} />
        </ErrorBoundary>
      )

      // Should show normal content
      expect(screen.getByText('No error')).toBeInTheDocument()
      expect(screen.queryByRole('alert')).not.toBeInTheDocument()
    })

    it('resets with custom fallback reset button', () => {
      const { rerender } = render(
        <ErrorBoundary fallback={CustomFallback}>
          <ThrowError shouldThrow />
        </ErrorBoundary>
      )

      expect(screen.getByTestId('custom-fallback')).toBeInTheDocument()

      fireEvent.click(screen.getByTestId('custom-reset'))

      rerender(
        <ErrorBoundary fallback={CustomFallback}>
          <ThrowError shouldThrow={false} />
        </ErrorBoundary>
      )

      expect(screen.getByText('No error')).toBeInTheDocument()
    })
  })

  describe('Reset on props change', () => {
    it('resets error when resetKeys change', () => {
      let resetKey = 0
      const { rerender } = render(
        <ErrorBoundary resetKeys={[resetKey]} resetOnPropsChange>
          <ThrowError shouldThrow />
        </ErrorBoundary>
      )

      // Error should be displayed
      expect(screen.getByRole('alert')).toBeInTheDocument()

      // Change resetKey
      resetKey = 1
      rerender(
        <ErrorBoundary resetKeys={[resetKey]} resetOnPropsChange>
          <ThrowError shouldThrow={false} />
        </ErrorBoundary>
      )

      // Should show normal content after reset
      expect(screen.getByText('No error')).toBeInTheDocument()
      expect(screen.queryByRole('alert')).not.toBeInTheDocument()
    })
  })

  describe('Error callback', () => {
    it('calls onError callback when error occurs', () => {
      const onErrorSpy = vi.fn()

      render(
        <ErrorBoundary onError={onErrorSpy}>
          <ThrowError shouldThrow message="Callback test error" />
        </ErrorBoundary>
      )

      expect(onErrorSpy).toHaveBeenCalledTimes(1)
      expect(onErrorSpy).toHaveBeenCalledWith(
        expect.objectContaining({
          message: 'Callback test error',
        }),
        expect.objectContaining({
          componentStack: expect.any(String),
        })
      )
    })

    it('handles errors in onError callback gracefully', () => {
      const faultyCallback = vi.fn().mockImplementation(() => {
        throw new Error('Callback error')
      })

      // Should not crash when callback throws
      expect(() => {
        render(
          <ErrorBoundary onError={faultyCallback}>
            <ThrowError shouldThrow />
          </ErrorBoundary>
        )
      }).not.toThrow()

      expect(screen.getByRole('alert')).toBeInTheDocument()
    })
  })

  describe('withErrorBoundary HOC', () => {
    it('wraps component with error boundary', () => {
      const TestComponent = ({ shouldThrow }: { shouldThrow: boolean }) => (
        <ThrowError shouldThrow={shouldThrow} />
      )

      const WrappedComponent = withErrorBoundary(TestComponent, {
        level: 'component',
      })

      render(<WrappedComponent shouldThrow />)

      expect(screen.getByRole('alert')).toBeInTheDocument()
      expect(screen.getByText('Component Error')).toBeInTheDocument()
    })

    it('passes props correctly to wrapped component', () => {
      const TestComponent = ({ testProp }: { testProp: string }) => (
        <div data-testid="wrapped-component">{testProp}</div>
      )

      const WrappedComponent = withErrorBoundary(TestComponent)

      render(<WrappedComponent testProp="test value" />)

      expect(screen.getByTestId('wrapped-component')).toBeInTheDocument()
      expect(screen.getByText('test value')).toBeInTheDocument()
    })
  })

  describe('Development mode features', () => {
    const originalMode = import.meta.env.MODE

    beforeEach(() => {
      // Mock development mode
      Object.defineProperty(import.meta.env, 'MODE', {
        value: 'development',
        writable: true,
      })
    })

    afterEach(() => {
      // Restore original mode
      Object.defineProperty(import.meta.env, 'MODE', {
        value: originalMode,
        writable: true,
      })
    })

    it('shows error details in development mode', () => {
      render(
        <ErrorBoundary>
          <ThrowError shouldThrow message="Dev error" />
        </ErrorBoundary>
      )

      expect(screen.getByText('Error Details (Development Only)')).toBeInTheDocument()

      // Click details to expand
      fireEvent.click(screen.getByText('Error Details (Development Only)'))

      expect(screen.getByText('Dev error')).toBeInTheDocument()
    })
  })

  describe('useErrorHandler hook', () => {
    it('provides error handling function', () => {
      let errorHandler: ((error: Error) => void) | null = null

      const TestComponent = () => {
        errorHandler = useErrorHandler()
        return <div>Test</div>
      }

      render(<TestComponent />)

      expect(errorHandler).toBeInstanceOf(Function)

      // Test calling the error handler
      const testError = new Error('Manual error')
      errorHandler!(testError)

      // Should call monitoring functions (these are mocked)
      const monitoring = await import('../../../src/lib/monitoring')
      const { captureError, addBreadcrumb } = monitoring
      expect(captureError).toHaveBeenCalledWith(
        testError,
        expect.objectContaining({
          context: 'useErrorHandler',
        })
      )
      expect(addBreadcrumb).toHaveBeenCalled()
    })
  })
})
</file>

<file path="tests/unit/components/example.test.tsx">
import { describe, it, expect } from 'vitest'
import { render, screen } from '@/test/test-utils'

// Example component test - remove this once real components are tested
const ExampleComponent = ({ title }: { title: string }) => (
  <div>
    <h1>{title}</h1>
    <p>This is an example component for testing setup verification.</p>
  </div>
)

describe('Example Component Test', () => {
  it('renders title correctly', () => {
    render(<ExampleComponent title="Test Title" />)
    
    expect(screen.getByRole('heading', { name: 'Test Title' })).toBeInTheDocument()
  })

  it('renders description text', () => {
    render(<ExampleComponent title="Test" />)
    
    expect(screen.getByText('This is an example component for testing setup verification.')).toBeInTheDocument()
  })
})
</file>

<file path="tests/unit/components/FallbackUI.test.tsx">
import { render, screen, fireEvent } from '@testing-library/react'
import { describe, it, expect, vi } from 'vitest'
import {
  ErrorFallback,
  NotFoundError,
  InternalServerError,
  UnauthorizedError,
  NetworkError,
  FormValidationError,
  FormSubmissionError,
  PaymentError,
  LoadingError,
  EmptyStateError,
  TimeoutError,
  SuccessState,
} from '../../../src/components/common/FallbackUI'

describe('FallbackUI Components', () => {
  describe('ErrorFallback', () => {
    it('renders basic error information', () => {
      render(<ErrorFallback title="Test Error" message="This is a test error message" />)

      expect(screen.getByText('Test Error')).toBeInTheDocument()
      expect(screen.getByText('This is a test error message')).toBeInTheDocument()
    })

    it('displays error code when provided', () => {
      render(<ErrorFallback title="Test Error" message="Test message" errorCode="ERR_001" />)

      expect(screen.getByText('Error Code: ERR_001')).toBeInTheDocument()
    })

    it('calls onRetry when retry button is clicked', () => {
      const onRetry = vi.fn()
      render(<ErrorFallback title="Test Error" message="Test message" onRetry={onRetry} />)

      fireEvent.click(screen.getByTestId('retry-button'))
      expect(onRetry).toHaveBeenCalledTimes(1)
    })

    it('shows technical details when enabled', () => {
      render(
        <ErrorFallback
          title="Test Error"
          message="Test message"
          details="Stack trace here"
          showTechnicalDetails={true}
        />
      )

      const toggleButton = screen.getByTestId('technical-details-toggle')
      expect(toggleButton).toBeInTheDocument()

      fireEvent.click(toggleButton)
      expect(screen.getByText('Stack trace here')).toBeInTheDocument()
    })

    it('shows home button when enabled', () => {
      const onGoHome = vi.fn()
      render(
        <ErrorFallback
          title="Test Error"
          message="Test message"
          onGoHome={onGoHome}
          showHomeButton={true}
        />
      )

      const homeButton = screen.getByTestId('home-button')
      expect(homeButton).toBeInTheDocument()

      fireEvent.click(homeButton)
      expect(onGoHome).toHaveBeenCalledTimes(1)
    })

    it('shows support button by default', () => {
      const onContactSupport = vi.fn()
      render(
        <ErrorFallback
          title="Test Error"
          message="Test message"
          onContactSupport={onContactSupport}
        />
      )

      const supportButton = screen.getByTestId('support-button')
      expect(supportButton).toBeInTheDocument()

      fireEvent.click(supportButton)
      expect(onContactSupport).toHaveBeenCalledTimes(1)
    })
  })

  describe('NotFoundError', () => {
    it('renders 404 error correctly', () => {
      render(<NotFoundError />)

      expect(screen.getByText('Page Not Found')).toBeInTheDocument()
      expect(
        screen.getByText("The page you're looking for doesn't exist or may have been moved.")
      ).toBeInTheDocument()
      expect(screen.getByText('Error Code: 404')).toBeInTheDocument()
    })
  })

  describe('InternalServerError', () => {
    it('renders 500 error correctly', () => {
      render(<InternalServerError />)

      expect(screen.getByText('Server Error')).toBeInTheDocument()
      expect(
        screen.getByText(
          "We're experiencing technical difficulties. Our team has been notified and is working to resolve this issue."
        )
      ).toBeInTheDocument()
      expect(screen.getByText('Error Code: 500')).toBeInTheDocument()
    })
  })

  describe('UnauthorizedError', () => {
    it('renders unauthorized error correctly', () => {
      render(<UnauthorizedError />)

      expect(screen.getByText('Access Denied')).toBeInTheDocument()
      expect(
        screen.getByText(
          "You don't have permission to access this page. Please log in or contact your administrator."
        )
      ).toBeInTheDocument()
      expect(screen.getByText('Sign In')).toBeInTheDocument()
    })
  })

  describe('NetworkError', () => {
    it('renders network error correctly', () => {
      const onRetry = vi.fn()
      render(<NetworkError onRetry={onRetry} />)

      expect(screen.getByText('Connection Problem')).toBeInTheDocument()
      expect(
        screen.getByText(
          'Unable to connect to our servers. Please check your internet connection and try again.'
        )
      ).toBeInTheDocument()

      fireEvent.click(screen.getByText('Try Again'))
      expect(onRetry).toHaveBeenCalledTimes(1)
    })
  })

  describe('FormValidationError', () => {
    it('renders validation errors correctly', () => {
      const errors = {
        email: 'Invalid email',
        password: 'Password too short',
      }

      render(<FormValidationError errors={errors} />)

      expect(screen.getByText('Form Validation Error')).toBeInTheDocument()
      expect(screen.getByText('Invalid email')).toBeInTheDocument()
      expect(screen.getByText('Password too short')).toBeInTheDocument()
    })

    it('calls onRetry when retry button is clicked', () => {
      const onRetry = vi.fn()
      const errors = { email: 'Invalid email' }

      render(<FormValidationError errors={errors} onRetry={onRetry} />)

      fireEvent.click(screen.getByText('Try Again'))
      expect(onRetry).toHaveBeenCalledTimes(1)
    })
  })

  describe('FormSubmissionError', () => {
    it('renders submission error correctly', () => {
      const onRetry = vi.fn()
      render(<FormSubmissionError onRetry={onRetry} />)

      expect(
        screen.getByText('There was an error submitting your form. Please try again.')
      ).toBeInTheDocument()

      fireEvent.click(screen.getByText('Retry'))
      expect(onRetry).toHaveBeenCalledTimes(1)
    })
  })

  describe('PaymentError', () => {
    it('renders card declined error correctly', () => {
      render(<PaymentError errorType="card_declined" />)

      expect(screen.getByText('Card Declined')).toBeInTheDocument()
      expect(
        screen.getByText(
          'Your card was declined. Please try a different payment method or contact your bank.'
        )
      ).toBeInTheDocument()
    })

    it('renders insufficient funds error correctly', () => {
      render(<PaymentError errorType="insufficient_funds" />)

      expect(screen.getByText('Insufficient Funds')).toBeInTheDocument()
      expect(
        screen.getByText('Your card has insufficient funds. Please use a different payment method.')
      ).toBeInTheDocument()
    })

    it('renders invalid card error correctly', () => {
      render(<PaymentError errorType="invalid_card" />)

      expect(screen.getByText('Invalid Card Information')).toBeInTheDocument()
      expect(
        screen.getByText('The card information you entered is invalid. Please check and try again.')
      ).toBeInTheDocument()
    })

    it('calls payment method handlers correctly', () => {
      const onUpdatePaymentMethod = vi.fn()
      const onRetry = vi.fn()
      const onContactSupport = vi.fn()

      render(
        <PaymentError
          errorType="card_declined"
          onUpdatePaymentMethod={onUpdatePaymentMethod}
          onRetry={onRetry}
          onContactSupport={onContactSupport}
        />
      )

      fireEvent.click(screen.getByText('Update Payment Method'))
      expect(onUpdatePaymentMethod).toHaveBeenCalledTimes(1)

      fireEvent.click(screen.getByText('Try Again'))
      expect(onRetry).toHaveBeenCalledTimes(1)

      fireEvent.click(screen.getByText('Contact Support'))
      expect(onContactSupport).toHaveBeenCalledTimes(1)
    })
  })

  describe('LoadingError', () => {
    it('renders data loading error correctly', () => {
      const onRetry = vi.fn()
      render(<LoadingError type="data" onRetry={onRetry} />)

      expect(screen.getByText('Failed to load data. Please try again.')).toBeInTheDocument()

      fireEvent.click(screen.getByText('Try Again'))
      expect(onRetry).toHaveBeenCalledTimes(1)
    })

    it('renders page loading error correctly', () => {
      render(<LoadingError type="page" />)

      expect(
        screen.getByText('Failed to load page content. Please refresh and try again.')
      ).toBeInTheDocument()
    })

    it('renders component loading error correctly', () => {
      render(<LoadingError type="component" />)

      expect(screen.getByText('This section failed to load. Please try again.')).toBeInTheDocument()
    })

    it('uses custom message when provided', () => {
      render(<LoadingError type="data" message="Custom loading error message" />)

      expect(screen.getByText('Custom loading error message')).toBeInTheDocument()
    })
  })

  describe('EmptyStateError', () => {
    it('renders empty state correctly', () => {
      render(<EmptyStateError title="No Data" message="No data available" />)

      expect(screen.getByText('No Data')).toBeInTheDocument()
      expect(screen.getByText('No data available')).toBeInTheDocument()
    })

    it('calls action handler when button is clicked', () => {
      const onAction = vi.fn()
      render(
        <EmptyStateError
          title="No Data"
          message="No data available"
          actionLabel="Create New"
          onAction={onAction}
        />
      )

      fireEvent.click(screen.getByText('Create New'))
      expect(onAction).toHaveBeenCalledTimes(1)
    })
  })

  describe('TimeoutError', () => {
    it('renders timeout error correctly', () => {
      const onRetry = vi.fn()
      const onCancel = vi.fn()

      render(<TimeoutError timeoutDuration={30} onRetry={onRetry} onCancel={onCancel} />)

      expect(screen.getByText('Request Timeout')).toBeInTheDocument()
      expect(
        screen.getByText(
          'The request took too long to complete (30s). Please try again or check your connection.'
        )
      ).toBeInTheDocument()

      fireEvent.click(screen.getByText('Try Again'))
      expect(onRetry).toHaveBeenCalledTimes(1)

      fireEvent.click(screen.getByText('Cancel'))
      expect(onCancel).toHaveBeenCalledTimes(1)
    })
  })

  describe('SuccessState', () => {
    it('renders success state correctly', () => {
      const onPrimaryAction = vi.fn()
      const onSecondaryAction = vi.fn()

      render(
        <SuccessState
          title="Success!"
          message="Operation completed successfully"
          onPrimaryAction={onPrimaryAction}
          onSecondaryAction={onSecondaryAction}
          primaryActionLabel="Continue"
          secondaryActionLabel="Done"
        />
      )

      expect(screen.getByText('Success!')).toBeInTheDocument()
      expect(screen.getByText('Operation completed successfully')).toBeInTheDocument()

      fireEvent.click(screen.getByText('Continue'))
      expect(onPrimaryAction).toHaveBeenCalledTimes(1)

      fireEvent.click(screen.getByText('Done'))
      expect(onSecondaryAction).toHaveBeenCalledTimes(1)
    })
  })

  describe('Accessibility', () => {
    it('has proper ARIA attributes for error components', () => {
      render(<ErrorFallback title="Test Error" message="Test message" testId="test-error" />)

      const errorContainer = screen.getByTestId('test-error')
      expect(errorContainer).toHaveAttribute('role', 'alert')
      expect(errorContainer).toHaveAttribute('aria-live', 'polite')
    })

    it('has proper ARIA attributes for success components', () => {
      render(<SuccessState title="Success" message="Success message" testId="test-success" />)

      const successContainer = screen.getByTestId('test-success')
      expect(successContainer).toHaveAttribute('role', 'status')
      expect(successContainer).toHaveAttribute('aria-live', 'polite')
    })

    it('has proper aria-expanded for technical details toggle', () => {
      render(
        <ErrorFallback
          title="Test Error"
          message="Test message"
          details="Technical details"
          showTechnicalDetails={true}
        />
      )

      const toggleButton = screen.getByTestId('technical-details-toggle')
      expect(toggleButton).toHaveAttribute('aria-expanded', 'false')

      fireEvent.click(toggleButton)
      expect(toggleButton).toHaveAttribute('aria-expanded', 'true')
    })
  })

  describe('Custom Styling', () => {
    it('applies custom className', () => {
      render(
        <ErrorFallback
          title="Test Error"
          message="Test message"
          className="custom-error-class"
          testId="custom-error"
        />
      )

      const errorContainer = screen.getByTestId('custom-error')
      expect(errorContainer).toHaveClass('custom-error-class')
    })

    it('applies custom testId', () => {
      render(<ErrorFallback title="Test Error" message="Test message" testId="my-custom-test-id" />)

      expect(screen.getByTestId('my-custom-test-id')).toBeInTheDocument()
    })
  })
})
</file>

<file path="tests/unit/integrations/stripe/billing.test.ts">
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import {
  createInvoice,
  createInvoiceItem,
  finalizeInvoice,
  sendInvoice,
  payInvoice,
  voidInvoice,
  updateInvoice,
  getInvoice,
  listCustomerInvoices,
  createCreditNote,
  createUsageBasedInvoice,
  CreateInvoiceParams,
  CreateInvoiceItemParams,
} from '@/integrations/stripe/billing'
import { stripeServerClient } from '@/integrations/stripe/client'
import type Stripe from 'stripe'

// Mock the stripe client
vi.mock('@/integrations/stripe/client', () => ({
  stripeServerClient: {
    invoices: {
      create: vi.fn(),
      finalizeInvoice: vi.fn(),
      sendInvoice: vi.fn(),
      pay: vi.fn(),
      voidInvoice: vi.fn(),
      update: vi.fn(),
      retrieve: vi.fn(),
      list: vi.fn(),
    },
    invoiceItems: {
      create: vi.fn(),
    },
    creditNotes: {
      create: vi.fn(),
    },
  },
}))

describe('Stripe Billing Module', () => {
  beforeEach(() => {
    vi.clearAllMocks()
    vi.spyOn(console, 'error').mockImplementation(() => {})
  })

  afterEach(() => {
    vi.restoreAllMocks()
  })

  describe('createInvoice', () => {
    const mockInvoice = {
      id: 'in_123',
      customer: 'cus_123',
      status: 'draft',
    } as Stripe.Invoice

    const invoiceParams: CreateInvoiceParams = {
      customerId: 'cus_123',
      description: 'Test invoice',
      metadata: {
        buyerId: 'buyer_123',
        billingPeriod: '2024-01',
        callCount: '50',
      },
    }

    it('should create an invoice successfully', async () => {
      vi.mocked(stripeServerClient.invoices.create).mockResolvedValue(mockInvoice)

      const result = await createInvoice(invoiceParams)

      expect(stripeServerClient.invoices.create).toHaveBeenCalledWith({
        customer: 'cus_123',
        description: 'Test invoice',
        metadata: {
          buyerId: 'buyer_123',
          billingPeriod: '2024-01',
          callCount: '50',
          platform: 'dependablecalls',
        },
        collection_method: 'charge_automatically',
        auto_advance: false,
      })
      expect(result).toEqual(mockInvoice)
    })

    it('should create an invoice with optional parameters', async () => {
      vi.mocked(stripeServerClient.invoices.create).mockResolvedValue(mockInvoice)

      const paramsWithOptionals: CreateInvoiceParams = {
        ...invoiceParams,
        dueDate: 1234567890,
        collectionMethod: 'send_invoice',
      }

      await createInvoice(paramsWithOptionals)

      expect(stripeServerClient.invoices.create).toHaveBeenCalledWith({
        customer: 'cus_123',
        description: 'Test invoice',
        metadata: {
          buyerId: 'buyer_123',
          billingPeriod: '2024-01',
          callCount: '50',
          platform: 'dependablecalls',
        },
        due_date: 1234567890,
        collection_method: 'send_invoice',
        auto_advance: false,
      })
    })

    it('should handle creation errors', async () => {
      vi.mocked(stripeServerClient.invoices.create).mockRejectedValue(new Error('Stripe API error'))

      await expect(createInvoice(invoiceParams)).rejects.toThrow(
        'Failed to create invoice: Stripe API error'
      )
      expect(console.error).toHaveBeenCalledWith('Error creating invoice:', expect.any(Error))
    })

    it('should handle non-Error exceptions', async () => {
      vi.mocked(stripeServerClient.invoices.create).mockRejectedValue('String error')

      await expect(createInvoice(invoiceParams)).rejects.toThrow(
        'Failed to create invoice: Unknown error'
      )
    })
  })

  describe('createInvoiceItem', () => {
    const mockInvoiceItem = {
      id: 'ii_123',
      customer: 'cus_123',
      amount: 5000,
    } as Stripe.InvoiceItem

    const invoiceItemParams: CreateInvoiceItemParams = {
      customerId: 'cus_123',
      amount: 5000,
      currency: 'usd',
      description: 'Call charges',
      metadata: {
        callId: 'call_123',
        campaignId: 'campaign_456',
        duration: '180',
      },
    }

    it('should create an invoice item successfully', async () => {
      vi.mocked(stripeServerClient.invoiceItems.create).mockResolvedValue(mockInvoiceItem)

      const result = await createInvoiceItem(invoiceItemParams)

      expect(stripeServerClient.invoiceItems.create).toHaveBeenCalledWith({
        customer: 'cus_123',
        amount: 5000,
        currency: 'usd',
        description: 'Call charges',
        metadata: {
          callId: 'call_123',
          campaignId: 'campaign_456',
          duration: '180',
          platform: 'dependablecalls',
        },
      })
      expect(result).toEqual(mockInvoiceItem)
    })

    it('should attach to existing invoice when invoiceId provided', async () => {
      vi.mocked(stripeServerClient.invoiceItems.create).mockResolvedValue(mockInvoiceItem)

      const paramsWithInvoice: CreateInvoiceItemParams = {
        ...invoiceItemParams,
        invoiceId: 'in_123',
      }

      await createInvoiceItem(paramsWithInvoice)

      expect(stripeServerClient.invoiceItems.create).toHaveBeenCalledWith({
        customer: 'cus_123',
        amount: 5000,
        currency: 'usd',
        description: 'Call charges',
        metadata: {
          callId: 'call_123',
          campaignId: 'campaign_456',
          duration: '180',
          platform: 'dependablecalls',
        },
        invoice: 'in_123',
      })
    })

    it('should handle creation errors', async () => {
      vi.mocked(stripeServerClient.invoiceItems.create).mockRejectedValue(
        new Error('Item creation failed')
      )

      await expect(createInvoiceItem(invoiceItemParams)).rejects.toThrow(
        'Failed to create invoice item: Item creation failed'
      )
    })
  })

  describe('finalizeInvoice', () => {
    const mockFinalizedInvoice = {
      id: 'in_123',
      status: 'open',
    } as Stripe.Invoice

    it('should finalize invoice with auto advance', async () => {
      vi.mocked(stripeServerClient.invoices.finalizeInvoice).mockResolvedValue(mockFinalizedInvoice)

      const result = await finalizeInvoice('in_123')

      expect(stripeServerClient.invoices.finalizeInvoice).toHaveBeenCalledWith('in_123', {
        auto_advance: true,
      })
      expect(result).toEqual(mockFinalizedInvoice)
    })

    it('should finalize invoice without auto advance', async () => {
      vi.mocked(stripeServerClient.invoices.finalizeInvoice).mockResolvedValue(mockFinalizedInvoice)

      await finalizeInvoice('in_123', false)

      expect(stripeServerClient.invoices.finalizeInvoice).toHaveBeenCalledWith('in_123', {
        auto_advance: false,
      })
    })

    it('should handle finalization errors', async () => {
      vi.mocked(stripeServerClient.invoices.finalizeInvoice).mockRejectedValue(
        new Error('Finalization failed')
      )

      await expect(finalizeInvoice('in_123')).rejects.toThrow(
        'Failed to finalize invoice: Finalization failed'
      )
    })
  })

  describe('sendInvoice', () => {
    const mockSentInvoice = {
      id: 'in_123',
      status: 'open',
    } as Stripe.Invoice

    it('should send invoice successfully', async () => {
      vi.mocked(stripeServerClient.invoices.sendInvoice).mockResolvedValue(mockSentInvoice)

      const result = await sendInvoice('in_123')

      expect(stripeServerClient.invoices.sendInvoice).toHaveBeenCalledWith('in_123')
      expect(result).toEqual(mockSentInvoice)
    })

    it('should handle send errors', async () => {
      vi.mocked(stripeServerClient.invoices.sendInvoice).mockRejectedValue(new Error('Send failed'))

      await expect(sendInvoice('in_123')).rejects.toThrow('Failed to send invoice: Send failed')
    })
  })

  describe('payInvoice', () => {
    const mockPaidInvoice = {
      id: 'in_123',
      status: 'paid',
    } as Stripe.Invoice

    it('should pay invoice with default payment method', async () => {
      vi.mocked(stripeServerClient.invoices.pay).mockResolvedValue(mockPaidInvoice)

      const result = await payInvoice('in_123')

      expect(stripeServerClient.invoices.pay).toHaveBeenCalledWith('in_123', {})
      expect(result).toEqual(mockPaidInvoice)
    })

    it('should pay invoice with specific payment method', async () => {
      vi.mocked(stripeServerClient.invoices.pay).mockResolvedValue(mockPaidInvoice)

      await payInvoice('in_123', 'pm_123')

      expect(stripeServerClient.invoices.pay).toHaveBeenCalledWith('in_123', {
        payment_method: 'pm_123',
      })
    })

    it('should handle payment errors', async () => {
      vi.mocked(stripeServerClient.invoices.pay).mockRejectedValue(new Error('Payment failed'))

      await expect(payInvoice('in_123')).rejects.toThrow('Failed to pay invoice: Payment failed')
    })
  })

  describe('voidInvoice', () => {
    const mockVoidedInvoice = {
      id: 'in_123',
      status: 'void',
    } as Stripe.Invoice

    it('should void invoice successfully', async () => {
      vi.mocked(stripeServerClient.invoices.voidInvoice).mockResolvedValue(mockVoidedInvoice)

      const result = await voidInvoice('in_123')

      expect(stripeServerClient.invoices.voidInvoice).toHaveBeenCalledWith('in_123')
      expect(result).toEqual(mockVoidedInvoice)
    })

    it('should handle void errors', async () => {
      vi.mocked(stripeServerClient.invoices.voidInvoice).mockRejectedValue(new Error('Void failed'))

      await expect(voidInvoice('in_123')).rejects.toThrow('Failed to void invoice: Void failed')
    })
  })

  describe('updateInvoice', () => {
    const mockUpdatedInvoice = {
      id: 'in_123',
      description: 'Updated description',
    } as Stripe.Invoice

    it('should update invoice successfully', async () => {
      vi.mocked(stripeServerClient.invoices.update).mockResolvedValue(mockUpdatedInvoice)

      const updates = { description: 'Updated description' }
      const result = await updateInvoice('in_123', updates)

      expect(stripeServerClient.invoices.update).toHaveBeenCalledWith('in_123', updates)
      expect(result).toEqual(mockUpdatedInvoice)
    })

    it('should handle update errors', async () => {
      vi.mocked(stripeServerClient.invoices.update).mockRejectedValue(new Error('Update failed'))

      await expect(updateInvoice('in_123', {})).rejects.toThrow(
        'Failed to update invoice: Update failed'
      )
    })
  })

  describe('getInvoice', () => {
    const mockInvoice = {
      id: 'in_123',
      customer: 'cus_123',
    } as Stripe.Invoice

    it('should retrieve invoice successfully', async () => {
      vi.mocked(stripeServerClient.invoices.retrieve).mockResolvedValue(mockInvoice)

      const result = await getInvoice('in_123')

      expect(stripeServerClient.invoices.retrieve).toHaveBeenCalledWith('in_123')
      expect(result).toEqual(mockInvoice)
    })

    it('should return null for missing invoice', async () => {
      const missingError = { code: 'resource_missing' }
      vi.mocked(stripeServerClient.invoices.retrieve).mockRejectedValue(missingError)

      const result = await getInvoice('in_123')

      expect(result).toBeNull()
    })

    it('should handle other errors', async () => {
      vi.mocked(stripeServerClient.invoices.retrieve).mockRejectedValue(
        new Error('Retrieve failed')
      )

      await expect(getInvoice('in_123')).rejects.toThrow(
        'Failed to retrieve invoice: Retrieve failed'
      )
    })
  })

  describe('listCustomerInvoices', () => {
    const mockInvoices = {
      data: [
        { id: 'in_1', status: 'paid' },
        { id: 'in_2', status: 'open' },
      ],
    } as Stripe.ApiList<Stripe.Invoice>

    it('should list customer invoices', async () => {
      vi.mocked(stripeServerClient.invoices.list).mockResolvedValue(mockInvoices)

      const result = await listCustomerInvoices('cus_123')

      expect(stripeServerClient.invoices.list).toHaveBeenCalledWith({
        customer: 'cus_123',
        status: undefined,
        limit: 100,
      })
      expect(result).toEqual(mockInvoices.data)
    })

    it('should filter by status', async () => {
      vi.mocked(stripeServerClient.invoices.list).mockResolvedValue(mockInvoices)

      await listCustomerInvoices('cus_123', 'open', 50)

      expect(stripeServerClient.invoices.list).toHaveBeenCalledWith({
        customer: 'cus_123',
        status: 'open',
        limit: 50,
      })
    })

    it('should handle listing errors', async () => {
      vi.mocked(stripeServerClient.invoices.list).mockRejectedValue(new Error('List failed'))

      await expect(listCustomerInvoices('cus_123')).rejects.toThrow(
        'Failed to list invoices: List failed'
      )
    })
  })

  describe('createCreditNote', () => {
    const mockCreditNote = {
      id: 'cn_123',
      invoice: 'in_123',
      amount: 1000,
    } as Stripe.CreditNote

    it('should create credit note successfully', async () => {
      vi.mocked(stripeServerClient.creditNotes.create).mockResolvedValue(mockCreditNote)

      const result = await createCreditNote('in_123', 1000, 'duplicate', 'Test memo')

      expect(stripeServerClient.creditNotes.create).toHaveBeenCalledWith({
        invoice: 'in_123',
        amount: 1000,
        reason: 'duplicate',
        memo: 'Test memo',
        metadata: {
          platform: 'dependablecalls',
        },
      })
      expect(result).toEqual(mockCreditNote)
    })

    it('should create credit note without memo', async () => {
      vi.mocked(stripeServerClient.creditNotes.create).mockResolvedValue(mockCreditNote)

      await createCreditNote('in_123', 1000, 'fraudulent')

      expect(stripeServerClient.creditNotes.create).toHaveBeenCalledWith({
        invoice: 'in_123',
        amount: 1000,
        reason: 'fraudulent',
        memo: undefined,
        metadata: {
          platform: 'dependablecalls',
        },
      })
    })

    it('should handle credit note errors', async () => {
      vi.mocked(stripeServerClient.creditNotes.create).mockRejectedValue(
        new Error('Credit note failed')
      )

      await expect(createCreditNote('in_123', 1000, 'duplicate')).rejects.toThrow(
        'Failed to create credit note: Credit note failed'
      )
    })
  })

  describe('createUsageBasedInvoice', () => {
    const mockInvoice = {
      id: 'in_123',
      customer: 'cus_123',
    } as Stripe.Invoice

    const mockFinalizedInvoice = {
      ...mockInvoice,
      status: 'open',
    } as Stripe.Invoice

    const billingPeriod = {
      start: new Date('2024-01-01'),
      end: new Date('2024-01-31'),
    }

    const usageRecords = [
      {
        amount: 2500,
        description: 'Call 1',
        metadata: { callId: 'call_1' },
      },
      {
        amount: 3500,
        description: 'Call 2',
        metadata: { callId: 'call_2' },
      },
    ]

    it('should create usage-based invoice with multiple items', async () => {
      vi.mocked(stripeServerClient.invoices.create).mockResolvedValue(mockInvoice)
      vi.mocked(stripeServerClient.invoiceItems.create).mockResolvedValue({} as Stripe.InvoiceItem)
      vi.mocked(stripeServerClient.invoices.finalizeInvoice).mockResolvedValue(mockFinalizedInvoice)

      const result = await createUsageBasedInvoice('cus_123', billingPeriod, usageRecords)

      // Check invoice creation
      expect(stripeServerClient.invoices.create).toHaveBeenCalledWith({
        customer: 'cus_123',
        description: 'Usage charges for 2024-01-01 to 2024-01-31',
        metadata: {
          buyerId: 'cus_123',
          billingPeriod: `${billingPeriod.start.toISOString()}_${billingPeriod.end.toISOString()}`,
          callCount: '2',
          platform: 'dependablecalls',
        },
        collection_method: 'charge_automatically',
        auto_advance: false,
      })

      // Check invoice items creation
      expect(stripeServerClient.invoiceItems.create).toHaveBeenCalledTimes(2)
      expect(stripeServerClient.invoiceItems.create).toHaveBeenNthCalledWith(1, {
        customer: 'cus_123',
        amount: 2500,
        currency: 'usd',
        description: 'Call 1',
        metadata: {
          callId: 'call_1',
          platform: 'dependablecalls',
        },
        invoice: 'in_123',
      })

      // Check finalization
      expect(stripeServerClient.invoices.finalizeInvoice).toHaveBeenCalledWith('in_123', {
        auto_advance: true,
      })

      expect(result).toEqual(mockFinalizedInvoice)
    })

    it('should handle errors in usage-based invoice creation', async () => {
      vi.mocked(stripeServerClient.invoices.create).mockRejectedValue(new Error('Creation failed'))

      await expect(createUsageBasedInvoice('cus_123', billingPeriod, usageRecords)).rejects.toThrow(
        'Failed to create usage-based invoice: Failed to create invoice: Creation failed'
      )
    })

    it('should handle errors in invoice item creation', async () => {
      vi.mocked(stripeServerClient.invoices.create).mockResolvedValue(mockInvoice)
      vi.mocked(stripeServerClient.invoiceItems.create).mockRejectedValue(new Error('Item failed'))

      await expect(createUsageBasedInvoice('cus_123', billingPeriod, usageRecords)).rejects.toThrow(
        'Failed to create usage-based invoice: Failed to create invoice item: Item failed'
      )
    })
  })
})
</file>

<file path="tests/unit/integrations/stripe/client.test.ts">
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import { getStripeClient, stripeConfig, isStripeConfigured } from '@/integrations/stripe/client'
import Stripe from 'stripe'
import { loadStripe } from '@stripe/stripe-js'

// Mock the Stripe modules
vi.mock('stripe')
vi.mock('@stripe/stripe-js')

// Mock environment variables
const mockEnv = {
  VITE_STRIPE_SECRET_KEY: 'sk_test_mock_secret_key',
  VITE_STRIPE_PUBLISHABLE_KEY: 'pk_test_mock_publishable_key',
  VITE_STRIPE_WEBHOOK_SECRET: 'whsec_test_mock_webhook_secret',
  VITE_STRIPE_CONNECT_CLIENT_ID: 'ca_test_mock_client_id',
}

describe('Stripe Client Module', () => {
  const originalEnv = import.meta.env

  beforeEach(() => {
    // Reset mocks
    vi.clearAllMocks()

    // Setup environment variables
    import.meta.env = { ...originalEnv, ...mockEnv }
  })

  afterEach(() => {
    // Restore original environment
    import.meta.env = originalEnv
  })

  describe('stripeServerClient', () => {
    it('should create a Stripe instance with correct configuration', () => {
      const MockedStripe = vi.mocked(Stripe)

      // Import module to trigger initialization
      vi.resetModules()

      expect(MockedStripe).toHaveBeenCalledWith(mockEnv.VITE_STRIPE_SECRET_KEY, {
        apiVersion: '2023-10-16',
        typescript: true,
      })
    })

    it('should handle missing secret key gracefully', () => {
      import.meta.env = { ...originalEnv, VITE_STRIPE_SECRET_KEY: '' }
      const MockedStripe = vi.mocked(Stripe)

      vi.resetModules()

      expect(MockedStripe).toHaveBeenCalledWith('', {
        apiVersion: '2023-10-16',
        typescript: true,
      })
    })
  })

  describe('getStripeClient', () => {
    it('should return the same promise instance on multiple calls', async () => {
      const mockStripeInstance = { id: 'mock-stripe' }
      vi.mocked(loadStripe).mockResolvedValue(
        mockStripeInstance as unknown as ReturnType<typeof loadStripe>
      )

      const firstCall = getStripeClient()
      const secondCall = getStripeClient()

      expect(firstCall).toBe(secondCall)
      expect(loadStripe).toHaveBeenCalledTimes(1)
      expect(loadStripe).toHaveBeenCalledWith(mockEnv.VITE_STRIPE_PUBLISHABLE_KEY)
    })

    it('should handle missing publishable key', async () => {
      import.meta.env = { ...originalEnv, VITE_STRIPE_PUBLISHABLE_KEY: '' }

      vi.resetModules()
      const { getStripeClient: getClient } = await import('@/integrations/stripe/client')

      getClient()

      expect(loadStripe).toHaveBeenCalledWith('')
    })

    it('should return null when loadStripe fails', async () => {
      vi.mocked(loadStripe).mockResolvedValue(null)

      vi.resetModules()
      const { getStripeClient: getClient } = await import('@/integrations/stripe/client')

      const result = await getClient()

      expect(result).toBeNull()
    })
  })

  describe('stripeConfig', () => {
    it('should contain all required configuration values', () => {
      expect(stripeConfig).toEqual({
        webhookSecret: mockEnv.VITE_STRIPE_WEBHOOK_SECRET,
        connectClientId: mockEnv.VITE_STRIPE_CONNECT_CLIENT_ID,
        apiVersion: '2023-10-16',
      })
    })

    it('should handle missing environment variables', () => {
      import.meta.env = { ...originalEnv }

      vi.resetModules()

      expect(stripeConfig).toEqual({
        webhookSecret: '',
        connectClientId: '',
        apiVersion: '2023-10-16',
      })
    })
  })

  describe('isStripeConfigured', () => {
    it('should return true when all required keys are present', () => {
      expect(isStripeConfigured()).toBe(true)
    })

    it('should return false when secret key is missing', () => {
      import.meta.env = {
        ...originalEnv,
        VITE_STRIPE_PUBLISHABLE_KEY: mockEnv.VITE_STRIPE_PUBLISHABLE_KEY,
      }

      expect(isStripeConfigured()).toBe(false)
    })

    it('should return false when publishable key is missing', () => {
      import.meta.env = {
        ...originalEnv,
        VITE_STRIPE_SECRET_KEY: mockEnv.VITE_STRIPE_SECRET_KEY,
      }

      expect(isStripeConfigured()).toBe(false)
    })

    it('should return false when both keys are missing', () => {
      import.meta.env = { ...originalEnv }

      expect(isStripeConfigured()).toBe(false)
    })

    it('should return false when keys are empty strings', () => {
      import.meta.env = {
        ...originalEnv,
        VITE_STRIPE_SECRET_KEY: '',
        VITE_STRIPE_PUBLISHABLE_KEY: '',
      }

      expect(isStripeConfigured()).toBe(false)
    })
  })
})
</file>

<file path="tests/unit/integrations/stripe/customers.test.ts">
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import {
  createStripeCustomer,
  updateStripeCustomer,
  getStripeCustomer,
  deleteStripeCustomer,
  listCustomerPaymentMethods,
  attachPaymentMethod,
  savePaymentMethod,
  detachPaymentMethod,
  setDefaultPaymentMethod,
  createSetupIntent,
} from '@/integrations/stripe/customers'
import { stripeServerClient } from '@/integrations/stripe/client'
import type Stripe from 'stripe'

// Mock uuid
vi.mock('uuid', () => ({
  v4: vi.fn(() => 'mock-uuid-123'),
}))

// Mock the stripe client
vi.mock('@/integrations/stripe/client', () => ({
  stripeServerClient: {
    customers: {
      create: vi.fn(),
      update: vi.fn(),
      retrieve: vi.fn(),
      del: vi.fn(),
    },
    paymentMethods: {
      list: vi.fn(),
      retrieve: vi.fn(),
      detach: vi.fn(),
    },
    setupIntents: {
      create: vi.fn(),
    },
    errors: {
      StripeError: class StripeError extends Error {
        constructor(
          public type: string,
          public code: string,
          public param?: string,
          public requestId?: string
        ) {
          super('Stripe error')
          this.name = 'StripeError'
        }
      },
    },
  },
}))

describe('Stripe Customers Module', () => {
  beforeEach(() => {
    vi.clearAllMocks()
    // Reset console mocks
    vi.spyOn(console, 'error').mockImplementation(() => {})
    vi.spyOn(console, 'warn').mockImplementation(() => {})
  })

  afterEach(() => {
    vi.restoreAllMocks()
  })

  describe('createStripeCustomer', () => {
    const mockCustomer = {
      id: 'cus_123',
      email: 'test@example.com',
      metadata: {
        userId: 'user_123',
        userType: 'buyer',
        platform: 'dependablecalls',
      },
    } as Stripe.Customer

    it('should create a customer with required fields', async () => {
      vi.mocked(stripeServerClient.customers.create).mockResolvedValue(mockCustomer)

      const result = await createStripeCustomer('test@example.com', {
        userId: 'user_123',
        userType: 'buyer',
      })

      expect(stripeServerClient.customers.create).toHaveBeenCalledWith(
        {
          email: 'test@example.com',
          metadata: {
            userId: 'user_123',
            userType: 'buyer',
            platform: 'dependablecalls',
          },
        },
        { idempotencyKey: 'mock-uuid-123' }
      )
      expect(result).toEqual(mockCustomer)
    })

    it('should create a customer with additional data', async () => {
      vi.mocked(stripeServerClient.customers.create).mockResolvedValue(mockCustomer)

      const additionalData = {
        name: 'John Doe',
        phone: '+1234567890',
        address: {
          line1: '123 Main St',
          city: 'San Francisco',
          state: 'CA',
          postal_code: '94105',
          country: 'US',
        } as Stripe.CustomerCreateParams.Address,
      }

      await createStripeCustomer(
        'test@example.com',
        {
          userId: 'user_123',
          userType: 'supplier',
          companyName: 'Test Company',
        },
        additionalData
      )

      expect(stripeServerClient.customers.create).toHaveBeenCalledWith(
        {
          email: 'test@example.com',
          name: 'John Doe',
          phone: '+1234567890',
          address: additionalData.address,
          metadata: {
            userId: 'user_123',
            userType: 'supplier',
            companyName: 'Test Company',
            platform: 'dependablecalls',
          },
        },
        { idempotencyKey: 'mock-uuid-123' }
      )
    })

    it('should handle Stripe errors properly', async () => {
      const stripeError = new stripeServerClient.errors.StripeError(
        'card_error',
        'card_declined',
        'payment_method',
        'req_123'
      )
      vi.mocked(stripeServerClient.customers.create).mockRejectedValue(stripeError)

      await expect(
        createStripeCustomer('test@example.com', {
          userId: 'user_123',
          userType: 'buyer',
        })
      ).rejects.toThrow('Customer service error. Please retry or contact support.')

      expect(console.error).toHaveBeenCalledWith('create Stripe customer failed', {
        type: 'card_error',
        code: 'card_declined',
        param: 'payment_method',
        requestId: 'req_123',
      })
    })

    it('should handle resource_missing errors with specific message', async () => {
      const stripeError = new stripeServerClient.errors.StripeError(
        'invalid_request_error',
        'resource_missing'
      )
      vi.mocked(stripeServerClient.customers.create).mockRejectedValue(stripeError)

      await expect(
        createStripeCustomer('test@example.com', {
          userId: 'user_123',
          userType: 'buyer',
        })
      ).rejects.toThrow('Resource not found. Please check your request and try again.')
    })

    it('should handle unexpected errors', async () => {
      vi.mocked(stripeServerClient.customers.create).mockRejectedValue(new Error('Network error'))

      await expect(
        createStripeCustomer('test@example.com', {
          userId: 'user_123',
          userType: 'buyer',
        })
      ).rejects.toThrow('Internal server error. Please try again later.')
    })
  })

  describe('updateStripeCustomer', () => {
    const mockUpdatedCustomer = {
      id: 'cus_123',
      email: 'updated@example.com',
    } as Stripe.Customer

    it('should update a customer successfully', async () => {
      vi.mocked(stripeServerClient.customers.update).mockResolvedValue(mockUpdatedCustomer)

      const updates = { email: 'updated@example.com' }
      const result = await updateStripeCustomer('cus_123', updates)

      expect(stripeServerClient.customers.update).toHaveBeenCalledWith('cus_123', updates, {
        idempotencyKey: 'mock-uuid-123',
      })
      expect(result).toEqual(mockUpdatedCustomer)
    })

    it('should handle update errors', async () => {
      vi.mocked(stripeServerClient.customers.update).mockRejectedValue(new Error('Update failed'))

      await expect(updateStripeCustomer('cus_123', { email: 'test@example.com' })).rejects.toThrow(
        'Internal server error. Please try again later.'
      )
    })
  })

  describe('getStripeCustomer', () => {
    it('should retrieve a customer successfully', async () => {
      const mockCustomer = {
        id: 'cus_123',
        deleted: false,
      } as Stripe.Customer
      vi.mocked(stripeServerClient.customers.retrieve).mockResolvedValue(mockCustomer)

      const result = await getStripeCustomer('cus_123')

      expect(stripeServerClient.customers.retrieve).toHaveBeenCalledWith('cus_123')
      expect(result).toEqual(mockCustomer)
    })

    it('should return null for deleted customers', async () => {
      const deletedCustomer = {
        id: 'cus_123',
        deleted: true,
      } as Stripe.DeletedCustomer
      vi.mocked(stripeServerClient.customers.retrieve).mockResolvedValue(deletedCustomer)

      const result = await getStripeCustomer('cus_123')

      expect(result).toBeNull()
    })

    it('should return null for resource_missing errors', async () => {
      const stripeError = new stripeServerClient.errors.StripeError(
        'invalid_request_error',
        'resource_missing'
      )
      vi.mocked(stripeServerClient.customers.retrieve).mockRejectedValue(stripeError)

      const result = await getStripeCustomer('cus_123')

      expect(result).toBeNull()
    })

    it('should handle other errors', async () => {
      vi.mocked(stripeServerClient.customers.retrieve).mockRejectedValue(new Error('Network error'))

      await expect(getStripeCustomer('cus_123')).rejects.toThrow(
        'Internal server error. Please try again later.'
      )
    })
  })

  describe('deleteStripeCustomer', () => {
    it('should delete a customer successfully', async () => {
      vi.mocked(stripeServerClient.customers.del).mockResolvedValue({
        id: 'cus_123',
        object: 'customer',
        deleted: true,
      })

      const result = await deleteStripeCustomer('cus_123')

      expect(stripeServerClient.customers.del).toHaveBeenCalledWith('cus_123')
      expect(result).toBe(true)
    })

    it('should handle deletion errors', async () => {
      vi.mocked(stripeServerClient.customers.del).mockRejectedValue(new Error('Delete failed'))

      await expect(deleteStripeCustomer('cus_123')).rejects.toThrow(
        'Internal server error. Please try again later.'
      )
    })
  })

  describe('listCustomerPaymentMethods', () => {
    it('should list payment methods with pagination', async () => {
      const mockPaymentMethods = [
        { id: 'pm_1', type: 'card' },
        { id: 'pm_2', type: 'card' },
      ] as Stripe.PaymentMethod[]

      // Mock async iterator
      const mockAsyncIterator = {
        [Symbol.asyncIterator]: async function* () {
          for (const pm of mockPaymentMethods) {
            yield pm
          }
        },
      }

      vi.mocked(stripeServerClient.paymentMethods.list).mockReturnValue(
        mockAsyncIterator as AsyncIterableIterator<Stripe.PaymentMethod>
      )

      const result = await listCustomerPaymentMethods('cus_123')

      expect(stripeServerClient.paymentMethods.list).toHaveBeenCalledWith({
        customer: 'cus_123',
        type: 'card',
        limit: 100,
      })
      expect(result).toEqual(mockPaymentMethods)
    })

    it('should list bank account payment methods', async () => {
      const mockAsyncIterator = {
        [Symbol.asyncIterator]: async function* () {
          yield { id: 'pm_bank', type: 'us_bank_account' }
        },
      }

      vi.mocked(stripeServerClient.paymentMethods.list).mockReturnValue(
        mockAsyncIterator as AsyncIterableIterator<Stripe.PaymentMethod>
      )

      const result = await listCustomerPaymentMethods('cus_123', 'us_bank_account', 50)

      expect(stripeServerClient.paymentMethods.list).toHaveBeenCalledWith({
        customer: 'cus_123',
        type: 'us_bank_account',
        limit: 50,
      })
      expect(result).toHaveLength(1)
    })

    it('should handle listing errors', async () => {
      vi.mocked(stripeServerClient.paymentMethods.list).mockImplementation(() => {
        throw new Error('List failed')
      })

      await expect(listCustomerPaymentMethods('cus_123')).rejects.toThrow(
        'Internal server error. Please try again later.'
      )
    })
  })

  describe('attachPaymentMethod', () => {
    it('should log deprecation warning and call savePaymentMethod', async () => {
      const mockPaymentMethod = { id: 'pm_123' } as Stripe.PaymentMethod
      const mockSetupIntent = {
        id: 'seti_123',
        status: 'succeeded',
      } as Stripe.SetupIntent

      vi.mocked(stripeServerClient.setupIntents.create).mockResolvedValue(mockSetupIntent)
      vi.mocked(stripeServerClient.paymentMethods.retrieve).mockResolvedValue(mockPaymentMethod)

      const result = await attachPaymentMethod('pm_123', 'cus_123')

      expect(console.warn).toHaveBeenCalledWith(
        'attachPaymentMethod is deprecated. Use savePaymentMethod for better SCA compliance.'
      )
      expect(result).toEqual(mockPaymentMethod)
    })
  })

  describe('savePaymentMethod', () => {
    it('should save payment method with SetupIntent', async () => {
      const mockSetupIntent = {
        id: 'seti_123',
        status: 'succeeded',
      } as Stripe.SetupIntent
      const mockPaymentMethod = { id: 'pm_123' } as Stripe.PaymentMethod

      vi.mocked(stripeServerClient.setupIntents.create).mockResolvedValue(mockSetupIntent)
      vi.mocked(stripeServerClient.paymentMethods.retrieve).mockResolvedValue(mockPaymentMethod)

      const result = await savePaymentMethod('cus_123', 'pm_123', { source: 'web' })

      expect(stripeServerClient.setupIntents.create).toHaveBeenCalledWith(
        {
          customer: 'cus_123',
          payment_method_types: ['card', 'us_bank_account'],
          payment_method: 'pm_123',
          confirm: true,
          usage: 'off_session',
          metadata: {
            source: 'web',
            platform: 'dependablecalls',
          },
        },
        { idempotencyKey: 'mock-uuid-123' }
      )
      expect(stripeServerClient.paymentMethods.retrieve).toHaveBeenCalledWith('pm_123')
      expect(result).toEqual(mockPaymentMethod)
    })

    it('should throw error if SetupIntent fails', async () => {
      const mockSetupIntent = {
        id: 'seti_123',
        status: 'requires_payment_method',
      } as Stripe.SetupIntent

      vi.mocked(stripeServerClient.setupIntents.create).mockResolvedValue(mockSetupIntent)

      await expect(savePaymentMethod('cus_123', 'pm_123')).rejects.toThrow(
        'SetupIntent failed with status: requires_payment_method'
      )
    })

    it('should handle setup errors', async () => {
      vi.mocked(stripeServerClient.setupIntents.create).mockRejectedValue(new Error('Setup failed'))

      await expect(savePaymentMethod('cus_123', 'pm_123')).rejects.toThrow(
        'Internal server error. Please try again later.'
      )
    })
  })

  describe('detachPaymentMethod', () => {
    it('should detach payment method successfully', async () => {
      const mockPaymentMethod = { id: 'pm_123', customer: null } as Stripe.PaymentMethod
      vi.mocked(stripeServerClient.paymentMethods.detach).mockResolvedValue(mockPaymentMethod)

      const result = await detachPaymentMethod('pm_123')

      expect(stripeServerClient.paymentMethods.detach).toHaveBeenCalledWith('pm_123')
      expect(result).toEqual(mockPaymentMethod)
    })

    it('should handle detach errors', async () => {
      vi.mocked(stripeServerClient.paymentMethods.detach).mockRejectedValue(
        new Error('Detach failed')
      )

      await expect(detachPaymentMethod('pm_123')).rejects.toThrow(
        'Internal server error. Please try again later.'
      )
    })
  })

  describe('setDefaultPaymentMethod', () => {
    it('should set default payment method successfully', async () => {
      const mockCustomer = {
        id: 'cus_123',
        invoice_settings: {
          default_payment_method: 'pm_123',
        },
      } as Stripe.Customer

      vi.mocked(stripeServerClient.customers.update).mockResolvedValue(mockCustomer)

      const result = await setDefaultPaymentMethod('cus_123', 'pm_123')

      expect(stripeServerClient.customers.update).toHaveBeenCalledWith(
        'cus_123',
        {
          invoice_settings: {
            default_payment_method: 'pm_123',
          },
        },
        { idempotencyKey: 'mock-uuid-123' }
      )
      expect(result).toEqual(mockCustomer)
    })
  })

  describe('createSetupIntent', () => {
    it('should create setup intent successfully', async () => {
      const mockSetupIntent = {
        id: 'seti_123',
        customer: 'cus_123',
      } as Stripe.SetupIntent

      vi.mocked(stripeServerClient.setupIntents.create).mockResolvedValue(mockSetupIntent)

      const result = await createSetupIntent('cus_123', { source: 'mobile' })

      expect(stripeServerClient.setupIntents.create).toHaveBeenCalledWith(
        {
          customer: 'cus_123',
          payment_method_types: ['card', 'us_bank_account'],
          usage: 'off_session',
          metadata: {
            source: 'mobile',
            platform: 'dependablecalls',
          },
        },
        { idempotencyKey: 'mock-uuid-123' }
      )
      expect(result).toEqual(mockSetupIntent)
    })

    it('should handle creation errors', async () => {
      vi.mocked(stripeServerClient.setupIntents.create).mockRejectedValue(
        new Error('Create failed')
      )

      await expect(createSetupIntent('cus_123')).rejects.toThrow(
        'Internal server error. Please try again later.'
      )
    })
  })
})
</file>

<file path="tests/unit/integrations/stripe/payments.test.ts">
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import {
  createPaymentIntent,
  confirmPaymentIntent,
  cancelPaymentIntent,
  getPaymentIntent,
  capturePaymentIntent,
  listPayments,
  createRefund,
  getPaymentStatus,
} from '@/integrations/stripe/payments'
import { stripeServerClient } from '@/integrations/stripe/client'
import type Stripe from 'stripe'
import type { CreatePaymentIntentParams } from '@/integrations/stripe/types'

// Mock uuid
vi.mock('uuid', () => ({
  v4: vi.fn(() => 'mock-uuid-123'),
}))

// Mock the stripe client
vi.mock('@/integrations/stripe/client', () => ({
  stripeServerClient: {
    paymentIntents: {
      create: vi.fn(),
      confirm: vi.fn(),
      cancel: vi.fn(),
      retrieve: vi.fn(),
      capture: vi.fn(),
      list: vi.fn(),
    },
    refunds: {
      create: vi.fn(),
    },
    errors: {
      StripeError: class StripeError extends Error {
        constructor(
          public type: string,
          public code: string,
          public param?: string,
          public requestId?: string
        ) {
          super('Stripe error')
          this.name = 'StripeError'
        }
      },
    },
  },
}))

describe('Stripe Payments Module', () => {
  beforeEach(() => {
    vi.clearAllMocks()
    vi.spyOn(console, 'error').mockImplementation(() => {})
  })

  afterEach(() => {
    vi.restoreAllMocks()
  })

  describe('createPaymentIntent', () => {
    const mockPaymentIntent = {
      id: 'pi_123',
      amount: 5000,
      status: 'requires_payment_method',
    } as Stripe.PaymentIntent

    const params: CreatePaymentIntentParams = {
      amount: 5000,
      currency: 'usd',
      customerId: 'cus_123',
      metadata: {
        campaignId: 'campaign_123',
        buyerId: 'buyer_123',
      },
    }

    it('should create payment intent with default payment method types', async () => {
      vi.mocked(stripeServerClient.paymentIntents.create).mockResolvedValue(mockPaymentIntent)

      const result = await createPaymentIntent(params)

      expect(stripeServerClient.paymentIntents.create).toHaveBeenCalledWith(
        {
          amount: 5000,
          currency: 'usd',
          customer: 'cus_123',
          payment_method_types: ['card', 'us_bank_account'],
          metadata: {
            campaignId: 'campaign_123',
            buyerId: 'buyer_123',
            platform: 'dependablecalls',
          },
          setup_future_usage: 'off_session',
          automatic_payment_methods: {
            enabled: true,
          },
        },
        { idempotencyKey: 'mock-uuid-123' }
      )
      expect(result).toEqual(mockPaymentIntent)
    })

    it('should create payment intent with custom payment method types', async () => {
      vi.mocked(stripeServerClient.paymentIntents.create).mockResolvedValue(mockPaymentIntent)

      const customParams: CreatePaymentIntentParams = {
        ...params,
        paymentMethodTypes: ['card'],
      }

      await createPaymentIntent(customParams)

      expect(stripeServerClient.paymentIntents.create).toHaveBeenCalledWith(
        expect.objectContaining({
          payment_method_types: ['card'],
        }),
        { idempotencyKey: 'mock-uuid-123' }
      )
    })

    it('should handle Stripe errors properly', async () => {
      const stripeError = new stripeServerClient.errors.StripeError(
        'card_error',
        'card_declined',
        'payment_method',
        'req_123'
      )
      vi.mocked(stripeServerClient.paymentIntents.create).mockRejectedValue(stripeError)

      await expect(createPaymentIntent(params)).rejects.toThrow(
        'Payment service error. Please retry or contact support.'
      )

      expect(console.error).toHaveBeenCalledWith('create payment intent failed', {
        type: 'card_error',
        code: 'card_declined',
        param: 'payment_method',
        requestId: 'req_123',
      })
    })

    it('should handle resource_missing errors with specific message', async () => {
      const stripeError = new stripeServerClient.errors.StripeError(
        'invalid_request_error',
        'resource_missing'
      )
      vi.mocked(stripeServerClient.paymentIntents.create).mockRejectedValue(stripeError)

      await expect(createPaymentIntent(params)).rejects.toThrow(
        'Resource not found. Please check your request and try again.'
      )
    })

    it('should handle unexpected errors', async () => {
      vi.mocked(stripeServerClient.paymentIntents.create).mockRejectedValue(
        new Error('Network error')
      )

      await expect(createPaymentIntent(params)).rejects.toThrow(
        'Internal server error. Please try again later.'
      )
    })
  })

  describe('confirmPaymentIntent', () => {
    const mockConfirmedIntent = {
      id: 'pi_123',
      status: 'processing',
    } as Stripe.PaymentIntent

    it('should confirm payment intent successfully', async () => {
      vi.mocked(stripeServerClient.paymentIntents.confirm).mockResolvedValue(mockConfirmedIntent)

      const result = await confirmPaymentIntent('pi_123', 'pm_123', 'https://example.com/return')

      expect(stripeServerClient.paymentIntents.confirm).toHaveBeenCalledWith(
        'pi_123',
        {
          payment_method: 'pm_123',
          return_url: 'https://example.com/return',
        },
        { idempotencyKey: 'mock-uuid-123' }
      )
      expect(result).toEqual(mockConfirmedIntent)
    })

    it('should handle confirmation errors', async () => {
      vi.mocked(stripeServerClient.paymentIntents.confirm).mockRejectedValue(
        new Error('Confirmation failed')
      )

      await expect(
        confirmPaymentIntent('pi_123', 'pm_123', 'https://example.com/return')
      ).rejects.toThrow('Internal server error. Please try again later.')
    })
  })

  describe('cancelPaymentIntent', () => {
    const mockCancelledIntent = {
      id: 'pi_123',
      status: 'canceled',
    } as Stripe.PaymentIntent

    it('should cancel payment intent with default reason', async () => {
      vi.mocked(stripeServerClient.paymentIntents.cancel).mockResolvedValue(mockCancelledIntent)

      const result = await cancelPaymentIntent('pi_123')

      expect(stripeServerClient.paymentIntents.cancel).toHaveBeenCalledWith(
        'pi_123',
        {
          cancellation_reason: 'requested_by_customer',
        },
        { idempotencyKey: 'mock-uuid-123' }
      )
      expect(result).toEqual(mockCancelledIntent)
    })

    it('should cancel payment intent with custom reason', async () => {
      vi.mocked(stripeServerClient.paymentIntents.cancel).mockResolvedValue(mockCancelledIntent)

      await cancelPaymentIntent('pi_123', 'duplicate')

      expect(stripeServerClient.paymentIntents.cancel).toHaveBeenCalledWith(
        'pi_123',
        {
          cancellation_reason: 'duplicate',
        },
        { idempotencyKey: 'mock-uuid-123' }
      )
    })

    it('should handle cancellation errors', async () => {
      vi.mocked(stripeServerClient.paymentIntents.cancel).mockRejectedValue(
        new Error('Cancellation failed')
      )

      await expect(cancelPaymentIntent('pi_123')).rejects.toThrow(
        'Internal server error. Please try again later.'
      )
    })
  })

  describe('getPaymentIntent', () => {
    const mockPaymentIntent = {
      id: 'pi_123',
      amount: 5000,
    } as Stripe.PaymentIntent

    it('should retrieve payment intent successfully', async () => {
      vi.mocked(stripeServerClient.paymentIntents.retrieve).mockResolvedValue(mockPaymentIntent)

      const result = await getPaymentIntent('pi_123')

      expect(stripeServerClient.paymentIntents.retrieve).toHaveBeenCalledWith('pi_123')
      expect(result).toEqual(mockPaymentIntent)
    })

    it('should return null for missing payment intent', async () => {
      const missingError = new stripeServerClient.errors.StripeError(
        'invalid_request_error',
        'resource_missing'
      )
      vi.mocked(stripeServerClient.paymentIntents.retrieve).mockRejectedValue(missingError)

      const result = await getPaymentIntent('pi_123')

      expect(result).toBeNull()
    })

    it('should handle other retrieval errors', async () => {
      vi.mocked(stripeServerClient.paymentIntents.retrieve).mockRejectedValue(
        new Error('Retrieval failed')
      )

      await expect(getPaymentIntent('pi_123')).rejects.toThrow(
        'Internal server error. Please try again later.'
      )
    })
  })

  describe('capturePaymentIntent', () => {
    const mockCapturedIntent = {
      id: 'pi_123',
      status: 'succeeded',
    } as Stripe.PaymentIntent

    it('should capture full amount by default', async () => {
      vi.mocked(stripeServerClient.paymentIntents.capture).mockResolvedValue(mockCapturedIntent)

      const result = await capturePaymentIntent('pi_123')

      expect(stripeServerClient.paymentIntents.capture).toHaveBeenCalledWith(
        'pi_123',
        {},
        { idempotencyKey: 'mock-uuid-123' }
      )
      expect(result).toEqual(mockCapturedIntent)
    })

    it('should capture partial amount when specified', async () => {
      vi.mocked(stripeServerClient.paymentIntents.capture).mockResolvedValue(mockCapturedIntent)

      await capturePaymentIntent('pi_123', 3000)

      expect(stripeServerClient.paymentIntents.capture).toHaveBeenCalledWith(
        'pi_123',
        { amount_to_capture: 3000 },
        { idempotencyKey: 'mock-uuid-123' }
      )
    })

    it('should handle capture errors', async () => {
      vi.mocked(stripeServerClient.paymentIntents.capture).mockRejectedValue(
        new Error('Capture failed')
      )

      await expect(capturePaymentIntent('pi_123')).rejects.toThrow(
        'Internal server error. Please try again later.'
      )
    })
  })

  describe('createRefund', () => {
    const mockRefund = {
      id: 'refund_123',
      amount: 2000,
      status: 'succeeded',
    } as Stripe.Refund

    it('should create full refund', async () => {
      vi.mocked(stripeServerClient.refunds.create).mockResolvedValue(mockRefund)

      const result = await createRefund('pi_123', undefined, 'requested_by_customer')

      expect(stripeServerClient.refunds.create).toHaveBeenCalledWith(
        {
          payment_intent: 'pi_123',
          reason: 'requested_by_customer',
          metadata: {
            platform: 'dependablecalls',
          },
        },
        { idempotencyKey: 'mock-uuid-123' }
      )
      expect(result).toEqual(mockRefund)
    })

    it('should create partial refund', async () => {
      vi.mocked(stripeServerClient.refunds.create).mockResolvedValue(mockRefund)

      await createRefund('pi_123', 2000, 'duplicate', { orderId: 'order_123' })

      expect(stripeServerClient.refunds.create).toHaveBeenCalledWith(
        {
          payment_intent: 'pi_123',
          amount: 2000,
          reason: 'duplicate',
          metadata: {
            orderId: 'order_123',
            platform: 'dependablecalls',
          },
        },
        { idempotencyKey: 'mock-uuid-123' }
      )
    })

    it('should handle refund errors', async () => {
      vi.mocked(stripeServerClient.refunds.create).mockRejectedValue(new Error('Refund failed'))

      await expect(createRefund('pi_123')).rejects.toThrow(
        'Internal server error. Please try again later.'
      )
    })
  })

  describe('listPayments', () => {
    const mockPayments = {
      data: [
        { id: 'pi_1', amount: 5000 },
        { id: 'pi_2', amount: 3000 },
      ],
    } as Stripe.ApiList<Stripe.PaymentIntent>

    it('should list customer payments', async () => {
      vi.mocked(stripeServerClient.paymentIntents.list).mockResolvedValue(mockPayments)

      const result = await listPayments({ customerId: 'cus_123' })

      expect(stripeServerClient.paymentIntents.list).toHaveBeenCalledWith({
        customer: 'cus_123',
        limit: 100,
      })
      expect(result).toEqual(mockPayments.data)
    })

    it('should list payments with filters', async () => {
      vi.mocked(stripeServerClient.paymentIntents.list).mockResolvedValue(mockPayments)

      await listPayments({
        customerId: 'cus_123',
        status: 'succeeded',
        limit: 50,
        startingAfter: 'pi_0',
      })

      expect(stripeServerClient.paymentIntents.list).toHaveBeenCalledWith({
        customer: 'cus_123',
        limit: 50,
        starting_after: 'pi_0',
      })
    })

    it('should handle listing errors', async () => {
      vi.mocked(stripeServerClient.paymentIntents.list).mockRejectedValue(new Error('List failed'))

      await expect(listPayments({ customerId: 'cus_123' })).rejects.toThrow(
        'Internal server error. Please try again later.'
      )
    })
  })

  describe('getPaymentStatus', () => {
    it('should map succeeded status', () => {
      const paymentIntent = {
        status: 'succeeded',
        last_payment_error: null,
      } as Stripe.PaymentIntent

      const status = getPaymentStatus(paymentIntent)

      expect(status).toEqual({
        status: 'succeeded',
        isTerminal: true,
        requiresAction: false,
        error: null,
      })
    })

    it('should map requires_action status', () => {
      const paymentIntent = {
        status: 'requires_action',
        last_payment_error: null,
      } as Stripe.PaymentIntent

      const status = getPaymentStatus(paymentIntent)

      expect(status).toEqual({
        status: 'requires_action',
        isTerminal: false,
        requiresAction: true,
        error: null,
      })
    })

    it('should include error information', () => {
      const paymentIntent = {
        status: 'requires_payment_method',
        last_payment_error: {
          code: 'card_declined',
          message: 'Your card was declined',
        },
      } as Stripe.PaymentIntent

      const status = getPaymentStatus(paymentIntent)

      expect(status).toEqual({
        status: 'requires_payment_method',
        isTerminal: false,
        requiresAction: false,
        error: {
          code: 'card_declined',
          message: 'Your card was declined',
        },
      })
    })
  })
})
</file>

<file path="tests/unit/integrations/stripe-client.test.ts">
import { describe, it, expect, vi, beforeEach } from 'vitest'
import Stripe from 'stripe'

// Mock Stripe
vi.mock('stripe', () => {
  return {
    default: vi.fn().mockImplementation(() => ({
      paymentIntents: {
        create: vi.fn(),
        confirm: vi.fn(),
        cancel: vi.fn(),
        retrieve: vi.fn(),
      },
      customers: {
        create: vi.fn(),
        update: vi.fn(),
        retrieve: vi.fn(),
      },
      webhooks: {
        constructEvent: vi.fn(),
      },
      accounts: {
        create: vi.fn(),
        retrieve: vi.fn(),
      },
      transfers: {
        create: vi.fn(),
      },
    })),
    errors: {
      StripeError: class extends Error {
        constructor(message: string) {
          super(message)
          this.name = 'StripeError'
        }
      },
    },
  }
})

// Mock @stripe/stripe-js
vi.mock('@stripe/stripe-js', () => ({
  loadStripe: vi.fn().mockResolvedValue({
    confirmPayment: vi.fn(),
    confirmSetup: vi.fn(),
    elements: vi.fn(),
  }),
}))

describe('Stripe Client Configuration', () => {
  beforeEach(() => {
    vi.clearAllMocks()

    // Mock environment variables
    vi.stubEnv('VITE_STRIPE_SECRET_KEY', 'sk_test_mock_secret_key')
    vi.stubEnv('VITE_STRIPE_PUBLISHABLE_KEY', 'pk_test_mock_publishable_key')
    vi.stubEnv('VITE_STRIPE_WEBHOOK_SECRET', 'whsec_mock_webhook_secret')
  })

  it('should create Stripe server client with correct configuration', async () => {
    const { stripeServerClient } = await import('../../../src/integrations/stripe/client')

    expect(stripeServerClient).toBeDefined()
    // Verify the client was created (mocked)
    expect(vi.mocked(Stripe)).toHaveBeenCalledWith(
      'sk_test_mock_secret_key',
      expect.objectContaining({
        apiVersion: '2025-06-30.basil',
        typescript: true,
      })
    )
  })

  it('should load Stripe client for frontend', async () => {
    const { getStripeClient } = await import('../../../src/integrations/stripe/client')
    const { loadStripe } = await import('@stripe/stripe-js')

    const client = await getStripeClient()

    expect(loadStripe).toHaveBeenCalledWith('pk_test_mock_publishable_key')
    expect(client).toBeDefined()
  })

  it('should check if Stripe is configured', async () => {
    const { isStripeConfigured } = await import('../../../src/integrations/stripe/client')

    const isConfigured = isStripeConfigured()

    expect(isConfigured).toBe(true)
  })

  it('should return false when Stripe is not configured', async () => {
    // Clear environment variables
    vi.stubEnv('VITE_STRIPE_SECRET_KEY', '')
    vi.stubEnv('VITE_STRIPE_PUBLISHABLE_KEY', '')

    // Need to re-import to get updated env values
    vi.resetModules()
    const { isStripeConfigured } = await import('../../../src/integrations/stripe/client')

    const isConfigured = isStripeConfigured()

    expect(isConfigured).toBe(false)
  })

  it('should have correct stripe config', async () => {
    const { stripeConfig } = await import('../../../src/integrations/stripe/client')

    expect(stripeConfig).toEqual({
      webhookSecret: 'whsec_mock_webhook_secret',
      connectClientId: '', // Not set in test
      apiVersion: '2025-06-30.basil',
    })
  })
})
</file>

<file path="tests/unit/integrations/stripe-integration.test.ts">
import { describe, it, expect, vi, beforeEach } from 'vitest'
import type Stripe from 'stripe'
import {
  createPaymentIntent,
  validateStripeEnvironment,
  getStripeClient,
  isStripeConfigured,
} from '../../../src/integrations/stripe'

// Mock environment variables
vi.mock('import.meta', () => ({
  env: {
    VITE_STRIPE_SECRET_KEY: 'sk_test_mock_secret_key',
    VITE_STRIPE_PUBLISHABLE_KEY: 'pk_test_mock_publishable_key',
    VITE_STRIPE_WEBHOOK_SECRET: 'whsec_mock_webhook_secret',
  },
}))

// Mock Stripe
vi.mock('stripe', () => {
  const mockStripe = {
    paymentIntents: {
      create: vi.fn(),
      confirm: vi.fn(),
      cancel: vi.fn(),
      retrieve: vi.fn(),
    },
    customers: {
      create: vi.fn(),
    },
    webhooks: {
      constructEvent: vi.fn(),
    },
  }

  return {
    default: vi.fn(() => mockStripe),
  }
})

// Mock loadStripe
vi.mock('@stripe/stripe-js', () => ({
  loadStripe: vi.fn().mockResolvedValue({
    confirmPayment: vi.fn(),
    confirmSetup: vi.fn(),
  }),
}))

describe('Stripe Integration', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  describe('Environment Validation', () => {
    it('should validate required environment variables', () => {
      const result = validateStripeEnvironment()

      expect(result.isValid).toBe(true)
      expect(result.missing).toHaveLength(0)
    })

    it('should detect missing environment variables', () => {
      vi.doMock('import.meta', () => ({
        env: {
          VITE_STRIPE_SECRET_KEY: '',
          VITE_STRIPE_PUBLISHABLE_KEY: 'pk_test_mock',
          VITE_STRIPE_WEBHOOK_SECRET: '',
        },
      }))

      const result = validateStripeEnvironment()

      expect(result.isValid).toBe(false)
      expect(result.missing).toContain('VITE_STRIPE_SECRET_KEY')
      expect(result.missing).toContain('VITE_STRIPE_WEBHOOK_SECRET')
    })

    it('should check if Stripe is configured', () => {
      expect(isStripeConfigured()).toBe(true)
    })
  })

  describe('Stripe Client', () => {
    it('should load Stripe client', async () => {
      const stripeClient = await getStripeClient()
      expect(stripeClient).toBeDefined()
    })

    it('should return the same promise for multiple calls', async () => {
      const client1 = getStripeClient()
      const client2 = getStripeClient()

      expect(client1).toBe(client2)
    })
  })

  describe('Payment Intent Creation', () => {
    it('should create payment intent with valid parameters', async () => {
      const mockPaymentIntent = {
        id: 'pi_test_12345',
        client_secret: 'pi_test_12345_secret',
        amount: 5000,
        currency: 'usd',
        status: 'requires_payment_method',
      }

      // We need to mock the actual Stripe instance returned by the constructor
      const Stripe = await import('stripe')
      const mockStripeInstance = new Stripe.default()
      vi.mocked(mockStripeInstance.paymentIntents.create).mockResolvedValue(
        mockPaymentIntent as Partial<Stripe.PaymentIntent>
      )

      const params = {
        amount: 5000, // $50.00 in cents
        currency: 'usd',
        customerId: 'cus_test_customer',
        metadata: {
          invoice_id: 'inv_test_123',
          buyer_id: 'buyer_test_456',
        },
      }

      const result = await createPaymentIntent(params)

      expect(result).toEqual(mockPaymentIntent)
      expect(mockStripeInstance.paymentIntents.create).toHaveBeenCalledWith(
        {
          amount: 5000,
          currency: 'usd',
          customer: 'cus_test_customer',
          payment_method_types: ['card', 'us_bank_account'],
          metadata: {
            invoice_id: 'inv_test_123',
            buyer_id: 'buyer_test_456',
            platform: 'dependablecalls',
          },
          setup_future_usage: 'off_session',
          automatic_payment_methods: {
            enabled: true,
          },
        },
        {
          idempotencyKey: expect.any(String),
        }
      )
    })

    it('should handle Stripe errors gracefully', async () => {
      const Stripe = await import('stripe')
      const mockStripeInstance = new Stripe.default()
      const stripeError = new Error('Your card was declined.') as Error & { code: string }
      stripeError.name = 'StripeCardError'
      stripeError.code = 'card_declined'

      vi.mocked(mockStripeInstance.paymentIntents.create).mockRejectedValue(stripeError)

      const params = {
        amount: 5000,
        currency: 'usd',
      }

      await expect(createPaymentIntent(params)).rejects.toThrow('Payment service error')
    })

    it('should use default payment method types', async () => {
      const mockPaymentIntent = {
        id: 'pi_test_12345',
        client_secret: 'pi_test_12345_secret',
      }

      const Stripe = await import('stripe')
      const mockStripeInstance = new Stripe.default()
      vi.mocked(mockStripeInstance.paymentIntents.create).mockResolvedValue(
        mockPaymentIntent as Partial<Stripe.PaymentIntent>
      )

      const params = {
        amount: 2500,
        currency: 'usd',
      }

      await createPaymentIntent(params)

      expect(mockStripeInstance.paymentIntents.create).toHaveBeenCalledWith(
        expect.objectContaining({
          payment_method_types: ['card', 'us_bank_account'],
        }),
        expect.any(Object)
      )
    })
  })

  describe('Error Handling', () => {
    it('should handle network errors', async () => {
      const Stripe = await import('stripe')
      const mockStripeInstance = new Stripe.default()
      const networkError = new Error('Network error')

      vi.mocked(mockStripeInstance.paymentIntents.create).mockRejectedValue(networkError)

      const params = {
        amount: 1000,
        currency: 'usd',
      }

      await expect(createPaymentIntent(params)).rejects.toThrow('Internal server error')
    })

    it('should include idempotency keys', async () => {
      const mockPaymentIntent = { id: 'pi_test_12345' }

      const Stripe = await import('stripe')
      const mockStripeInstance = new Stripe.default()
      vi.mocked(mockStripeInstance.paymentIntents.create).mockResolvedValue(
        mockPaymentIntent as Partial<Stripe.PaymentIntent>
      )

      const params = {
        amount: 1000,
        currency: 'usd',
      }

      await createPaymentIntent(params)

      expect(mockStripeInstance.paymentIntents.create).toHaveBeenCalledWith(
        expect.any(Object),
        expect.objectContaining({
          idempotencyKey: expect.any(String),
        })
      )
    })
  })

  describe('Metadata Handling', () => {
    it('should include platform metadata', async () => {
      const mockPaymentIntent = { id: 'pi_test_12345' }

      const Stripe = await import('stripe')
      const mockStripeInstance = new Stripe.default()
      vi.mocked(mockStripeInstance.paymentIntents.create).mockResolvedValue(
        mockPaymentIntent as Partial<Stripe.PaymentIntent>
      )

      const params = {
        amount: 1000,
        currency: 'usd',
        metadata: {
          custom_field: 'test_value',
        },
      }

      await createPaymentIntent(params)

      expect(mockStripeInstance.paymentIntents.create).toHaveBeenCalledWith(
        expect.objectContaining({
          metadata: expect.objectContaining({
            platform: 'dependablecalls',
            custom_field: 'test_value',
          }),
        }),
        expect.any(Object)
      )
    })
  })
})
</file>

<file path="tests/unit/pages/auth/ForgotPasswordPage.test.tsx">
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import { screen, fireEvent, waitFor } from '@testing-library/react'
import { render } from '@/test/test-utils'
import ForgotPasswordPage from '@/pages/auth/ForgotPasswordPage'

// Mock the router navigate function
const mockNavigate = vi.fn()
vi.mock('react-router-dom', async () => {
  const actual = await vi.importActual('react-router-dom')
  return {
    ...actual,
    useNavigate: () => mockNavigate,
    Link: ({ to, children, ...props }: { to: string; children: React.ReactNode }) => (
      <a href={to} {...props}>
        {children}
      </a>
    ),
  }
})

// Mock Supabase
vi.mock('@/lib/supabase', () => ({
  supabase: {
    auth: {
      resetPasswordForEmail: vi.fn(),
    },
  },
}))

// Import to get the mocked function reference
import { supabase } from '@/lib/supabase'
const mockResetPasswordForEmail = vi.mocked(supabase.auth.resetPasswordForEmail)

// Mock window.location
Object.defineProperty(window, 'location', {
  value: {
    origin: 'http://localhost:3000',
  },
  writable: true,
})

describe('ForgotPasswordPage', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  afterEach(() => {
    vi.restoreAllMocks()
  })

  it('should render forgot password form with all required elements', () => {
    render(<ForgotPasswordPage />)

    expect(screen.getByRole('heading', { name: /forgot your password/i })).toBeInTheDocument()
    expect(
      screen.getByText(/enter your email address and we'll send you a link/i)
    ).toBeInTheDocument()
    expect(screen.getByPlaceholderText(/enter your email/i)).toBeInTheDocument()
    expect(screen.getByRole('button', { name: /send reset link/i })).toBeInTheDocument()
    expect(screen.getByRole('link', { name: /back to login/i })).toHaveAttribute('href', '/login')
  })

  it('should validate email field', async () => {
    render(<ForgotPasswordPage />)

    const emailInput = screen.getByPlaceholderText(/enter your email/i)
    const submitButton = screen.getByRole('button', { name: /send reset link/i })

    // Test invalid email
    fireEvent.change(emailInput, { target: { value: 'invalid-email' } })
    fireEvent.blur(emailInput) // Trigger validation
    fireEvent.click(submitButton)

    await waitFor(() => {
      expect(screen.getByText(/invalid email address/i)).toBeInTheDocument()
    })
  })

  it('should handle successful password reset request', async () => {
    mockResetPasswordForEmail.mockResolvedValueOnce({ error: null })

    render(<ForgotPasswordPage />)

    const emailInput = screen.getByPlaceholderText(/enter your email/i)
    const submitButton = screen.getByRole('button', { name: /send reset link/i })

    // Fill in valid email
    fireEvent.change(emailInput, { target: { value: 'test@example.com' } })
    fireEvent.click(submitButton)

    // Check loading state
    await waitFor(() => {
      expect(screen.getByText(/sending.../i)).toBeInTheDocument()
    })

    // Check that resetPasswordForEmail was called with correct arguments
    await waitFor(() => {
      expect(mockResetPasswordForEmail).toHaveBeenCalledWith('test@example.com', {
        redirectTo: 'http://localhost:3000/reset-password',
      })
    })

    // Check success state is displayed
    await waitFor(() => {
      expect(screen.getByRole('heading', { name: /check your email/i })).toBeInTheDocument()
      expect(
        screen.getByText(/we've sent a password reset link to your email address/i)
      ).toBeInTheDocument()
      expect(screen.getByRole('link', { name: /back to login/i })).toHaveAttribute('href', '/login')
    })
  })

  it('should handle password reset error with Error instance', async () => {
    const errorMessage = 'User not found'
    mockResetPasswordForEmail.mockResolvedValueOnce({ error: new Error(errorMessage) })

    render(<ForgotPasswordPage />)

    const emailInput = screen.getByPlaceholderText(/enter your email/i)
    const submitButton = screen.getByRole('button', { name: /send reset link/i })

    // Fill in email
    fireEvent.change(emailInput, { target: { value: 'test@example.com' } })
    fireEvent.click(submitButton)

    // Wait for error to appear
    await waitFor(() => {
      expect(screen.getByText(errorMessage)).toBeInTheDocument()
    })

    // Check that loading state is cleared
    expect(screen.getByRole('button', { name: /send reset link/i })).toBeInTheDocument()
    expect(screen.queryByText(/sending.../i)).not.toBeInTheDocument()
  })

  it('should handle password reset error with non-Error instance', async () => {
    mockResetPasswordForEmail.mockRejectedValueOnce('String error')

    render(<ForgotPasswordPage />)

    const emailInput = screen.getByPlaceholderText(/enter your email/i)
    const submitButton = screen.getByRole('button', { name: /send reset link/i })

    // Fill in email
    fireEvent.change(emailInput, { target: { value: 'test@example.com' } })
    fireEvent.click(submitButton)

    // Wait for default error message to appear
    await waitFor(() => {
      expect(screen.getByText(/failed to send reset email/i)).toBeInTheDocument()
    })
  })

  it('should disable submit button while loading', async () => {
    // Mock a slow reset request to test loading state
    mockResetPasswordForEmail.mockImplementation(
      () => new Promise((resolve) => setTimeout(() => resolve({ error: null }), 1000))
    )

    render(<ForgotPasswordPage />)

    const emailInput = screen.getByPlaceholderText(/enter your email/i)
    const submitButton = screen.getByRole('button', { name: /send reset link/i })

    // Fill in email and submit
    fireEvent.change(emailInput, { target: { value: 'test@example.com' } })
    fireEvent.click(submitButton)

    // Check that button is disabled and shows loading text
    await waitFor(() => {
      const loadingButton = screen.getByRole('button', { name: /sending.../i })
      expect(loadingButton).toBeDisabled()
    })
  })

  it('should clear error when form is resubmitted', async () => {
    // First submission fails
    mockResetPasswordForEmail.mockResolvedValueOnce({ error: new Error('Network error') })

    render(<ForgotPasswordPage />)

    const emailInput = screen.getByPlaceholderText(/enter your email/i)
    const submitButton = screen.getByRole('button', { name: /send reset link/i })

    // First submission
    fireEvent.change(emailInput, { target: { value: 'test@example.com' } })
    fireEvent.click(submitButton)

    // Wait for error
    await waitFor(() => {
      expect(screen.getByText(/network error/i)).toBeInTheDocument()
    })

    // Second submission should succeed
    mockResetPasswordForEmail.mockResolvedValueOnce({ error: null })
    fireEvent.click(submitButton)

    // Error should be cleared during loading
    await waitFor(() => {
      expect(screen.queryByText(/network error/i)).not.toBeInTheDocument()
    })
  })

  it('should not submit form with missing email', async () => {
    render(<ForgotPasswordPage />)

    const emailInput = screen.getByPlaceholderText(/enter your email/i)
    const submitButton = screen.getByRole('button', { name: /send reset link/i })

    // Try to submit empty form
    fireEvent.blur(emailInput) // Trigger validation on empty field
    fireEvent.click(submitButton)

    // Should show validation error
    await waitFor(() => {
      expect(screen.getByText(/invalid email address/i)).toBeInTheDocument()
    })

    // Should not call resetPasswordForEmail
    expect(mockResetPasswordForEmail).not.toHaveBeenCalled()
  })

  it('should handle form submission with Enter key', async () => {
    mockResetPasswordForEmail.mockResolvedValueOnce({ error: null })

    render(<ForgotPasswordPage />)

    const emailInput = screen.getByPlaceholderText(/enter your email/i)

    // Fill in email
    fireEvent.change(emailInput, { target: { value: 'test@example.com' } })

    // Submit with Enter key
    fireEvent.keyDown(emailInput, { key: 'Enter', code: 'Enter' })

    await waitFor(() => {
      expect(mockResetPasswordForEmail).toHaveBeenCalledWith('test@example.com', {
        redirectTo: 'http://localhost:3000/reset-password',
      })
    })
  })

  it('should have proper accessibility attributes', () => {
    render(<ForgotPasswordPage />)

    const emailInput = screen.getByPlaceholderText(/enter your email/i)

    expect(emailInput).toHaveAttribute('type', 'email')
    expect(emailInput).toHaveAttribute('autoComplete', 'email')

    // Check that label exists for accessibility
    expect(screen.getByText(/email address/i)).toBeInTheDocument()
  })

  it('should render success state correctly', async () => {
    mockResetPasswordForEmail.mockResolvedValueOnce({ error: null })

    render(<ForgotPasswordPage />)

    const emailInput = screen.getByPlaceholderText(/enter your email/i)
    const submitButton = screen.getByRole('button', { name: /send reset link/i })

    // Submit form
    fireEvent.change(emailInput, { target: { value: 'test@example.com' } })
    fireEvent.click(submitButton)

    // Wait for success state
    await waitFor(() => {
      expect(screen.getByRole('heading', { name: /check your email/i })).toBeInTheDocument()
    })

    // Check that form is no longer visible
    expect(screen.queryByPlaceholderText(/enter your email/i)).not.toBeInTheDocument()
    expect(screen.queryByRole('button', { name: /send reset link/i })).not.toBeInTheDocument()

    // Check success message and back link
    expect(
      screen.getByText(/we've sent a password reset link to your email address/i)
    ).toBeInTheDocument()
    expect(screen.getByRole('link', { name: /back to login/i })).toHaveAttribute('href', '/login')
  })

  it('should set correct redirect URL based on current origin', async () => {
    // Mock different origin
    Object.defineProperty(window, 'location', {
      value: {
        origin: 'https://dependablecalls.com',
      },
      writable: true,
    })

    mockResetPasswordForEmail.mockResolvedValueOnce({ error: null })

    render(<ForgotPasswordPage />)

    const emailInput = screen.getByPlaceholderText(/enter your email/i)
    const submitButton = screen.getByRole('button', { name: /send reset link/i })

    fireEvent.change(emailInput, { target: { value: 'test@example.com' } })
    fireEvent.click(submitButton)

    await waitFor(() => {
      expect(mockResetPasswordForEmail).toHaveBeenCalledWith('test@example.com', {
        redirectTo: 'https://dependablecalls.com/reset-password',
      })
    })

    // Reset location for other tests
    Object.defineProperty(window, 'location', {
      value: {
        origin: 'http://localhost:3000',
      },
      writable: true,
    })
  })

  it('should maintain email input value after validation error', async () => {
    render(<ForgotPasswordPage />)

    const emailInput = screen.getByPlaceholderText(/enter your email/i)
    const submitButton = screen.getByRole('button', { name: /send reset link/i })

    // Enter invalid email
    fireEvent.change(emailInput, { target: { value: 'invalid-email' } })
    fireEvent.click(submitButton)

    // Wait for validation error
    await waitFor(() => {
      expect(screen.getByText(/invalid email address/i)).toBeInTheDocument()
    })

    // Check that input value is preserved
    expect(emailInput).toHaveValue('invalid-email')
  })

  it('should show error message styling correctly', async () => {
    mockResetPasswordForEmail.mockResolvedValueOnce({ error: new Error('Test error') })

    render(<ForgotPasswordPage />)

    const emailInput = screen.getByPlaceholderText(/enter your email/i)
    const submitButton = screen.getByRole('button', { name: /send reset link/i })

    fireEvent.change(emailInput, { target: { value: 'test@example.com' } })
    fireEvent.click(submitButton)

    await waitFor(() => {
      const errorElement = screen.getByText('Test error')
      expect(errorElement).toBeInTheDocument()
      // Find the error container div that has the styling classes
      const errorContainer = errorElement.closest('div[class*="bg-red-50"]')
      expect(errorContainer).toHaveClass('rounded-md', 'bg-red-50', 'p-4')
    })
  })
})
</file>

<file path="tests/unit/pages/auth/LoginPage.test.tsx">
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import { screen, fireEvent, waitFor } from '@testing-library/react'
import { render } from '@/test/test-utils'
import LoginPage from '@/pages/auth/LoginPage'

// Mock the router navigate function
const mockNavigate = vi.fn()
vi.mock('react-router-dom', async () => {
  const actual = await vi.importActual('react-router-dom')
  return {
    ...actual,
    useNavigate: () => mockNavigate,
    Link: ({ to, children, ...props }: { to: string; children: React.ReactNode }) => (
      <a href={to} {...props}>
        {children}
      </a>
    ),
  }
})

// Mock the auth store
const mockSignIn = vi.fn()
vi.mock('@/store/authStore', () => ({
  useAuthStore: vi.fn(() => ({
    signIn: mockSignIn,
  })),
}))

describe('LoginPage', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  afterEach(() => {
    vi.restoreAllMocks()
  })

  it('should render login form with all required fields', () => {
    render(<LoginPage />)

    expect(screen.getByRole('heading', { name: /sign in to your account/i })).toBeInTheDocument()
    expect(screen.getByPlaceholderText(/email address/i)).toBeInTheDocument()
    expect(screen.getByPlaceholderText(/password/i)).toBeInTheDocument()
    expect(screen.getByRole('button', { name: /sign in/i })).toBeInTheDocument()
    expect(screen.getByRole('checkbox', { name: /remember me/i })).toBeInTheDocument()
  })

  it('should display navigation links', () => {
    render(<LoginPage />)

    expect(screen.getByRole('link', { name: /create a new account/i })).toHaveAttribute(
      'href',
      '/register'
    )
    expect(screen.getByRole('link', { name: /forgot your password/i })).toHaveAttribute(
      'href',
      '/forgot-password'
    )
  })

  it('should validate email field', async () => {
    render(<LoginPage />)

    const emailInput = screen.getByPlaceholderText(/email address/i)
    const passwordInput = screen.getByPlaceholderText(/password/i)
    const submitButton = screen.getByRole('button', { name: /sign in/i })

    // Test invalid email - need valid password to trigger email validation
    fireEvent.change(emailInput, { target: { value: 'invalid-email' } })
    fireEvent.change(passwordInput, { target: { value: 'validpassword' } })
    fireEvent.click(submitButton)

    await waitFor(() => {
      expect(screen.getByText(/invalid email address/i)).toBeInTheDocument()
    })
  })

  it('should validate password field', async () => {
    render(<LoginPage />)

    const emailInput = screen.getByPlaceholderText(/email address/i)
    const passwordInput = screen.getByPlaceholderText(/password/i)
    const submitButton = screen.getByRole('button', { name: /sign in/i })

    // Test short password - need valid email to trigger password validation
    fireEvent.change(emailInput, { target: { value: 'test@example.com' } })
    fireEvent.change(passwordInput, { target: { value: '12345' } })
    fireEvent.click(submitButton)

    await waitFor(() => {
      expect(screen.getByText(/password must be at least 6 characters/i)).toBeInTheDocument()
    })
  })

  it('should handle successful login', async () => {
    mockSignIn.mockResolvedValueOnce(undefined)

    render(<LoginPage />)

    const emailInput = screen.getByPlaceholderText(/email address/i)
    const passwordInput = screen.getByPlaceholderText(/password/i)
    const submitButton = screen.getByRole('button', { name: /sign in/i })

    // Fill in valid credentials
    fireEvent.change(emailInput, { target: { value: 'test@example.com' } })
    fireEvent.change(passwordInput, { target: { value: 'password123' } })
    fireEvent.click(submitButton)

    // Check loading state
    await waitFor(() => {
      expect(screen.getByText(/signing in.../i)).toBeInTheDocument()
    })

    // Check that signIn was called with correct arguments
    await waitFor(() => {
      expect(mockSignIn).toHaveBeenCalledWith('test@example.com', 'password123')
    })

    // Check navigation after successful login
    await waitFor(() => {
      expect(mockNavigate).toHaveBeenCalledWith('/app/dashboard')
    })
  })

  it('should handle login error with Error instance', async () => {
    const errorMessage = 'Invalid credentials'
    mockSignIn.mockRejectedValueOnce(new Error(errorMessage))

    render(<LoginPage />)

    const emailInput = screen.getByPlaceholderText(/email address/i)
    const passwordInput = screen.getByPlaceholderText(/password/i)
    const submitButton = screen.getByRole('button', { name: /sign in/i })

    // Fill in credentials
    fireEvent.change(emailInput, { target: { value: 'test@example.com' } })
    fireEvent.change(passwordInput, { target: { value: 'wrongpassword' } })
    fireEvent.click(submitButton)

    // Wait for error to appear
    await waitFor(() => {
      expect(screen.getByText(errorMessage)).toBeInTheDocument()
    })

    // Check that loading state is cleared
    expect(screen.getByRole('button', { name: /sign in/i })).toBeInTheDocument()
    expect(screen.queryByText(/signing in.../i)).not.toBeInTheDocument()
  })

  it('should handle login error with non-Error instance', async () => {
    mockSignIn.mockRejectedValueOnce('String error')

    render(<LoginPage />)

    const emailInput = screen.getByPlaceholderText(/email address/i)
    const passwordInput = screen.getByPlaceholderText(/password/i)
    const submitButton = screen.getByRole('button', { name: /sign in/i })

    // Fill in credentials
    fireEvent.change(emailInput, { target: { value: 'test@example.com' } })
    fireEvent.change(passwordInput, { target: { value: 'wrongpassword' } })
    fireEvent.click(submitButton)

    // Wait for default error message to appear
    await waitFor(() => {
      expect(screen.getByText(/invalid email or password/i)).toBeInTheDocument()
    })
  })

  it('should disable submit button while loading', async () => {
    // Mock a slow sign in to test loading state
    mockSignIn.mockImplementation(() => new Promise((resolve) => setTimeout(resolve, 1000)))

    render(<LoginPage />)

    const emailInput = screen.getByPlaceholderText(/email address/i)
    const passwordInput = screen.getByPlaceholderText(/password/i)
    const submitButton = screen.getByRole('button', { name: /sign in/i })

    // Fill in credentials and submit
    fireEvent.change(emailInput, { target: { value: 'test@example.com' } })
    fireEvent.change(passwordInput, { target: { value: 'password123' } })
    fireEvent.click(submitButton)

    // Check that button is disabled and shows loading text
    await waitFor(() => {
      const loadingButton = screen.getByRole('button', { name: /signing in.../i })
      expect(loadingButton).toBeDisabled()
    })
  })

  it('should clear error when form is resubmitted', async () => {
    // First submission fails
    mockSignIn.mockRejectedValueOnce(new Error('Network error'))

    render(<LoginPage />)

    const emailInput = screen.getByPlaceholderText(/email address/i)
    const passwordInput = screen.getByPlaceholderText(/password/i)
    const submitButton = screen.getByRole('button', { name: /sign in/i })

    // First submission
    fireEvent.change(emailInput, { target: { value: 'test@example.com' } })
    fireEvent.change(passwordInput, { target: { value: 'password123' } })
    fireEvent.click(submitButton)

    // Wait for error
    await waitFor(() => {
      expect(screen.getByText(/network error/i)).toBeInTheDocument()
    })

    // Second submission should succeed
    mockSignIn.mockResolvedValueOnce(undefined)
    fireEvent.click(submitButton)

    // Error should be cleared
    await waitFor(() => {
      expect(screen.queryByText(/network error/i)).not.toBeInTheDocument()
    })
  })

  it('should not submit form with missing fields', async () => {
    render(<LoginPage />)

    const submitButton = screen.getByRole('button', { name: /sign in/i })

    // Submit empty form
    fireEvent.click(submitButton)

    // Should show validation errors
    await waitFor(() => {
      expect(screen.getByText(/invalid email address/i)).toBeInTheDocument()
      expect(screen.getByText(/password must be at least 6 characters/i)).toBeInTheDocument()
    })

    // Should not call signIn
    expect(mockSignIn).not.toHaveBeenCalled()
  })

  it('should allow checking remember me checkbox', () => {
    render(<LoginPage />)

    const rememberMeCheckbox = screen.getByRole('checkbox', { name: /remember me/i })

    expect(rememberMeCheckbox).not.toBeChecked()

    fireEvent.click(rememberMeCheckbox)

    expect(rememberMeCheckbox).toBeChecked()
  })

  it('should handle form submission with Enter key', async () => {
    mockSignIn.mockResolvedValueOnce(undefined)

    render(<LoginPage />)

    const emailInput = screen.getByPlaceholderText(/email address/i)
    const passwordInput = screen.getByPlaceholderText(/password/i)

    // Fill in credentials
    fireEvent.change(emailInput, { target: { value: 'test@example.com' } })
    fireEvent.change(passwordInput, { target: { value: 'password123' } })

    // Submit with Enter key on password field
    fireEvent.keyDown(passwordInput, { key: 'Enter', code: 'Enter' })

    await waitFor(() => {
      expect(mockSignIn).toHaveBeenCalledWith('test@example.com', 'password123')
    })
  })

  it('should have proper accessibility attributes', () => {
    render(<LoginPage />)

    const emailInput = screen.getByPlaceholderText(/email address/i)
    const passwordInput = screen.getByPlaceholderText(/password/i)

    expect(emailInput).toHaveAttribute('type', 'email')
    expect(emailInput).toHaveAttribute('autoComplete', 'email')
    expect(passwordInput).toHaveAttribute('type', 'password')
    expect(passwordInput).toHaveAttribute('autoComplete', 'current-password')

    // Check for label association
    expect(screen.getByLabelText(/email address/i)).toBe(emailInput)
    expect(screen.getByLabelText(/password/i)).toBe(passwordInput)
  })
})
</file>

<file path="tests/unit/pages/auth/RegisterPage.test.tsx">
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import { screen, fireEvent, waitFor } from '@testing-library/react'
import { render } from '@/test/test-utils'
import RegisterPage from '@/pages/auth/RegisterPage'

// Mock the router navigate function
const mockNavigate = vi.fn()
vi.mock('react-router-dom', async () => {
  const actual = await vi.importActual('react-router-dom')
  return {
    ...actual,
    useNavigate: () => mockNavigate,
    Link: ({ to, children, ...props }: { to: string; children: React.ReactNode }) => (
      <a href={to} {...props}>
        {children}
      </a>
    ),
  }
})

// Mock the auth store
const mockSignUp = vi.fn()
vi.mock('@/store/authStore', () => ({
  useAuthStore: vi.fn(() => ({
    signUp: mockSignUp,
  })),
}))

describe('RegisterPage', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  afterEach(() => {
    vi.restoreAllMocks()
  })

  it('should render registration form with all required fields', () => {
    render(<RegisterPage />)

    expect(screen.getByRole('heading', { name: /create your account/i })).toBeInTheDocument()
    expect(screen.getByText(/i am a.../i)).toBeInTheDocument()
    expect(screen.getByRole('radio', { name: /supplier/i })).toBeInTheDocument()
    expect(screen.getByRole('radio', { name: /buyer/i })).toBeInTheDocument()
    expect(screen.getByLabelText(/email address/i)).toBeInTheDocument()
    expect(screen.getByLabelText(/^password$/i)).toBeInTheDocument()
    expect(screen.getByLabelText(/confirm password/i)).toBeInTheDocument()
    expect(screen.getByRole('checkbox')).toBeInTheDocument()
    expect(screen.getByRole('button', { name: /create account/i })).toBeInTheDocument()
  })

  it('should display navigation link to login', () => {
    render(<RegisterPage />)

    expect(screen.getByRole('link', { name: /sign in to existing account/i })).toHaveAttribute(
      'href',
      '/login'
    )
  })

  it('should have supplier selected by default', () => {
    render(<RegisterPage />)

    const supplierRadio = screen.getByRole('radio', { name: /supplier/i })
    const buyerRadio = screen.getByRole('radio', { name: /buyer/i })

    expect(supplierRadio).toBeChecked()
    expect(buyerRadio).not.toBeChecked()
  })

  it('should allow switching between user types', () => {
    render(<RegisterPage />)

    const supplierRadio = screen.getByRole('radio', { name: /supplier/i })
    const buyerRadio = screen.getByRole('radio', { name: /buyer/i })

    // Initially supplier should be selected
    expect(supplierRadio).toBeChecked()
    expect(buyerRadio).not.toBeChecked()

    // Click buyer radio
    fireEvent.click(buyerRadio)

    expect(buyerRadio).toBeChecked()
    expect(supplierRadio).not.toBeChecked()

    // Click supplier radio again
    fireEvent.click(supplierRadio)

    expect(supplierRadio).toBeChecked()
    expect(buyerRadio).not.toBeChecked()
  })

  it('should validate email field', async () => {
    render(<RegisterPage />)

    const emailInput = screen.getByLabelText(/email address/i)
    const submitButton = screen.getByRole('button', { name: /create account/i })

    // Test invalid email
    fireEvent.change(emailInput, { target: { value: 'invalid-email' } })
    fireEvent.click(submitButton)

    await waitFor(() => {
      expect(screen.getByText(/invalid email address/i)).toBeInTheDocument()
    })
  })

  it('should validate password length', async () => {
    render(<RegisterPage />)

    const passwordInput = screen.getByLabelText(/^password$/i)
    const submitButton = screen.getByRole('button', { name: /create account/i })

    // Test short password
    fireEvent.change(passwordInput, { target: { value: '1234567' } })
    fireEvent.click(submitButton)

    await waitFor(() => {
      expect(screen.getByText(/password must be at least 8 characters/i)).toBeInTheDocument()
    })
  })

  it('should validate password confirmation', async () => {
    render(<RegisterPage />)

    const passwordInput = screen.getByLabelText(/^password$/i)
    const confirmPasswordInput = screen.getByLabelText(/confirm password/i)
    const submitButton = screen.getByRole('button', { name: /create account/i })

    // Enter different passwords
    fireEvent.change(passwordInput, { target: { value: 'password123' } })
    fireEvent.change(confirmPasswordInput, { target: { value: 'different123' } })
    fireEvent.click(submitButton)

    await waitFor(() => {
      expect(screen.getByText(/passwords don't match/i)).toBeInTheDocument()
    })
  })

  it('should validate terms acceptance', async () => {
    render(<RegisterPage />)

    const emailInput = screen.getByLabelText(/email address/i)
    const passwordInput = screen.getByLabelText(/^password$/i)
    const confirmPasswordInput = screen.getByLabelText(/confirm password/i)
    const submitButton = screen.getByRole('button', { name: /create account/i })

    // Fill valid data but don't accept terms
    fireEvent.change(emailInput, { target: { value: 'test@example.com' } })
    fireEvent.change(passwordInput, { target: { value: 'password123' } })
    fireEvent.change(confirmPasswordInput, { target: { value: 'password123' } })
    fireEvent.click(submitButton)

    await waitFor(() => {
      expect(screen.getByText(/you must accept the terms and conditions/i)).toBeInTheDocument()
    })
  })

  it('should handle successful registration', async () => {
    mockSignUp.mockResolvedValueOnce(undefined)

    render(<RegisterPage />)

    const emailInput = screen.getByLabelText(/email address/i)
    const passwordInput = screen.getByLabelText(/^password$/i)
    const confirmPasswordInput = screen.getByLabelText(/confirm password/i)
    const termsCheckbox = screen.getByRole('checkbox')
    const submitButton = screen.getByRole('button', { name: /create account/i })

    // Fill in valid data
    fireEvent.change(emailInput, { target: { value: 'test@example.com' } })
    fireEvent.change(passwordInput, { target: { value: 'password123' } })
    fireEvent.change(confirmPasswordInput, { target: { value: 'password123' } })
    fireEvent.click(termsCheckbox)
    fireEvent.click(submitButton)

    // Check loading state
    await waitFor(() => {
      expect(screen.getByText(/creating account.../i)).toBeInTheDocument()
    })

    // Check that signUp was called with correct arguments (default supplier)
    await waitFor(() => {
      expect(mockSignUp).toHaveBeenCalledWith('test@example.com', 'password123', 'supplier')
    })

    // Check navigation after successful registration
    await waitFor(() => {
      expect(mockNavigate).toHaveBeenCalledWith('/app/dashboard')
    })
  })

  it('should handle registration with buyer user type', async () => {
    mockSignUp.mockResolvedValueOnce(undefined)

    render(<RegisterPage />)

    const buyerRadio = screen.getByRole('radio', { name: /buyer/i })
    const emailInput = screen.getByLabelText(/email address/i)
    const passwordInput = screen.getByLabelText(/^password$/i)
    const confirmPasswordInput = screen.getByLabelText(/confirm password/i)
    const termsCheckbox = screen.getByRole('checkbox')
    const submitButton = screen.getByRole('button', { name: /create account/i })

    // Select buyer user type
    fireEvent.click(buyerRadio)

    // Fill in valid data
    fireEvent.change(emailInput, { target: { value: 'buyer@example.com' } })
    fireEvent.change(passwordInput, { target: { value: 'password123' } })
    fireEvent.change(confirmPasswordInput, { target: { value: 'password123' } })
    fireEvent.click(termsCheckbox)
    fireEvent.click(submitButton)

    // Check that signUp was called with buyer type
    await waitFor(() => {
      expect(mockSignUp).toHaveBeenCalledWith('buyer@example.com', 'password123', 'buyer')
    })
  })

  it('should handle registration error with Error instance', async () => {
    const errorMessage = 'Email already exists'
    mockSignUp.mockRejectedValueOnce(new Error(errorMessage))

    render(<RegisterPage />)

    const emailInput = screen.getByLabelText(/email address/i)
    const passwordInput = screen.getByLabelText(/^password$/i)
    const confirmPasswordInput = screen.getByLabelText(/confirm password/i)
    const termsCheckbox = screen.getByRole('checkbox')
    const submitButton = screen.getByRole('button', { name: /create account/i })

    // Fill in data
    fireEvent.change(emailInput, { target: { value: 'test@example.com' } })
    fireEvent.change(passwordInput, { target: { value: 'password123' } })
    fireEvent.change(confirmPasswordInput, { target: { value: 'password123' } })
    fireEvent.click(termsCheckbox)
    fireEvent.click(submitButton)

    // Wait for error to appear
    await waitFor(() => {
      expect(screen.getByText(errorMessage)).toBeInTheDocument()
    })

    // Check that loading state is cleared
    expect(screen.getByRole('button', { name: /create account/i })).toBeInTheDocument()
    expect(screen.queryByText(/creating account.../i)).not.toBeInTheDocument()
  })

  it('should handle registration error with non-Error instance', async () => {
    mockSignUp.mockRejectedValueOnce('String error')

    render(<RegisterPage />)

    const emailInput = screen.getByLabelText(/email address/i)
    const passwordInput = screen.getByLabelText(/^password$/i)
    const confirmPasswordInput = screen.getByLabelText(/confirm password/i)
    const termsCheckbox = screen.getByRole('checkbox')
    const submitButton = screen.getByRole('button', { name: /create account/i })

    // Fill in data
    fireEvent.change(emailInput, { target: { value: 'test@example.com' } })
    fireEvent.change(passwordInput, { target: { value: 'password123' } })
    fireEvent.change(confirmPasswordInput, { target: { value: 'password123' } })
    fireEvent.click(termsCheckbox)
    fireEvent.click(submitButton)

    // Wait for default error message to appear
    await waitFor(() => {
      expect(screen.getByText(/failed to create account/i)).toBeInTheDocument()
    })
  })

  it('should disable submit button while loading', async () => {
    // Mock a slow sign up to test loading state
    mockSignUp.mockImplementation(() => new Promise((resolve) => setTimeout(resolve, 1000)))

    render(<RegisterPage />)

    const emailInput = screen.getByLabelText(/email address/i)
    const passwordInput = screen.getByLabelText(/^password$/i)
    const confirmPasswordInput = screen.getByLabelText(/confirm password/i)
    const termsCheckbox = screen.getByRole('checkbox')
    const submitButton = screen.getByRole('button', { name: /create account/i })

    // Fill in data and submit
    fireEvent.change(emailInput, { target: { value: 'test@example.com' } })
    fireEvent.change(passwordInput, { target: { value: 'password123' } })
    fireEvent.change(confirmPasswordInput, { target: { value: 'password123' } })
    fireEvent.click(termsCheckbox)
    fireEvent.click(submitButton)

    // Check that button is disabled and shows loading text
    await waitFor(() => {
      const loadingButton = screen.getByRole('button', { name: /creating account.../i })
      expect(loadingButton).toBeDisabled()
    })
  })

  it('should clear error when form is resubmitted', async () => {
    // First submission fails
    mockSignUp.mockRejectedValueOnce(new Error('Network error'))

    render(<RegisterPage />)

    const emailInput = screen.getByLabelText(/email address/i)
    const passwordInput = screen.getByLabelText(/^password$/i)
    const confirmPasswordInput = screen.getByLabelText(/confirm password/i)
    const termsCheckbox = screen.getByRole('checkbox')
    const submitButton = screen.getByRole('button', { name: /create account/i })

    // First submission
    fireEvent.change(emailInput, { target: { value: 'test@example.com' } })
    fireEvent.change(passwordInput, { target: { value: 'password123' } })
    fireEvent.change(confirmPasswordInput, { target: { value: 'password123' } })
    fireEvent.click(termsCheckbox)
    fireEvent.click(submitButton)

    // Wait for error
    await waitFor(() => {
      expect(screen.getByText(/network error/i)).toBeInTheDocument()
    })

    // Second submission should succeed
    mockSignUp.mockResolvedValueOnce(undefined)
    fireEvent.click(submitButton)

    // Error should be cleared
    await waitFor(() => {
      expect(screen.queryByText(/network error/i)).not.toBeInTheDocument()
    })
  })

  it('should display terms and privacy policy links', () => {
    render(<RegisterPage />)

    expect(screen.getByRole('link', { name: /terms and conditions/i })).toHaveAttribute(
      'href',
      '/terms'
    )
    expect(screen.getByRole('link', { name: /privacy policy/i })).toHaveAttribute(
      'href',
      '/privacy'
    )
  })

  it('should have proper accessibility attributes', () => {
    render(<RegisterPage />)

    const emailInput = screen.getByLabelText(/email address/i)
    const passwordInput = screen.getByLabelText(/^password$/i)
    const confirmPasswordInput = screen.getByLabelText(/confirm password/i)

    expect(emailInput).toHaveAttribute('type', 'email')
    expect(emailInput).toHaveAttribute('autoComplete', 'email')
    expect(passwordInput).toHaveAttribute('type', 'password')
    expect(passwordInput).toHaveAttribute('autoComplete', 'new-password')
    expect(confirmPasswordInput).toHaveAttribute('type', 'password')
    expect(confirmPasswordInput).toHaveAttribute('autoComplete', 'new-password')
  })

  it('should show user type descriptions', () => {
    render(<RegisterPage />)

    expect(screen.getByText(/i have traffic to send/i)).toBeInTheDocument()
    expect(screen.getByText(/i need quality calls/i)).toBeInTheDocument()
  })

  it('should highlight selected user type visually', () => {
    render(<RegisterPage />)

    const supplierRadio = screen.getByRole('radio', { name: /supplier/i })
    const buyerRadio = screen.getByRole('radio', { name: /buyer/i })

    // Initially supplier should be highlighted
    expect(supplierRadio).toBeChecked()

    // Click buyer to switch
    fireEvent.click(buyerRadio)
    expect(buyerRadio).toBeChecked()
    expect(supplierRadio).not.toBeChecked()
  })

  it('should not submit form with missing required fields', async () => {
    render(<RegisterPage />)

    const submitButton = screen.getByRole('button', { name: /create account/i })

    // Submit empty form
    fireEvent.click(submitButton)

    // Should show validation errors
    await waitFor(() => {
      expect(screen.getByText(/invalid email address/i)).toBeInTheDocument()
      expect(screen.getByText(/password must be at least 8 characters/i)).toBeInTheDocument()
      expect(screen.getByText(/you must accept the terms and conditions/i)).toBeInTheDocument()
    })

    // Should not call signUp
    expect(mockSignUp).not.toHaveBeenCalled()
  })
})
</file>

<file path="tests/unit/CLAUDE.md">
# Unit Test Patterns

# Test File Organization
```
unit/
â”œâ”€â”€ components/     # React component tests
â”œâ”€â”€ hooks/         # Custom hook tests
â”œâ”€â”€ stores/        # Zustand store tests
â”œâ”€â”€ utils/         # Utility function tests
â”œâ”€â”€ services/      # Service layer tests
â””â”€â”€ lib/           # Library function tests
```

# Component Testing Template
```tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { expect, describe, it, vi } from 'vitest';
import { ComponentName } from './ComponentName';

describe('ComponentName', () => {
  const defaultProps = {
    title: 'Test Title',
    onAction: vi.fn(),
  };

  it('should render with correct title', () => {
    render(<ComponentName {...defaultProps} />);
    expect(screen.getByText('Test Title')).toBeInTheDocument();
  });

  it('should call onAction when button clicked', () => {
    render(<ComponentName {...defaultProps} />);
    fireEvent.click(screen.getByRole('button'));
    expect(defaultProps.onAction).toHaveBeenCalledTimes(1);
  });
});
```

# Hook Testing Pattern
```tsx
import { renderHook, act } from '@testing-library/react';
import { expect, describe, it } from 'vitest';
import { useCustomHook } from './useCustomHook';

describe('useCustomHook', () => {
  it('should return initial state', () => {
    const { result } = renderHook(() => useCustomHook());
    
    expect(result.current.data).toBe(null);
    expect(result.current.loading).toBe(false);
  });

  it('should handle state updates', () => {
    const { result } = renderHook(() => useCustomHook());
    
    act(() => {
      result.current.updateData('new data');
    });
    
    expect(result.current.data).toBe('new data');
  });
});
```

# Store Testing Pattern
```tsx
import { describe, it, beforeEach, expect } from 'vitest';
import { useAuthStore } from '@/store/authStore';

describe('AuthStore', () => {
  beforeEach(() => {
    // Reset store before each test
    useAuthStore.getState().reset();
  });

  it('should have initial state', () => {
    const state = useAuthStore.getState();
    
    expect(state.user).toBe(null);
    expect(state.isAuthenticated).toBe(false);
  });

  it('should login user correctly', async () => {
    const { login } = useAuthStore.getState();
    
    await login('test@example.com', 'password');
    
    const state = useAuthStore.getState();
    expect(state.isAuthenticated).toBe(true);
    expect(state.user?.email).toBe('test@example.com');
  });
});
```

# Utility Function Testing
```tsx
import { describe, it, expect } from 'vitest';
import { formatCurrency, validateEmail } from '@/lib/utils';

describe('formatCurrency', () => {
  it('should format USD correctly', () => {
    expect(formatCurrency(1234.56)).toBe('$1,234.56');
  });

  it('should handle zero amount', () => {
    expect(formatCurrency(0)).toBe('$0.00');
  });
});

describe('validateEmail', () => {
  it('should validate correct email', () => {
    expect(validateEmail('test@example.com')).toBe(true);
  });

  it('should reject invalid email', () => {
    expect(validateEmail('invalid-email')).toBe(false);
  });
});
```

# Async Function Testing
```tsx
import { describe, it, expect, vi } from 'vitest';
import { fetchUser } from '@/lib/api';

// Mock external dependencies
vi.mock('@/lib/supabase', () => ({
  supabase: {
    from: vi.fn(() => ({
      select: vi.fn(() => ({
        eq: vi.fn(() => ({
          single: vi.fn(() => Promise.resolve({
            data: { id: '1', email: 'test@example.com' },
            error: null,
          })),
        })),
      })),
    })),
  },
}));

describe('fetchUser', () => {
  it('should fetch user successfully', async () => {
    const user = await fetchUser('1');
    
    expect(user).toEqual({
      id: '1',
      email: 'test@example.com',
    });
  });
});
```

# Form Validation Testing
```tsx
import { describe, it, expect } from 'vitest';
import { loginSchema } from '@/types/auth';

describe('loginSchema', () => {
  it('should validate correct login data', () => {
    const validData = {
      email: 'test@example.com',
      password: 'password123',
    };
    
    const result = loginSchema.safeParse(validData);
    expect(result.success).toBe(true);
  });

  it('should reject invalid email', () => {
    const invalidData = {
      email: 'invalid-email',
      password: 'password123',
    };
    
    const result = loginSchema.safeParse(invalidData);
    expect(result.success).toBe(false);
    expect(result.error?.issues[0].path).toEqual(['email']);
  });
});
```

# Error Handling Tests
```tsx
describe('error handling', () => {
  it('should handle API errors gracefully', async () => {
    // Mock API to throw error
    vi.mocked(apiCall).mockRejectedValue(new Error('API Error'));
    
    const { result } = renderHook(() => useApiHook());
    
    await act(async () => {
      await result.current.fetchData();
    });
    
    expect(result.current.error).toBe('API Error');
    expect(result.current.loading).toBe(false);
  });
});
```

# Test Setup & Teardown
```tsx
import { beforeEach, afterEach } from 'vitest';

describe('Component with cleanup', () => {
  beforeEach(() => {
    // Setup before each test
    vi.clearAllMocks();
  });

  afterEach(() => {
    // Cleanup after each test
    vi.resetAllMocks();
  });
});
```

# Mocking External Dependencies
```tsx
// Mock Supabase
vi.mock('@/lib/supabase', () => ({
  supabase: {
    auth: {
      signIn: vi.fn(),
      signOut: vi.fn(),
      getUser: vi.fn(),
    },
    from: vi.fn(),
  },
}));

// Mock React Router
vi.mock('react-router-dom', () => ({
  useNavigate: () => vi.fn(),
  useLocation: () => ({ pathname: '/dashboard' }),
}));

// Mock environment variables
vi.mock('@/lib/env', () => ({
  env: {
    SUPABASE_URL: 'http://localhost:54321',
    STRIPE_PUBLIC_KEY: 'pk_test_123',
  },
}));
```

# DCE-Specific Unit Tests
- Campaign validation logic
- Call duration calculations
- Commission rate computations
- Fraud detection algorithms
- Real-time data transformations
- User permission checks

# Accessibility Testing
```tsx
import { axe, toHaveNoViolations } from 'jest-axe';

expect.extend(toHaveNoViolations);

describe('accessibility', () => {
  it('should not have accessibility violations', async () => {
    const { container } = render(<Component />);
    const results = await axe(container);
    expect(results).toHaveNoViolations();
  });
});
```

# Performance Testing
```tsx
import { performance } from 'perf_hooks';

describe('performance', () => {
  it('should render within acceptable time', () => {
    const start = performance.now();
    render(<ExpensiveComponent />);
    const end = performance.now();
    
    expect(end - start).toBeLessThan(100); // 100ms threshold
  });
});
```

# CRITICAL RULES
- NO regex in test code
- NO any types in assertions
- ALWAYS mock external dependencies
- ALWAYS test error conditions
- ALWAYS clean up after tests
- TEST accessibility compliance
- TEST performance requirements
- USE proper TypeScript typing
- WRITE descriptive test names
- COVER edge cases and error paths
</file>

<file path="tests/CLAUDE.md">
# Test Organization & Strategy

# Test Structure
```
tests/
â”œâ”€â”€ unit/           # Component and utility tests
â”œâ”€â”€ integration/    # API and workflow tests
â”œâ”€â”€ e2e/           # End-to-end user flows
â”œâ”€â”€ performance/   # Load and stress tests
â””â”€â”€ fixtures/      # Shared test data
```

# Testing Tools
- Vitest: Unit and integration testing
- Testing Library: React component testing
- Playwright: End-to-end testing
- jsdom: DOM environment for Vitest

# Test Commands
- `npm test` - Run unit tests
- `npm run test:ci` - CI tests with coverage
- `npm run test:ui` - Visual test interface
- `npm run test:e2e` - Playwright E2E tests
- `npm run test:e2e:ui` - Playwright UI mode

# Coverage Requirements
- **90% minimum** code coverage
- Cover all critical business logic
- Test error conditions and edge cases
- Verify real-time functionality
- Test role-based access control

# Test File Naming
- Unit: `*.test.tsx` or `*.test.ts`
- Integration: `*.integration.test.ts`
- E2E: `*.spec.ts`
- Fixtures: descriptive names in `/fixtures/`

# Test Categories

## Unit Tests (`/unit/`)
- Component rendering and interaction
- Utility functions and helpers
- Store actions and state changes
- Custom hooks behavior
- Form validation logic

## Integration Tests (`/integration/`)
- API endpoint interactions
- Database operations
- Webhook processing
- Third-party service mocks
- Multi-component workflows

## E2E Tests (`/e2e/`)
- Complete user journeys
- Authentication flows
- Campaign creation/management
- Call tracking workflows
- Payment processing
- Cross-browser compatibility

## Performance Tests (`/performance/`)
- Real-time connection handling
- High-volume call processing
- Database query optimization
- Frontend rendering performance

# Test Data Management
- Use fixtures for consistent test data
- Mock external APIs in unit/integration tests
- Use test database for E2E tests
- Clean up test data after each test run

# DCE-Specific Test Scenarios
- Supplier registration and verification
- Buyer campaign setup and management
- Call routing and tracking accuracy
- Fraud detection algorithms
- Payment processing and payouts
- Real-time dashboard updates

# CI/CD Integration
- All tests must pass before deployment
- Generate coverage reports
- Run E2E tests in multiple browsers
- Performance regression detection
- Automated visual regression testing

# Test Environment Setup
- Separate test database instance
- Mock Stripe webhooks
- Test Supabase configuration
- Environment variable management
- Seed data for consistent testing

# Accessibility Testing
- Screen reader compatibility
- Keyboard navigation
- Color contrast validation
- ARIA label verification
- Focus management testing

# CRITICAL RULES
- NO regex in test code
- NO any types in test assertions
- ALWAYS clean up after tests
- ALWAYS test error conditions
- ALWAYS mock external dependencies
- MINIMUM 90% code coverage required
- TEST real-time features thoroughly
- VERIFY security and authorization
</file>

<file path=".dockerignore">
# Dependencies
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Build outputs
dist/
build/
.next/
out/

# Test outputs
coverage/
playwright-report/
test-results/
.nyc_output/

# Environment files
.env
.env.local
.env.production.local
.env.development.local
.env.test.local

# Development files
.vscode/
.idea/
.DS_Store
*.swp
*.swo
.husky/
.git/

# Documentation
*.md
docs/

# CI/CD
.github/
.gitlab-ci.yml
.circleci/

# Temporary files
*.tmp
*.temp
.cache/
tmp/
temp/

# Logs
logs/
*.log
monitor.log
</file>

<file path=".mcp.json">
{
    "mcpServers": {
        "treesitter": {
            "command": "npx",
            "args": [
                "treesitter_mcp"
            ],
            "env": {}
        },
        "playwright": {
            "type": "stdio",
            "command": "npx",
            "args": [
                "-y",
                "@executeautomation/playwright-mcp-server"
            ],
            "env": {}
        },
        "browsermcp": {
            "command": "npx",
            "args": [
                "@browsermcp/mcp@latest"
            ],
            "env": {}
        },
        "Bright Data": {
            "command": "/Users/davidleathers/.nvm/versions/node/v22.14.0/bin/node",
            "args": [
                "/Users/davidleathers/.nvm/versions/node/v22.14.0/bin/npx",
                "@brightdata/mcp"
            ],
            "env": {
                "API_TOKEN": "a1c52bce-9154-439a-b33a-c7dddf98bf9e",
                "WEB_UNLOCKER_ZONE": "mcp_unlocker1",
                "BROWSER_AUTH": "brd-customer-hl_9610ba6a-zone-scraping_browser1:q99o75w2xffs"
            }
        },
        "Sentry": {
            "command": "npx",
            "args": [
                "-y",
                "mcp-remote@latest",
                "https://mcp.sentry.dev/mcp",
                "--debug"
            ],
            "env": {}
        }
    }
}
</file>

<file path=".nvmrc">
20
</file>

<file path=".prettierignore">
# Dependencies
node_modules/

# Build outputs
dist/
build/
coverage/
.next/
out/

# Test outputs
playwright-report/
test-results/

# Logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Environment files
.env
.env.local
.env.production.local
.env.development.local
.env.test.local

# Lock files
package-lock.json
yarn.lock
pnpm-lock.yaml

# Cache
.eslintcache
.cache/

# Misc
.DS_Store
.vscode/
.idea/

# Generated files
*.generated.*
tsconfig.tsbuildinfo
</file>

<file path=".prettierrc.json">
{
  "semi": false,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 100,
  "tabWidth": 2,
  "useTabs": false,
  "arrowParens": "always",
  "endOfLine": "lf",
  "bracketSpacing": true,
  "jsxBracketSameLine": false,
  "jsxSingleQuote": false,
  "quoteProps": "as-needed"
}
</file>

<file path="BACKEND_SETUP.md">
# DCE Platform Backend Setup Complete

## âœ… Database Schema Implementation

The complete Supabase database schema has been implemented according to the technical architecture specifications. The following migrations have been created:

### Migration Files Created:

1. **001_initial_schema.sql** - Core database schema
   - Users, suppliers, buyers, admins tables
   - Campaigns and buyer_campaigns tables
   - Calls and tracking_numbers tables
   - Financial tables (payouts, invoices, invoice_line_items)
   - Quality and compliance tables (call_quality_scores, disputes)
   - Analytics tables (campaign_stats, buyer_campaign_stats)
   - Audit logs table for compliance
   - All required ENUM types and constraints

2. **002_security_policies.sql** - Row Level Security
   - Comprehensive RLS policies for all tables
   - Role-based access control (suppliers, buyers, admins)
   - Helper functions for role checking
   - Data isolation and privacy protection

3. **003_functions.sql** - Business Logic Functions
   - Balance calculation functions (supplier/buyer balances)
   - Quality scoring and fraud detection
   - Campaign matching algorithms
   - Billing calculation functions
   - Analytics and reporting functions
   - Validation and utility functions

4. **004_triggers.sql** - Automated Processes
   - Audit logging triggers for all sensitive operations
   - Automatic call completion processing
   - Balance update triggers
   - Data validation triggers
   - Real-time notification triggers
   - Stats aggregation triggers

5. **005_indexes.sql** - Performance Optimization
   - 80+ optimized indexes for all query patterns
   - Composite indexes for complex queries
   - Partial indexes for active records
   - JSONB indexes for metadata queries
   - Full-text search indexes

### Configuration Files:

- **config.toml** - Supabase local development configuration
- **seed.sql** - Comprehensive test data including all user types
- **README.md** - Complete setup and deployment guide
- **.env.local** - Local development environment variables

## ðŸ” Security Features Implemented:

- Row Level Security (RLS) enabled on all tables
- Role-based access control with proper data isolation
- Comprehensive audit logging for compliance
- Input validation at database level
- Fraud detection and quality scoring systems

## ðŸš€ Performance Features:

- Comprehensive indexing strategy for all query patterns
- Real-time data aggregation and statistics
- Optimized queries with proper joins and filters
- Connection pooling and query optimization

## ðŸ“Š Business Logic Features:

- Automated balance calculations
- Quality scoring algorithms (1-100 scale)
- Fraud detection with pattern analysis
- Real-time campaign matching
- Automated billing and payout calculations

## ðŸ› ï¸ Development Environment:

- Local Supabase configuration ready
- Test data for all user types and scenarios
- Environment variables properly configured
- Documentation for setup and deployment

## ðŸ“‹ Next Steps:

1. Start local Supabase instance: `npx supabase start`
2. Apply migrations: `npx supabase db reset`
3. Generate TypeScript types: `npx supabase gen types typescript --local > src/types/database.ts`
4. Test API endpoints and real-time subscriptions

The backend is now fully ready for frontend integration and supports all features required for the DCE pay-per-call platform including real-time call tracking, fraud prevention, automated billing, and comprehensive analytics.

## Files Location:

All Supabase files are located in the `supabase/` directory:

- `/supabase/migrations/` - Database migration files
- `/supabase/config.toml` - Supabase configuration
- `/supabase/seed.sql` - Development test data
- `/supabase/README.md` - Detailed setup guide
</file>

<file path="CLAUDE.md">
# Tech Stack
- Vite 7.0, React 19.1, TypeScript 5.8
- Tailwind CSS 4.1, Headless UI 2.2, Heroicons 2.2
- Supabase 2.52 (PostgreSQL + Auth + Realtime)
- Zustand 5.0, React Query 5.83, React Hook Form 7.60
- Stripe 18.3 (payments), Axios 1.10 (HTTP)
- Vitest 3.2, Playwright 1.54, Testing Library

# Commands
- `npm run dev` - Start dev server (localhost:5173)
- `npm run build` - Production build
- `npm run lint` - ESLint + TypeScript check
- `npm run preview` - Preview production build
- `npm test` - Run Vitest tests (if configured)

# Code Rules
- NO regex - use validator.js or zod
- NO any types - use unknown or proper types
- NO deprecated ESLint configs - use flat config only
- ALWAYS fix TS/ESLint errors immediately
- ALWAYS commit every 30 minutes

# Project Structure
- `/src/components/` - Reusable React components
- `/src/pages/` - Route-based page components
- `/src/lib/` - Utility functions and shared logic
- `/src/store/` - Zustand state management
- `/src/integrations/` - External service integrations
- `/src/types/` - TypeScript definitions
- `/src/hooks/` - Custom React hooks

# Testing
- Unit: Vitest + Testing Library
- E2E: Playwright for critical flows
- Coverage: 90% minimum requirement
- Run before commit: `npm run lint && npm test`

# DCE Platform Context
Pay-per-call network with suppliers (traffic) and buyers (advertisers).
Focus: Real-time call tracking, fraud prevention, billing automation.

## ðŸš¨ Critical: Multi-Agent Orchestration via tmux

When being managed via tmux, remember that **tmux send-keys requires explicit Enter**:

```bash
# âŒ WRONG - Prompt appears but Claude never receives it:
tmux send-keys -t dce-impl:1 "You are the Frontend Lead..."

# âœ… CORRECT - Prompt is typed AND submitted to Claude:
tmux send-keys -t dce-impl:1 "You are the Frontend Lead..." Enter
```

If you appear stuck at the welcome screen with a typed prompt, the orchestrator forgot to send Enter. See `/Users/davidleathers/projects/dce-website-spec/ORCHESTRATION_BEST_PRACTICES.md` for full details.
</file>

<file path="docker-compose.yml">
version: '3.9'

services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
      target: production
    container_name: dce-website
    ports:
      - '4173:4173'
    environment:
      NODE_ENV: production
      VITE_SUPABASE_URL: ${VITE_SUPABASE_URL}
      VITE_SUPABASE_ANON_KEY: ${VITE_SUPABASE_ANON_KEY}
      VITE_STRIPE_PUBLISHABLE_KEY: ${VITE_STRIPE_PUBLISHABLE_KEY}
      VITE_SENTRY_DSN: ${VITE_SENTRY_DSN}
      VITE_APP_VERSION: ${VITE_APP_VERSION:-1.0.0}
    healthcheck:
      test: ['CMD', 'curl', '-f', 'http://localhost:4173/health']
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    restart: unless-stopped
    networks:
      - dce-network

  # Development environment with hot reload
  app-dev:
    build:
      context: .
      dockerfile: Dockerfile.dev
    container_name: dce-website-dev
    ports:
      - '5173:5173'
    environment:
      NODE_ENV: development
    volumes:
      - ./src:/app/src
      - ./public:/app/public
      - ./index.html:/app/index.html
      - ./vite.config.ts:/app/vite.config.ts
      - ./tsconfig.json:/app/tsconfig.json
      - ./tailwind.config.js:/app/tailwind.config.js
      - ./postcss.config.js:/app/postcss.config.js
    env_file:
      - .env
    networks:
      - dce-network

  # Nginx reverse proxy
  nginx:
    image: nginx:alpine
    container_name: dce-nginx
    ports:
      - '80:80'
      - '443:443'
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/ssl:/etc/nginx/ssl:ro
    depends_on:
      - app
    networks:
      - dce-network
    restart: unless-stopped

  # Redis for caching
  redis:
    image: redis:7-alpine
    container_name: dce-redis
    command: redis-server --appendonly yes --requirepass ${REDIS_PASSWORD:-defaultpass}
    ports:
      - '6379:6379'
    volumes:
      - redis-data:/data
    networks:
      - dce-network
    restart: unless-stopped
    healthcheck:
      test: ['CMD', 'redis-cli', '--raw', 'incr', 'ping']
      interval: 30s
      timeout: 3s
      retries: 5

networks:
  dce-network:
    driver: bridge

volumes:
  redis-data:
</file>

<file path="Dockerfile">
# Multi-stage build for optimized production image
FROM node:22-alpine AS builder

# Install dependencies for building native modules
RUN apk add --no-cache python3 make g++

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm ci --only=production && \
    npm cache clean --force

# Copy application source
COPY . .

# Build the application
RUN npm run build

# Production stage
FROM node:22-alpine AS production

# Install dumb-init for proper signal handling
RUN apk add --no-cache dumb-init

# Create non-root user
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nodejs -u 1001

WORKDIR /app

# Copy built application from builder stage
COPY --from=builder --chown=nodejs:nodejs /app/dist ./dist
COPY --from=builder --chown=nodejs:nodejs /app/node_modules ./node_modules
COPY --from=builder --chown=nodejs:nodejs /app/package*.json ./

# Copy public assets
COPY --chown=nodejs:nodejs public ./public

# Switch to non-root user
USER nodejs

# Expose port (Vite preview server)
EXPOSE 4173

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD node -e "require('http').get('http://localhost:4173/health', (res) => process.exit(res.statusCode === 200 ? 0 : 1))"

# Use dumb-init to handle signals properly
ENTRYPOINT ["dumb-init", "--"]

# Start the application
CMD ["npm", "run", "preview", "--", "--host", "0.0.0.0", "--port", "4173"]
</file>

<file path="Dockerfile.dev">
# Development Dockerfile with hot reload
FROM node:22-alpine

# Install development dependencies
RUN apk add --no-cache python3 make g++ git

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install all dependencies including devDependencies
RUN npm ci

# Copy application source
COPY . .

# Expose development server port
EXPOSE 5173

# Start development server
CMD ["npm", "run", "dev", "--", "--host", "0.0.0.0"]
</file>

<file path="eslint.config.js">
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import { globalIgnores } from 'eslint/config'

export default tseslint.config([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs['recommended-latest'],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
  },
])
</file>

<file path="index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React + TS</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="lighthouserc.json">
{
  "ci": {
    "collect": {
      "url": [
        "https://staging.dependablecalls.com",
        "https://staging.dependablecalls.com/features",
        "https://staging.dependablecalls.com/pricing",
        "https://staging.dependablecalls.com/contact"
      ],
      "startServerCommand": "npm run preview",
      "startServerReadyPattern": "Local:",
      "numberOfRuns": 3
    },
    "assert": {
      "assertions": {
        "categories:performance": ["warn", { "minScore": 0.8 }],
        "categories:accessibility": ["error", { "minScore": 0.9 }],
        "categories:best-practices": ["warn", { "minScore": 0.85 }],
        "categories:seo": ["warn", { "minScore": 0.9 }],
        "first-contentful-paint": ["warn", { "maxNumericValue": 2000 }],
        "largest-contentful-paint": ["warn", { "maxNumericValue": 2500 }],
        "cumulative-layout-shift": ["warn", { "maxNumericValue": 0.1 }],
        "total-blocking-time": ["warn", { "maxNumericValue": 300 }]
      }
    },
    "upload": {
      "target": "temporary-public-storage"
    }
  }
}
</file>

<file path="netlify.toml">
[build]
  publish = "dist"
  command = "npm run build"
  
[build.environment]
  NODE_VERSION = "22"
  NPM_FLAGS = "--prefix=/dev/null"

# Production settings
[context.production]
  command = "npm run build"
  
[context.production.environment]
  NODE_ENV = "production"

# Staging/develop branch settings
[context.develop]
  command = "npm run build"
  
[context.develop.environment]
  NODE_ENV = "staging"

# Branch deploy previews
[context.branch-deploy]
  command = "npm run build"

# Security headers
[[headers]]
  for = "/*"
  [headers.values]
    X-Frame-Options = "DENY"
    X-Content-Type-Options = "nosniff"
    X-XSS-Protection = "1; mode=block"
    Referrer-Policy = "strict-origin-when-cross-origin"
    Permissions-Policy = "camera=(), microphone=(), geolocation=(), payment=()"
    Strict-Transport-Security = "max-age=31536000; includeSubDomains; preload"
    Content-Security-Policy = """
      default-src 'self';
      script-src 'self' 'unsafe-inline' https://js.stripe.com https://cdn.jsdelivr.net;
      style-src 'self' 'unsafe-inline' https://fonts.googleapis.com;
      font-src 'self' https://fonts.gstatic.com;
      img-src 'self' data: https: blob:;
      connect-src 'self' https://*.supabase.co wss://*.supabase.co https://api.stripe.com https://*.sentry.io;
      frame-src https://js.stripe.com;
      object-src 'none';
      base-uri 'self';
      form-action 'self';
      upgrade-insecure-requests;
    """

# Cache static assets
[[headers]]
  for = "/assets/*"
  [headers.values]
    Cache-Control = "public, max-age=31536000, immutable"

[[headers]]
  for = "*.js"
  [headers.values]
    Cache-Control = "public, max-age=31536000, immutable"

[[headers]]
  for = "*.css"
  [headers.values]
    Cache-Control = "public, max-age=31536000, immutable"

[[headers]]
  for = "*.woff2"
  [headers.values]
    Cache-Control = "public, max-age=31536000, immutable"

# SPA routing - serve index.html for all routes
[[redirects]]
  from = "/*"
  to = "/index.html"
  status = 200
  conditions = {Role = ["admin", "user"], Country = ["US", "CA"]}

# Health check endpoint
[[redirects]]
  from = "/health"
  to = "/.netlify/functions/health"
  status = 200

# API redirects to edge functions
[[redirects]]
  from = "/api/*"
  to = "/.netlify/functions/:splat"
  status = 200

# Force HTTPS
[[redirects]]
  from = "http://dependablecalls.com/*"
  to = "https://dependablecalls.com/:splat"
  status = 301
  force = true

[[redirects]]
  from = "http://www.dependablecalls.com/*"
  to = "https://dependablecalls.com/:splat"
  status = 301
  force = true

# Redirect www to non-www
[[redirects]]
  from = "https://www.dependablecalls.com/*"
  to = "https://dependablecalls.com/:splat"
  status = 301
  force = true

# Edge Functions
[[edge_functions]]
  function = "auth-middleware"
  path = "/dashboard/*"

[[edge_functions]]
  function = "rate-limiter"
  path = "/api/*"

# Form handling
[plugins]
  [[plugins.inputs]]
    command = "npm run build"
</file>

<file path="playwright.config.ts">
import { defineConfig, devices } from '@playwright/test'

/**
 * @see https://playwright.dev/docs/test-configuration
 */
export default defineConfig({
  testDir: './tests/e2e',
  /* Run tests in files in parallel */
  fullyParallel: true,
  /* Fail the build on CI if you accidentally left test.only in the source code. */
  forbidOnly: !!process.env.CI,
  /* Retry on CI only */
  retries: process.env.CI ? 2 : 0,
  /* Opt out of parallel tests on CI. */
  workers: process.env.CI ? 1 : undefined,
  /* Reporter to use. See https://playwright.dev/docs/test-reporters */
  reporter: 'html',
  /* Shared settings for all the projects below. See https://playwright.dev/docs/api/class-testoptions. */
  use: {
    /* Base URL to use in actions like `await page.goto('/')`. */
    baseURL: 'http://localhost:5173',

    /* Collect trace when retrying the failed test. See https://playwright.dev/docs/trace-viewer */
    trace: 'on-first-retry',
  },

  /* Configure projects for major browsers */
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },

    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },

    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    },

    /* Test against mobile viewports. */
    {
      name: 'Mobile Chrome',
      use: { ...devices['Pixel 5'] },
    },
    {
      name: 'Mobile Safari',
      use: { ...devices['iPhone 12'] },
    },

    /* Test against branded browsers. */
    // {
    //   name: 'Microsoft Edge',
    //   use: { ...devices['Desktop Edge'], channel: 'msedge' },
    // },
    // {
    //   name: 'Google Chrome',
    //   use: { ...devices['Desktop Chrome'], channel: 'chrome' },
    // },
  ],

  /* Run your local dev server before starting the tests */
  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:5173',
    reuseExistingServer: !process.env.CI,
  },
})
</file>

<file path="tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="ui-testing-baseline-report.md">
# UI Testing Baseline Report

**Project**: Dependable Call Exchange (DCE) Website  
**Test Date**: January 23, 2025  
**Test Environment**: Development (localhost:5173)  
**Testing Framework**: Playwright MCP with 5 Parallel Task Agents

## Executive Summary

Initial automated UI testing of the DCE website revealed critical functionality issues across the platform, with **58% of interactive elements failing** to perform their intended functions. This baseline report documents the current state of the application and provides a roadmap for systematic repairs.

## Test Methodology

### Approach

- **Testing Strategy**: Parallel automated testing using 5 independent task agents
- **Tool**: Playwright MCP for browser automation and interaction testing
- **Coverage**: All major pages and interactive elements
- **Test Types**: Click interactions, form submissions, navigation flows, and visual verification

### Pages Tested

1. HomePage (`/`)
2. BlogPage (`/blog`)
3. ContactPage (`/contact`)
4. CareersPage (`/careers`)
5. Legal Pages (`/privacy`, `/terms`, `/cookies`)

### Test Execution

Each task agent was assigned specific pages and UI elements to test, operating in parallel to maximize coverage efficiency. Tests included:

- Click event verification
- Form field interaction and validation
- Navigation link functionality
- Button state changes and actions
- Dynamic content loading

## Key Findings

### Overall Failure Rate: 58%

Of all interactive elements tested across the application, 58% exhibited some form of functional failure. This represents a critical state requiring immediate attention before production deployment.

## Failure Categories

### 1. Navigation and Routing Issues (Critical)

**Affected Elements:**

- Header navigation links
- Footer navigation links
- Internal page routing
- Call-to-action navigation buttons

**Symptoms:**

- Links present visually but non-functional
- No route navigation occurs on click
- Missing onClick handlers
- Incorrect href attributes

**Impact:** Users cannot navigate between pages, severely limiting site usability.

### 2. Form Validation Problems (High Priority)

**Affected Forms:**

- Contact form (`/contact`)
- Newsletter subscription forms
- Demo request forms

**Issues Identified:**

- Submit buttons non-functional
- No client-side validation triggering
- Form state not updating on input
- Missing error message displays
- No success feedback after submission

**Impact:** Lead generation and user communication channels are completely broken.

### 3. Pagination Controls (Medium Priority)

**Location:** Blog page (`/blog`)

**Problems:**

- Page number buttons do not respond to clicks
- No visual feedback on current page
- Unable to navigate between blog post pages
- "Next" and "Previous" buttons non-functional

**Impact:** Users cannot browse through blog content, limiting content accessibility.

### 4. Footer Link Failures (Medium Priority)

**Broken Links:**

- Privacy Policy
- Terms of Service
- Cookie Policy
- Company information links
- Social media links

**Technical Issues:**

- Links using `#` placeholders instead of proper routes
- Missing route definitions
- No onClick handlers implemented

**Impact:** Legal compliance issues and reduced user trust.

### 5. Pricing and CTA Buttons (Critical)

**Affected Elements:**

- "View Pricing" buttons
- "Get Started" CTAs
- "Request Demo" buttons
- Plan selection buttons

**Problems:**

- Buttons visually present but non-clickable
- No event handlers attached
- Missing navigation logic
- No hover states or interaction feedback

**Impact:** Conversion funnel is completely broken, preventing user signup and engagement.

## Critical Issues Requiring Immediate Fix

### Priority 1 (Business Critical)

1. **Main Navigation System**: Implement proper React Router navigation for all header links
2. **Pricing/CTA Buttons**: Add onClick handlers and navigation logic for all conversion-related buttons
3. **Contact Form**: Implement form submission logic with proper validation and Supabase integration

### Priority 2 (User Experience)

1. **Footer Links**: Replace placeholder hrefs with actual routes
2. **Blog Pagination**: Implement state management and click handlers for page navigation
3. **Form Validation**: Add client-side validation with error messaging

### Priority 3 (Polish)

1. **Loading States**: Add visual feedback during async operations
2. **Error Handling**: Implement user-friendly error messages
3. **Success Feedback**: Add confirmation messages for successful actions

## Technical Root Causes

Based on the testing results, the primary technical issues appear to be:

1. **Missing Event Handlers**: Most interactive elements lack onClick implementations
2. **Incomplete React Router Setup**: Routes defined but not connected to navigation elements
3. **State Management Gaps**: Form and pagination state not properly managed
4. **Component Integration**: UI components exist but lack business logic integration

## Recommendations

### Immediate Actions

1. Implement a systematic fix starting with navigation and routing
2. Add onClick handlers to all interactive elements
3. Connect forms to Supabase backend
4. Implement proper state management for dynamic content

### Testing Strategy

1. Implement unit tests for all interactive components
2. Add integration tests for critical user flows
3. Set up continuous testing in CI/CD pipeline
4. Establish minimum 90% test coverage requirement

### Quality Gates

1. No deployment without 100% navigation functionality
2. All forms must have working validation and submission
3. Critical business flows (signup, contact) must be fully tested
4. Accessibility testing for all interactive elements

## Conclusion

The current state of the DCE website shows significant functionality gaps that must be addressed before production deployment. The 58% failure rate indicates systematic issues with event handling and state management rather than isolated bugs. A methodical approach to fixing these issues, starting with critical business functions, will be necessary to bring the application to production readiness.

## Next Steps

1. Create detailed fix tickets for each failure category
2. Assign priority levels based on business impact
3. Implement fixes in priority order
4. Re-run comprehensive tests after each fix cycle
5. Maintain this baseline for comparison with future test runs

---

_This baseline report will be updated as fixes are implemented and retested._
</file>

<file path=".husky/pre-commit">
# Run lint-staged for automatic formatting and linting
npx lint-staged

# Run type checking
echo "ðŸ” Running type check..."
npm run type-check || {
  echo "âŒ Type check failed. Please fix TypeScript errors before committing."
  exit 1
}

echo "âœ… Pre-commit checks passed!"
</file>

<file path="src/components/auth/ProtectedRoute.tsx">
import React from 'react'
import { Navigate } from 'react-router-dom'
import { useAuthStore } from '../../store/authStore'
import ErrorBoundary from '../common/ErrorBoundary'
import { UnauthorizedError } from '../common/FallbackUI'

interface ProtectedRouteProps {
  children: React.ReactNode
  requiredRole?: 'supplier' | 'buyer' | 'admin'
  allowUnauthenticated?: boolean
}

/**
 * Authentication-aware error boundary fallback for protected routes
 */
function AuthErrorFallback() {
  return (
    <UnauthorizedError onGoHome={() => (window.location.href = '/')} className="min-h-screen" />
  )
}

/**
 * Protected route component with integrated error boundary
 * Handles authentication, authorization, and error protection
 */
export function ProtectedRoute({
  children,
  requiredRole,
  allowUnauthenticated = false,
}: ProtectedRouteProps) {
  const { user, userType, loading } = useAuthStore()

  // Show loading state while checking authentication
  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary-600"></div>
      </div>
    )
  }

  // Handle unauthenticated users
  if (!user && !allowUnauthenticated) {
    return <Navigate to="/login" replace />
  }

  // Handle role-based authorization
  if (requiredRole && userType !== requiredRole) {
    // If user is authenticated but lacks required role, show unauthorized error
    if (user) {
      return <AuthErrorFallback />
    }
    // If user is not authenticated, redirect to login
    return <Navigate to="/login" replace />
  }

  // Wrap authenticated content with error boundary
  return (
    <ErrorBoundary
      context={`ProtectedRoute - ${requiredRole || 'authenticated'}`}
      fallback={<AuthErrorFallback />}
      onError={(error, errorInfo) => {
        // Log authentication-related errors with context
        console.error('Authentication error boundary triggered:', {
          error: error.message,
          user: user?.id,
          userType,
          requiredRole,
          componentStack: errorInfo.componentStack,
        })
      }}
    >
      {children}
    </ErrorBoundary>
  )
}

export default ProtectedRoute
</file>

<file path="src/components/auth/withProtectedRoute.tsx">
import { ProtectedRoute } from './ProtectedRoute'
import type { ComponentType } from 'react'

interface ProtectedRouteOptions {
  requiredRole?: 'supplier' | 'buyer' | 'admin'
  allowUnauthenticated?: boolean
}

/**
 * Higher-order component for protecting components with authentication and error boundaries
 */
export function withProtectedRoute<P extends object>(
  Component: ComponentType<P>,
  options?: ProtectedRouteOptions
) {
  const WrappedComponent = (props: P) => (
    <ProtectedRoute
      requiredRole={options?.requiredRole}
      allowUnauthenticated={options?.allowUnauthenticated}
    >
      <Component {...props} />
    </ProtectedRoute>
  )

  WrappedComponent.displayName = `withProtectedRoute(${Component.displayName || Component.name})`

  return WrappedComponent
}
</file>

<file path="src/components/common/Badge.tsx">
import { forwardRef } from 'react'
import type { HTMLAttributes } from 'react'

export interface BadgeProps extends HTMLAttributes<HTMLSpanElement> {
  variant?: 'default' | 'success' | 'warning' | 'danger' | 'info' | 'neutral'
  size?: 'sm' | 'md' | 'lg'
  dot?: boolean
  removable?: boolean
  onRemove?: () => void
}

const Badge = forwardRef<HTMLSpanElement, BadgeProps>(
  (
    {
      className = '',
      variant = 'default',
      size = 'md',
      dot = false,
      removable = false,
      onRemove,
      children,
      ...props
    },
    ref
  ) => {
    const baseClasses = [
      'inline-flex items-center font-medium rounded-full',
      'transition-colors duration-200',
    ].join(' ')

    const variantClasses = {
      default: 'bg-gray-100 text-gray-800',
      success: 'bg-green-100 text-green-800',
      warning: 'bg-yellow-100 text-yellow-800',
      danger: 'bg-red-100 text-red-800',
      info: 'bg-blue-100 text-blue-800',
      neutral: 'bg-gray-50 text-gray-600 ring-1 ring-inset ring-gray-500/10',
    }

    const sizeClasses = {
      sm: dot ? 'h-5 w-5' : 'px-2 py-0.5 text-xs',
      md: dot ? 'h-6 w-6' : 'px-2.5 py-0.5 text-xs',
      lg: dot ? 'h-7 w-7' : 'px-3 py-1 text-sm',
    }

    const classes = [baseClasses, variantClasses[variant], sizeClasses[size], className]
      .filter(Boolean)
      .join(' ')

    if (dot) {
      return <span ref={ref} className={classes} {...props} />
    }

    return (
      <span ref={ref} className={classes} {...props}>
        {children}
        {removable && onRemove && (
          <button
            type="button"
            onClick={(e) => {
              e.stopPropagation()
              onRemove()
            }}
            className="ml-1 inline-flex h-4 w-4 items-center justify-center rounded-full hover:bg-current hover:bg-opacity-20"
            aria-label="Remove badge"
          >
            <svg className="h-2 w-2" stroke="currentColor" fill="none" viewBox="0 0 8 8">
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={1.5}
                d="M1 1l6 6m0-6L1 7"
              />
            </svg>
          </button>
        )}
      </span>
    )
  }
)

Badge.displayName = 'Badge'

// Status Badge component for common status indicators
export interface StatusBadgeProps extends Omit<BadgeProps, 'variant'> {
  status: 'active' | 'inactive' | 'pending' | 'success' | 'failed' | 'paused' | 'draft' | 'archived'
}

const StatusBadge = forwardRef<HTMLSpanElement, StatusBadgeProps>(({ status, ...props }, ref) => {
  const statusVariantMap = {
    active: 'success' as const,
    inactive: 'neutral' as const,
    pending: 'warning' as const,
    success: 'success' as const,
    failed: 'danger' as const,
    paused: 'warning' as const,
    draft: 'neutral' as const,
    archived: 'danger' as const,
  }

  const statusTextMap = {
    active: 'Active',
    inactive: 'Inactive',
    pending: 'Pending',
    success: 'Success',
    failed: 'Failed',
    paused: 'Paused',
    draft: 'Draft',
    archived: 'Archived',
  }

  return (
    <Badge ref={ref} variant={statusVariantMap[status]} {...props}>
      {statusTextMap[status]}
    </Badge>
  )
})

StatusBadge.displayName = 'StatusBadge'

// Number Badge component for counts and notifications
export interface NumberBadgeProps extends Omit<BadgeProps, 'children'> {
  count: number
  max?: number
  showZero?: boolean
}

const NumberBadge = forwardRef<HTMLSpanElement, NumberBadgeProps>(
  ({ count, max = 99, showZero = false, ...props }, ref) => {
    if (count === 0 && !showZero) {
      return null
    }

    const displayCount = count > max ? `${max}+` : count.toString()

    return (
      <Badge ref={ref} {...props}>
        {displayCount}
      </Badge>
    )
  }
)

NumberBadge.displayName = 'NumberBadge'

export { Badge, StatusBadge, NumberBadge }
export default Badge
</file>

<file path="src/components/common/Button.tsx">
import { forwardRef } from 'react'
import type { ButtonHTMLAttributes } from 'react'
import { Slot } from '@radix-ui/react-slot'

export interface ButtonProps extends ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary' | 'outline' | 'ghost' | 'danger'
  size?: 'sm' | 'md' | 'lg'
  loading?: boolean
  asChild?: boolean
  fullWidth?: boolean
  leftIcon?: React.ReactNode
  rightIcon?: React.ReactNode
}

const Button = forwardRef<HTMLButtonElement, ButtonProps>(
  (
    {
      className = '',
      variant = 'primary',
      size = 'md',
      loading = false,
      asChild = false,
      fullWidth = false,
      leftIcon,
      rightIcon,
      disabled,
      children,
      ...props
    },
    ref
  ) => {
    const Comp = asChild ? Slot : 'button'

    const baseClasses = [
      'inline-flex items-center justify-center font-medium transition-all duration-200',
      'focus:outline-none focus:ring-2 focus:ring-offset-2',
      'disabled:opacity-50 disabled:cursor-not-allowed disabled:pointer-events-none',
      fullWidth && 'w-full',
    ]
      .filter(Boolean)
      .join(' ')

    const variantClasses = {
      primary: [
        'bg-blue-600 text-white border border-transparent',
        'hover:bg-blue-700 focus:ring-blue-500',
        'active:bg-blue-800',
      ].join(' '),
      secondary: [
        'bg-gray-600 text-white border border-transparent',
        'hover:bg-gray-700 focus:ring-gray-500',
        'active:bg-gray-800',
      ].join(' '),
      outline: [
        'bg-white text-gray-700 border border-gray-300',
        'hover:bg-gray-50 hover:border-gray-400 focus:ring-gray-500',
        'active:bg-gray-100',
      ].join(' '),
      ghost: [
        'bg-transparent text-gray-700 border border-transparent',
        'hover:bg-gray-100 focus:ring-gray-500',
        'active:bg-gray-200',
      ].join(' '),
      danger: [
        'bg-red-600 text-white border border-transparent',
        'hover:bg-red-700 focus:ring-red-500',
        'active:bg-red-800',
      ].join(' '),
    }

    const sizeClasses = {
      sm: 'h-8 px-3 text-sm rounded-md',
      md: 'h-10 px-4 text-sm rounded-md',
      lg: 'h-11 px-6 text-base rounded-md',
    }

    const classes = [baseClasses, variantClasses[variant], sizeClasses[size], className]
      .filter(Boolean)
      .join(' ')

    const isDisabled = disabled || loading

    const content = (
      <>
        {loading && (
          <div className="mr-2 h-4 w-4 animate-spin rounded-full border-2 border-current border-t-transparent" />
        )}
        {!loading && leftIcon && <span className="mr-2">{leftIcon}</span>}
        {children}
        {!loading && rightIcon && <span className="ml-2">{rightIcon}</span>}
      </>
    )

    return (
      <Comp ref={ref} className={classes} disabled={isDisabled} {...props}>
        {content}
      </Comp>
    )
  }
)

Button.displayName = 'Button'

export { Button }
export default Button
</file>

<file path="src/components/common/Card.tsx">
import { forwardRef } from 'react'
import type { HTMLAttributes } from 'react'

export interface CardProps extends HTMLAttributes<HTMLDivElement> {
  variant?: 'default' | 'bordered' | 'elevated'
  padding?: 'none' | 'sm' | 'md' | 'lg'
  hover?: boolean
  clickable?: boolean
}

const Card = forwardRef<HTMLDivElement, CardProps>(
  (
    {
      className = '',
      variant = 'default',
      padding = 'md',
      hover = false,
      clickable = false,
      children,
      ...props
    },
    ref
  ) => {
    const baseClasses = [
      'rounded-lg transition-all duration-200',
      hover && 'hover:shadow-md',
      clickable && 'cursor-pointer',
    ]
      .filter(Boolean)
      .join(' ')

    const variantClasses = {
      default: 'bg-white shadow-sm',
      bordered: 'bg-white border border-gray-200',
      elevated: 'bg-white shadow-lg',
    }

    const paddingClasses = {
      none: '',
      sm: 'p-4',
      md: 'p-6',
      lg: 'p-8',
    }

    const classes = [baseClasses, variantClasses[variant], paddingClasses[padding], className]
      .filter(Boolean)
      .join(' ')

    return (
      <div ref={ref} className={classes} {...props}>
        {children}
      </div>
    )
  }
)

Card.displayName = 'Card'

// Card sub-components
export interface CardHeaderProps extends HTMLAttributes<HTMLDivElement> {
  title?: string
  description?: string
  actions?: React.ReactNode
}

const CardHeader = forwardRef<HTMLDivElement, CardHeaderProps>(
  ({ className = '', title, description, actions, children, ...props }, ref) => {
    const classes = `flex items-center justify-between pb-4 border-b border-gray-200 ${className}`

    return (
      <div ref={ref} className={classes} {...props}>
        <div className="min-w-0 flex-1">
          {title && <h3 className="text-lg font-semibold text-gray-900 truncate">{title}</h3>}
          {description && <p className="mt-1 text-sm text-gray-500">{description}</p>}
          {children}
        </div>
        {actions && <div className="ml-4 flex-shrink-0">{actions}</div>}
      </div>
    )
  }
)

CardHeader.displayName = 'CardHeader'

export type CardContentProps = HTMLAttributes<HTMLDivElement>

const CardContent = forwardRef<HTMLDivElement, CardContentProps>(
  ({ className = '', ...props }, ref) => {
    const classes = `py-4 ${className}`
    return <div ref={ref} className={classes} {...props} />
  }
)

CardContent.displayName = 'CardContent'

export type CardFooterProps = HTMLAttributes<HTMLDivElement>

const CardFooter = forwardRef<HTMLDivElement, CardFooterProps>(
  ({ className = '', ...props }, ref) => {
    const classes = `pt-4 border-t border-gray-200 ${className}`
    return <div ref={ref} className={classes} {...props} />
  }
)

CardFooter.displayName = 'CardFooter'

export { Card, CardHeader, CardContent, CardFooter }
export default Card
</file>

<file path="src/components/common/FallbackUI.examples.tsx">
// Example usage file for FallbackUI components
// This file demonstrates how to use the various error fallback components

import {
  ErrorFallback,
  NotFoundError,
  InternalServerError,
  UnauthorizedError,
  NetworkError,
  FormValidationError,
  FormSubmissionError,
  PaymentError,
  LoadingError,
  EmptyStateError,
  TimeoutError,
  SuccessState,
} from './FallbackUI'

// Usage Examples for each component

export function GenericErrorExample() {
  return (
    <ErrorFallback
      title="Something went wrong"
      message="We encountered an unexpected error. Our team has been notified and is working to resolve this issue."
      errorCode="ERR_GENERIC_001"
      showTechnicalDetails={true}
      details="TypeError: Cannot read property 'id' of undefined at UserService.getUser (user.service.ts:45)"
      onRetry={() => window.location.reload()}
      onGoHome={() => (window.location.href = '/')}
      onContactSupport={() => {
        window.location.href = '/contact'
      }}
      showHomeButton={true}
      showSupportButton={true}
    />
  )
}

export function RouteErrorExamples() {
  return (
    <div className="space-y-8">
      {/* 404 Error */}
      <NotFoundError onGoHome={() => (window.location.href = '/')} />

      {/* 500 Error */}
      <InternalServerError
        onRetry={() => window.location.reload()}
        onGoHome={() => (window.location.href = '/')}
      />

      {/* 401 Unauthorized */}
      <UnauthorizedError onGoHome={() => (window.location.href = '/')} />

      {/* Network Error */}
      <NetworkError onRetry={() => window.location.reload()} />
    </div>
  )
}

export function FormErrorExamples() {
  const validationErrors = {
    email: 'Please enter a valid email address',
    password: 'Password must be at least 8 characters long',
    confirmPassword: 'Passwords do not match',
  }

  return (
    <div className="space-y-6">
      {/* Form Validation Errors */}
      <FormValidationError errors={validationErrors} onRetry={() => console.log('Reset form')} />

      {/* Form Submission Error */}
      <FormSubmissionError
        message="Failed to create your account. Please try again."
        onRetry={() => console.log('Retry submission')}
      />
    </div>
  )
}

export function PaymentErrorExamples() {
  return (
    <div className="space-y-8">
      {/* Card Declined */}
      <PaymentError
        errorType="card_declined"
        onRetry={() => console.log('Retry payment')}
        onUpdatePaymentMethod={() => console.log('Update payment method')}
        onContactSupport={() => console.log('Contact support')}
      />

      {/* Insufficient Funds */}
      <PaymentError
        errorType="insufficient_funds"
        onUpdatePaymentMethod={() => console.log('Update payment method')}
        onContactSupport={() => console.log('Contact support')}
      />

      {/* Invalid Card */}
      <PaymentError
        errorType="invalid_card"
        onUpdatePaymentMethod={() => console.log('Update payment method')}
      />

      {/* Connection Error */}
      <PaymentError
        errorType="connection_error"
        onRetry={() => console.log('Retry payment')}
        onContactSupport={() => console.log('Contact support')}
      />
    </div>
  )
}

export function LoadingErrorExamples() {
  return (
    <div className="space-y-8">
      {/* Data Loading Error */}
      <LoadingError type="data" onRetry={() => console.log('Retry data fetch')} />

      {/* Page Loading Error */}
      <LoadingError
        type="page"
        onRetry={() => window.location.reload()}
        message="The dashboard failed to load completely."
      />

      {/* Component Loading Error */}
      <LoadingError type="component" onRetry={() => console.log('Retry component load')} />
    </div>
  )
}

export function EmptyStateExamples() {
  return (
    <div className="space-y-8">
      {/* No Data Found */}
      <EmptyStateError
        title="No campaigns found"
        message="You haven't created any campaigns yet. Create your first campaign to get started."
        actionLabel="Create Campaign"
        onAction={() => console.log('Create new campaign')}
      />

      {/* No Search Results */}
      <EmptyStateError
        title="No results found"
        message="We couldn't find any campaigns matching your search criteria. Try adjusting your filters."
        actionLabel="Clear Filters"
        onAction={() => console.log('Clear search filters')}
      />
    </div>
  )
}

export function TimeoutErrorExample() {
  return (
    <TimeoutError
      timeoutDuration={30}
      onRetry={() => console.log('Retry request')}
      onCancel={() => console.log('Cancel operation')}
    />
  )
}

export function SuccessStateExample() {
  return (
    <SuccessState
      title="Campaign Created Successfully"
      message="Your new campaign has been created and is now active. You can start receiving calls immediately."
      onPrimaryAction={() => console.log('View campaign')}
      onSecondaryAction={() => console.log('Create another')}
      primaryActionLabel="View Campaign"
      secondaryActionLabel="Create Another"
    />
  )
}

// Real-world usage patterns for DCE platform

export function DCECampaignErrorExample() {
  return (
    <ErrorFallback
      title="Campaign Load Failed"
      message="We couldn't load your campaign data. This might be due to a temporary network issue or server maintenance."
      errorCode="CAMPAIGN_001"
      onRetry={() => console.log('Retry loading campaigns')}
      onGoHome={() => (window.location.href = '/app/dashboard')}
      onContactSupport={() => {
        window.location.href = '/contact'
      }}
      showHomeButton={true}
      showSupportButton={true}
      retryLabel="Reload Campaigns"
    />
  )
}

export function DCECallTrackingErrorExample() {
  return (
    <LoadingError
      type="data"
      message="Real-time call tracking data is temporarily unavailable. Historical data may still be visible."
      onRetry={() => console.log('Retry call tracking connection')}
    />
  )
}

export function DCEPayoutErrorExample() {
  return (
    <PaymentError
      errorType="payment_failed"
      onRetry={() => console.log('Retry payout')}
      onUpdatePaymentMethod={() => console.log('Update bank account')}
      onContactSupport={() => (window.location.href = '/contact')}
    />
  )
}

export function DCEBuyerOnboardingErrorExample() {
  const onboardingErrors = {
    companyName: 'Company name is required',
    businessLicense: 'Please upload a valid business license',
    creditCheck: 'Credit verification failed. Please contact support.',
  }

  return (
    <FormValidationError
      errors={onboardingErrors}
      title="Onboarding Incomplete"
      message="Please complete the following requirements to activate your buyer account:"
      onRetry={() => console.log('Continue onboarding')}
    />
  )
}

// Example of using components with React Query
// eslint-disable-next-line react-refresh/only-export-components
export function withReactQueryExample() {
  // This would typically be used with React Query's error handling
  const exampleQueryError = new Error('Failed to fetch campaign data')

  const handleRetry = () => {
    // queryClient.refetchQueries(['campaigns'])
    console.log('Refetch campaigns')
  }

  if (exampleQueryError.message.includes('404')) {
    return <NotFoundError onGoHome={() => (window.location.href = '/')} />
  }

  if (exampleQueryError.message.includes('network')) {
    return <NetworkError onRetry={handleRetry} />
  }

  return (
    <ErrorFallback
      title="Data Loading Error"
      message="Unable to load the requested data. Please try again."
      onRetry={handleRetry}
      showSupportButton={true}
      onContactSupport={() => {
        window.location.href = '/contact'
      }}
    />
  )
}

// Example of using components with form libraries (React Hook Form)
// eslint-disable-next-line react-refresh/only-export-components
export function withFormLibraryExample() {
  // This would typically be used with React Hook Form's error handling
  const formErrors = {
    email: 'Invalid email format',
    phone: 'Please enter a valid phone number',
    campaign_name: 'Campaign name must be unique',
  }

  const handleFormSubmissionError = () => {
    console.log('Reset form and clear errors')
  }

  return (
    <div className="space-y-4">
      <FormValidationError errors={formErrors} onRetry={handleFormSubmissionError} />

      <FormSubmissionError
        message="Failed to save campaign settings. Please check your network connection and try again."
        onRetry={() => console.log('Resubmit form')}
      />
    </div>
  )
}
</file>

<file path="src/components/common/index.ts">
// Common UI Components
export { Button } from './Button'
export type { ButtonProps } from './Button'

export { Card, CardHeader, CardContent, CardFooter } from './Card'
export type { CardProps, CardHeaderProps, CardContentProps, CardFooterProps } from './Card'

export { Input } from './Input'
export type { InputProps } from './Input'

export { Loading, Skeleton, PageLoading, CardLoading } from './Loading'
export type { LoadingProps, SkeletonProps, PageLoadingProps, CardLoadingProps } from './Loading'

export { Badge, StatusBadge, NumberBadge } from './Badge'
export type { BadgeProps, StatusBadgeProps, NumberBadgeProps } from './Badge'

export { ErrorBoundary } from './ErrorBoundary'
export type { ErrorFallbackProps } from './ErrorBoundary'

export { withErrorBoundary } from './withErrorBoundary'
export type { WithErrorBoundaryOptions } from './withErrorBoundary'

export { FallbackUI, ErrorFallback } from './FallbackUI'
export type {
  BaseErrorProps,
  ErrorActionProps,
  ErrorDetailsProps,
  RouteErrorProps,
  FormErrorProps,
  PaymentErrorProps,
  LoadingErrorProps,
  EmptyStateErrorProps,
  TimeoutErrorProps,
  SuccessStateProps,
} from './FallbackUI'
</file>

<file path="src/components/common/Input.tsx">
import { forwardRef } from 'react'
import type { InputHTMLAttributes } from 'react'

export interface InputProps extends InputHTMLAttributes<HTMLInputElement> {
  label?: string
  error?: string
  helpText?: string
  leftIcon?: React.ReactNode
  rightIcon?: React.ReactNode
  variant?: 'default' | 'filled'
  inputSize?: 'sm' | 'md' | 'lg'
}

const Input = forwardRef<HTMLInputElement, InputProps>(
  (
    {
      className = '',
      label,
      error,
      helpText,
      leftIcon,
      rightIcon,
      variant = 'default',
      inputSize = 'md',
      disabled,
      id,
      ...props
    },
    ref
  ) => {
    const inputId = id || `input-${Math.random().toString(36).substr(2, 9)}`

    const baseClasses = [
      'block w-full rounded-md border-0 shadow-sm ring-1 ring-inset',
      'placeholder:text-gray-400 focus:ring-2 focus:ring-inset',
      'disabled:cursor-not-allowed disabled:bg-gray-50 disabled:text-gray-500',
      'transition-colors duration-200',
    ].join(' ')

    const variantClasses = {
      default: [
        error
          ? 'ring-red-300 focus:ring-red-500 bg-red-50'
          : 'ring-gray-300 focus:ring-blue-500 bg-white',
        'text-gray-900',
      ].join(' '),
      filled: [
        error
          ? 'ring-red-300 focus:ring-red-500 bg-red-50'
          : 'ring-gray-300 focus:ring-blue-500 bg-gray-50',
        'text-gray-900',
      ].join(' '),
    }

    const sizeClasses = {
      sm: leftIcon || rightIcon ? 'py-1.5 pl-8 pr-3 text-sm' : 'py-1.5 px-3 text-sm',
      md: leftIcon || rightIcon ? 'py-2 pl-10 pr-4 text-sm' : 'py-2 px-4 text-sm',
      lg: leftIcon || rightIcon ? 'py-3 pl-12 pr-4 text-base' : 'py-3 px-4 text-base',
    }

    const iconSizeClasses = {
      sm: 'h-4 w-4',
      md: 'h-5 w-5',
      lg: 'h-6 w-6',
    }

    const iconPositionClasses = {
      sm: { left: 'left-2.5', right: 'right-2.5' },
      md: { left: 'left-3', right: 'right-3' },
      lg: { left: 'left-4', right: 'right-4' },
    }

    const classes = [baseClasses, variantClasses[variant], sizeClasses[inputSize], className]
      .filter(Boolean)
      .join(' ')

    return (
      <div className="w-full">
        {label && (
          <label htmlFor={inputId} className="block text-sm font-medium text-gray-700 mb-2">
            {label}
          </label>
        )}
        <div className="relative">
          {leftIcon && (
            <div
              className={`pointer-events-none absolute inset-y-0 left-0 flex items-center ${iconPositionClasses[inputSize].left}`}
            >
              <span className={`text-gray-400 ${iconSizeClasses[inputSize]}`}>{leftIcon}</span>
            </div>
          )}
          <input
            ref={ref}
            id={inputId}
            className={classes}
            disabled={disabled}
            aria-invalid={error ? 'true' : 'false'}
            aria-describedby={error ? `${inputId}-error` : helpText ? `${inputId}-help` : undefined}
            {...props}
          />
          {rightIcon && (
            <div
              className={`pointer-events-none absolute inset-y-0 right-0 flex items-center ${iconPositionClasses[inputSize].right}`}
            >
              <span className={`text-gray-400 ${iconSizeClasses[inputSize]}`}>{rightIcon}</span>
            </div>
          )}
        </div>
        {error && (
          <p id={`${inputId}-error`} className="mt-2 text-sm text-red-600" role="alert">
            {error}
          </p>
        )}
        {helpText && !error && (
          <p id={`${inputId}-help`} className="mt-2 text-sm text-gray-500">
            {helpText}
          </p>
        )}
      </div>
    )
  }
)

Input.displayName = 'Input'

export { Input }
export default Input
</file>

<file path="src/components/common/Loading.tsx">
import type { HTMLAttributes } from 'react'

export interface LoadingProps extends HTMLAttributes<HTMLDivElement> {
  size?: 'sm' | 'md' | 'lg' | 'xl'
  variant?: 'spinner' | 'dots' | 'pulse'
  text?: string
  centered?: boolean
  overlay?: boolean
}

const Loading = ({
  className = '',
  size = 'md',
  variant = 'spinner',
  text,
  centered = false,
  overlay = false,
  ...props
}: LoadingProps) => {
  const sizeClasses = {
    sm: 'h-4 w-4',
    md: 'h-6 w-6',
    lg: 'h-8 w-8',
    xl: 'h-12 w-12',
  }

  const textSizeClasses = {
    sm: 'text-xs',
    md: 'text-sm',
    lg: 'text-base',
    xl: 'text-lg',
  }

  const containerClasses = [
    'flex items-center',
    centered && 'justify-center',
    text ? 'flex-col space-y-2' : 'space-x-2',
    overlay && 'fixed inset-0 bg-white bg-opacity-75 z-50',
    className,
  ]
    .filter(Boolean)
    .join(' ')

  const renderSpinner = () => (
    <div
      className={`animate-spin rounded-full border-2 border-current border-t-transparent text-blue-600 ${sizeClasses[size]}`}
      role="status"
      aria-label="Loading"
    />
  )

  const renderDots = () => (
    <div className="flex space-x-1" role="status" aria-label="Loading">
      {[0, 1, 2].map((i) => (
        <div
          key={i}
          className={`bg-blue-600 rounded-full animate-pulse ${
            size === 'sm'
              ? 'h-1.5 w-1.5'
              : size === 'md'
                ? 'h-2 w-2'
                : size === 'lg'
                  ? 'h-2.5 w-2.5'
                  : 'h-3 w-3'
          }`}
          style={{
            animationDelay: `${i * 0.15}s`,
            animationDuration: '0.6s',
          }}
        />
      ))}
    </div>
  )

  const renderPulse = () => (
    <div
      className={`bg-blue-600 rounded-full animate-pulse ${sizeClasses[size]}`}
      role="status"
      aria-label="Loading"
    />
  )

  const renderLoader = () => {
    switch (variant) {
      case 'dots':
        return renderDots()
      case 'pulse':
        return renderPulse()
      case 'spinner':
      default:
        return renderSpinner()
    }
  }

  return (
    <div className={containerClasses} {...props}>
      {renderLoader()}
      {text && <span className={`text-gray-600 ${textSizeClasses[size]}`}>{text}</span>}
    </div>
  )
}

// Skeleton loading component for content placeholders
export interface SkeletonProps extends HTMLAttributes<HTMLDivElement> {
  width?: string | number
  height?: string | number
  rounded?: boolean
  lines?: number
}

const Skeleton = ({
  className = '',
  width,
  height,
  rounded = false,
  lines = 1,
  ...props
}: SkeletonProps) => {
  const baseClasses = ['animate-pulse bg-gray-200', rounded ? 'rounded-full' : 'rounded'].join(' ')

  const style = {
    width: typeof width === 'number' ? `${width}px` : width,
    height: typeof height === 'number' ? `${height}px` : height,
  }

  if (lines > 1) {
    return (
      <div className={`space-y-2 ${className}`} {...props}>
        {Array.from({ length: lines }).map((_, i) => (
          <div
            key={i}
            className={`${baseClasses} h-4`}
            style={{
              width: i === lines - 1 ? '60%' : '100%',
            }}
          />
        ))}
      </div>
    )
  }

  return <div className={`${baseClasses} ${className}`} style={style} {...props} />
}

// Full page loading component
export interface PageLoadingProps {
  text?: string
  size?: LoadingProps['size']
}

const PageLoading = ({ text = 'Loading...', size = 'lg' }: PageLoadingProps) => {
  return (
    <div className="min-h-screen flex items-center justify-center">
      <Loading size={size} text={text} centered />
    </div>
  )
}

// Card/Component loading placeholder
export interface CardLoadingProps {
  lines?: number
  showAvatar?: boolean
}

const CardLoading = ({ lines = 3, showAvatar = false }: CardLoadingProps) => {
  return (
    <div className="p-6 space-y-4">
      {showAvatar && (
        <div className="flex items-center space-x-4">
          <Skeleton width={40} height={40} rounded />
          <div className="flex-1">
            <Skeleton width="60%" height={16} />
            <Skeleton width="40%" height={12} className="mt-2" />
          </div>
        </div>
      )}
      <div className="space-y-2">
        {Array.from({ length: lines }).map((_, i) => (
          <Skeleton key={i} width={i === lines - 1 ? '60%' : '100%'} height={16} />
        ))}
      </div>
    </div>
  )
}

export { Loading, Skeleton, PageLoading, CardLoading }
export default Loading
</file>

<file path="src/components/dashboard/buyer/BuyerDashboard.tsx">
import { useState, useEffect } from 'react'
import { useAuth } from '../../../hooks/useAuth'
import {
  CurrencyDollarIcon,
  PhoneIcon,
  ChartBarIcon,
  ArrowTrendingUpIcon,
  ClockIcon,
  UserGroupIcon,
  PlusIcon,
} from '@heroicons/react/24/outline'
import { PaymentModal } from '../../payments/PaymentModal'
import { useBuyerStore } from '../../../store/buyerStore'
import { formatCurrency } from '../../../utils/format'

interface BuyerStats {
  totalSpent: number
  spentTrend: number
  totalLeads: number
  leadsTrend: number
  activeCampaigns: number
  campaignsTrend: number
  conversionRate: number
  conversionTrend: number
  averageCallDuration: number
  durationTrend: number
  qualityScore: number
  qualityTrend: number
}

function StatCard({
  title,
  value,
  trend,
  icon: Icon,
  format = 'number',
}: {
  title: string
  value: number | string
  trend: number
  icon: React.ComponentType<{ className?: string }>
  format?: 'number' | 'currency' | 'percentage' | 'duration'
}) {
  const formatValue = (val: number | string) => {
    if (typeof val === 'string') return val
    switch (format) {
      case 'currency':
        return new Intl.NumberFormat('en-US', {
          style: 'currency',
          currency: 'USD',
        }).format(val)
      case 'percentage':
        return `${val.toFixed(1)}%`
      case 'duration': {
        const minutes = Math.floor(val / 60)
        const seconds = val % 60
        return `${minutes}:${seconds.toString().padStart(2, '0')}`
      }
      default:
        return val.toLocaleString()
    }
  }

  const getTrendColor = (trend: number) => {
    if (trend > 0) return 'text-green-600'
    if (trend < 0) return 'text-red-600'
    return 'text-gray-500'
  }

  const getTrendIcon = (trend: number) => {
    if (trend > 0) return 'â†—'
    if (trend < 0) return 'â†˜'
    return 'â†’'
  }

  return (
    <div className="bg-white rounded-lg shadow p-6">
      <div className="flex items-center justify-between">
        <div className="flex items-center">
          <Icon className="h-8 w-8 text-primary-600" />
          <div className="ml-3">
            <p className="text-sm font-medium text-gray-600">{title}</p>
            <p className="text-2xl font-bold text-gray-900">{formatValue(value)}</p>
          </div>
        </div>
        <div className={`text-sm font-medium ${getTrendColor(trend)}`}>
          <span className="inline-flex items-center">
            {getTrendIcon(trend)} {Math.abs(trend).toFixed(1)}%
          </span>
        </div>
      </div>
    </div>
  )
}

export function BuyerDashboard() {
  const { user } = useAuth()
  const [selectedTimeRange, setSelectedTimeRange] = useState<'24h' | '7d' | '30d'>('7d')
  const [isPaymentModalOpen, setIsPaymentModalOpen] = useState(false)
  const { currentBalance, fetchBalance } = useBuyerStore()

  useEffect(() => {
    if (user?.id) {
      fetchBalance(user.id)
    }
  }, [user?.id, fetchBalance])

  if (!user || user.user_metadata?.userType !== 'buyer') {
    return (
      <div className="flex items-center justify-center h-64">
        <p className="text-gray-500">Access denied. Buyer account required.</p>
      </div>
    )
  }

  // Mock data - in real app, this would come from API
  const stats: BuyerStats = {
    totalSpent: 45678,
    spentTrend: 12.5,
    totalLeads: 234,
    leadsTrend: 8.3,
    activeCampaigns: 5,
    campaignsTrend: 0,
    conversionRate: 32.5,
    conversionTrend: -2.1,
    averageCallDuration: 245, // seconds
    durationTrend: 5.7,
    qualityScore: 92,
    qualityTrend: 3.2,
  }

  return (
    <div data-testid="buyer-dashboard" className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold text-gray-900">Buyer Dashboard</h1>
          <p className="text-gray-600">Monitor your campaigns and lead quality</p>
        </div>
        <div className="flex items-center space-x-4">
          {/* Balance Display */}
          <div className="bg-gray-100 rounded-lg px-4 py-2">
            <div className="text-xs text-gray-600">Account Balance</div>
            <div className="text-lg font-bold text-gray-900">{formatCurrency(currentBalance)}</div>
          </div>

          {/* Add Funds Button */}
          <button
            onClick={() => setIsPaymentModalOpen(true)}
            className="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
          >
            <PlusIcon className="h-4 w-4 mr-2" />
            Add Funds
          </button>

          {/* Time Range Selector */}
          <div className="flex items-center space-x-2">
            <label htmlFor="timeRange" className="text-sm text-gray-700">
              Time Range:
            </label>
            <select
              id="timeRange"
              value={selectedTimeRange}
              onChange={(e) => setSelectedTimeRange(e.target.value as '24h' | '7d' | '30d')}
              className="rounded-md border-gray-300 text-sm focus:border-primary-500 focus:ring-primary-500"
            >
              <option value="24h">Last 24 Hours</option>
              <option value="7d">Last 7 Days</option>
              <option value="30d">Last 30 Days</option>
            </select>
          </div>
        </div>
      </div>

      {/* Stats Grid */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        <StatCard
          title="Total Spent"
          value={stats.totalSpent}
          trend={stats.spentTrend}
          icon={CurrencyDollarIcon}
          format="currency"
        />
        <StatCard
          title="Total Leads"
          value={stats.totalLeads}
          trend={stats.leadsTrend}
          icon={PhoneIcon}
        />
        <StatCard
          title="Active Campaigns"
          value={stats.activeCampaigns}
          trend={stats.campaignsTrend}
          icon={ChartBarIcon}
        />
        <StatCard
          title="Conversion Rate"
          value={stats.conversionRate}
          trend={stats.conversionTrend}
          icon={ArrowTrendingUpIcon}
          format="percentage"
        />
        <StatCard
          title="Avg Call Duration"
          value={stats.averageCallDuration}
          trend={stats.durationTrend}
          icon={ClockIcon}
          format="duration"
        />
        <StatCard
          title="Quality Score"
          value={stats.qualityScore}
          trend={stats.qualityTrend}
          icon={UserGroupIcon}
        />
      </div>

      {/* Campaign Performance Table */}
      <div className="bg-white shadow rounded-lg">
        <div className="px-6 py-4 border-b border-gray-200">
          <h2 className="text-lg font-medium text-gray-900">Campaign Performance</h2>
        </div>
        <div className="overflow-x-auto">
          <table className="min-w-full divide-y divide-gray-200">
            <thead className="bg-gray-50">
              <tr>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Campaign
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Status
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Leads
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Cost
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  CPL
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Conversion
                </th>
              </tr>
            </thead>
            <tbody className="bg-white divide-y divide-gray-200">
              {/* Mock campaign data */}
              <tr>
                <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                  Home Insurance - National
                </td>
                <td className="px-6 py-4 whitespace-nowrap">
                  <span className="px-2 inline-flex text-xs leading-5 font-semibold rounded-full bg-green-100 text-green-800">
                    Active
                  </span>
                </td>
                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">87</td>
                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">$3,480</td>
                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">$40.00</td>
                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">35.2%</td>
              </tr>
              <tr>
                <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                  Auto Loans - CA Only
                </td>
                <td className="px-6 py-4 whitespace-nowrap">
                  <span className="px-2 inline-flex text-xs leading-5 font-semibold rounded-full bg-green-100 text-green-800">
                    Active
                  </span>
                </td>
                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">62</td>
                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">$2,170</td>
                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">$35.00</td>
                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">28.9%</td>
              </tr>
              <tr>
                <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                  Solar Installation
                </td>
                <td className="px-6 py-4 whitespace-nowrap">
                  <span className="px-2 inline-flex text-xs leading-5 font-semibold rounded-full bg-yellow-100 text-yellow-800">
                    Paused
                  </span>
                </td>
                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">45</td>
                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">$2,700</td>
                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">$60.00</td>
                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">22.5%</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

      {/* Recent Leads */}
      <div className="bg-white shadow rounded-lg">
        <div className="px-6 py-4 border-b border-gray-200">
          <h2 className="text-lg font-medium text-gray-900">Recent Leads</h2>
        </div>
        <ul className="divide-y divide-gray-200">
          <li className="px-6 py-4">
            <div className="flex items-center justify-between">
              <div className="flex items-center">
                <div className="flex-shrink-0">
                  <PhoneIcon className="h-8 w-8 text-gray-400" />
                </div>
                <div className="ml-4">
                  <p className="text-sm font-medium text-gray-900">+1 (555) 123-4567</p>
                  <p className="text-sm text-gray-500">Campaign: Home Insurance - National</p>
                  <p className="text-sm text-gray-500">Duration: 4:32 | Quality Score: 95</p>
                </div>
              </div>
              <div className="text-sm text-gray-500">2 minutes ago</div>
            </div>
          </li>
          <li className="px-6 py-4">
            <div className="flex items-center justify-between">
              <div className="flex items-center">
                <div className="flex-shrink-0">
                  <PhoneIcon className="h-8 w-8 text-gray-400" />
                </div>
                <div className="ml-4">
                  <p className="text-sm font-medium text-gray-900">+1 (555) 987-6543</p>
                  <p className="text-sm text-gray-500">Campaign: Auto Loans - CA Only</p>
                  <p className="text-sm text-gray-500">Duration: 3:15 | Quality Score: 88</p>
                </div>
              </div>
              <div className="text-sm text-gray-500">15 minutes ago</div>
            </div>
          </li>
        </ul>
      </div>

      {/* Payment Modal */}
      <PaymentModal
        isOpen={isPaymentModalOpen}
        onClose={() => setIsPaymentModalOpen(false)}
        type="topup"
        onSuccess={(paymentIntentId, amount) => {
          console.log('Payment successful:', paymentIntentId, amount)
          // Refresh balance after successful payment
          if (user?.id) {
            fetchBalance(user.id)
          }
        }}
      />
    </div>
  )
}
</file>

<file path="src/components/demo/ErrorBoundaryDemo.tsx">
/**
 * Error Boundary Demo Component
 * This component demonstrates the environment-aware error handling
 * Use this for testing error boundary behavior in different environments
 */

import { useState } from 'react'
import ErrorBoundary from '../common/ErrorBoundary'
import { ErrorFallback } from '../common/FallbackUI'
import { environment, getEnvironmentName } from '../../utils/environment'

// Component that throws different types of errors
function ErrorTrigger({ errorType }: { errorType: string }) {
  if (errorType === 'render') {
    throw new Error('Render Error: Component failed to render properly')
  }

  if (errorType === 'async') {
    setTimeout(() => {
      throw new Error('Async Error: This will not be caught by error boundary')
    }, 100)
  }

  if (errorType === 'type') {
    // This will cause a TypeError
    const obj: unknown = null
    const typedObj = obj as { nonExistent: { property: string } }
    return <div>{typedObj.nonExistent.property}</div>
  }

  if (errorType === 'reference') {
    // This will cause a ReferenceError
    // @ts-expect-error - Intentional error for demo
    return <div>{undefinedVariable}</div>
  }

  return <div>Component rendered successfully</div>
}

export function ErrorBoundaryDemo() {
  const [errorType, setErrorType] = useState<string | null>(null)
  const [showError, setShowError] = useState(false)

  const triggerError = (type: string) => {
    setErrorType(type)
    setShowError(true)
  }

  const resetDemo = () => {
    setErrorType(null)
    setShowError(false)
  }

  return (
    <div className="max-w-4xl mx-auto p-6">
      <h1 className="text-2xl font-bold mb-4">Error Boundary Demo</h1>

      <div className="mb-6 p-4 bg-blue-50 border border-blue-200 rounded-lg">
        <h2 className="text-lg font-semibold mb-2">Current Environment</h2>
        <div className="grid grid-cols-2 gap-2 text-sm">
          <div>
            <span className="font-medium">Environment:</span> {getEnvironmentName()}
          </div>
          <div>
            <span className="font-medium">Technical Details:</span>{' '}
            {environment.showTechnicalDetails ? 'Enabled' : 'Disabled'}
          </div>
          <div>
            <span className="font-medium">Error Display Level:</span>{' '}
            {environment.errorDisplayLevel}
          </div>
          <div>
            <span className="font-medium">Console Logging:</span>{' '}
            {environment.logToConsole ? 'Enabled' : 'Disabled'}
          </div>
        </div>
      </div>

      <div className="mb-6">
        <h2 className="text-lg font-semibold mb-3">Trigger Error Types</h2>
        <div className="grid grid-cols-2 md:grid-cols-4 gap-3">
          <button
            onClick={() => triggerError('render')}
            className="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700 transition-colors"
          >
            Render Error
          </button>
          <button
            onClick={() => triggerError('type')}
            className="px-4 py-2 bg-orange-600 text-white rounded hover:bg-orange-700 transition-colors"
          >
            Type Error
          </button>
          <button
            onClick={() => triggerError('reference')}
            className="px-4 py-2 bg-yellow-600 text-white rounded hover:bg-yellow-700 transition-colors"
          >
            Reference Error
          </button>
          <button
            onClick={() => triggerError('async')}
            className="px-4 py-2 bg-purple-600 text-white rounded hover:bg-purple-700 transition-colors"
          >
            Async Error
          </button>
        </div>
        <p className="mt-2 text-sm text-gray-600">
          Note: Async errors cannot be caught by React error boundaries
        </p>
      </div>

      <div className="border-2 border-dashed border-gray-300 rounded-lg p-6 min-h-[300px]">
        <h3 className="text-lg font-medium mb-4">Error Boundary Container</h3>

        <ErrorBoundary
          context="ErrorBoundaryDemo Component"
          onError={(error, errorInfo) => {
            console.log('Demo: Error caught by boundary', { error, errorInfo })
          }}
          fallback={
            <ErrorFallback
              title="Demo Error Caught"
              message="This error was caught by the demo error boundary"
              details={errorType ? `Error Type: ${errorType}` : undefined}
              errorCode="DEMO-001"
              onRetry={resetDemo}
              onGoHome={() => (window.location.href = '/')}
              showHomeButton={true}
              retryLabel="Reset Demo"
            />
          }
        >
          {showError && errorType ? (
            <ErrorTrigger errorType={errorType} />
          ) : (
            <div className="text-center text-gray-600">
              <p className="mb-4">Click a button above to trigger an error</p>
              <div className="inline-flex items-center px-4 py-2 bg-green-100 text-green-800 rounded">
                âœ“ No errors - Component rendering normally
              </div>
            </div>
          )}
        </ErrorBoundary>
      </div>

      {showError && (
        <div className="mt-4">
          <button
            onClick={resetDemo}
            className="px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-700 transition-colors"
          >
            Reset Demo
          </button>
        </div>
      )}

      <div className="mt-8 p-4 bg-gray-50 rounded-lg">
        <h3 className="font-semibold mb-2">How Error Display Changes by Environment:</h3>
        <ul className="space-y-2 text-sm">
          <li className="flex items-start">
            <span className="font-medium mr-2">Development:</span>
            <span>Full stack traces, component stacks, and debugging hints are shown</span>
          </li>
          <li className="flex items-start">
            <span className="font-medium mr-2">Staging:</span>
            <span>Error messages are shown but stack traces may be hidden</span>
          </li>
          <li className="flex items-start">
            <span className="font-medium mr-2">Production:</span>
            <span>Only user-friendly messages are shown, no technical details</span>
          </li>
        </ul>
      </div>
    </div>
  )
}

export default ErrorBoundaryDemo
</file>

<file path="src/components/forms/withFormErrorBoundary.tsx">
import { FormErrorBoundary } from './FormErrorBoundary'
import type { ComponentType } from 'react'
import type { z } from 'zod'

interface FormErrorBoundaryOptions {
  onRetry?: () => void
  onSaveDraft?: (data: Record<string, unknown>) => void
  onReset?: () => void
  formName?: string
  enableDraftSaving?: boolean
  validationSchema?: z.ZodSchema
}

/**
 * Higher-order component that wraps a form component with FormErrorBoundary
 */
export function withFormErrorBoundary<P extends object>(
  Component: ComponentType<P>,
  options?: FormErrorBoundaryOptions
) {
  return (props: P) => (
    <FormErrorBoundary {...options}>
      <Component {...props} />
    </FormErrorBoundary>
  )
}
</file>

<file path="src/components/layout/PublicLayout.tsx">
import { Outlet, Link } from 'react-router-dom'
import { useState } from 'react'
import { useAuthStore } from '../../store/authStore'
import { navigateToHomeSection } from '../../utils/navigation'
import { Bars3Icon, XMarkIcon } from '@heroicons/react/24/outline'
import ErrorBoundary from '../common/ErrorBoundary'
import { PublicLayoutFallbackUI } from '../common/FallbackUI'

// Social media links
const socialLinks = [
  {
    name: 'Facebook',
    href: 'https://facebook.com/dependablecalls',
    icon: (props: React.SVGProps<SVGSVGElement>) => (
      <svg fill="currentColor" viewBox="0 0 24 24" {...props}>
        <path
          fillRule="evenodd"
          d="M22 12c0-5.523-4.477-10-10-10S2 6.477 2 12c0 4.991 3.657 9.128 8.438 9.878v-6.987h-2.54V12h2.54V9.797c0-2.506 1.492-3.89 3.777-3.89 1.094 0 2.238.195 2.238.195v2.46h-1.26c-1.243 0-1.63.771-1.63 1.562V12h2.773l-.443 2.89h-2.33v6.988C18.343 21.128 22 16.991 22 12z"
          clipRule="evenodd"
        />
      </svg>
    ),
  },
  {
    name: 'Twitter',
    href: 'https://twitter.com/dependablecalls',
    icon: (props: React.SVGProps<SVGSVGElement>) => (
      <svg fill="currentColor" viewBox="0 0 24 24" {...props}>
        <path d="M8.29 20.251c7.547 0 11.675-6.253 11.675-11.675 0-.178 0-.355-.012-.53A8.348 8.348 0 0022 5.92a8.19 8.19 0 01-2.357.646 4.118 4.118 0 001.804-2.27 8.224 8.224 0 01-2.605.996 4.107 4.107 0 00-6.993 3.743 11.65 11.65 0 01-8.457-4.287 4.106 4.106 0 001.27 5.477A4.072 4.072 0 012.8 9.713v.052a4.105 4.105 0 003.292 4.022 4.095 4.095 0 01-1.853.07 4.108 4.108 0 003.834 2.85A8.233 8.233 0 012 18.407a11.616 11.616 0 006.29 1.84" />
      </svg>
    ),
  },
  {
    name: 'LinkedIn',
    href: 'https://linkedin.com/company/dependablecalls',
    icon: (props: React.SVGProps<SVGSVGElement>) => (
      <svg fill="currentColor" viewBox="0 0 24 24" {...props}>
        <path
          fillRule="evenodd"
          d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"
          clipRule="evenodd"
        />
      </svg>
    ),
  },
  {
    name: 'YouTube',
    href: 'https://youtube.com/dependablecalls',
    icon: (props: React.SVGProps<SVGSVGElement>) => (
      <svg fill="currentColor" viewBox="0 0 24 24" {...props}>
        <path
          fillRule="evenodd"
          d="M19.812 5.418c.861.23 1.538.907 1.768 1.768C21.998 8.746 22 12 22 12s0 3.255-.418 4.814a2.504 2.504 0 0 1-1.768 1.768c-1.56.419-7.814.419-7.814.419s-6.255 0-7.814-.419a2.505 2.505 0 0 1-1.768-1.768C2 15.255 2 12 2 12s0-3.255.417-4.814a2.507 2.507 0 0 1 1.768-1.768C5.744 5 11.998 5 11.998 5s6.255 0 7.814.418ZM15.194 12 10 15V9l5.194 3Z"
          clipRule="evenodd"
        />
      </svg>
    ),
  },
]

export default function PublicLayout() {
  const { user } = useAuthStore()
  const [mobileMenuOpen, setMobileMenuOpen] = useState(false)

  return (
    <div className="flex flex-col min-h-screen bg-gray-50">
      {/* Navigation */}
      <nav className="bg-white shadow-sm flex-shrink-0">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="flex justify-between items-center h-16">
            <div className="flex items-center">
              <Link to="/" className="text-2xl font-bold text-primary-600">
                DependableCalls
              </Link>
            </div>

            <div className="flex items-center space-x-4">
              <button
                onClick={() => navigateToHomeSection('features')}
                className="text-gray-700 hover:text-primary-600 px-3 py-2 rounded-md text-sm font-medium"
              >
                Features
              </button>
              <button
                onClick={() => navigateToHomeSection('pricing')}
                className="text-gray-700 hover:text-primary-600 px-3 py-2 rounded-md text-sm font-medium"
              >
                Pricing
              </button>
              <button
                onClick={() => navigateToHomeSection('about')}
                className="text-gray-700 hover:text-primary-600 px-3 py-2 rounded-md text-sm font-medium"
              >
                About
              </button>

              {user ? (
                <Link
                  to="/app/dashboard"
                  className="bg-primary-600 text-white hover:bg-primary-700 px-4 py-2 rounded-md text-sm font-medium"
                >
                  Dashboard
                </Link>
              ) : (
                <>
                  <Link
                    to="/login"
                    className="text-gray-700 hover:text-primary-600 px-3 py-2 rounded-md text-sm font-medium"
                  >
                    Login
                  </Link>
                  <Link
                    to="/register"
                    className="bg-primary-600 text-white hover:bg-primary-700 px-4 py-2 rounded-md text-sm font-medium"
                  >
                    Get Started
                  </Link>
                </>
              )}
            </div>

            {/* Mobile menu button */}
            <div className="md:hidden">
              <button
                onClick={() => setMobileMenuOpen(!mobileMenuOpen)}
                className="text-gray-700 hover:text-primary-600 p-2 rounded-md"
                aria-label="Toggle mobile menu"
              >
                {mobileMenuOpen ? (
                  <XMarkIcon className="h-6 w-6" />
                ) : (
                  <Bars3Icon className="h-6 w-6" />
                )}
              </button>
            </div>
          </div>
        </div>

        {/* Mobile Navigation Menu */}
        {mobileMenuOpen && (
          <div className="md:hidden bg-white border-t border-gray-200">
            <div className="px-2 pt-2 pb-3 space-y-1">
              <button
                onClick={() => {
                  navigateToHomeSection('features')
                  setMobileMenuOpen(false)
                }}
                className="block w-full text-left text-gray-700 hover:text-primary-600 hover:bg-gray-50 px-3 py-2 rounded-md text-base font-medium transition-colors"
              >
                Features
              </button>
              <button
                onClick={() => {
                  navigateToHomeSection('pricing')
                  setMobileMenuOpen(false)
                }}
                className="block w-full text-left text-gray-700 hover:text-primary-600 hover:bg-gray-50 px-3 py-2 rounded-md text-base font-medium transition-colors"
              >
                Pricing
              </button>
              <button
                onClick={() => {
                  navigateToHomeSection('about')
                  setMobileMenuOpen(false)
                }}
                className="block w-full text-left text-gray-700 hover:text-primary-600 hover:bg-gray-50 px-3 py-2 rounded-md text-base font-medium transition-colors"
              >
                About
              </button>
              <Link
                to="/blog"
                onClick={() => setMobileMenuOpen(false)}
                className="block text-gray-700 hover:text-primary-600 hover:bg-gray-50 px-3 py-2 rounded-md text-base font-medium transition-colors"
              >
                Blog
              </Link>

              {user ? (
                <Link
                  to="/app/dashboard"
                  onClick={() => setMobileMenuOpen(false)}
                  className="block bg-primary-600 text-white hover:bg-primary-700 px-3 py-2 rounded-md text-base font-medium transition-colors"
                >
                  Dashboard
                </Link>
              ) : (
                <>
                  <Link
                    to="/login"
                    onClick={() => setMobileMenuOpen(false)}
                    className="block text-gray-700 hover:text-primary-600 hover:bg-gray-50 px-3 py-2 rounded-md text-base font-medium transition-colors"
                  >
                    Login
                  </Link>
                  <Link
                    to="/register"
                    onClick={() => setMobileMenuOpen(false)}
                    className="block bg-primary-600 text-white hover:bg-primary-700 px-3 py-2 rounded-md text-base font-medium transition-colors"
                  >
                    Get Started
                  </Link>
                </>
              )}
            </div>
          </div>
        )}
      </nav>

      {/* Main Content */}
      <main className="flex-grow flex flex-col">
        <ErrorBoundary context="PublicLayout - Main Content" fallback={<PublicLayoutFallbackUI />}>
          <Outlet />
        </ErrorBoundary>
      </main>

      {/* Footer */}
      <footer className="bg-gray-800 text-white flex-shrink-0">
        <div className="max-w-7xl mx-auto px-4 py-12 sm:px-6 lg:px-8">
          <div className="grid grid-cols-1 md:grid-cols-4 gap-8">
            <div>
              <h3 className="text-2xl font-bold mb-4">DependableCalls</h3>
              <p className="text-gray-400">
                The most trusted pay-per-call network for quality lead generation.
              </p>
            </div>

            <div>
              <h4 className="text-lg font-semibold mb-4">Product</h4>
              <ul className="space-y-2">
                <li>
                  <button
                    onClick={() => navigateToHomeSection('features')}
                    className="text-gray-400 hover:text-white text-left"
                  >
                    Features
                  </button>
                </li>
                <li>
                  <button
                    onClick={() => navigateToHomeSection('pricing')}
                    className="text-gray-400 hover:text-white text-left"
                  >
                    Pricing
                  </button>
                </li>
                <li>
                  <Link to="/blog" className="text-gray-400 hover:text-white">
                    Blog
                  </Link>
                </li>
              </ul>
            </div>

            <div>
              <h4 className="text-lg font-semibold mb-4">Company</h4>
              <ul className="space-y-2">
                <li>
                  <button
                    onClick={() => navigateToHomeSection('about')}
                    className="text-gray-400 hover:text-white text-left"
                  >
                    About Us
                  </button>
                </li>
                <li>
                  <Link to="/contact" className="text-gray-400 hover:text-white">
                    Contact
                  </Link>
                </li>
                <li>
                  <Link to="/careers" className="text-gray-400 hover:text-white">
                    Careers
                  </Link>
                </li>
              </ul>
            </div>

            <div>
              <h4 className="text-lg font-semibold mb-4">Legal</h4>
              <ul className="space-y-2">
                <li>
                  <Link to="/privacy" className="text-gray-400 hover:text-white">
                    Privacy Policy
                  </Link>
                </li>
                <li>
                  <Link to="/terms" className="text-gray-400 hover:text-white">
                    Terms of Service
                  </Link>
                </li>
                <li>
                  <Link to="/compliance" className="text-gray-400 hover:text-white">
                    Compliance
                  </Link>
                </li>
              </ul>
            </div>
          </div>

          <div className="mt-8 pt-8 border-t border-gray-700">
            <div className="flex flex-col md:flex-row md:justify-between md:items-center">
              <div className="flex justify-center space-x-6 md:order-2">
                {socialLinks.map((item) => (
                  <a
                    key={item.name}
                    href={item.href}
                    target="_blank"
                    rel="noopener noreferrer"
                    className="text-gray-400 hover:text-white transition-colors duration-200"
                  >
                    <span className="sr-only">{item.name}</span>
                    <item.icon className="h-6 w-6" aria-hidden="true" />
                  </a>
                ))}
              </div>
              <div className="mt-8 md:mt-0 md:order-1">
                <p className="text-center md:text-left text-gray-400">
                  &copy; {new Date().getFullYear()} DependableCalls. All rights reserved.
                </p>
              </div>
            </div>
          </div>
        </div>
      </footer>
    </div>
  )
}
</file>

<file path="src/components/payments/PaymentErrorBoundary.tsx">
import { Component } from 'react'
import type { ErrorInfo, ReactNode } from 'react'
import { PaymentError } from '../common/FallbackUI'
import { captureException } from '@sentry/react'

interface PaymentErrorBoundaryProps {
  children: ReactNode
  onError?: (error: Error, errorInfo: ErrorInfo) => void
  onRetry?: () => void
  onUpdatePaymentMethod?: () => void
  onContactSupport?: () => void
  fallbackComponent?: ReactNode
  preserveFormData?: boolean
}

interface PaymentErrorBoundaryState {
  hasError: boolean
  error?: Error
  errorType?:
    | 'card_declined'
    | 'insufficient_funds'
    | 'payment_failed'
    | 'connection_error'
    | 'invalid_card'
  formData?: Record<string, unknown>
}

/**
 * PaymentErrorBoundary - Specialized error boundary for payment-related components
 *
 * Features:
 * - Detects and categorizes payment-specific errors
 * - Preserves form data during errors (if enabled)
 * - Provides payment-specific recovery options
 * - Integrates with Sentry for error tracking
 */
export class PaymentErrorBoundary extends Component<
  PaymentErrorBoundaryProps,
  PaymentErrorBoundaryState
> {

  constructor(props: PaymentErrorBoundaryProps) {
    super(props)
    this.state = {
      hasError: false,
      formData: {},
    }
  }

  static getDerivedStateFromError(error: Error): Partial<PaymentErrorBoundaryState> {
    // Categorize payment errors based on error message or code
    const errorType = PaymentErrorBoundary.categorizePaymentError(error)

    return {
      hasError: true,
      error,
      errorType,
    }
  }

  static categorizePaymentError(error: Error): PaymentErrorBoundaryState['errorType'] {
    const errorMessage = error.message.toLowerCase()
    const errorCode = (error as Error & { code?: string }).code?.toLowerCase()

    // Stripe-specific error codes
    if (errorCode === 'card_declined' || errorMessage.includes('card declined')) {
      return 'card_declined'
    }

    if (errorCode === 'insufficient_funds' || errorMessage.includes('insufficient funds')) {
      return 'insufficient_funds'
    }

    if (errorCode === 'invalid_card' || errorMessage.includes('invalid card')) {
      return 'invalid_card'
    }

    // Network/connection errors
    if (
      errorMessage.includes('network') ||
      errorMessage.includes('connection') ||
      errorMessage.includes('timeout') ||
      errorCode === 'network_error'
    ) {
      return 'connection_error'
    }

    // Default to generic payment failure
    return 'payment_failed'
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    // Log to console with payment context
    console.error('PaymentErrorBoundary caught an error:', error, errorInfo)

    // Capture in Sentry with payment context
    captureException(error, {
      contexts: {
        payment: {
          errorType: this.state.errorType,
          hasFormData: Boolean(this.state.formData && Object.keys(this.state.formData).length > 0),
        },
      },
      tags: {
        component: 'PaymentErrorBoundary',
        errorType: this.state.errorType || 'unknown',
      },
    })

    // Call custom error handler if provided
    if (this.props.onError) {
      this.props.onError(error, errorInfo)
    }

    // Try to preserve form data if enabled
    if (this.props.preserveFormData) {
      this.preserveFormData()
    }
  }

  preserveFormData = () => {
    try {
      // Find all form elements within the error boundary
      const forms = document.querySelectorAll('form')
      const formData: Record<string, unknown> = {}

      forms.forEach((form) => {
        const data = new FormData(form)
        data.forEach((value, key) => {
          // Don't store sensitive payment data
          if (!key.includes('cvv') && !key.includes('cvc') && !key.includes('securityCode')) {
            formData[key] = value
          }
        })
      })

      // Store in state and sessionStorage for recovery
      this.setState({ formData })
      sessionStorage.setItem('paymentFormRecovery', JSON.stringify(formData))
    } catch (err) {
      console.error('Failed to preserve form data:', err)
    }
  }

  handleRetry = () => {
    // Clear error state
    this.setState({ hasError: false, error: undefined, errorType: undefined })

    // Restore form data if available
    if (this.state.formData && Object.keys(this.state.formData).length > 0) {
      // This would need to be implemented based on your form library
      console.log('Form data available for restoration:', this.state.formData)
    }

    // Call custom retry handler if provided
    if (this.props.onRetry) {
      this.props.onRetry()
    }
  }

  handleUpdatePaymentMethod = () => {
    // Clear error state
    this.setState({ hasError: false, error: undefined, errorType: undefined })

    // Call custom handler if provided
    if (this.props.onUpdatePaymentMethod) {
      this.props.onUpdatePaymentMethod()
    }
  }

  handleContactSupport = () => {
    // Prepare error details for support
    const errorDetails = {
      errorType: this.state.errorType,
      errorMessage: this.state.error?.message,
      timestamp: new Date().toISOString(),
    }

    // Store error details for support reference
    sessionStorage.setItem('paymentErrorDetails', JSON.stringify(errorDetails))

    // Call custom handler if provided
    if (this.props.onContactSupport) {
      this.props.onContactSupport()
    } else {
      // Default to opening support page
      window.location.href = '/support?type=payment-error'
    }
  }

  componentDidUpdate(prevProps: PaymentErrorBoundaryProps) {
    // Reset error state if children change (e.g., navigating to a different payment form)
    if (prevProps.children !== this.props.children && this.state.hasError) {
      this.setState({ hasError: false, error: undefined, errorType: undefined })
    }
  }

  render() {
    if (this.state.hasError && this.state.errorType) {
      // Use custom fallback if provided
      if (this.props.fallbackComponent) {
        return this.props.fallbackComponent
      }

      // Use PaymentError component with appropriate handlers
      return (
        <PaymentError
          errorType={this.state.errorType}
          onRetry={this.handleRetry}
          onUpdatePaymentMethod={this.handleUpdatePaymentMethod}
          onContactSupport={this.handleContactSupport}
          className="my-8"
          testId="payment-error-boundary-fallback"
        />
      )
    }

    return this.props.children
  }
}

// Export as default for easier imports
export default PaymentErrorBoundary
</file>

<file path="src/components/payments/PaymentForm.tsx">
import React, { useState, useEffect, useCallback } from 'react'
import { loadStripe, type StripeElementsOptions } from '@stripe/stripe-js'
import { Elements, useStripe, useElements, PaymentElement } from '@stripe/react-stripe-js'
import { CreditCardIcon, LockClosedIcon, CheckCircleIcon } from '@heroicons/react/24/outline'
import { createPaymentIntent } from '@/integrations/stripe/payments'
import { useAuth } from '@/hooks/useAuth'
import type { CreatePaymentIntentParams } from '@/integrations/stripe/types'
import { PaymentErrorBoundary } from './PaymentErrorBoundary'

const stripePromise = loadStripe(import.meta.env.VITE_STRIPE_PUBLISHABLE_KEY || '')

interface PaymentFormProps {
  amount: number
  currency?: string
  description: string
  metadata: {
    invoiceId: string
    buyerId: string
    billingPeriod: string
  }
  onSuccess?: (paymentIntentId: string) => void
  onError?: (error: string) => void
  paymentMethods?: ('card' | 'us_bank_account')[]
}

interface PaymentFormInnerProps extends PaymentFormProps {
  clientSecret: string
}

const PaymentFormInner: React.FC<PaymentFormInnerProps> = ({
  amount,
  currency = 'usd',
  description,
  onSuccess,
  onError,
  paymentMethods = ['card'],
}) => {
  const stripe = useStripe()
  const elements = useElements()
  const [isProcessing, setIsProcessing] = useState(false)
  const [paymentStatus, setPaymentStatus] = useState<
    'idle' | 'processing' | 'succeeded' | 'failed'
  >('idle')
  const [errorMessage, setErrorMessage] = useState('')

  const handleSubmit = async (event: React.FormEvent) => {
    event.preventDefault()

    if (!stripe || !elements) {
      return
    }

    setIsProcessing(true)
    setErrorMessage('')
    setPaymentStatus('processing')

    try {
      const { error, paymentIntent } = await stripe.confirmPayment({
        elements,
        confirmParams: {
          return_url: `${window.location.origin}/payments/return`,
        },
        redirect: 'if_required',
      })

      if (error) {
        setErrorMessage(error.message || 'Payment failed')
        setPaymentStatus('failed')
        onError?.(error.message || 'Payment failed')
      } else if (paymentIntent && paymentIntent.status === 'succeeded') {
        setPaymentStatus('succeeded')
        onSuccess?.(paymentIntent.id)
      }
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Payment processing failed'
      setErrorMessage(message)
      setPaymentStatus('failed')
      onError?.(message)
    } finally {
      setIsProcessing(false)
    }
  }

  if (paymentStatus === 'succeeded') {
    return (
      <div className="text-center py-8">
        <div className="mx-auto w-16 h-16 bg-green-100 rounded-full flex items-center justify-center mb-4">
          <CheckCircleIcon className="w-8 h-8 text-green-600" />
        </div>
        <h3 className="text-lg font-medium text-gray-900 mb-2">Payment Successful</h3>
        <p className="text-gray-600">
          Your payment of ${(amount / 100).toFixed(2)} has been processed successfully.
        </p>
      </div>
    )
  }

  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      <div className="bg-gray-50 rounded-lg p-4">
        <div className="flex items-center justify-between mb-2">
          <span className="text-sm font-medium text-gray-700">Amount</span>
          <span className="text-lg font-bold text-gray-900">
            ${(amount / 100).toFixed(2)} {currency.toUpperCase()}
          </span>
        </div>
        <p className="text-sm text-gray-600">{description}</p>
      </div>

      <div className="space-y-4">
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-2">Payment Method</label>
          <div className="border border-gray-300 rounded-lg p-4">
            <PaymentElement
              options={{
                layout: 'tabs',
                paymentMethodOrder: paymentMethods,
              }}
            />
          </div>
        </div>
      </div>

      {errorMessage && (
        <div className="bg-red-50 border border-red-200 rounded-lg p-4">
          <p className="text-sm text-red-600">{errorMessage}</p>
        </div>
      )}

      <div className="flex items-center text-sm text-gray-500 mb-4">
        <LockClosedIcon className="w-4 h-4 mr-2" />
        <span>Your payment information is secure and encrypted</span>
      </div>

      <button
        type="submit"
        disabled={!stripe || isProcessing || paymentStatus === 'processing'}
        className={`w-full py-3 px-4 rounded-lg font-medium transition-colors ${
          isProcessing || paymentStatus === 'processing'
            ? 'bg-gray-400 cursor-not-allowed'
            : 'bg-blue-600 hover:bg-blue-700'
        } text-white`}
      >
        {isProcessing || paymentStatus === 'processing' ? (
          <div className="flex items-center justify-center">
            <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-white mr-2"></div>
            Processing Payment...
          </div>
        ) : (
          <>
            <CreditCardIcon className="w-5 h-5 inline mr-2" />
            Pay ${(amount / 100).toFixed(2)}
          </>
        )}
      </button>

      <div className="text-xs text-gray-500 text-center">
        Powered by <span className="font-medium">Stripe</span> â€¢ Your card details are never stored
        on our servers
      </div>
    </form>
  )
}

// Wrapped version with error boundary
export const PaymentFormWithErrorBoundary: React.FC<PaymentFormProps> = (props) => {
  const [retryKey, setRetryKey] = useState(0)

  const handleRetry = () => {
    // Force re-render by changing key
    setRetryKey((prev) => prev + 1)
  }

  const handleUpdatePaymentMethod = () => {
    // Navigate to payment methods page
    window.location.href = '/app/settings/payment-methods'
  }

  const handleContactSupport = () => {
    // Navigate to support with payment context
    window.location.href = '/support?type=payment-error'
  }

  return (
    <PaymentErrorBoundary
      onRetry={handleRetry}
      onUpdatePaymentMethod={handleUpdatePaymentMethod}
      onContactSupport={handleContactSupport}
      preserveFormData={true}
    >
      <PaymentFormWithClientSecret key={retryKey} {...props} />
    </PaymentErrorBoundary>
  )
}

// Inner form component (original PaymentForm)
const PaymentFormWithClientSecret: React.FC<PaymentFormProps> = (props) => {
  const { user } = useAuth()
  const [clientSecret, setClientSecret] = useState<string>('')
  const [isLoading, setIsLoading] = useState(true)
  const [error, setError] = useState<string>('')

  // Destructure props for useCallback dependencies
  const { amount, currency, metadata, paymentMethods, onError } = props

  const createPaymentIntentForForm = useCallback(async () => {
    if (!user) {
      setError('User not authenticated')
      setIsLoading(false)
      return
    }

    try {
      setIsLoading(true)
      setError('')

      const params: CreatePaymentIntentParams = {
        amount: amount,
        currency: currency || 'usd',
        customerId: user.stripe_customer_id || '',
        metadata: metadata,
        paymentMethodTypes: paymentMethods,
      }

      const paymentIntent = await createPaymentIntent(params)

      if (paymentIntent.client_secret) {
        setClientSecret(paymentIntent.client_secret)
      } else {
        throw new Error('Failed to create payment intent')
      }
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to initialize payment'
      setError(message)
      onError?.(message)
    } finally {
      setIsLoading(false)
    }
  }, [amount, currency, metadata, paymentMethods, onError, user])

  useEffect(() => {
    createPaymentIntentForForm()
  }, [createPaymentIntentForForm])

  if (isLoading) {
    return (
      <div className="flex items-center justify-center py-12">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
        <span className="ml-3 text-gray-600">Preparing payment form...</span>
      </div>
    )
  }

  if (error) {
    return (
      <div className="bg-red-50 border border-red-200 rounded-lg p-4">
        <p className="text-red-600">{error}</p>
        <button
          onClick={createPaymentIntentForForm}
          className="mt-2 text-red-700 hover:text-red-800 underline"
        >
          Try again
        </button>
      </div>
    )
  }

  if (!clientSecret) {
    return (
      <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-4">
        <p className="text-yellow-600">Payment form is not ready</p>
      </div>
    )
  }

  const elementsOptions: StripeElementsOptions = {
    clientSecret,
    appearance: {
      theme: 'stripe',
      variables: {
        colorPrimary: '#2563eb',
        colorBackground: '#ffffff',
        colorText: '#374151',
        colorDanger: '#ef4444',
        fontFamily: 'system-ui, sans-serif',
        spacingUnit: '4px',
        borderRadius: '8px',
      },
    },
  }

  return (
    <div className="max-w-md mx-auto">
      <Elements stripe={stripePromise} options={elementsOptions}>
        <PaymentFormInner {...props} clientSecret={clientSecret} />
      </Elements>
    </div>
  )
}

// Export both versions
export const PaymentForm = PaymentFormInner
export default PaymentFormWithErrorBoundary
</file>

<file path="src/components/payments/withPaymentErrorBoundary.tsx">
import { PaymentErrorBoundary } from './PaymentErrorBoundary'
import type { ComponentType } from 'react'

interface PaymentErrorBoundaryOptions {
  onRetry?: () => void
  onUpdatePaymentMethod?: () => void
  onContactSupport?: () => void
  preserveFormData?: boolean
}

/**
 * Higher-order component that wraps a component with PaymentErrorBoundary
 */
export function withPaymentErrorBoundary<P extends object>(
  Component: ComponentType<P>,
  options?: PaymentErrorBoundaryOptions
) {
  return (props: P) => (
    <PaymentErrorBoundary {...options}>
      <Component {...props} />
    </PaymentErrorBoundary>
  )
}
</file>

<file path="src/components/realtime/withRealtimeErrorBoundary.tsx">
import { RealtimeErrorBoundary } from './RealtimeErrorBoundary'
import type { ComponentType } from 'react'

interface RealtimeErrorBoundaryOptions {
  onReconnect?: () => void
  onFallbackToPolling?: () => void
  onRefresh?: () => void
  featureName?: string
  enableAutoReconnect?: boolean
  maxReconnectAttempts?: number
  reconnectDelay?: number
}

/**
 * Higher-order component that wraps a real-time component with RealtimeErrorBoundary
 */
export function withRealtimeErrorBoundary<P extends object>(
  Component: ComponentType<P>,
  options?: RealtimeErrorBoundaryOptions
) {
  return (props: P) => (
    <RealtimeErrorBoundary {...options}>
      <Component {...props} />
    </RealtimeErrorBoundary>
  )
}
</file>

<file path="src/components/ui/AppErrorFallback.tsx">
import { ErrorFallback } from './ErrorFallback'

interface AppErrorFallbackProps {
  error: Error
  resetErrorBoundary: () => void
  errorInfo?: { componentStack?: string; [key: string]: unknown }
}

export function AppErrorFallback({ error, resetErrorBoundary, errorInfo }: AppErrorFallbackProps) {
  return (
    <ErrorFallback
      error={error}
      resetErrorBoundary={resetErrorBoundary}
      errorInfo={errorInfo}
      isRoot={true}
    />
  )
}
</file>

<file path="src/components/ui/ErrorFallback.tsx">
import {
  ExclamationTriangleIcon,
  ArrowPathIcon,
  ChevronDownIcon,
  ChevronUpIcon,
} from '@heroicons/react/24/outline'
import { captureMessage } from '../../lib/monitoring'
import {
  shouldShowTechnicalDetails,
  getEnvironmentName,
  getEnvironmentErrorMessage,
  environment,
} from '../../utils/environment'
import { useState } from 'react'

interface ErrorFallbackProps {
  error: Error
  resetErrorBoundary: () => void
  isRoot?: boolean
  errorInfo?: { componentStack?: string; [key: string]: unknown }
}

export function ErrorFallback({
  error,
  resetErrorBoundary,
  isRoot = false,
  errorInfo,
}: ErrorFallbackProps) {
  const [showDetails, setShowDetails] = useState(false)
  const shouldShowTechDetails = shouldShowTechnicalDetails()
  const envName = getEnvironmentName()
  const handleReset = () => {
    // Log the recovery attempt
    captureMessage('User initiated error boundary reset', 'info', {
      errorMessage: error.message,
      isRootBoundary: isRoot,
    })

    resetErrorBoundary()
  }

  const handleReload = () => {
    // Log the full reload attempt
    captureMessage('User initiated full page reload from error boundary', 'warning', {
      errorMessage: error.message,
      isRootBoundary: isRoot,
    })

    window.location.reload()
  }

  return (
    <div
      className={`min-h-screen flex items-center justify-center px-4 ${isRoot ? 'bg-gray-50' : 'bg-white'}`}
    >
      <div className="max-w-md w-full text-center">
        <div className="mb-6">
          <ExclamationTriangleIcon className="mx-auto h-16 w-16 text-red-500" />
        </div>

        <h1 className="text-2xl font-bold text-gray-900 mb-4">
          {isRoot ? 'Something went wrong' : 'Error in this section'}
        </h1>

        <p className="text-gray-600 mb-6">
          {getEnvironmentErrorMessage(
            error,
            isRoot
              ? 'We apologize for the inconvenience. The application encountered an unexpected error.'
              : 'This section encountered an error, but the rest of the application should work normally.'
          )}
        </p>

        {shouldShowTechDetails && (
          <div className="mb-6">
            <button
              onClick={() => setShowDetails(!showDetails)}
              className="flex items-center gap-1 text-sm text-gray-500 hover:text-gray-700 focus:outline-none focus:underline mx-auto mb-3"
              aria-expanded={showDetails}
              aria-label={showDetails ? 'Hide technical details' : 'Show technical details'}
            >
              Technical Details ({envName})
              {showDetails ? (
                <ChevronUpIcon className="h-4 w-4" />
              ) : (
                <ChevronDownIcon className="h-4 w-4" />
              )}
            </button>

            {showDetails && (
              <div className="p-4 bg-red-50 border border-red-200 rounded-lg text-left space-y-3">
                {/* Environment Info */}
                <div className="text-xs text-gray-600 flex items-center justify-between border-b border-red-200 pb-2">
                  <span>
                    Environment: <span className="font-medium">{envName}</span>
                  </span>
                  <span>Time: {new Date().toLocaleString()}</span>
                </div>

                {/* Error Details */}
                <div>
                  <h3 className="text-sm font-medium text-red-800 mb-1">Error Message</h3>
                  <pre className="text-xs text-red-700 whitespace-pre-wrap break-words bg-white p-2 rounded">
                    {error.message}
                  </pre>
                </div>

                {/* Stack Trace */}
                {error.stack && (
                  <div>
                    <h3 className="text-sm font-medium text-red-800 mb-1">Stack Trace</h3>
                    <pre className="text-xs text-red-600 whitespace-pre-wrap break-words bg-white p-2 rounded max-h-48 overflow-auto">
                      {error.stack}
                    </pre>
                  </div>
                )}

                {/* Component Stack */}
                {errorInfo?.componentStack && (
                  <div>
                    <h3 className="text-sm font-medium text-red-800 mb-1">Component Stack</h3>
                    <pre className="text-xs text-red-600 whitespace-pre-wrap break-words bg-white p-2 rounded max-h-48 overflow-auto">
                      {errorInfo.componentStack}
                    </pre>
                  </div>
                )}

                {/* Error Type & Name */}
                <div className="grid grid-cols-2 gap-2 text-xs">
                  <div>
                    <span className="text-red-700 font-medium">Error Type:</span>
                    <span className="ml-1 text-red-600">{error.name}</span>
                  </div>
                  <div>
                    <span className="text-red-700 font-medium">Root Boundary:</span>
                    <span className="ml-1 text-red-600">{isRoot ? 'Yes' : 'No'}</span>
                  </div>
                </div>

                {/* Development Hints */}
                {environment.isDevelopment && (
                  <div className="text-xs text-gray-600 italic border-t border-red-200 pt-2">
                    ðŸ’¡ Development Tips:
                    <ul className="list-disc list-inside mt-1 space-y-1">
                      <li>Check browser console for additional debugging info</li>
                      <li>React DevTools can help identify component issues</li>
                      <li>Error boundaries don't catch async errors or event handlers</li>
                    </ul>
                  </div>
                )}
              </div>
            )}
          </div>
        )}

        <div className="space-y-3">
          <button
            onClick={handleReset}
            className="w-full flex items-center justify-center px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-primary-600 hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500"
          >
            <ArrowPathIcon className="mr-2 h-4 w-4" />
            Try Again
          </button>

          {isRoot && (
            <button
              onClick={handleReload}
              className="w-full flex items-center justify-center px-4 py-2 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500"
            >
              Reload Page
            </button>
          )}
        </div>

        {isRoot && (
          <div className="mt-6 text-xs text-gray-500">
            <p>If this problem persists, please contact support.</p>
            <p className="mt-1">
              Error ID: {error.name}-{Date.now()}
            </p>
            {!environment.isProduction && (
              <p className="mt-1 text-orange-600">[{envName.toUpperCase()} MODE]</p>
            )}
          </div>
        )}
      </div>
    </div>
  )
}
</file>

<file path="src/hooks/useStripe.ts">
import { useState, useEffect } from 'react'
import type { Stripe, StripeElements } from '@stripe/stripe-js'
import { getStripeClient } from '../integrations/stripe'

export const useStripe = () => {
  const [stripe, setStripe] = useState<Stripe | null>(null)
  const [isLoading, setIsLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    const initStripe = async () => {
      try {
        const stripeClient = await getStripeClient()
        setStripe(stripeClient)
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : 'Failed to initialize Stripe'
        setError(errorMessage)
      } finally {
        setIsLoading(false)
      }
    }

    initStripe()
  }, [])

  return { stripe, isLoading, error }
}

export const useStripeElements = () => {
  const { stripe } = useStripe()
  const [elements, setElements] = useState<StripeElements | null>(null)

  useEffect(() => {
    if (stripe) {
      setElements(stripe.elements())
    }
  }, [stripe])

  return { stripe, elements }
}
</file>

<file path="src/integrations/fraud/config.ts">
import type { FraudConfig } from './types'

export const fraudConfig: FraudConfig = {
  truecaller: {
    apiKey: import.meta.env.VITE_TRUECALLER_API_KEY || '',
    baseUrl: 'https://api.truecaller.com/v2',
    timeout: 5000,
  },
  ipquality: {
    apiKey: import.meta.env.VITE_IPQUALITY_API_KEY || '',
    baseUrl: 'https://ipqualityscore.com/api/json',
    timeout: 5000,
  },
  fraudlabs: {
    apiKey: import.meta.env.VITE_FRAUDLABS_API_KEY || '',
    baseUrl: 'https://api.fraudlabspro.com/v1',
    timeout: 5000,
  },
  sift: {
    apiKey: import.meta.env.VITE_SIFT_API_KEY || '',
    baseUrl: 'https://api.sift.com/v205',
    timeout: 10000,
  },
  maxmind: {
    apiKey: import.meta.env.VITE_MAXMIND_API_KEY || '',
    baseUrl: 'https://geoip.maxmind.com/geoip/v2.1',
    timeout: 5000,
  },
  thresholds: {
    autoReject: 85, // Fraud score >= 85: automatic rejection
    manualReview: 50, // Fraud score 50-84: manual review required
    autoApprove: 49, // Fraud score <= 49: automatic approval
  },
}

export const isFraudDetectionConfigured = (): boolean => {
  return !!(
    fraudConfig.truecaller.apiKey &&
    fraudConfig.ipquality.apiKey &&
    fraudConfig.fraudlabs.apiKey &&
    fraudConfig.sift.apiKey &&
    fraudConfig.maxmind.apiKey
  )
}

export const getFraudDecision = (score: number): 'approve' | 'review' | 'reject' => {
  if (score >= fraudConfig.thresholds.autoReject) {
    return 'reject'
  } else if (score >= fraudConfig.thresholds.manualReview) {
    return 'review'
  }
  return 'approve'
}
</file>

<file path="src/integrations/fraud/index.ts">
export * from './types'
export * from './config'
export { truecallerClient } from './truecaller'
export { ipQualityClient } from './ipquality'
export { fraudLabsClient } from './fraudlabs'
export { siftClient } from './sift'
export { maxMindClient } from './maxmind'
export { fraudScoringService } from './scoring'
export { autoBlockingService } from './blocking'

// Main fraud detection API
import { fraudScoringService } from './scoring'
import { autoBlockingService } from './blocking'
import type { FraudCheckRequest, UnifiedFraudScore } from './types'

export async function checkFraud(request: FraudCheckRequest): Promise<UnifiedFraudScore> {
  // Check if any values are already blocked
  const blockChecks = await Promise.all([
    request.phone ? autoBlockingService.checkBlocked('phone', request.phone) : null,
    request.ip ? autoBlockingService.checkBlocked('ip', request.ip) : null,
    request.email ? autoBlockingService.checkBlocked('email', request.email) : null,
  ])

  // If any value is blocked, return immediate rejection
  const blockedRule = blockChecks.find((rule) => rule !== null)
  if (blockedRule) {
    return {
      overallScore: 100,
      decision: 'reject',
      reasons: [`Blocked: ${blockedRule.reason}`],
      timestamp: new Date(),
    }
  }

  // Perform comprehensive fraud check
  const fraudScore = await fraudScoringService.performComprehensiveCheck(request)

  // Process auto-blocking if needed
  await autoBlockingService.processAutoBlocking(fraudScore, request)

  return fraudScore
}

// Utility function for call validation
export async function validateIncomingCall(
  phoneNumber: string,
  ipAddress: string,
  campaignId: string
): Promise<{ allowed: boolean; score: UnifiedFraudScore }> {
  const score = await checkFraud({
    phone: phoneNumber,
    ip: ipAddress,
    campaignId,
    metadata: { type: 'incoming_call' },
  })

  return {
    allowed: score.decision === 'approve',
    score,
  }
}

// Utility function for user registration validation
export async function validateRegistration(
  email: string,
  ipAddress: string,
  phone?: string
): Promise<{ allowed: boolean; score: UnifiedFraudScore }> {
  const score = await checkFraud({
    email,
    ip: ipAddress,
    phone,
    metadata: { type: 'user_registration' },
  })

  return {
    allowed: score.decision !== 'reject',
    score,
  }
}

// Cleanup function to be called periodically
export async function cleanupFraudData(): Promise<void> {
  const cleaned = await autoBlockingService.cleanupExpiredRules()
  console.log(`Cleaned up ${cleaned} expired blocking rules`)
}
</file>

<file path="src/integrations/fraud/scoring.ts">
import { truecallerClient } from './truecaller'
import { ipQualityClient } from './ipquality'
import { fraudLabsClient } from './fraudlabs'
import { siftClient } from './sift'
import { maxMindClient } from './maxmind'
import { getFraudDecision } from './config'
import type {
  FraudCheckRequest,
  UnifiedFraudScore,
  PhoneVerificationResult,
  IPReputationResult,
  TransactionScreeningResult,
  SiftFraudResult,
  MaxMindGeoResult,
} from './types'

export class FraudScoringService {
  async performComprehensiveCheck(request: FraudCheckRequest): Promise<UnifiedFraudScore> {
    const timestamp = new Date()
    const results = await Promise.allSettled([
      request.phone ? truecallerClient.verifyPhone(request.phone) : Promise.resolve(null),
      request.ip ? ipQualityClient.checkIPReputation(request.ip) : Promise.resolve(null),
      fraudLabsClient.screenTransaction(request),
      siftClient.screenTransaction(request),
      request.ip ? maxMindClient.checkIPLocation(request.ip) : Promise.resolve(null),
    ])

    // Extract results
    const phoneResult =
      results[0].status === 'fulfilled'
        ? (results[0].value as PhoneVerificationResult | null)
        : null
    const ipResult =
      results[1].status === 'fulfilled' ? (results[1].value as IPReputationResult | null) : null
    const transactionResult =
      results[2].status === 'fulfilled' ? (results[2].value as TransactionScreeningResult) : null
    const siftResult =
      results[3].status === 'fulfilled' ? (results[3].value as SiftFraudResult) : null
    const maxMindResult =
      results[4].status === 'fulfilled' ? (results[4].value as MaxMindGeoResult | null) : null

    // Calculate individual scores
    const phoneScore = this.calculatePhoneScore(phoneResult)
    const ipScore = ipResult?.fraudScore || 0
    const transactionScore = transactionResult?.fraudScore || 0
    const siftScore = siftResult?.fraudScore || 0
    const maxmindScore = maxMindResult?.fraudScore || 0

    // Calculate weighted overall score
    const overallScore = this.calculateOverallScore({
      phoneScore,
      ipScore,
      transactionScore,
      siftScore,
      maxmindScore,
    })

    // Collect reasons for the score
    const reasons = this.collectReasons({
      phoneResult,
      ipResult,
      transactionResult,
      siftResult,
      maxMindResult,
    })

    // Make final decision
    const decision = getFraudDecision(overallScore)

    return {
      overallScore,
      phoneScore,
      ipScore,
      transactionScore,
      siftScore,
      maxmindScore,
      decision,
      reasons,
      timestamp,
    }
  }

  private calculatePhoneScore(result: PhoneVerificationResult | null): number {
    if (!result) return 0

    let score = 0

    // Invalid phone number
    if (!result.valid) {
      score += 40
    }

    // High spam score
    if ((result.spamScore || 0) > 50) {
      score += 30
    }

    // VOIP numbers are higher risk
    if (result.lineType === 'voip') {
      score += 20
    }

    // Inactive numbers
    if (result.valid && !result.isActive) {
      score += 25
    }

    return Math.min(100, score)
  }

  private calculateOverallScore(scores: {
    phoneScore: number
    ipScore: number
    transactionScore: number
    siftScore: number
    maxmindScore: number
  }): number {
    // Weighted average with Sift and transaction screening having the highest weights
    const weights = {
      phone: 0.15,
      ip: 0.2,
      transaction: 0.25,
      sift: 0.25,
      maxmind: 0.15,
    }

    const weightedScore =
      scores.phoneScore * weights.phone +
      scores.ipScore * weights.ip +
      scores.transactionScore * weights.transaction +
      scores.siftScore * weights.sift +
      scores.maxmindScore * weights.maxmind

    return Math.round(weightedScore)
  }

  private collectReasons(data: {
    phoneResult: PhoneVerificationResult | null
    ipResult: IPReputationResult | null
    transactionResult: TransactionScreeningResult | null
    siftResult: SiftFraudResult | null
    maxMindResult: MaxMindGeoResult | null
  }): string[] {
    const reasons: string[] = []

    // Phone-related reasons
    if (data.phoneResult) {
      if (!data.phoneResult.valid) {
        reasons.push('Invalid phone number')
      }
      if ((data.phoneResult.spamScore || 0) > 50) {
        reasons.push('High spam score on phone number')
      }
      if (data.phoneResult.lineType === 'voip') {
        reasons.push('VOIP phone number detected')
      }
      if (data.phoneResult.valid && !data.phoneResult.isActive) {
        reasons.push('Inactive phone number')
      }
    }

    // IP-related reasons
    if (data.ipResult) {
      if (data.ipResult.proxy) {
        reasons.push('Proxy IP detected')
      }
      if (data.ipResult.vpn) {
        reasons.push('VPN connection detected')
      }
      if (data.ipResult.tor) {
        reasons.push('TOR network detected')
      }
      if (data.ipResult.recentAbuse) {
        reasons.push('Recent abuse from IP address')
      }
      if (data.ipResult.botStatus) {
        reasons.push('Bot activity detected')
      }
    }

    // Transaction-related reasons
    if (data.transactionResult) {
      reasons.push(...data.transactionResult.rules)
    }

    // Sift-related reasons
    if (data.siftResult) {
      reasons.push(...data.siftResult.reasons)
      if (data.siftResult.status === 'reject') {
        reasons.push('Sift AI flagged as high-risk transaction')
      }
    }

    // MaxMind-related reasons
    if (data.maxMindResult) {
      if (data.maxMindResult.isVpn) {
        reasons.push('VPN detected by MaxMind')
      }
      if (data.maxMindResult.isProxy) {
        reasons.push('Proxy detected by MaxMind')
      }
      if (data.maxMindResult.riskLevel === 'high') {
        reasons.push('High-risk location detected')
      }
    }

    return [...new Set(reasons)] // Remove duplicates
  }

  // Quick check methods for specific scenarios
  async quickPhoneCheck(phone: string): Promise<number> {
    const result = await truecallerClient.verifyPhone(phone)
    return this.calculatePhoneScore(result)
  }

  async quickIPCheck(ip: string): Promise<number> {
    const result = await ipQualityClient.checkIPReputation(ip)
    return result.fraudScore
  }

  async checkCallFraud(phone: string, ip: string, campaignId: string): Promise<UnifiedFraudScore> {
    return this.performComprehensiveCheck({
      phone,
      ip,
      campaignId,
      metadata: { checkType: 'incoming_call' },
    })
  }

  async checkRegistrationFraud(
    email: string,
    ip: string,
    phone?: string
  ): Promise<UnifiedFraudScore> {
    return this.performComprehensiveCheck({
      email,
      ip,
      phone,
      metadata: { checkType: 'user_registration' },
    })
  }

  async checkPaymentFraud(
    amount: number,
    currency: string,
    email: string,
    ip: string
  ): Promise<UnifiedFraudScore> {
    return this.performComprehensiveCheck({
      amount,
      currency,
      email,
      ip,
      metadata: { checkType: 'payment_transaction' },
    })
  }
}

// Export singleton instance
export const fraudScoringService = new FraudScoringService()
</file>

<file path="src/integrations/fraud/types.ts">
export interface PhoneVerificationResult {
  valid: boolean
  carrier?: string
  country?: string
  lineType?: 'mobile' | 'landline' | 'voip' | 'unknown'
  name?: string
  spamScore?: number
  isActive?: boolean
  error?: string
}

export interface IPReputationResult {
  fraudScore: number
  countryCode?: string
  region?: string
  city?: string
  isp?: string
  proxy?: boolean
  vpn?: boolean
  tor?: boolean
  recentAbuse?: boolean
  botStatus?: boolean
  error?: string
}

export interface TransactionScreeningResult {
  fraudScore: number
  status: 'approve' | 'review' | 'reject'
  rules: string[]
  riskFactors: {
    ip?: string
    email?: string
    phone?: string
    billing?: string
    shipping?: string
  }
  error?: string
}

export interface SiftFraudResult {
  fraudScore: number
  status: 'approve' | 'review' | 'reject'
  workflowStatus?: string
  reasons: string[]
  paymentAbuseScore?: number
  accountAbuseScore?: number
  error?: string
}

export interface MaxMindGeoResult {
  fraudScore: number
  countryCode?: string
  region?: string
  city?: string
  riskLevel: 'low' | 'medium' | 'high'
  isVpn?: boolean
  isProxy?: boolean
  isp?: string
  accuracyRadius?: number
  error?: string
}

export interface UnifiedFraudScore {
  overallScore: number
  phoneScore?: number
  ipScore?: number
  transactionScore?: number
  siftScore?: number
  maxmindScore?: number
  decision: 'approve' | 'review' | 'reject'
  reasons: string[]
  timestamp: Date
}

export interface FraudCheckRequest {
  phone?: string
  ip?: string
  email?: string
  amount?: number
  currency?: string
  userId?: string
  campaignId?: string
  metadata?: Record<string, unknown>
}

export interface BlockingRule {
  id: string
  type: 'phone' | 'ip' | 'email' | 'pattern'
  value: string
  reason: string
  createdAt: Date
  expiresAt?: Date
  autoBlocked: boolean
}

export interface FraudConfig {
  truecaller: {
    apiKey: string
    baseUrl: string
    timeout: number
  }
  ipquality: {
    apiKey: string
    baseUrl: string
    timeout: number
  }
  fraudlabs: {
    apiKey: string
    baseUrl: string
    timeout: number
  }
  sift: {
    apiKey: string
    baseUrl: string
    timeout: number
  }
  maxmind: {
    apiKey: string
    baseUrl: string
    timeout: number
  }
  thresholds: {
    autoReject: number
    manualReview: number
    autoApprove: number
  }
}
</file>

<file path="src/integrations/stripe/billing.ts">
import { stripeServerClient } from './client'
import type Stripe from 'stripe'

export interface CreateInvoiceParams {
  customerId: string
  description: string
  metadata: {
    buyerId: string
    billingPeriod: string
    callCount: string
  }
  dueDate?: number
  collectionMethod?: 'charge_automatically' | 'send_invoice'
}

export interface CreateInvoiceItemParams {
  customerId: string
  amount: number
  currency: string
  description: string
  metadata: {
    callId?: string
    campaignId?: string
    duration?: string
  }
  invoiceId?: string
}

export const createInvoice = async (params: CreateInvoiceParams): Promise<Stripe.Invoice> => {
  try {
    const invoice = await stripeServerClient.invoices.create({
      customer: params.customerId,
      description: params.description,
      metadata: {
        ...params.metadata,
        platform: 'dependablecalls',
      },
      due_date: params.dueDate,
      collection_method: params.collectionMethod || 'charge_automatically',
      auto_advance: false, // We'll finalize manually
    })

    return invoice
  } catch (error) {
    console.error('Error creating invoice:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    throw new Error(`Failed to create invoice: ${errorMessage}`)
  }
}

export const createInvoiceItem = async (
  params: CreateInvoiceItemParams
): Promise<Stripe.InvoiceItem> => {
  try {
    const invoiceItem = await stripeServerClient.invoiceItems.create({
      customer: params.customerId,
      amount: params.amount,
      currency: params.currency,
      description: params.description,
      metadata: {
        ...params.metadata,
        platform: 'dependablecalls',
      },
      ...(params.invoiceId && { invoice: params.invoiceId }),
    })

    return invoiceItem
  } catch (error) {
    console.error('Error creating invoice item:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    throw new Error(`Failed to create invoice item: ${errorMessage}`)
  }
}

export const finalizeInvoice = async (
  invoiceId: string,
  autoAdvance: boolean = true
): Promise<Stripe.Invoice> => {
  try {
    const invoice = await stripeServerClient.invoices.finalizeInvoice(invoiceId, {
      auto_advance: autoAdvance,
    })

    return invoice
  } catch (error) {
    console.error('Error finalizing invoice:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    throw new Error(`Failed to finalize invoice: ${errorMessage}`)
  }
}

export const sendInvoice = async (invoiceId: string): Promise<Stripe.Invoice> => {
  try {
    const invoice = await stripeServerClient.invoices.sendInvoice(invoiceId)
    return invoice
  } catch (error) {
    console.error('Error sending invoice:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    throw new Error(`Failed to send invoice: ${errorMessage}`)
  }
}

export const payInvoice = async (
  invoiceId: string,
  paymentMethodId?: string
): Promise<Stripe.Invoice> => {
  try {
    const invoice = await stripeServerClient.invoices.pay(invoiceId, {
      ...(paymentMethodId && { payment_method: paymentMethodId }),
    })

    return invoice
  } catch (error) {
    console.error('Error paying invoice:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    throw new Error(`Failed to pay invoice: ${errorMessage}`)
  }
}

export const voidInvoice = async (invoiceId: string): Promise<Stripe.Invoice> => {
  try {
    const invoice = await stripeServerClient.invoices.voidInvoice(invoiceId)
    return invoice
  } catch (error) {
    console.error('Error voiding invoice:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    throw new Error(`Failed to void invoice: ${errorMessage}`)
  }
}

export const updateInvoice = async (
  invoiceId: string,
  updates: Stripe.InvoiceUpdateParams
): Promise<Stripe.Invoice> => {
  try {
    const invoice = await stripeServerClient.invoices.update(invoiceId, updates)

    return invoice
  } catch (error) {
    console.error('Error updating invoice:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    throw new Error(`Failed to update invoice: ${errorMessage}`)
  }
}

export const getInvoice = async (invoiceId: string): Promise<Stripe.Invoice | null> => {
  try {
    const invoice = await stripeServerClient.invoices.retrieve(invoiceId)
    return invoice
  } catch (error) {
    if (
      error &&
      typeof error === 'object' &&
      'code' in error &&
      error.code === 'resource_missing'
    ) {
      return null
    }
    console.error('Error retrieving invoice:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    throw new Error(`Failed to retrieve invoice: ${errorMessage}`)
  }
}

export const listCustomerInvoices = async (
  customerId: string,
  status?: 'draft' | 'open' | 'paid' | 'uncollectible' | 'void',
  limit: number = 100
): Promise<Stripe.Invoice[]> => {
  try {
    const invoices = await stripeServerClient.invoices.list({
      customer: customerId,
      status,
      limit,
    })

    return invoices.data
  } catch (error) {
    console.error('Error listing invoices:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    throw new Error(`Failed to list invoices: ${errorMessage}`)
  }
}

export const createCreditNote = async (
  invoiceId: string,
  amount: number,
  reason: 'duplicate' | 'fraudulent' | 'order_change' | 'product_unsatisfactory',
  memo?: string
): Promise<Stripe.CreditNote> => {
  try {
    const creditNote = await stripeServerClient.creditNotes.create({
      invoice: invoiceId,
      amount,
      reason,
      memo,
      metadata: {
        platform: 'dependablecalls',
      },
    })

    return creditNote
  } catch (error) {
    console.error('Error creating credit note:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    throw new Error(`Failed to create credit note: ${errorMessage}`)
  }
}

export const createUsageBasedInvoice = async (
  customerId: string,
  billingPeriod: { start: Date; end: Date },
  usageRecords: Array<{
    amount: number
    description: string
    metadata: Record<string, string>
  }>
): Promise<Stripe.Invoice> => {
  try {
    // Create invoice for the billing period
    const invoice = await createInvoice({
      customerId,
      description: `Usage charges for ${billingPeriod.start.toISOString().split('T')[0]} to ${billingPeriod.end.toISOString().split('T')[0]}`,
      metadata: {
        buyerId: customerId,
        billingPeriod: `${billingPeriod.start.toISOString()}_${billingPeriod.end.toISOString()}`,
        callCount: usageRecords.length.toString(),
      },
    })

    // Add line items for each usage record
    for (const record of usageRecords) {
      await createInvoiceItem({
        customerId,
        amount: record.amount,
        currency: 'usd',
        description: record.description,
        metadata: record.metadata,
        invoiceId: invoice.id,
      })
    }

    // Finalize and send the invoice
    if (!invoice.id) {
      throw new Error('Invoice creation failed - no invoice ID returned')
    }
    const finalizedInvoice = await finalizeInvoice(invoice.id)

    return finalizedInvoice
  } catch (error) {
    console.error('Error creating usage-based invoice:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    throw new Error(`Failed to create usage-based invoice: ${errorMessage}`)
  }
}
</file>

<file path="src/integrations/stripe/connected-accounts.ts">
import { stripeServerClient } from './client';
import type { CreateConnectedAccountParams, ConnectedAccountStatus, PayoutSchedule } from './types';
import type Stripe from 'stripe';
import { v4 as uuid } from 'uuid';

/**
 * Centralized error handler for Stripe operations
 * Prevents leaking sensitive information and provides type-safe error handling
 */
function handleStripeError(err: unknown, context: string): never {
  if (err instanceof stripeServerClient.errors.StripeError) {
    console.error(`${context} failed`, { 
      type: err.type, 
      code: err.code, 
      param: err.param,
      requestId: err.requestId 
    });
    
    // Return generic error messages to prevent information leakage
    if (err.code === 'resource_missing') {
      throw new Error(`Resource not found. Please check your request and try again.`);
    }
    
    throw new Error(`Stripe ${context} failed. Please retry or contact support.`);
  }
  
  console.error(`${context} unexpected error`, err);
  throw new Error('Internal server error. Please try again later.');
}

export const createConnectedAccount = async (
  params: CreateConnectedAccountParams
): Promise<Stripe.Account> => {
  try {
    const account = await stripeServerClient.accounts.create({
      type: 'express',
      email: params.email,
      country: params.country ?? 'US',
      business_type: params.businessType ?? 'individual',
      capabilities: {
        card_payments: { requested: true },
        transfers: { requested: true },
      },
      settings: {
        payouts: {
          schedule: {
            delay_days: 7,
            interval: 'weekly',
            weekly_anchor: 'friday',
          },
        },
      },
      metadata: {
        ...params.metadata,
        platform: 'dependablecalls',
      },
    }, {
      idempotencyKey: uuid() // Prevent duplicate account creation
    });
    
    return account;
  } catch (error: unknown) {
    handleStripeError(error, 'create connected account');
  }
};

export const createAccountLink = async (
  accountId: string,
  refreshUrl: string,
  returnUrl: string,
  type: 'account_onboarding' | 'account_update' = 'account_onboarding'
): Promise<Stripe.AccountLink> => {
  try {
    const accountLink = await stripeServerClient.accountLinks.create({
      account: accountId,
      refresh_url: refreshUrl,
      return_url: returnUrl,
      type,
    }, {
      idempotencyKey: uuid() // Prevent duplicate link creation
    });
    
    return accountLink;
  } catch (error: unknown) {
    handleStripeError(error, 'create account link');
  }
};

export const getConnectedAccount = async (
  accountId: string
): Promise<Stripe.Account | null> => {
  try {
    const account = await stripeServerClient.accounts.retrieve(accountId);
    return account;
  } catch (error: unknown) {
    if (error instanceof stripeServerClient.errors.StripeError && 
        error.code === 'resource_missing') {
      return null;
    }
    handleStripeError(error, 'retrieve connected account');
  }
};

export const updateConnectedAccount = async (
  accountId: string,
  updates: Stripe.AccountUpdateParams
): Promise<Stripe.Account> => {
  try {
    const account = await stripeServerClient.accounts.update(
      accountId,
      updates
    );
    
    return account;
  } catch (error: unknown) {
    handleStripeError(error, 'update connected account');
  }
};

export const deleteConnectedAccount = async (
  accountId: string
): Promise<boolean> => {
  try {
    const result = await stripeServerClient.accounts.del(accountId);
    return result.deleted;
  } catch (error: unknown) {
    handleStripeError(error, 'delete connected account');
  }
};

export const getAccountStatus = async (
  accountId: string
): Promise<ConnectedAccountStatus> => {
  try {
    const account = await stripeServerClient.accounts.retrieve(accountId);
    
    return {
      id: account.id,
      chargesEnabled: account.charges_enabled ?? false,
      payoutsEnabled: account.payouts_enabled ?? false,
      detailsSubmitted: account.details_submitted ?? false,
      requirementsCurrentlyDue: account.requirements?.currently_due ?? [],
    };
  } catch (error: unknown) {
    handleStripeError(error, 'get account status');
  }
};

export const updatePayoutSchedule = async (
  accountId: string,
  schedule: PayoutSchedule
): Promise<Stripe.Account> => {
  try {
    const account = await stripeServerClient.accounts.update(accountId, {
      settings: {
        payouts: {
          schedule: {
            delay_days: schedule.delayDays,
            interval: schedule.interval,
            ...(schedule.weeklyAnchor && { weekly_anchor: schedule.weeklyAnchor }),
          },
        },
      },
    });
    
    return account;
  } catch (error: unknown) {
    handleStripeError(error, 'update payout schedule');
  }
};

export const createLoginLink = async (
  accountId: string
): Promise<Stripe.LoginLink> => {
  try {
    const loginLink = await stripeServerClient.accounts.createLoginLink(
      accountId
    );
    
    return loginLink;
  } catch (error: unknown) {
    handleStripeError(error, 'create login link');
  }
};

/**
 * List all transfers for an account with automatic pagination
 * This ensures we get ALL transfers, not just the first page
 */
export const listAccountTransfers = async (
  accountId: string,
  limit = 1000 // Increased from 100 for better performance
): Promise<Stripe.Transfer[]> => {
  try {
    const transfers: Stripe.Transfer[] = [];
    
    // Use auto-pagination to ensure we get all transfers
    for await (const transfer of stripeServerClient.transfers.list({
      destination: accountId,
      limit, // Page size
    })) {
      transfers.push(transfer);
    }
    
    return transfers;
  } catch (error: unknown) {
    handleStripeError(error, 'list account transfers');
  }
};

export const getAccountBalance = async (
  accountId: string
): Promise<Stripe.Balance> => {
  try {
    const balance = await stripeServerClient.balance.retrieve({
      stripeAccount: accountId,
    });
    
    return balance;
  } catch (error: unknown) {
    handleStripeError(error, 'retrieve account balance');
  }
};

/**
 * Create a transfer to a connected account with idempotency
 * Useful for payouts and platform fees
 */
export const createTransfer = async (
  accountId: string,
  amount: number,
  currency = 'usd',
  description?: string,
  metadata?: Record<string, string>
): Promise<Stripe.Transfer> => {
  try {
    const transfer = await stripeServerClient.transfers.create({
      amount: Math.round(amount * 100), // Convert to cents
      currency,
      destination: accountId,
      description,
      metadata: {
        ...metadata,
        platform: 'dependablecalls',
      },
    }, {
      idempotencyKey: uuid() // Prevent duplicate transfers
    });
    
    return transfer;
  } catch (error: unknown) {
    handleStripeError(error, 'create transfer');
  }
};

/**
 * Create a payout for a connected account with idempotency
 */
export const createPayout = async (
  accountId: string,
  amount: number,
  currency = 'usd',
  description?: string,
  metadata?: Record<string, string>
): Promise<Stripe.Payout> => {
  try {
    const payout = await stripeServerClient.payouts.create({
      amount: Math.round(amount * 100), // Convert to cents
      currency,
      description,
      metadata: {
        ...metadata,
        platform: 'dependablecalls',
      },
    }, {
      stripeAccount: accountId,
      idempotencyKey: uuid() // Prevent duplicate payouts
    });
    
    return payout;
  } catch (error: unknown) {
    handleStripeError(error, 'create payout');
  }
};
</file>

<file path="src/integrations/stripe/index.ts">
export * from './client'
export * from './types'
export * from './customers'
export * from './connected-accounts'
export * from './payments'
export * from './subscriptions'
export * from './billing'
export {
  toCents,
  toDollars,
  isValidCents,
  createCents,
  createTransfer as createPayoutTransfer,
  reverseTransfer,
  getTransfer,
  updateTransfer,
  getPayout,
  listAccountPayouts,
  createBulkPayout,
  calculatePayoutSummary,
  scheduleWeeklyPayouts,
} from './payouts'
export * from './webhooks'

// Re-export commonly used functions
export { stripeServerClient, getStripeClient, isStripeConfigured } from './client'

export { createStripeCustomer } from './customers'

export { createConnectedAccount, createTransfer } from './connected-accounts'

export { createPaymentIntent } from './payments'

export { createSubscription } from './subscriptions'

export { createInvoice } from './billing'

export { handleStripeWebhook } from './webhooks'

// Helper to check if all required Stripe environment variables are set
export const validateStripeEnvironment = (): { isValid: boolean; missing: string[] } => {
  const required = [
    'VITE_STRIPE_SECRET_KEY',
    'VITE_STRIPE_PUBLISHABLE_KEY',
    'VITE_STRIPE_WEBHOOK_SECRET',
  ]

  const missing = required.filter((key) => !import.meta.env[key])

  return {
    isValid: missing.length === 0,
    missing,
  }
}
</file>

<file path="src/integrations/stripe/payouts.ts">
import { stripeServerClient } from './client'
import type { CreateTransferParams } from './types'
import type Stripe from 'stripe'
import { v4 as uuid } from 'uuid'
import { z } from 'zod'

/**
 * Strongly typed cents to prevent decimal amount errors
 * Stripe requires amounts as positive integers in smallest currency unit
 */
export type Cents = number & { __brand: 'cents' }

/**
 * Convert dollars to cents with proper rounding
 */
export function toCents(dollars: number): Cents {
  return Math.round(dollars * 100) as Cents
}

/**
 * Convert cents to dollars
 */
export function toDollars(cents: Cents): number {
  return cents / 100
}

/**
 * Validate amount is valid cents (positive integer)
 */
export function isValidCents(amount: number): amount is Cents {
  return Number.isInteger(amount) && amount > 0
}

/**
 * Create Cents from a validated number
 */
export function createCents(amount: number): Cents {
  if (!isValidCents(amount)) {
    throw new Error('Amount must be a positive integer in cents')
  }
  return amount as Cents
}

/**
 * Validate statement descriptor according to Stripe requirements
 */
const statementDescriptorSchema = z
  .string()
  .max(22, 'Statement descriptor must be 22 chars or less')
  .transform((val) => val.replace(/[<>]/g, ''))

/**
 * Restricted update params for transfers (Stripe only allows metadata and description)
 */
export interface TransferUpdateParams {
  metadata?: Stripe.Metadata
  description?: string
}

/**
 * Centralized error handler for Stripe operations
 * Prevents leaking sensitive information and provides type-safe error handling
 */
function handleStripeError(err: unknown, context: string): never {
  if (err instanceof stripeServerClient.errors.StripeError) {
    console.error(`${context} failed`, {
      type: err.type,
      code: err.code,
      param: err.param,
      requestId: err.requestId,
    })

    // Handle idempotent request duplicates as success
    if (err.code === 'idempotency_key_in_use' || err.statusCode === 409) {
      // This is actually a success - the operation was already completed
      // The caller should handle this appropriately
      const duplicateError = new Error('Operation already completed') as Error & {
        isDuplicate: boolean
        originalRequest?: unknown
      }
      duplicateError.isDuplicate = true
      duplicateError.originalRequest = err.raw
      throw duplicateError
    }

    // Return generic error messages to prevent information leakage
    if (err.code === 'resource_missing') {
      throw new Error(`Resource not found. Please check your request and try again.`)
    }

    if (err.code === 'insufficient_funds') {
      throw new Error('Insufficient funds for payout. Please try again later.')
    }

    if (err.code === 'invalid_request_error' && err.param === 'amount') {
      throw new Error('Invalid amount. Amount must be a positive integer in cents.')
    }

    throw new Error(`Payout service error. Please retry or contact support.`)
  }

  console.error(`${context} unexpected error`, err)
  throw new Error('Internal server error. Please try again later.')
}

export interface CreatePayoutParams {
  accountId: string
  amount: Cents // Enforced as integer cents
  currency: string
  metadata: {
    supplierId: string
    payoutPeriod: string
    callCount: string
  }
  statementDescriptor?: string
}

export interface PayoutSummary {
  totalAmount: Cents // Enforced as integer cents
  currency: string
  transferCount: number
  period: {
    start: Date
    end: Date
  }
}

export const createTransfer = async (params: CreateTransferParams): Promise<Stripe.Transfer> => {
  try {
    // Validate amount is positive integer
    if (!Number.isInteger(params.amount) || params.amount <= 0) {
      throw new Error('Amount must be a positive integer in cents')
    }

    const transfer = await stripeServerClient.transfers.create(
      {
        amount: params.amount,
        currency: params.currency,
        destination: params.destination,
        transfer_group: `payout_${params.metadata.payoutId}`,
        metadata: {
          ...params.metadata,
          platform: 'dependablecalls',
        },
      },
      {
        idempotencyKey: uuid(), // Prevent duplicate transfers
      }
    )

    return transfer
  } catch (error: unknown) {
    // Check if this is a duplicate operation (409 response)
    if (error instanceof Error && 'isDuplicate' in error && error.isDuplicate) {
      console.log('Transfer already created, returning success')
      // In production, you'd retrieve and return the original transfer
      // For now, we re-throw to let caller handle
      throw error
    }
    handleStripeError(error, 'create transfer')
  }
}

export const reverseTransfer = async (
  transferId: string,
  amount?: Cents,
  reason?: string
): Promise<Stripe.TransferReversal> => {
  try {
    // Validate amount if provided
    if (amount !== undefined && (!Number.isInteger(amount) || amount <= 0)) {
      throw new Error('Amount must be a positive integer in cents')
    }

    const reversal = await stripeServerClient.transfers.createReversal(
      transferId,
      {
        amount,
        description: reason,
        metadata: {
          platform: 'dependablecalls',
          reason: reason || 'fraud_detected',
        },
      },
      {
        idempotencyKey: uuid(), // Prevent duplicate reversals
      }
    )

    return reversal
  } catch (error: unknown) {
    handleStripeError(error, 'reverse transfer')
  }
}

export const getTransfer = async (transferId: string): Promise<Stripe.Transfer | null> => {
  try {
    const transfer = await stripeServerClient.transfers.retrieve(transferId)
    return transfer
  } catch (error: unknown) {
    if (
      error instanceof stripeServerClient.errors.StripeError &&
      error.code === 'resource_missing'
    ) {
      return null
    }
    handleStripeError(error, 'retrieve transfer')
  }
}

export const updateTransfer = async (
  transferId: string,
  updates: TransferUpdateParams // Restricted to only metadata and description
): Promise<Stripe.Transfer> => {
  try {
    // Stripe only allows updating metadata and description on transfers
    const allowedUpdates: Stripe.TransferUpdateParams = {}
    if (updates.metadata !== undefined) {
      allowedUpdates.metadata = updates.metadata
    }
    if (updates.description !== undefined) {
      allowedUpdates.description = updates.description
    }

    const transfer = await stripeServerClient.transfers.update(transferId, allowedUpdates, {
      idempotencyKey: uuid(), // Prevent duplicate updates
    })

    return transfer
  } catch (error: unknown) {
    handleStripeError(error, 'update transfer')
  }
}

export const createPayout = async (params: CreatePayoutParams): Promise<Stripe.Payout> => {
  try {
    // Validate amount is positive integer
    if (!Number.isInteger(params.amount) || params.amount <= 0) {
      throw new Error('Amount must be a positive integer in cents')
    }

    // Validate and sanitize statement descriptor
    const statementDescriptor = params.statementDescriptor
      ? statementDescriptorSchema.parse(params.statementDescriptor)
      : 'DCE Payout'

    // First check if account can receive payouts
    const account = await stripeServerClient.accounts.retrieve(params.accountId)
    if (account.type === 'standard') {
      throw new Error('Cannot create payouts for Standard accounts. Use transfers instead.')
    }
    if (!account.payouts_enabled) {
      throw new Error('Account is not enabled for payouts. Please complete account verification.')
    }

    const payout = await stripeServerClient.payouts.create(
      {
        amount: params.amount,
        currency: params.currency,
        statement_descriptor: statementDescriptor,
        metadata: {
          ...params.metadata,
          platform: 'dependablecalls',
        },
      },
      {
        stripeAccount: params.accountId,
        idempotencyKey: uuid(), // Prevent duplicate payouts
      }
    )

    return payout
  } catch (error: unknown) {
    handleStripeError(error, 'create payout')
  }
}

export const cancelPayout = async (payoutId: string, accountId: string): Promise<Stripe.Payout> => {
  try {
    const payout = await stripeServerClient.payouts.cancel(
      payoutId,
      {},
      { stripeAccount: accountId }
    )

    return payout
  } catch (error) {
    console.error('Error canceling payout:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    throw new Error(`Failed to cancel payout: ${errorMessage}`)
  }
}

export const getPayout = async (
  payoutId: string,
  accountId: string
): Promise<Stripe.Payout | null> => {
  try {
    const payout = await stripeServerClient.payouts.retrieve(
      payoutId,
      {},
      { stripeAccount: accountId }
    )

    return payout
  } catch (error: unknown) {
    if (
      error instanceof stripeServerClient.errors.StripeError &&
      error.code === 'resource_missing'
    ) {
      return null
    }
    handleStripeError(error, 'retrieve payout')
  }
}

export const listAccountPayouts = async (
  accountId: string,
  status?: 'pending' | 'paid' | 'failed' | 'canceled',
  limit: number = 100
): Promise<Stripe.Payout[]> => {
  try {
    const payouts: Stripe.Payout[] = []

    // Use auto-pagination to ensure we get all payouts
    for await (const payout of stripeServerClient.payouts.list(
      {
        status,
        limit,
      },
      {
        stripeAccount: accountId,
      }
    )) {
      payouts.push(payout)
    }

    return payouts
  } catch (error: unknown) {
    handleStripeError(error, 'list payouts')
  }
}

export const createBulkPayout = async (
  payouts: Array<{
    accountId: string
    amount: Cents
    metadata: Record<string, string>
  }>,
  transferGroup: string,
  maxConcurrency: number = 5 // Limit concurrent requests
): Promise<Array<{ success: boolean; transfer?: Stripe.Transfer; error?: Error }>> => {
  try {
    // Create batches for concurrent processing
    const results: Array<{ success: boolean; transfer?: Stripe.Transfer; error?: Error }> = []

    // Process in batches to avoid rate limits
    for (let i = 0; i < payouts.length; i += maxConcurrency) {
      const batch = payouts.slice(i, i + maxConcurrency)

      const batchPromises = batch.map(async (payout) => {
        try {
          const transfer = await createTransfer({
            amount: payout.amount,
            currency: 'usd',
            destination: payout.accountId,
            metadata: {
              ...payout.metadata,
              transferGroup,
              payoutId: `${transferGroup}_${payout.accountId}_${Date.now()}`,
              supplierId: payout.metadata.supplierId || 'bulk',
              callCount: payout.metadata.callCount || '0',
              period: payout.metadata.period || transferGroup,
            },
          } as CreateTransferParams)

          return { success: true, transfer }
        } catch (error: unknown) {
          // Don't fail entire batch for individual errors
          const errorObj = error instanceof Error ? error : new Error(String(error))
          return { success: false, error: errorObj }
        }
      })

      const batchResults = await Promise.allSettled(batchPromises)

      batchResults.forEach((result) => {
        if (result.status === 'fulfilled') {
          results.push(result.value)
        } else {
          results.push({ success: false, error: result.reason })
        }
      })
    }

    return results
  } catch (error: unknown) {
    handleStripeError(error, 'create bulk payout')
  }
}

export const calculatePayoutSummary = async (
  accountId: string,
  period: { start: Date; end: Date }
): Promise<PayoutSummary> => {
  try {
    let totalAmount = 0
    let transferCount = 0

    // Use auto-pagination to ensure we get ALL transfers
    for await (const transfer of stripeServerClient.transfers.list({
      destination: accountId,
      created: {
        gte: Math.floor(period.start.getTime() / 1000),
        lt: Math.floor(period.end.getTime() / 1000),
      },
      limit: 100, // Page size
    })) {
      totalAmount += transfer.amount
      transferCount++
    }

    return {
      totalAmount: totalAmount as Cents,
      currency: 'usd',
      transferCount,
      period,
    }
  } catch (error: unknown) {
    handleStripeError(error, 'calculate payout summary')
  }
}

export const scheduleWeeklyPayouts = async (
  suppliers: Array<{
    accountId: string
    supplierId: string
    amount: Cents
    callCount: number
  }>,
  maxConcurrency: number = 5
): Promise<
  Array<{ supplierId: string; success: boolean; transfer?: Stripe.Transfer; error?: Error }>
> => {
  try {
    const now = new Date()
    const weekStart = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)
    const payoutPeriod = weekStart.toISOString().split('T')[0]
    const payoutGroup = `weekly_${payoutPeriod}`

    // Generate deterministic payout IDs to prevent duplicates
    const generatePayoutId = (supplierId: string) => {
      // Use supplier ID and period for idempotency
      return `payout_${supplierId}_${payoutPeriod}`
    }

    const results: Array<{
      supplierId: string
      success: boolean
      transfer?: Stripe.Transfer
      error?: Error
    }> = []

    // Filter eligible suppliers
    const eligibleSuppliers = suppliers.filter((s) => s.amount >= 10000) // $100 minimum

    // Process in batches for better performance
    for (let i = 0; i < eligibleSuppliers.length; i += maxConcurrency) {
      const batch = eligibleSuppliers.slice(i, i + maxConcurrency)

      const batchPromises = batch.map(async (supplier) => {
        try {
          const transfer = await createTransfer({
            amount: supplier.amount,
            currency: 'usd',
            destination: supplier.accountId,
            metadata: {
              payoutId: generatePayoutId(supplier.supplierId),
              supplierId: supplier.supplierId,
              callCount: supplier.callCount.toString(),
              period: payoutGroup,
            },
          } as CreateTransferParams)

          return { supplierId: supplier.supplierId, success: true, transfer }
        } catch (error: unknown) {
          // Check if it's a duplicate (already processed)
          if (
            error instanceof Error &&
            'isDuplicate' in error &&
            (error as Error & { isDuplicate: boolean }).isDuplicate
          ) {
            console.log(`Payout already processed for supplier ${supplier.supplierId}`)
            return { supplierId: supplier.supplierId, success: true, transfer: undefined }
          }

          console.error(`Failed to create payout for supplier ${supplier.supplierId}:`, error)
          return { supplierId: supplier.supplierId, success: false, error: error as Error }
        }
      })

      const batchResults = await Promise.allSettled(batchPromises)

      batchResults.forEach((result) => {
        if (result.status === 'fulfilled') {
          results.push(result.value)
        } else {
          results.push({
            supplierId: 'unknown',
            success: false,
            error: result.reason,
          })
        }
      })
    }

    // Log summary
    const successful = results.filter((r) => r.success).length
    const failed = results.filter((r) => !r.success).length
    console.log(`Weekly payouts completed: ${successful} successful, ${failed} failed`)

    return results
  } catch (error: unknown) {
    handleStripeError(error, 'schedule weekly payouts')
  }
}

/**
 * Get payout history for an account
 */
export const getPayoutHistory = async (
  accountId: string,
  limit: number = 20,
  starting_after?: string
): Promise<{
  payouts: Stripe.Payout[]
  has_more: boolean
}> => {
  try {
    const response = await stripeServerClient.payouts.list(
      {
        limit,
        starting_after,
      },
      {
        stripeAccount: accountId,
      }
    )

    return {
      payouts: response.data,
      has_more: response.has_more,
    }
  } catch (error: unknown) {
    handleStripeError(error, 'get payout history')
  }
}

/**
 * Get account balance
 */
export const getPayoutBalance = async (accountId: string): Promise<{
  available: Stripe.Balance.Available[]
  pending: Stripe.Balance.Pending[]
}> => {
  try {
    const balance = await stripeServerClient.balance.retrieve({
      stripeAccount: accountId,
    })

    return {
      available: balance.available,
      pending: balance.pending,
    }
  } catch (error: unknown) {
    handleStripeError(error, 'get payout balance')
  }
}
</file>

<file path="src/integrations/stripe/subscriptions.ts">
import { stripeServerClient } from './client'
import type Stripe from 'stripe'

export interface CreateSubscriptionParams {
  customerId: string
  priceId: string
  metadata: {
    buyerId: string
    planType: 'starter' | 'professional' | 'enterprise'
  }
  trialDays?: number
  defaultPaymentMethod?: string
}

export interface UsageRecord {
  subscriptionItemId: string
  quantity: number
  timestamp?: number
  action?: 'set' | 'increment'
}

export const createSubscription = async (
  params: CreateSubscriptionParams
): Promise<Stripe.Subscription> => {
  try {
    const subscription = await stripeServerClient.subscriptions.create({
      customer: params.customerId,
      items: [{ price: params.priceId }],
      payment_behavior: 'default_incomplete',
      payment_settings: { save_default_payment_method: 'on_subscription' },
      expand: ['latest_invoice.payment_intent'],
      metadata: {
        ...params.metadata,
        platform: 'dependablecalls',
      },
      ...(params.trialDays && { trial_period_days: params.trialDays }),
      ...(params.defaultPaymentMethod && {
        default_payment_method: params.defaultPaymentMethod,
      }),
    })

    return subscription
  } catch (error) {
    console.error('Error creating subscription:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    throw new Error(`Failed to create subscription: ${errorMessage}`)
  }
}

export const updateSubscription = async (
  subscriptionId: string,
  updates: Stripe.SubscriptionUpdateParams
): Promise<Stripe.Subscription> => {
  try {
    const subscription = await stripeServerClient.subscriptions.update(subscriptionId, updates)

    return subscription
  } catch (error) {
    console.error('Error updating subscription:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    throw new Error(`Failed to update subscription: ${errorMessage}`)
  }
}

export const cancelSubscription = async (
  subscriptionId: string,
  immediately: boolean = false
): Promise<Stripe.Subscription> => {
  try {
    if (immediately) {
      return await stripeServerClient.subscriptions.cancel(subscriptionId)
    } else {
      return await stripeServerClient.subscriptions.update(subscriptionId, {
        cancel_at_period_end: true,
      })
    }
  } catch (error) {
    console.error('Error canceling subscription:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    throw new Error(`Failed to cancel subscription: ${errorMessage}`)
  }
}

export const reactivateSubscription = async (
  subscriptionId: string
): Promise<Stripe.Subscription> => {
  try {
    const subscription = await stripeServerClient.subscriptions.update(subscriptionId, {
      cancel_at_period_end: false,
    })

    return subscription
  } catch (error) {
    console.error('Error reactivating subscription:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    throw new Error(`Failed to reactivate subscription: ${errorMessage}`)
  }
}

export const getSubscription = async (
  subscriptionId: string
): Promise<Stripe.Subscription | null> => {
  try {
    const subscription = await stripeServerClient.subscriptions.retrieve(subscriptionId)

    return subscription
  } catch (error) {
    if (
      error &&
      typeof error === 'object' &&
      'code' in error &&
      error.code === 'resource_missing'
    ) {
      return null
    }
    console.error('Error retrieving subscription:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    throw new Error(`Failed to retrieve subscription: ${errorMessage}`)
  }
}

export const listCustomerSubscriptions = async (
  customerId: string,
  status?: 'active' | 'canceled' | 'past_due' | 'trialing'
): Promise<Stripe.Subscription[]> => {
  try {
    const subscriptions = await stripeServerClient.subscriptions.list({
      customer: customerId,
      status,
    })

    return subscriptions.data
  } catch (error) {
    console.error('Error listing subscriptions:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    throw new Error(`Failed to list subscriptions: ${errorMessage}`)
  }
}

export const createUsageRecord = async (record: UsageRecord): Promise<unknown> => {
  try {
    // Note: Usage records are created through billing, not directly
    // This is a placeholder implementation
    console.warn('Usage records should be created through billing system')
    return { success: true, record }
  } catch (error) {
    console.error('Error creating usage record:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    throw new Error(`Failed to create usage record: ${errorMessage}`)
  }
}

export const listUsageRecords = async (): Promise<unknown[]> => {
  try {
    // Note: Usage records are retrieved through billing, not directly
    // This is a placeholder implementation
    console.warn('Usage records should be retrieved through billing system')
    return []
  } catch (error) {
    console.error('Error listing usage records:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    throw new Error(`Failed to list usage records: ${errorMessage}`)
  }
}

export const updateSubscriptionItem = async (
  subscriptionId: string,
  itemId: string,
  newPriceId: string
): Promise<Stripe.Subscription> => {
  try {
    const subscription = await stripeServerClient.subscriptions.update(subscriptionId, {
      items: [
        {
          id: itemId,
          price: newPriceId,
        },
      ],
      proration_behavior: 'create_prorations',
    })

    return subscription
  } catch (error) {
    console.error('Error updating subscription item:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    throw new Error(`Failed to update subscription item: ${errorMessage}`)
  }
}

export const createSubscriptionSchedule = async (
  customerId: string,
  phases: Stripe.SubscriptionScheduleCreateParams.Phase[]
): Promise<Stripe.SubscriptionSchedule> => {
  try {
    const schedule = await stripeServerClient.subscriptionSchedules.create({
      customer: customerId,
      start_date: 'now',
      phases,
    })

    return schedule
  } catch (error) {
    console.error('Error creating subscription schedule:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    throw new Error(`Failed to create subscription schedule: ${errorMessage}`)
  }
}
</file>

<file path="src/integrations/stripe/types.ts">
import type Stripe from 'stripe';

export interface StripeCustomerData {
  id: string;
  email: string;
  name?: string;
  phone?: string;
  metadata: {
    userId: string;
    userType: 'buyer' | 'supplier';
    companyName?: string;
  };
}

export interface CreateConnectedAccountParams {
  email: string;
  country?: string;
  businessType?: 'individual' | 'company';
  metadata: {
    supplierId: string;
    companyName?: string;
  };
}

export interface CreatePaymentIntentParams {
  amount: number;
  currency: string;
  customerId: string;
  metadata: {
    invoiceId: string;
    buyerId: string;
    billingPeriod: string;
  };
  paymentMethodTypes?: string[];
}

import type { Cents } from './payouts';

export interface CreateTransferParams {
  amount: Cents;
  currency: string;
  destination: string;
  metadata: {
    payoutId: string;
    supplierId: string;
    callCount: string;
    period: string;
  };
}

export interface StripeWebhookEvent {
  id: string;
  type: string;
  data: {
    object: Stripe.Event.Data.Object;
  };
  created: number;
}

export interface PaymentStatus {
  id: string;
  status: 'pending' | 'processing' | 'succeeded' | 'failed';
  amount: number;
  currency: string;
  error?: string;
}

export interface ConnectedAccountStatus {
  id: string;
  chargesEnabled: boolean;
  payoutsEnabled: boolean;
  detailsSubmitted: boolean;
  requirementsCurrentlyDue: string[];
}

export interface PayoutSchedule {
  delayDays: number;
  interval: 'daily' | 'weekly' | 'monthly' | 'manual';
  weeklyAnchor?: 'monday' | 'tuesday' | 'wednesday' | 'thursday' | 'friday';
}

export type StripeEventType =
  | 'payment_intent.succeeded'
  | 'payment_intent.payment_failed'
  | 'charge.dispute.created'
  | 'account.updated'
  | 'account.application.authorized'
  | 'account.application.deauthorized'
  | 'payout.created'
  | 'payout.paid'
  | 'payout.failed'
  | 'transfer.created'
  | 'transfer.reversed';

export interface WebhookHandlerMap {
  [key: string]: (event: Stripe.Event) => Promise<void>;
}
</file>

<file path="src/lib/health-check.ts">
import { logger } from './logger'

export interface HealthCheckResult extends Record<string, unknown> {
  status: 'healthy' | 'degraded' | 'unhealthy'
  timestamp: string
  checks: {
    [key: string]: {
      status: 'pass' | 'fail'
      message?: string
      duration?: number
      metadata?: Record<string, unknown>
    }
  }
  overall: {
    healthy: number
    failed: number
    duration: number
  }
}

export interface HealthCheckConfig {
  supabase: {
    url: string
    anonKey: string
  }
  stripe: {
    enabled: boolean
  }
  sentry: {
    enabled: boolean
  }
}

class HealthChecker {
  private config: HealthCheckConfig
  private lastCheck?: HealthCheckResult
  private checkInterval?: NodeJS.Timeout
  private isChecking = false

  constructor(config: HealthCheckConfig) {
    this.config = config
  }

  async checkSupabase(): Promise<{ status: 'pass' | 'fail'; message?: string; duration: number }> {
    const start = performance.now()

    try {
      const response = await fetch(`${this.config.supabase.url}/rest/v1/`, {
        method: 'GET',
        headers: {
          apikey: this.config.supabase.anonKey,
          Authorization: `Bearer ${this.config.supabase.anonKey}`,
        },
      })

      const duration = performance.now() - start

      if (response.ok) {
        return { status: 'pass', duration }
      } else {
        return {
          status: 'fail',
          message: `HTTP ${response.status}`,
          duration,
        }
      }
    } catch (error) {
      const duration = performance.now() - start
      return {
        status: 'fail',
        message: error instanceof Error ? error.message : 'Unknown error',
        duration,
      }
    }
  }

  async checkStripe(): Promise<{ status: 'pass' | 'fail'; message?: string }> {
    if (!this.config.stripe.enabled) {
      return { status: 'pass', message: 'Stripe not configured' }
    }

    try {
      // Check if Stripe.js is loaded
      if (typeof window !== 'undefined' && window.Stripe) {
        return { status: 'pass' }
      } else {
        return { status: 'fail', message: 'Stripe.js not loaded' }
      }
    } catch (error) {
      return {
        status: 'fail',
        message: error instanceof Error ? error.message : 'Unknown error',
      }
    }
  }

  async checkSentry(): Promise<{ status: 'pass' | 'fail'; message?: string }> {
    if (!this.config.sentry.enabled) {
      return { status: 'pass', message: 'Sentry not configured' }
    }

    try {
      // Check if Sentry is initialized
      const Sentry = await import('@sentry/react')
      const client = Sentry.getCurrentHub().getClient()

      if (client) {
        return { status: 'pass' }
      } else {
        return { status: 'fail', message: 'Sentry not initialized' }
      }
    } catch (error) {
      return {
        status: 'fail',
        message: error instanceof Error ? error.message : 'Unknown error',
      }
    }
  }

  async checkAPI(): Promise<{ status: 'pass' | 'fail'; message?: string; duration: number }> {
    const start = performance.now()

    try {
      const response = await fetch('/api/health', {
        method: 'GET',
      })

      const duration = performance.now() - start

      if (response.ok) {
        return { status: 'pass', duration }
      } else {
        return {
          status: 'fail',
          message: `HTTP ${response.status}`,
          duration,
        }
      }
    } catch (error) {
      const duration = performance.now() - start
      return {
        status: 'fail',
        message: error instanceof Error ? error.message : 'Network error',
        duration,
      }
    }
  }

  async performHealthCheck(): Promise<HealthCheckResult> {
    if (this.isChecking) {
      throw new Error('Health check already in progress')
    }

    this.isChecking = true
    const startTime = performance.now()
    const timestamp = new Date().toISOString()

    try {
      // Run all checks in parallel
      const [supabase, stripe, sentry, api] = await Promise.all([
        this.checkSupabase(),
        this.checkStripe(),
        this.checkSentry(),
        this.checkAPI(),
      ])

      const checks = {
        supabase,
        stripe,
        sentry,
        api,
      }

      // Calculate overall status
      const failed = Object.values(checks).filter((check) => check.status === 'fail').length
      const healthy = Object.values(checks).filter((check) => check.status === 'pass').length
      const duration = performance.now() - startTime

      let status: 'healthy' | 'degraded' | 'unhealthy'
      if (failed === 0) {
        status = 'healthy'
      } else if (failed >= Object.keys(checks).length / 2) {
        status = 'unhealthy'
      } else {
        status = 'degraded'
      }

      const result: HealthCheckResult = {
        status,
        timestamp,
        checks,
        overall: {
          healthy,
          failed,
          duration,
        },
      }

      this.lastCheck = result

      // Log health status
      if (status === 'unhealthy') {
        logger.error('Health check failed', undefined, {
          component: 'health-check',
          metadata: result,
        })
      } else if (status === 'degraded') {
        logger.warn('Health check degraded', {
          component: 'health-check',
          metadata: result,
        })
      }

      return result
    } finally {
      this.isChecking = false
    }
  }

  startPeriodicCheck(intervalMs: number = 60000) {
    if (this.checkInterval) {
      clearInterval(this.checkInterval)
    }

    // Initial check
    this.performHealthCheck().catch((error) => {
      logger.error('Initial health check failed', error)
    })

    // Set up periodic checks
    this.checkInterval = setInterval(() => {
      this.performHealthCheck().catch((error) => {
        logger.error('Periodic health check failed', error)
      })
    }, intervalMs)
  }

  stopPeriodicCheck() {
    if (this.checkInterval) {
      clearInterval(this.checkInterval)
      this.checkInterval = undefined
    }
  }

  getLastCheck(): HealthCheckResult | undefined {
    return this.lastCheck
  }

  // Create health endpoint response
  createHealthResponse(): Response {
    if (!this.lastCheck) {
      return new Response(
        JSON.stringify({
          status: 'unknown',
          message: 'No health check performed yet',
        }),
        {
          status: 503,
          headers: { 'Content-Type': 'application/json' },
        }
      )
    }

    const statusCode =
      this.lastCheck.status === 'healthy' ? 200 : this.lastCheck.status === 'degraded' ? 200 : 503

    return new Response(JSON.stringify(this.lastCheck), {
      status: statusCode,
      headers: { 'Content-Type': 'application/json' },
    })
  }
}

// Create singleton instance
export const healthChecker = new HealthChecker({
  supabase: {
    url: import.meta.env.VITE_SUPABASE_URL || '',
    anonKey: import.meta.env.VITE_SUPABASE_ANON_KEY || '',
  },
  stripe: {
    enabled: !!import.meta.env.VITE_STRIPE_PUBLISHABLE_KEY,
  },
  sentry: {
    enabled: !!import.meta.env.VITE_SENTRY_DSN,
  },
})

// Start periodic health checks in production
if (import.meta.env.PROD) {
  healthChecker.startPeriodicCheck(60000) // Check every minute
}

// Export for use in service workers or edge functions
export function handleHealthRequest(): Response {
  return healthChecker.createHealthResponse()
}
</file>

<file path="src/lib/monitoring.ts">
import * as Sentry from '@sentry/react'
import { Routes, Route } from 'react-router-dom'

/**
 * Initialize Sentry monitoring for error tracking and performance monitoring
 */
export function initSentry(): void {
  const dsn = import.meta.env.VITE_SENTRY_DSN
  const environment = import.meta.env.MODE

  if (!dsn) {
    console.warn('Sentry DSN not configured, monitoring disabled')
    return
  }

  Sentry.init({
    dsn,
    environment,
    integrations: [
      Sentry.browserTracingIntegration({
        // Set up automatic route change tracking for React Router
        enableInp: true,
      }),
      Sentry.replayIntegration({
        // Mask sensitive data
        maskAllText: true,
        blockAllMedia: true,
      }),
    ],

    // Performance monitoring
    tracesSampleRate: environment === 'production' ? 0.1 : 1.0,

    // Session replay
    replaysSessionSampleRate: 0.1,
    replaysOnErrorSampleRate: 1.0,

    // Release tracking
    release: import.meta.env.VITE_APP_VERSION || 'unknown',

    // Error filtering
    beforeSend(event, hint) {
      // Filter out development errors
      if (environment === 'development') {
        console.error('Sentry event:', event, hint)
        return null
      }

      // Filter out network errors that are not actionable
      if (event.exception) {
        const error = hint.originalException
        if (error instanceof TypeError && error.message.includes('NetworkError')) {
          return null
        }
      }

      return event
    },

    // Additional context
    initialScope: {
      tags: {
        component: 'dce-website',
        platform: 'web',
      },
    },
  })
}

/**
 * Set user context for error tracking
 */
export function setSentryUser(user: { id: string; email?: string; role?: string }): void {
  Sentry.setUser({
    id: user.id,
    email: user.email,
    role: user.role,
  })
}

/**
 * Add breadcrumb for debugging
 */
export function addBreadcrumb(
  message: string,
  category: string = 'custom',
  level: Sentry.SeverityLevel = 'info',
  data?: Record<string, unknown>
): void {
  Sentry.addBreadcrumb({
    message,
    category,
    level,
    data,
    timestamp: Date.now() / 1000,
  })
}

/**
 * Capture exception manually
 */
export function captureError(error: Error, context?: Record<string, unknown>): void {
  Sentry.withScope((scope) => {
    if (context) {
      scope.setContext('error_context', context)
    }
    Sentry.captureException(error)
  })
}

/**
 * Capture custom message
 */
export function captureMessage(
  message: string,
  level: Sentry.SeverityLevel = 'info',
  context?: Record<string, unknown>
): void {
  Sentry.withScope((scope) => {
    if (context) {
      scope.setContext('message_context', context)
    }
    scope.setLevel(level)
    Sentry.captureMessage(message)
  })
}

/**
 * Performance monitoring for critical operations
 */
export function startTransaction(name: string, operation: string = 'navigation'): unknown {
  return Sentry.startSpan(
    {
      name,
      op: operation,
    },
    () => ({})
  )
}

/**
 * Track API call performance
 */
export function trackApiCall<T>(apiName: string, apiCall: () => Promise<T>): Promise<T> {
  const transaction = startTransaction(apiName, 'http.client')

  return apiCall()
    .then((result) => {
      ;(transaction as { setStatus?: (status: string) => void })?.setStatus?.('ok')
      return result
    })
    .catch((error) => {
      ;(transaction as { setStatus?: (status: string) => void })?.setStatus?.('internal_error')
      captureError(error, { apiName })
      throw error
    })
    .finally(() => {
      ;(transaction as { finish?: () => void })?.finish?.()
    })
}

// React integration components
export const SentryRoutes = Sentry.withSentryRouting(Routes)
export const SentryRoute = Sentry.withSentryRouting(Route)
export const SentryErrorBoundary = Sentry.ErrorBoundary
</file>

<file path="src/lib/queryClient.ts">
import { QueryClient, QueryCache, MutationCache } from '@tanstack/react-query'
import { captureError, addBreadcrumb } from './monitoring'

/**
 * Custom error handling for React Query
 * Integrates with Sentry monitoring and error boundaries
 */
const handleQueryError = (error: Error, query?: unknown) => {
  // Add breadcrumb for debugging
  addBreadcrumb('React Query error occurred', 'query', 'error', {
    queryKey:
      query && typeof query === 'object' && 'queryKey' in query
        ? (query as { queryKey: unknown }).queryKey
        : 'unknown',
    errorMessage: error.message,
  })

  // Capture error with context
  captureError(error, {
    context: 'react-query',
    queryInfo: query,
  })
}

const handleMutationError = (
  error: Error,
  variables?: unknown,
  context?: unknown,
  mutation?: unknown
) => {
  // Add breadcrumb for debugging
  addBreadcrumb('React Query mutation error occurred', 'mutation', 'error', {
    mutationKey:
      mutation && typeof mutation === 'object' && 'mutationKey' in mutation
        ? (mutation as { mutationKey: unknown }).mutationKey
        : 'unknown',
    errorMessage: error.message,
    variables: typeof variables === 'object' ? variables : 'non-object',
  })

  // Capture error with context
  captureError(error, {
    context: 'react-query-mutation',
    variables,
    mutationContext: context,
  })
}

/**
 * Create and configure QueryClient with error boundary integration
 */
export const createQueryClient = () => {
  return new QueryClient({
    queryCache: new QueryCache({
      onError: handleQueryError,
    }),
    mutationCache: new MutationCache({
      onError: handleMutationError,
    }),
    defaultOptions: {
      queries: {
        // Retry configuration
        retry: (failureCount, error) => {
          // Don't retry on 4xx errors (client errors)
          if (error && typeof error === 'object' && 'status' in error) {
            const status = error.status as number
            if (status >= 400 && status < 500) {
              return false
            }
          }

          // Retry up to 3 times for other errors
          return failureCount < 3
        },

        // Stale time configuration
        staleTime: 5 * 60 * 1000, // 5 minutes

        // Error handling
        throwOnError: (_, query) => {
          // Allow error boundaries to catch errors for critical operations
          if (query.meta?.critical) {
            return true
          }

          // Don't throw for background refetches
          if (query.state.data !== undefined) {
            return false
          }

          // Throw on initial load errors
          return true
        },

        // Network mode
        networkMode: 'online',

        // Refetch configuration
        refetchOnWindowFocus: false,
        refetchOnReconnect: 'always',
      },
      mutations: {
        // Retry configuration for mutations
        retry: (failureCount, error) => {
          // Don't retry mutations on client errors
          if (error && typeof error === 'object' && 'status' in error) {
            const status = error.status as number
            if (status >= 400 && status < 500) {
              return false
            }
          }

          // Only retry once for server errors
          return failureCount < 1
        },

        // Error handling
        throwOnError: true, // Always throw mutation errors to error boundaries

        // Network mode
        networkMode: 'online',
      },
    },
  })
}

/**
 * Singleton QueryClient instance
 */
export const queryClient = createQueryClient()

/**
 * Query keys factory for consistent key management
 */
export const queryKeys = {
  // Authentication
  auth: {
    user: ['auth', 'user'] as const,
    session: ['auth', 'session'] as const,
  },

  // Campaigns
  campaigns: {
    all: ['campaigns'] as const,
    lists: () => [...queryKeys.campaigns.all, 'list'] as const,
    list: (filters: string) => [...queryKeys.campaigns.lists(), { filters }] as const,
    details: () => [...queryKeys.campaigns.all, 'detail'] as const,
    detail: (id: string) => [...queryKeys.campaigns.details(), id] as const,
    analytics: (id: string) => [...queryKeys.campaigns.detail(id), 'analytics'] as const,
  },

  // Calls
  calls: {
    all: ['calls'] as const,
    lists: () => [...queryKeys.calls.all, 'list'] as const,
    list: (filters: string) => [...queryKeys.calls.lists(), { filters }] as const,
    details: () => [...queryKeys.calls.all, 'detail'] as const,
    detail: (id: string) => [...queryKeys.calls.details(), id] as const,
    recording: (id: string) => [...queryKeys.calls.detail(id), 'recording'] as const,
  },

  // Payments
  payments: {
    all: ['payments'] as const,
    transactions: () => [...queryKeys.payments.all, 'transactions'] as const,
    payouts: () => [...queryKeys.payments.all, 'payouts'] as const,
    billing: () => [...queryKeys.payments.all, 'billing'] as const,
    stripeAccount: () => [...queryKeys.payments.all, 'stripe-account'] as const,
  },

  // Reports
  reports: {
    all: ['reports'] as const,
    dashboard: () => [...queryKeys.reports.all, 'dashboard'] as const,
    performance: (timeRange: string) =>
      [...queryKeys.reports.all, 'performance', timeRange] as const,
    conversion: (timeRange: string) => [...queryKeys.reports.all, 'conversion', timeRange] as const,
  },
} as const

/**
 * Mutation keys factory for consistent key management
 */
export const mutationKeys = {
  // Authentication
  auth: {
    login: ['auth', 'login'] as const,
    logout: ['auth', 'logout'] as const,
    register: ['auth', 'register'] as const,
    resetPassword: ['auth', 'reset-password'] as const,
  },

  // Campaigns
  campaigns: {
    create: ['campaigns', 'create'] as const,
    update: ['campaigns', 'update'] as const,
    delete: ['campaigns', 'delete'] as const,
    activate: ['campaigns', 'activate'] as const,
    deactivate: ['campaigns', 'deactivate'] as const,
  },

  // Payments
  payments: {
    createPaymentIntent: ['payments', 'create-intent'] as const,
    processPayment: ['payments', 'process'] as const,
    requestPayout: ['payments', 'request-payout'] as const,
    connectStripe: ['payments', 'connect-stripe'] as const,
  },
} as const

export default queryClient
</file>

<file path="src/pages/auth/ForgotPasswordPage.tsx">
import { useState } from 'react'
import { Link } from 'react-router-dom'
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { z } from 'zod'
import { supabase } from '../../lib/supabase'

const forgotPasswordSchema = z.object({
  email: z.string().email('Invalid email address'),
})

type ForgotPasswordFormData = z.infer<typeof forgotPasswordSchema>

export default function ForgotPasswordPage() {
  const [success, setSuccess] = useState(false)
  const [error, setError] = useState('')
  const [loading, setLoading] = useState(false)

  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<ForgotPasswordFormData>({
    resolver: zodResolver(forgotPasswordSchema),
  })

  const onSubmit = async (data: ForgotPasswordFormData) => {
    setError('')
    setLoading(true)

    try {
      const { error } = await supabase.auth.resetPasswordForEmail(data.email, {
        redirectTo: `${window.location.origin}/reset-password`,
      })

      if (error) throw error

      setSuccess(true)
    } catch (err: unknown) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to send reset email'
      setError(errorMessage)
    } finally {
      setLoading(false)
    }
  }

  if (success) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
        <div className="max-w-md w-full space-y-8">
          <div className="text-center">
            <h2 className="mt-6 text-3xl font-extrabold text-gray-900">
              Check your email
            </h2>
            <p className="mt-2 text-sm text-gray-600">
              We've sent a password reset link to your email address.
            </p>
            <Link
              to="/login"
              className="mt-4 inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-primary-600 bg-primary-100 hover:bg-primary-200"
            >
              Back to login
            </Link>
          </div>
        </div>
      </div>
    )
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
      <div className="max-w-md w-full space-y-8">
        <div>
          <h2 className="mt-6 text-center text-3xl font-extrabold text-gray-900">
            Forgot your password?
          </h2>
          <p className="mt-2 text-center text-sm text-gray-600">
            Enter your email address and we'll send you a link to reset your password.
          </p>
        </div>

        <form className="mt-8 space-y-6" onSubmit={handleSubmit(onSubmit)}>
          <div>
            <label htmlFor="email" className="block text-sm font-medium text-gray-700">
              Email address
            </label>
            <input
              {...register('email')}
              type="email"
              autoComplete="email"
              className="mt-1 appearance-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-md focus:outline-none focus:ring-primary-500 focus:border-primary-500 focus:z-10 sm:text-sm"
              placeholder="Enter your email"
            />
            {errors.email && (
              <p className="mt-1 text-sm text-red-600">{errors.email.message}</p>
            )}
          </div>

          {error && (
            <div className="rounded-md bg-red-50 p-4">
              <div className="flex">
                <div className="ml-3">
                  <h3 className="text-sm font-medium text-red-800">{error}</h3>
                </div>
              </div>
            </div>
          )}

          <div>
            <button
              type="submit"
              disabled={loading}
              className="group relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-primary-600 hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {loading ? 'Sending...' : 'Send reset link'}
            </button>
          </div>

          <div className="text-center">
            <Link
              to="/login"
              className="font-medium text-primary-600 hover:text-primary-500"
            >
              Back to login
            </Link>
          </div>
        </form>
      </div>
    </div>
  )
}
</file>

<file path="src/pages/dashboard/DashboardPage.tsx">
import { useAuthStore } from '../../store/authStore'
import { SupplierDashboard } from '../../components/dashboard/supplier'
import { BuyerDashboard } from '../../components/dashboard/buyer/BuyerDashboard'
import { AdminDashboard } from '../../components/dashboard/admin/AdminDashboard'

export default function DashboardPage() {
  const { user, userType } = useAuthStore()

  // Render appropriate dashboard based on user type
  if (userType === 'supplier') {
    return <SupplierDashboard />
  }

  if (userType === 'buyer') {
    return <BuyerDashboard />
  }

  if (userType === 'admin') {
    return <AdminDashboard />
  }

  // Default fallback for unknown user types
  return (
    <div className="py-6">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <h1 className="text-2xl font-semibold text-gray-900">Dashboard</h1>
        <p className="mt-1 text-sm text-gray-600">
          Welcome back, {user?.email}
        </p>
        <div className="mt-8 bg-yellow-50 border border-yellow-200 rounded-md p-4">
          <p className="text-sm text-yellow-800">
            Unable to determine user type. Please contact support.
          </p>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/pages/public/BlogPage.tsx">
import { useState, useMemo } from 'react'
import { Link } from 'react-router-dom'
import {
  CalendarIcon,
  UserIcon,
  ClockIcon,
  MagnifyingGlassIcon,
  ChevronLeftIcon,
  ChevronRightIcon,
} from '@heroicons/react/24/outline'
import { blogPosts } from '../../data/blogPosts'

const POSTS_PER_PAGE = 6

// Get unique categories for filtering
const categories = ['All', ...Array.from(new Set(blogPosts.map((post) => post.category)))]

export default function BlogPage() {
  const [searchTerm, setSearchTerm] = useState('')
  const [selectedCategory, setSelectedCategory] = useState('All')
  const [currentPage, setCurrentPage] = useState(1)

  // Filter posts based on search and category
  const filteredPosts = useMemo(() => {
    let filtered = blogPosts

    // Filter by search term
    if (searchTerm) {
      const searchLower = searchTerm.toLowerCase()
      filtered = filtered.filter(
        (post) =>
          post.title.toLowerCase().includes(searchLower) ||
          post.excerpt.toLowerCase().includes(searchLower) ||
          post.author.toLowerCase().includes(searchLower) ||
          post.category.toLowerCase().includes(searchLower)
      )
    }

    // Filter by category
    if (selectedCategory !== 'All') {
      filtered = filtered.filter((post) => post.category === selectedCategory)
    }

    return filtered
  }, [searchTerm, selectedCategory])

  // Calculate pagination
  const totalPages = Math.ceil(filteredPosts.length / POSTS_PER_PAGE)
  const startIndex = (currentPage - 1) * POSTS_PER_PAGE
  const endIndex = startIndex + POSTS_PER_PAGE
  const currentPosts = filteredPosts.slice(startIndex, endIndex)

  // Reset to page 1 when filters change
  const handleSearchChange = (value: string) => {
    setSearchTerm(value)
    setCurrentPage(1)
  }

  const handleCategoryChange = (category: string) => {
    setSelectedCategory(category)
    setCurrentPage(1)
  }

  const handlePageChange = (page: number) => {
    setCurrentPage(page)
    // Scroll to top when changing pages
    window.scrollTo({ top: 0, behavior: 'smooth' })
  }

  return (
    <div className="bg-white">
      {/* Header */}
      <div className="bg-gray-50">
        <div className="max-w-7xl mx-auto py-12 px-4 sm:px-6 lg:py-16 lg:px-8">
          <div className="text-center">
            <h1 className="text-4xl font-extrabold text-gray-900 sm:text-5xl">Blog</h1>
            <p className="mt-4 text-xl text-gray-500 max-w-2xl mx-auto">
              Insights, tips, and best practices for pay-per-call marketing success
            </p>
          </div>
        </div>
      </div>

      {/* Search and Filters */}
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <div className="flex flex-col sm:flex-row gap-4 items-center justify-between">
          {/* Search */}
          <div className="relative flex-1 max-w-md">
            <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
              <MagnifyingGlassIcon className="h-5 w-5 text-gray-400" />
            </div>
            <input
              type="text"
              placeholder="Search articles..."
              value={searchTerm}
              onChange={(e) => handleSearchChange(e.target.value)}
              className="block w-full pl-10 pr-3 py-2 border border-gray-300 rounded-md leading-5 bg-white placeholder-gray-500 focus:outline-none focus:placeholder-gray-400 focus:ring-1 focus:ring-primary-500 focus:border-primary-500"
            />
          </div>

          {/* Category Filter */}
          <div className="flex flex-wrap gap-2">
            {categories.map((category) => (
              <button
                key={category}
                onClick={() => handleCategoryChange(category)}
                className={`px-4 py-2 rounded-full text-sm font-medium transition-colors ${
                  selectedCategory === category
                    ? 'bg-primary-600 text-white'
                    : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                }`}
              >
                {category}
              </button>
            ))}
          </div>
        </div>

        {/* Results count */}
        <div className="mt-4 text-sm text-gray-600">
          {filteredPosts.length === 0
            ? 'No articles found'
            : `Showing ${startIndex + 1}-${Math.min(endIndex, filteredPosts.length)} of ${filteredPosts.length} articles`}
        </div>
      </div>

      {/* Blog Posts */}
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pb-12">
        {currentPosts.length === 0 ? (
          <div className="text-center py-12">
            <p className="text-gray-500 text-lg">No articles match your search criteria.</p>
            <button
              onClick={() => {
                setSearchTerm('')
                setSelectedCategory('All')
                setCurrentPage(1)
              }}
              className="mt-4 text-primary-600 hover:text-primary-700 font-medium"
            >
              Clear filters
            </button>
          </div>
        ) : (
          <div className="grid gap-8 lg:grid-cols-2">
            {currentPosts.map((post) => (
              <article
                key={post.id}
                className="bg-white rounded-lg shadow-md overflow-hidden hover:shadow-lg transition-shadow"
              >
                <div className="p-6">
                  <div className="flex items-center text-sm text-gray-500 mb-4">
                    <span className="bg-primary-100 text-primary-800 text-xs font-medium px-2.5 py-0.5 rounded">
                      {post.category}
                    </span>
                  </div>
                  <h2 className="text-2xl font-bold text-gray-900 mb-3">
                    <Link to={`/blog/${post.slug}`} className="hover:text-primary-600">
                      {post.title}
                    </Link>
                  </h2>
                  <p className="text-gray-600 mb-4">{post.excerpt}</p>
                  <div className="flex items-center text-sm text-gray-500 space-x-4">
                    <div className="flex items-center">
                      <UserIcon className="h-4 w-4 mr-1" />
                      {post.author}
                    </div>
                    <div className="flex items-center">
                      <CalendarIcon className="h-4 w-4 mr-1" />
                      {post.date}
                    </div>
                    <div className="flex items-center">
                      <ClockIcon className="h-4 w-4 mr-1" />
                      {post.readTime}
                    </div>
                  </div>
                </div>
              </article>
            ))}
          </div>
        )}

        {/* Pagination */}
        {totalPages > 1 && (
          <div className="mt-12 flex justify-center">
            <nav className="flex items-center space-x-2">
              <button
                onClick={() => handlePageChange(currentPage - 1)}
                disabled={currentPage === 1}
                className={`flex items-center px-3 py-2 text-sm font-medium rounded-md ${
                  currentPage === 1
                    ? 'text-gray-400 bg-gray-100 cursor-not-allowed'
                    : 'text-gray-700 bg-white border border-gray-300 hover:bg-gray-50'
                }`}
              >
                <ChevronLeftIcon className="h-4 w-4 mr-1" />
                Previous
              </button>

              {/* Page numbers */}
              <div className="flex space-x-1">
                {Array.from({ length: totalPages }, (_, i) => i + 1).map((page) => {
                  // Show first page, last page, current page, and pages around current page
                  const showPage =
                    page === 1 ||
                    page === totalPages ||
                    (page >= currentPage - 1 && page <= currentPage + 1)

                  if (!showPage) {
                    // Show ellipsis for gaps
                    if (page === currentPage - 2 || page === currentPage + 2) {
                      return (
                        <span key={page} className="px-3 py-2 text-sm text-gray-500">
                          ...
                        </span>
                      )
                    }
                    return null
                  }

                  return (
                    <button
                      key={page}
                      onClick={() => handlePageChange(page)}
                      className={`px-3 py-2 text-sm font-medium rounded-md ${
                        currentPage === page
                          ? 'text-white bg-primary-600 border border-transparent'
                          : 'text-gray-700 bg-white border border-gray-300 hover:bg-gray-50'
                      }`}
                    >
                      {page}
                    </button>
                  )
                })}
              </div>

              <button
                onClick={() => handlePageChange(currentPage + 1)}
                disabled={currentPage === totalPages}
                className={`flex items-center px-3 py-2 text-sm font-medium rounded-md ${
                  currentPage === totalPages
                    ? 'text-gray-400 bg-gray-100 cursor-not-allowed'
                    : 'text-gray-700 bg-white border border-gray-300 hover:bg-gray-50'
                }`}
              >
                Next
                <ChevronRightIcon className="h-4 w-4 ml-1" />
              </button>
            </nav>
          </div>
        )}
      </div>

      {/* Newsletter CTA */}
      <div className="bg-gray-50">
        <div className="max-w-7xl mx-auto py-12 px-4 sm:px-6 lg:py-16 lg:px-8">
          <div className="text-center">
            <h2 className="text-3xl font-extrabold text-gray-900">
              Stay updated with our newsletter
            </h2>
            <p className="mt-4 text-lg text-gray-500">
              Get the latest insights and tips delivered to your inbox weekly.
            </p>
            <form className="mt-8 sm:flex sm:justify-center">
              <input
                type="email"
                className="w-full px-5 py-3 border border-gray-300 shadow-sm placeholder-gray-400 focus:ring-1 focus:ring-primary-500 focus:border-primary-500 sm:max-w-xs rounded-md"
                placeholder="Enter your email"
              />
              <div className="mt-3 rounded-md shadow sm:mt-0 sm:ml-3">
                <button
                  type="submit"
                  className="w-full flex items-center justify-center px-5 py-3 border border-transparent text-base font-medium rounded-md text-white bg-primary-600 hover:bg-primary-700"
                >
                  Subscribe
                </button>
              </div>
            </form>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/test/setup.ts">
import '@testing-library/jest-dom'
import { cleanup } from '@testing-library/react'
import { afterEach } from 'vitest'

// Mock window.matchMedia
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: (query: string) => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: () => {},
    removeListener: () => {},
    addEventListener: () => {},
    removeEventListener: () => {},
    dispatchEvent: () => {},
  }),
})

// Mock IntersectionObserver
global.IntersectionObserver = class IntersectionObserver {
  root = null
  rootMargin = '0px'
  thresholds = [0]

  constructor() {}
  disconnect() {}
  observe() {}
  unobserve() {}
  takeRecords() {
    return []
  }
}

// Mock ResizeObserver
global.ResizeObserver = class ResizeObserver {
  constructor() {}
  disconnect() {}
  observe() {}
  unobserve() {}
}

// Clean up after each test
afterEach(() => {
  cleanup()
})
</file>

<file path="src/index.css">
@import "../app.css";
</file>

<file path="src/vite-env.d.ts">
/// <reference types="vite/client" />
/// <reference types="vitest/globals" />
</file>

<file path="supabase/migrations/005_indexes.sql">
-- DCE Platform Performance Indexes
-- Optimized indexes for frequent queries and performance critical operations

-- ================================
-- PRIMARY LOOKUP INDEXES
-- ================================

-- Users table indexes
CREATE INDEX IF NOT EXISTS idx_users_email ON users (email);
CREATE INDEX IF NOT EXISTS idx_users_status ON users (status) WHERE status = 'active';
CREATE INDEX IF NOT EXISTS idx_users_last_login ON users (last_login DESC) WHERE last_login IS NOT NULL;

-- Suppliers table indexes
CREATE INDEX IF NOT EXISTS idx_suppliers_user_id ON suppliers (user_id);
CREATE INDEX IF NOT EXISTS idx_suppliers_status ON suppliers (status) WHERE status = 'active';
CREATE INDEX IF NOT EXISTS idx_suppliers_company_name ON suppliers (company_name);
CREATE INDEX IF NOT EXISTS idx_suppliers_credit_balance ON suppliers (credit_balance DESC) WHERE credit_balance > 0;
CREATE INDEX IF NOT EXISTS idx_suppliers_created_at ON suppliers (created_at DESC);

-- Buyers table indexes
CREATE INDEX IF NOT EXISTS idx_buyers_user_id ON buyers (user_id);
CREATE INDEX IF NOT EXISTS idx_buyers_status ON buyers (status) WHERE status = 'active';
CREATE INDEX IF NOT EXISTS idx_buyers_company_name ON buyers (company_name);
CREATE INDEX IF NOT EXISTS idx_buyers_credit_limit ON buyers (credit_limit DESC);
CREATE INDEX IF NOT EXISTS idx_buyers_current_balance ON buyers (current_balance DESC);
CREATE INDEX IF NOT EXISTS idx_buyers_created_at ON buyers (created_at DESC);

-- ================================
-- CAMPAIGN INDEXES
-- ================================

-- Campaigns table indexes
CREATE INDEX IF NOT EXISTS idx_campaigns_supplier_id ON campaigns (supplier_id);
CREATE INDEX IF NOT EXISTS idx_campaigns_status ON campaigns (status);
CREATE INDEX IF NOT EXISTS idx_campaigns_status_active ON campaigns (status, created_at DESC) WHERE status = 'active';
CREATE INDEX IF NOT EXISTS idx_campaigns_bid_floor ON campaigns (bid_floor DESC);
CREATE INDEX IF NOT EXISTS idx_campaigns_category ON campaigns (category) WHERE category IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_campaigns_vertical ON campaigns (vertical) WHERE vertical IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_campaigns_created_at ON campaigns (created_at DESC);
CREATE INDEX IF NOT EXISTS idx_campaigns_updated_at ON campaigns (updated_at DESC);

-- JSONB indexes for campaign targeting and routing
CREATE INDEX IF NOT EXISTS idx_campaigns_targeting_geo ON campaigns USING GIN ((targeting->'geographic'));
CREATE INDEX IF NOT EXISTS idx_campaigns_targeting_schedule ON campaigns USING GIN ((targeting->'schedule'));
CREATE INDEX IF NOT EXISTS idx_campaigns_routing_rules ON campaigns USING GIN (routing_rules);

-- Buyer campaigns table indexes
CREATE INDEX IF NOT EXISTS idx_buyer_campaigns_buyer_id ON buyer_campaigns (buyer_id);
CREATE INDEX IF NOT EXISTS idx_buyer_campaigns_status ON buyer_campaigns (status);
CREATE INDEX IF NOT EXISTS idx_buyer_campaigns_status_active ON buyer_campaigns (status, created_at DESC) WHERE status = 'active';
CREATE INDEX IF NOT EXISTS idx_buyer_campaigns_max_bid ON buyer_campaigns (max_bid DESC);
CREATE INDEX IF NOT EXISTS idx_buyer_campaigns_daily_budget ON buyer_campaigns (daily_budget DESC) WHERE daily_budget IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_buyer_campaigns_created_at ON buyer_campaigns (created_at DESC);

-- JSONB indexes for buyer campaign criteria
CREATE INDEX IF NOT EXISTS idx_buyer_campaigns_targeting ON buyer_campaigns USING GIN (targeting_criteria);
CREATE INDEX IF NOT EXISTS idx_buyer_campaigns_schedule ON buyer_campaigns USING GIN (schedule);
CREATE INDEX IF NOT EXISTS idx_buyer_campaigns_quality ON buyer_campaigns USING GIN (quality_requirements);

-- ================================
-- CALL TRACKING INDEXES
-- ================================

-- Tracking numbers table indexes
CREATE INDEX IF NOT EXISTS idx_tracking_numbers_campaign_id ON tracking_numbers (campaign_id);
CREATE INDEX IF NOT EXISTS idx_tracking_numbers_number ON tracking_numbers (number);
CREATE INDEX IF NOT EXISTS idx_tracking_numbers_active ON tracking_numbers (campaign_id, is_active) WHERE is_active = true;
CREATE INDEX IF NOT EXISTS idx_tracking_numbers_area_code ON tracking_numbers (area_code) WHERE area_code IS NOT NULL;

-- ================================
-- CALLS PERFORMANCE INDEXES
-- ================================

-- Core call lookup indexes
CREATE INDEX IF NOT EXISTS idx_calls_campaign_id ON calls (campaign_id);
CREATE INDEX IF NOT EXISTS idx_calls_buyer_campaign_id ON calls (buyer_campaign_id);
CREATE INDEX IF NOT EXISTS idx_calls_tracking_number ON calls (tracking_number);
CREATE INDEX IF NOT EXISTS idx_calls_caller_number ON calls (caller_number);
CREATE INDEX IF NOT EXISTS idx_calls_status ON calls (status);
CREATE INDEX IF NOT EXISTS idx_calls_started_at ON calls (started_at DESC);
CREATE INDEX IF NOT EXISTS idx_calls_ended_at ON calls (ended_at DESC) WHERE ended_at IS NOT NULL;

-- Performance indexes for call queries
CREATE INDEX IF NOT EXISTS idx_calls_campaign_started ON calls (campaign_id, started_at DESC);
CREATE INDEX IF NOT EXISTS idx_calls_buyer_campaign_started ON calls (buyer_campaign_id, started_at DESC);
CREATE INDEX IF NOT EXISTS idx_calls_status_started ON calls (status, started_at DESC);
CREATE INDEX IF NOT EXISTS idx_calls_completed ON calls (status, started_at DESC) WHERE status = 'completed';

-- Billing and quality indexes
CREATE INDEX IF NOT EXISTS idx_calls_payout_amount ON calls (payout_amount DESC) WHERE payout_amount > 0;
CREATE INDEX IF NOT EXISTS idx_calls_charge_amount ON calls (charge_amount DESC) WHERE charge_amount > 0;
CREATE INDEX IF NOT EXISTS idx_calls_quality_score ON calls (quality_score DESC) WHERE quality_score IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_calls_fraud_score ON calls (fraud_score DESC) WHERE fraud_score IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_calls_duration ON calls (duration_seconds DESC) WHERE duration_seconds > 0;

-- Composite indexes for complex queries
CREATE INDEX IF NOT EXISTS idx_calls_campaign_status_date ON calls (campaign_id, status, started_at);
CREATE INDEX IF NOT EXISTS idx_calls_buyer_campaign_status_date ON calls (buyer_campaign_id, status, started_at);
CREATE INDEX IF NOT EXISTS idx_calls_quality_billing ON calls (quality_score DESC, payout_amount DESC) WHERE quality_score IS NOT NULL AND payout_amount > 0;

-- JSONB indexes for call metadata and location
CREATE INDEX IF NOT EXISTS idx_calls_metadata ON calls USING GIN (metadata);
CREATE INDEX IF NOT EXISTS idx_calls_caller_location ON calls USING GIN (caller_location);

-- ================================
-- CALL LOGS INDEXES
-- ================================

CREATE INDEX IF NOT EXISTS idx_call_logs_call_id ON call_logs (call_id);
CREATE INDEX IF NOT EXISTS idx_call_logs_event_type ON call_logs (event_type);
CREATE INDEX IF NOT EXISTS idx_call_logs_timestamp ON call_logs (timestamp DESC);
CREATE INDEX IF NOT EXISTS idx_call_logs_call_event_time ON call_logs (call_id, event_type, timestamp);

-- JSONB index for event data
CREATE INDEX IF NOT EXISTS idx_call_logs_event_data ON call_logs USING GIN (event_data);

-- ================================
-- FINANCIAL INDEXES
-- ================================

-- Payouts table indexes
CREATE INDEX IF NOT EXISTS idx_payouts_supplier_id ON payouts (supplier_id);
CREATE INDEX IF NOT EXISTS idx_payouts_status ON payouts (status);
CREATE INDEX IF NOT EXISTS idx_payouts_period ON payouts (period_start, period_end);
CREATE INDEX IF NOT EXISTS idx_payouts_created_at ON payouts (created_at DESC);
CREATE INDEX IF NOT EXISTS idx_payouts_paid_at ON payouts (paid_at DESC) WHERE paid_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_payouts_amount ON payouts (amount DESC);
CREATE INDEX IF NOT EXISTS idx_payouts_transaction_id ON payouts (transaction_id) WHERE transaction_id IS NOT NULL;

-- Composite indexes for payout queries
CREATE INDEX IF NOT EXISTS idx_payouts_supplier_status_period ON payouts (supplier_id, status, period_end DESC);
CREATE INDEX IF NOT EXISTS idx_payouts_status_period ON payouts (status, period_start, period_end);

-- Invoices table indexes
CREATE INDEX IF NOT EXISTS idx_invoices_buyer_id ON invoices (buyer_id);
CREATE INDEX IF NOT EXISTS idx_invoices_status ON invoices (status);
CREATE INDEX IF NOT EXISTS idx_invoices_invoice_number ON invoices (invoice_number);
CREATE INDEX IF NOT EXISTS idx_invoices_period ON invoices (period_start, period_end);
CREATE INDEX IF NOT EXISTS idx_invoices_due_date ON invoices (due_date) WHERE status != 'paid';
CREATE INDEX IF NOT EXISTS idx_invoices_created_at ON invoices (created_at DESC);
CREATE INDEX IF NOT EXISTS idx_invoices_paid_at ON invoices (paid_at DESC) WHERE paid_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_invoices_amount ON invoices (total_amount DESC);
CREATE INDEX IF NOT EXISTS idx_invoices_stripe ON invoices (stripe_invoice_id) WHERE stripe_invoice_id IS NOT NULL;

-- Composite indexes for invoice queries
CREATE INDEX IF NOT EXISTS idx_invoices_buyer_status_due ON invoices (buyer_id, status, due_date);
CREATE INDEX IF NOT EXISTS idx_invoices_status_due ON invoices (status, due_date) WHERE status IN ('open', 'overdue');

-- Invoice line items indexes
CREATE INDEX IF NOT EXISTS idx_invoice_line_items_invoice_id ON invoice_line_items (invoice_id);
CREATE INDEX IF NOT EXISTS idx_invoice_line_items_call_id ON invoice_line_items (call_id) WHERE call_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_invoice_line_items_amount ON invoice_line_items (total_amount DESC);

-- ================================
-- QUALITY AND COMPLIANCE INDEXES
-- ================================

-- Call quality scores indexes
CREATE INDEX IF NOT EXISTS idx_call_quality_scores_call_id ON call_quality_scores (call_id);
CREATE INDEX IF NOT EXISTS idx_call_quality_scores_overall ON call_quality_scores (overall_score DESC) WHERE overall_score IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_call_quality_scores_duration ON call_quality_scores (duration_score DESC) WHERE duration_score IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_call_quality_scores_intent ON call_quality_scores (intent_score DESC) WHERE intent_score IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_call_quality_scores_created_at ON call_quality_scores (created_at DESC);
CREATE INDEX IF NOT EXISTS idx_call_quality_scores_reviewed ON call_quality_scores (reviewed_at DESC) WHERE reviewed_at IS NOT NULL;

-- JSONB index for quality flags
CREATE INDEX IF NOT EXISTS idx_call_quality_flags ON call_quality_scores USING GIN (flags);

-- Disputes table indexes
CREATE INDEX IF NOT EXISTS idx_disputes_call_id ON disputes (call_id);
CREATE INDEX IF NOT EXISTS idx_disputes_raised_by ON disputes (raised_by);
CREATE INDEX IF NOT EXISTS idx_disputes_status ON disputes (status);
CREATE INDEX IF NOT EXISTS idx_disputes_dispute_type ON disputes (dispute_type);
CREATE INDEX IF NOT EXISTS idx_disputes_priority ON disputes (priority, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_disputes_assigned_to ON disputes (assigned_to) WHERE assigned_to IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_disputes_created_at ON disputes (created_at DESC);
CREATE INDEX IF NOT EXISTS idx_disputes_resolved_at ON disputes (resolved_at DESC) WHERE resolved_at IS NOT NULL;

-- Composite indexes for dispute queries
CREATE INDEX IF NOT EXISTS idx_disputes_status_priority_created ON disputes (status, priority, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_disputes_assigned_status ON disputes (assigned_to, status, created_at DESC) WHERE assigned_to IS NOT NULL;

-- JSONB index for dispute evidence
CREATE INDEX IF NOT EXISTS idx_disputes_evidence ON disputes USING GIN (evidence);

-- ================================
-- ANALYTICS AND REPORTING INDEXES
-- ================================

-- Campaign stats indexes
CREATE INDEX IF NOT EXISTS idx_campaign_stats_campaign_id ON campaign_stats (campaign_id);
CREATE INDEX IF NOT EXISTS idx_campaign_stats_date ON campaign_stats (date DESC);
CREATE INDEX IF NOT EXISTS idx_campaign_stats_campaign_date ON campaign_stats (campaign_id, date DESC);
CREATE INDEX IF NOT EXISTS idx_campaign_stats_campaign_date_hour ON campaign_stats (campaign_id, date DESC, hour) WHERE hour IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_campaign_stats_calls_count ON campaign_stats (calls_count DESC) WHERE calls_count > 0;
CREATE INDEX IF NOT EXISTS idx_campaign_stats_total_payout ON campaign_stats (total_payout DESC) WHERE total_payout > 0;
CREATE INDEX IF NOT EXISTS idx_campaign_stats_created_at ON campaign_stats (created_at DESC);

-- Composite indexes for analytics queries
CREATE INDEX IF NOT EXISTS idx_campaign_stats_performance ON campaign_stats (campaign_id, date DESC, calls_count DESC, total_payout DESC);
CREATE INDEX IF NOT EXISTS idx_campaign_stats_daily ON campaign_stats (date DESC, hour) WHERE hour IS NULL;
CREATE INDEX IF NOT EXISTS idx_campaign_stats_hourly ON campaign_stats (date DESC, hour) WHERE hour IS NOT NULL;

-- Buyer campaign stats indexes
CREATE INDEX IF NOT EXISTS idx_buyer_campaign_stats_buyer_campaign_id ON buyer_campaign_stats (buyer_campaign_id);
CREATE INDEX IF NOT EXISTS idx_buyer_campaign_stats_date ON buyer_campaign_stats (date DESC);
CREATE INDEX IF NOT EXISTS idx_buyer_campaign_stats_buyer_date ON buyer_campaign_stats (buyer_campaign_id, date DESC);
CREATE INDEX IF NOT EXISTS idx_buyer_campaign_stats_buyer_date_hour ON buyer_campaign_stats (buyer_campaign_id, date DESC, hour) WHERE hour IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_buyer_campaign_stats_calls_received ON buyer_campaign_stats (calls_received DESC) WHERE calls_received > 0;
CREATE INDEX IF NOT EXISTS idx_buyer_campaign_stats_total_cost ON buyer_campaign_stats (total_cost DESC) WHERE total_cost > 0;
CREATE INDEX IF NOT EXISTS idx_buyer_campaign_stats_created_at ON buyer_campaign_stats (created_at DESC);

-- Composite indexes for buyer analytics
CREATE INDEX IF NOT EXISTS idx_buyer_campaign_stats_performance ON buyer_campaign_stats (buyer_campaign_id, date DESC, calls_received DESC, total_cost DESC);
CREATE INDEX IF NOT EXISTS idx_buyer_campaign_stats_daily ON buyer_campaign_stats (date DESC, hour) WHERE hour IS NULL;
CREATE INDEX IF NOT EXISTS idx_buyer_campaign_stats_hourly ON buyer_campaign_stats (date DESC, hour) WHERE hour IS NOT NULL;

-- ================================
-- AUDIT AND SECURITY INDEXES
-- ================================

-- Audit logs indexes
CREATE INDEX IF NOT EXISTS idx_audit_logs_table_name ON audit_logs (table_name);
CREATE INDEX IF NOT EXISTS idx_audit_logs_operation ON audit_logs (operation);
CREATE INDEX IF NOT EXISTS idx_audit_logs_user_id ON audit_logs (user_id) WHERE user_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_audit_logs_record_id ON audit_logs (record_id) WHERE record_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON audit_logs (created_at DESC);
CREATE INDEX IF NOT EXISTS idx_audit_logs_ip_address ON audit_logs (ip_address) WHERE ip_address IS NOT NULL;

-- Composite indexes for audit queries
CREATE INDEX IF NOT EXISTS idx_audit_logs_table_user_time ON audit_logs (table_name, user_id, created_at DESC) WHERE user_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_audit_logs_record_time ON audit_logs (table_name, record_id, created_at DESC) WHERE record_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_audit_logs_user_time ON audit_logs (user_id, created_at DESC) WHERE user_id IS NOT NULL;

-- JSONB indexes for audit data
CREATE INDEX IF NOT EXISTS idx_audit_logs_old_data ON audit_logs USING GIN (old_data) WHERE old_data IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_audit_logs_new_data ON audit_logs USING GIN (new_data) WHERE new_data IS NOT NULL;

-- ================================
-- SPECIALIZED INDEXES FOR BUSINESS LOGIC
-- ================================

-- Index for fraud detection queries
CREATE INDEX IF NOT EXISTS idx_calls_fraud_detection ON calls (caller_number, started_at DESC);

-- Index for real-time call matching
CREATE INDEX IF NOT EXISTS idx_buyer_campaigns_matching ON buyer_campaigns (status, max_bid DESC, daily_budget DESC) WHERE status = 'active';

-- Index for balance calculations
CREATE INDEX IF NOT EXISTS idx_calls_balance_calc_supplier ON calls (campaign_id, status, payout_amount) WHERE status = 'completed' AND payout_amount > 0;
CREATE INDEX IF NOT EXISTS idx_calls_balance_calc_buyer ON calls (buyer_campaign_id, status, charge_amount) WHERE status = 'completed' AND charge_amount > 0;

-- Index for recent activity queries
CREATE INDEX IF NOT EXISTS idx_calls_recent_activity ON calls (started_at DESC);

-- Index for campaign performance optimization
CREATE INDEX IF NOT EXISTS idx_campaigns_performance ON campaigns (status, bid_floor DESC, created_at DESC) WHERE status = 'active';

-- ================================
-- PARTIAL INDEXES FOR EFFICIENCY
-- ================================

-- Only index active records for most lookups
CREATE INDEX IF NOT EXISTS idx_suppliers_active_only ON suppliers (user_id, created_at DESC) WHERE status = 'active';
CREATE INDEX IF NOT EXISTS idx_buyers_active_only ON buyers (user_id, created_at DESC) WHERE status = 'active';
CREATE INDEX IF NOT EXISTS idx_campaigns_active_only ON campaigns (supplier_id, bid_floor DESC) WHERE status = 'active';
CREATE INDEX IF NOT EXISTS idx_buyer_campaigns_active_only ON buyer_campaigns (buyer_id, max_bid DESC) WHERE status = 'active';

-- Only index completed calls for financial calculations
CREATE INDEX IF NOT EXISTS idx_calls_completed_billing ON calls (campaign_id, buyer_campaign_id, payout_amount, charge_amount) WHERE status = 'completed';

-- Only index pending payouts and open invoices
CREATE INDEX IF NOT EXISTS idx_payouts_pending ON payouts (supplier_id, amount DESC, created_at DESC) WHERE status = 'pending';
CREATE INDEX IF NOT EXISTS idx_invoices_open ON invoices (buyer_id, due_date, total_amount DESC) WHERE status IN ('open', 'overdue');

-- ================================
-- TEXT SEARCH INDEXES
-- ================================

-- Full-text search indexes for campaigns
CREATE INDEX IF NOT EXISTS idx_campaigns_search ON campaigns USING GIN (to_tsvector('english', name || ' ' || COALESCE(description, '')));

-- Full-text search for companies
CREATE INDEX IF NOT EXISTS idx_suppliers_search ON suppliers USING GIN (to_tsvector('english', company_name));
CREATE INDEX IF NOT EXISTS idx_buyers_search ON buyers USING GIN (to_tsvector('english', company_name));

-- Search index for disputes
CREATE INDEX IF NOT EXISTS idx_disputes_search ON disputes USING GIN (to_tsvector('english', reason || ' ' || COALESCE(description, '')));

-- Comments for documentation
COMMENT ON INDEX idx_calls_campaign_started IS 'Primary index for campaign call history queries';
COMMENT ON INDEX idx_calls_buyer_campaign_started IS 'Primary index for buyer call history queries';
COMMENT ON INDEX idx_calls_fraud_detection IS 'Optimized for fraud detection queries on recent calls';
COMMENT ON INDEX idx_buyer_campaigns_matching IS 'Optimized for real-time call matching algorithms';
COMMENT ON INDEX idx_campaigns_performance IS 'Performance index for active campaign discovery';
COMMENT ON INDEX idx_calls_completed_billing IS 'Optimized for billing calculations on completed calls';
COMMENT ON INDEX idx_campaign_stats_performance IS 'Comprehensive campaign analytics index';
COMMENT ON INDEX idx_audit_logs_table_user_time IS 'User activity tracking across all tables';
</file>

<file path="supabase/seed.sql">
-- DCE Platform Development Seed Data
-- Test data for local development and testing

-- Insert test users (these will need to be created via Supabase Auth first)
-- The UUIDs below are examples - replace with actual auth.users IDs after signup

-- Insert admin user profile
INSERT INTO users (id, email, first_name, last_name, status, is_active) VALUES
('00000000-0000-0000-0000-000000000001', 'admin@dce-platform.com', 'Admin', 'User', 'active', true)
ON CONFLICT (id) DO UPDATE SET
  email = EXCLUDED.email,
  first_name = EXCLUDED.first_name,
  last_name = EXCLUDED.last_name,
  status = EXCLUDED.status,
  is_active = EXCLUDED.is_active;

-- Insert test admin record
INSERT INTO admins (user_id, role, permissions, is_active) VALUES
('00000000-0000-0000-0000-000000000001', 'super_admin', '{"super_admin": true, "user_management": true, "financial_management": true}', true)
ON CONFLICT (user_id) DO UPDATE SET
  role = EXCLUDED.role,
  permissions = EXCLUDED.permissions,
  is_active = EXCLUDED.is_active;

-- Insert test supplier user
INSERT INTO users (id, email, first_name, last_name, status, is_active) VALUES
('11111111-1111-1111-1111-111111111111', 'supplier@test.com', 'Test', 'Supplier', 'active', true)
ON CONFLICT (id) DO UPDATE SET
  email = EXCLUDED.email,
  first_name = EXCLUDED.first_name,
  last_name = EXCLUDED.last_name,
  status = EXCLUDED.status,
  is_active = EXCLUDED.is_active;

-- Insert test supplier record
INSERT INTO suppliers (user_id, company_name, business_type, credit_balance, status, approved_at, approved_by) VALUES
('11111111-1111-1111-1111-111111111111', 'Test Traffic Co', 'Lead Generation', 1500.00, 'active', NOW(), (SELECT id FROM admins WHERE role = 'super_admin' LIMIT 1))
ON CONFLICT (user_id) DO UPDATE SET
  company_name = EXCLUDED.company_name,
  business_type = EXCLUDED.business_type,
  credit_balance = EXCLUDED.credit_balance,
  status = EXCLUDED.status;

-- Insert test buyer users
INSERT INTO users (id, email, first_name, last_name, status, is_active) VALUES
('22222222-2222-2222-2222-222222222222', 'buyer@test.com', 'Test', 'Buyer', 'active', true),
('33333333-3333-3333-3333-333333333333', 'buyer2@test.com', 'Premium', 'Buyer', 'active', true)
ON CONFLICT (id) DO UPDATE SET
  email = EXCLUDED.email,
  first_name = EXCLUDED.first_name,
  last_name = EXCLUDED.last_name,
  status = EXCLUDED.status,
  is_active = EXCLUDED.is_active;

-- Insert test buyer records
INSERT INTO buyers (user_id, company_name, business_type, credit_limit, current_balance, status, approved_at, approved_by) VALUES
('22222222-2222-2222-2222-222222222222', 'Insurance Plus LLC', 'Insurance', 10000.00, 8500.00, 'active', NOW(), (SELECT id FROM admins WHERE role = 'super_admin' LIMIT 1)),
('33333333-3333-3333-3333-333333333333', 'Premium Legal Services', 'Legal Services', 25000.00, 22000.00, 'active', NOW(), (SELECT id FROM admins WHERE role = 'super_admin' LIMIT 1))
ON CONFLICT (user_id) DO UPDATE SET
  company_name = EXCLUDED.company_name,
  business_type = EXCLUDED.business_type,
  credit_limit = EXCLUDED.credit_limit,
  current_balance = EXCLUDED.current_balance,
  status = EXCLUDED.status;

-- Insert test campaigns
INSERT INTO campaigns (
  id, supplier_id, name, description, category, vertical, 
  targeting, bid_floor, max_concurrent_calls, status,
  quality_threshold, recording_enabled
) VALUES
(
  'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa',
  (SELECT id FROM suppliers WHERE user_id = '11111111-1111-1111-1111-111111111111'),
  'Auto Insurance Leads - Florida',
  'High-quality auto insurance leads from Florida residents',
  'Insurance',
  'Auto Insurance',
  '{"geographic": {"states": ["FL"], "cities": ["Miami", "Orlando", "Tampa"]}, "demographic": {"age_range": "25-65", "income_level": "middle"}, "schedule": {"enabled": true, "timezone": "EST", "hours": {"monday": {"start": 9, "end": 18}, "tuesday": {"start": 9, "end": 18}, "wednesday": {"start": 9, "end": 18}, "thursday": {"start": 9, "end": 18}, "friday": {"start": 9, "end": 18}}}}',
  15.00,
  5,
  'active',
  75,
  true
),
(
  'bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb',
  (SELECT id FROM suppliers WHERE user_id = '11111111-1111-1111-1111-111111111111'),
  'Personal Injury Legal Leads',
  'Qualified personal injury leads for law firms',
  'Legal',
  'Personal Injury',
  '{"geographic": {"states": ["CA", "NY", "TX"], "metro_areas": ["Los Angeles", "New York", "Houston"]}, "demographic": {"age_range": "18-75"}, "schedule": {"enabled": true, "timezone": "PST", "hours": {"monday": {"start": 8, "end": 20}, "tuesday": {"start": 8, "end": 20}, "wednesday": {"start": 8, "end": 20}, "thursday": {"start": 8, "end": 20}, "friday": {"start": 8, "end": 20}}}}',
  85.00,
  10,
  'active',
  80,
  true
)
ON CONFLICT (id) DO UPDATE SET
  name = EXCLUDED.name,
  description = EXCLUDED.description,
  category = EXCLUDED.category,
  vertical = EXCLUDED.vertical,
  targeting = EXCLUDED.targeting,
  bid_floor = EXCLUDED.bid_floor,
  status = EXCLUDED.status;

-- Insert tracking numbers for campaigns
INSERT INTO tracking_numbers (campaign_id, number, display_number, area_code, is_active) VALUES
((SELECT id FROM campaigns WHERE name = 'Auto Insurance Leads - Florida'), '8005551234', '(800) 555-1234', '800', true),
((SELECT id FROM campaigns WHERE name = 'Auto Insurance Leads - Florida'), '8005551235', '(800) 555-1235', '800', true),
((SELECT id FROM campaigns WHERE name = 'Personal Injury Legal Leads'), '8005556789', '(800) 555-6789', '800', true),
((SELECT id FROM campaigns WHERE name = 'Personal Injury Legal Leads'), '8005556790', '(800) 555-6790', '800', true)
ON CONFLICT (number) DO UPDATE SET
  display_number = EXCLUDED.display_number,
  area_code = EXCLUDED.area_code,
  is_active = EXCLUDED.is_active;

-- Insert test buyer campaigns
INSERT INTO buyer_campaigns (
  id, buyer_id, name, description, targeting_criteria, 
  max_bid, daily_budget, monthly_budget, status,
  quality_requirements, auto_approval_enabled
) VALUES
(
  'cccccccc-cccc-cccc-cccc-cccccccccccc',
  (SELECT id FROM buyers WHERE user_id = '22222222-2222-2222-2222-222222222222'),
  'Florida Auto Insurance Campaign',
  'Buying auto insurance leads in Florida market',
  '{"geographic": {"states": ["FL"]}, "vertical": ["Auto Insurance"], "call_duration_min": 60, "quality_score_min": 70}',
  20.00,
  500.00,
  15000.00,
  'active',
  '{"minimum_duration": 45, "minimum_quality_score": 70, "required_fields": ["name", "phone", "email"]}',
  true
),
(
  'dddddddd-dddd-dddd-dddd-dddddddddddd',
  (SELECT id FROM buyers WHERE user_id = '33333333-3333-3333-3333-333333333333'),
  'Personal Injury Leads - Multi-State',
  'High-value personal injury leads across multiple states',
  '{"geographic": {"states": ["CA", "NY", "TX"]}, "vertical": ["Personal Injury"], "call_duration_min": 120, "quality_score_min": 80}',
  150.00,
  2000.00,
  60000.00,
  'active',
  '{"minimum_duration": 90, "minimum_quality_score": 80, "required_fields": ["name", "phone", "email", "injury_type"]}',
  false
)
ON CONFLICT (id) DO UPDATE SET
  name = EXCLUDED.name,
  description = EXCLUDED.description,
  targeting_criteria = EXCLUDED.targeting_criteria,
  max_bid = EXCLUDED.max_bid,
  daily_budget = EXCLUDED.daily_budget,
  monthly_budget = EXCLUDED.monthly_budget,
  status = EXCLUDED.status;

-- Insert sample calls data
INSERT INTO calls (
  id, campaign_id, buyer_campaign_id, tracking_number, 
  caller_number, destination_number, started_at, ended_at,
  duration_seconds, payout_amount, charge_amount, margin_amount,
  status, quality_score, caller_location, metadata
) VALUES
(
  'cccc1111-1111-1111-1111-111111111111',
  'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa',
  'cccccccc-cccc-cccc-cccc-cccccccccccc',
  '8005551234',
  '+13055551111',
  '+13055552222',
  NOW() - INTERVAL '2 hours',
  NOW() - INTERVAL '2 hours' + INTERVAL '185 seconds',
  185,
  18.50,
  20.00,
  1.50,
  'completed',
  85,
  '{"city": "Miami", "state": "FL", "country": "US", "zip": "33101"}',
  '{"intent_confirmed": true, "lead_quality": "high", "notes": "Interested in auto insurance quote"}'
),
(
  'cccc2222-2222-2222-2222-222222222222',
  'bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb',
  'dddddddd-dddd-dddd-dddd-dddddddddddd',
  '8005556789',
  '+12125553333',
  '+12125554444',
  NOW() - INTERVAL '1 hour',
  NOW() - INTERVAL '1 hour' + INTERVAL '320 seconds',
  320,
  127.50,
  150.00,
  22.50,
  'completed',
  92,
  '{"city": "New York", "state": "NY", "country": "US", "zip": "10001"}',
  '{"intent_confirmed": true, "injury_type": "car_accident", "lead_quality": "premium", "attorney_needed": true}'
),
(
  'cccc3333-3333-3333-3333-333333333333',
  'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa',
  'cccccccc-cccc-cccc-cccc-cccccccccccc',
  '8005551235',
  '+14075556666',
  '+14075557777',
  NOW() - INTERVAL '30 minutes',
  NOW() - INTERVAL '30 minutes' + INTERVAL '45 seconds',
  45,
  9.25,
  10.00,
  0.75,
  'completed',
  65,
  '{"city": "Orlando", "state": "FL", "country": "US", "zip": "32801"}',
  '{"intent_confirmed": false, "lead_quality": "low", "notes": "Short call, limited interest"}'
)
ON CONFLICT (id) DO UPDATE SET
  duration_seconds = EXCLUDED.duration_seconds,
  payout_amount = EXCLUDED.payout_amount,
  charge_amount = EXCLUDED.charge_amount,
  margin_amount = EXCLUDED.margin_amount,
  status = EXCLUDED.status,
  quality_score = EXCLUDED.quality_score;

-- Insert call quality scores for the sample calls
INSERT INTO call_quality_scores (
  call_id, duration_score, intent_score, content_score, 
  technical_score, overall_score, scoring_model, flags
) VALUES
(
  'cccc1111-1111-1111-1111-111111111111',
  90, 85, 80, 85, 85, 'v1.0', '[]'
),
(
  'cccc2222-2222-2222-2222-222222222222',
  95, 95, 90, 88, 92, 'v1.0', '[]'
),
(
  'cccc3333-3333-3333-3333-333333333333',
  45, 50, 65, 75, 65, 'v1.0', '["short_duration", "low_intent"]'
)
ON CONFLICT (call_id) DO UPDATE SET
  duration_score = EXCLUDED.duration_score,
  intent_score = EXCLUDED.intent_score,
  overall_score = EXCLUDED.overall_score;

-- Insert sample campaign stats
INSERT INTO campaign_stats (
  campaign_id, date, calls_count, connected_calls, completed_calls,
  total_duration, avg_duration, total_payout, avg_payout, quality_score_avg
) VALUES
(
  'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa',
  CURRENT_DATE,
  2, 2, 2, 230, 115.0, 27.75, 13.88, 75.0
),
(
  'bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb',
  CURRENT_DATE,
  1, 1, 1, 320, 320.0, 127.50, 127.50, 92.0
)
ON CONFLICT (campaign_id, date, hour) DO UPDATE SET
  calls_count = EXCLUDED.calls_count,
  connected_calls = EXCLUDED.connected_calls,
  completed_calls = EXCLUDED.completed_calls,
  total_duration = EXCLUDED.total_duration,
  avg_duration = EXCLUDED.avg_duration,
  total_payout = EXCLUDED.total_payout,
  avg_payout = EXCLUDED.avg_payout,
  quality_score_avg = EXCLUDED.quality_score_avg;

-- Insert sample buyer campaign stats
INSERT INTO buyer_campaign_stats (
  buyer_campaign_id, date, calls_received, calls_accepted, calls_completed,
  total_cost, avg_cost, total_duration, avg_duration, quality_score_avg
) VALUES
(
  'cccccccc-cccc-cccc-cccc-cccccccccccc',
  CURRENT_DATE,
  2, 2, 2, 30.00, 15.00, 230, 115.0, 75.0
),
(
  'dddddddd-dddd-dddd-dddd-dddddddddddd',
  CURRENT_DATE,
  1, 1, 1, 150.00, 150.00, 320, 320.0, 92.0
)
ON CONFLICT (buyer_campaign_id, date, hour) DO UPDATE SET
  calls_received = EXCLUDED.calls_received,
  calls_accepted = EXCLUDED.calls_accepted,
  calls_completed = EXCLUDED.calls_completed,
  total_cost = EXCLUDED.total_cost,
  avg_cost = EXCLUDED.avg_cost,
  total_duration = EXCLUDED.total_duration,
  avg_duration = EXCLUDED.avg_duration,
  quality_score_avg = EXCLUDED.quality_score_avg;

-- Insert sample invoice
INSERT INTO invoices (
  buyer_id, invoice_number, amount, tax_amount, total_amount,
  status, period_start, period_end, due_date, payment_terms
) VALUES
(
  (SELECT id FROM buyers WHERE user_id = '22222222-2222-2222-2222-222222222222'),
  'INV-2024-000001',
  30.00,
  2.40,
  32.40,
  'open',
  CURRENT_DATE - INTERVAL '7 days',
  CURRENT_DATE,
  CURRENT_DATE + INTERVAL '30 days',
  30
)
ON CONFLICT (invoice_number) DO UPDATE SET
  amount = EXCLUDED.amount,
  tax_amount = EXCLUDED.tax_amount,
  total_amount = EXCLUDED.total_amount;

-- Insert invoice line items
INSERT INTO invoice_line_items (
  invoice_id, description, quantity, unit_price, total_amount, call_id
) VALUES
(
  (SELECT id FROM invoices WHERE invoice_number = 'INV-2024-000001'),
  'Auto Insurance Call - Miami, FL (185s)',
  1,
  20.0000,
  20.00,
  'cccc1111-1111-1111-1111-111111111111'
),
(
  (SELECT id FROM invoices WHERE invoice_number = 'INV-2024-000001'),
  'Auto Insurance Call - Orlando, FL (45s)',
  1,
  10.0000,
  10.00,
  'cccc3333-3333-3333-3333-333333333333'
)
ON CONFLICT DO NOTHING;

-- Insert sample payout
INSERT INTO payouts (
  supplier_id, amount, fee_amount, net_amount, status,
  period_start, period_end, payment_method, reference_number
) VALUES
(
  (SELECT id FROM suppliers WHERE user_id = '11111111-1111-1111-1111-111111111111'),
  155.25,
  7.76,
  147.49,
  'pending',
  CURRENT_DATE - INTERVAL '7 days',
  CURRENT_DATE,
  'bank_transfer',
  'PAY-2024-000001'
)
ON CONFLICT DO NOTHING;

-- Update supplier balance based on completed calls
UPDATE suppliers 
SET credit_balance = calculate_supplier_balance(id)
WHERE user_id = '11111111-1111-1111-1111-111111111111';

-- Update buyer balance based on charges
UPDATE buyers 
SET current_balance = calculate_buyer_balance(id)
WHERE user_id IN ('22222222-2222-2222-2222-222222222222', '33333333-3333-3333-3333-333333333333');

-- Comments
COMMENT ON TABLE users IS 'Seed data includes admin, supplier, and buyer test accounts';
COMMENT ON TABLE campaigns IS 'Sample campaigns for auto insurance and legal verticals';
COMMENT ON TABLE calls IS 'Sample call data with varying quality scores and durations';
COMMENT ON TABLE invoices IS 'Sample billing data for testing payment flows';
</file>

<file path="tests/unit/integrations/stripe/webhooks.test.ts">
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import {
  verifyWebhookSignature,
  handleStripeWebhook,
  timingSafeEqual,
} from '@/integrations/stripe/webhooks'
import { stripeServerClient } from '@/integrations/stripe/client'
import { supabase } from '@/lib/supabase'
import type { Request, Response } from 'express'
import type Stripe from 'stripe'

// Mock dependencies
vi.mock('@/integrations/stripe/client', () => ({
  stripeServerClient: {
    webhooks: {
      constructEvent: vi.fn(),
    },
  },
  stripeConfig: {
    webhookSecret: 'whsec_test_secret',
  },
}))

vi.mock('@/lib/supabase', () => ({
  supabase: {
    from: vi.fn(() => ({
      insert: vi.fn(() => ({ error: null })),
      update: vi.fn(() => ({ error: null })),
      select: vi.fn(() => ({
        eq: vi.fn(() => ({
          single: vi.fn(() => ({ data: null, error: null })),
        })),
        gte: vi.fn(() => ({ data: [], error: null })),
      })),
      eq: vi.fn(() => ({ error: null })),
    })),
    raw: vi.fn((sql: string) => sql),
  },
}))

describe('Stripe Webhook Handler', () => {
  let mockRequest: Partial<Request>
  let mockResponse: Partial<Response>
  let statusMock: vi.Mock
  let jsonMock: vi.Mock
  let sendMock: vi.Mock

  beforeEach(() => {
    statusMock = vi.fn().mockReturnThis()
    jsonMock = vi.fn().mockReturnThis()
    sendMock = vi.fn().mockReturnThis()

    mockRequest = {
      body: 'test-body',
      headers: {
        'stripe-signature': 'test-signature',
      },
    }

    mockResponse = {
      status: statusMock,
      json: jsonMock,
      send: sendMock,
    }

    vi.clearAllMocks()
  })

  afterEach(() => {
    vi.clearAllMocks()
  })

  describe('verifyWebhookSignature', () => {
    it('should verify valid webhook signature', () => {
      const mockEvent = { id: 'evt_123', type: 'payment_intent.succeeded' }
      vi.mocked(stripeServerClient.webhooks.constructEvent).mockReturnValue(
        mockEvent as Stripe.Event
      )

      const result = verifyWebhookSignature('payload', 'signature')

      expect(result).toEqual(mockEvent)
      expect(stripeServerClient.webhooks.constructEvent).toHaveBeenCalledWith(
        'payload',
        'signature',
        'whsec_test_secret'
      )
    })

    it('should throw error for invalid signature', () => {
      vi.mocked(stripeServerClient.webhooks.constructEvent).mockImplementation(() => {
        throw new Error('Invalid signature')
      })

      expect(() => verifyWebhookSignature('payload', 'signature')).toThrow(
        'Webhook signature verification failed: Invalid signature'
      )
    })
  })

  describe('handleStripeWebhook', () => {
    it('should return 400 if stripe-signature header is missing', async () => {
      mockRequest.headers = {}

      await handleStripeWebhook(mockRequest as Request, mockResponse as Response)

      expect(statusMock).toHaveBeenCalledWith(400)
      expect(sendMock).toHaveBeenCalledWith('Missing stripe-signature header')
    })

    it('should return 400 if signature verification fails', async () => {
      vi.mocked(stripeServerClient.webhooks.constructEvent).mockImplementation(() => {
        throw new Error('Invalid signature')
      })

      await handleStripeWebhook(mockRequest as Request, mockResponse as Response)

      expect(statusMock).toHaveBeenCalledWith(400)
      expect(sendMock).toHaveBeenCalledWith('Webhook Error: Invalid signature')
    })

    it('should handle payment_intent.succeeded event', async () => {
      const mockEvent = {
        id: 'evt_123',
        type: 'payment_intent.succeeded',
        data: {
          object: {
            id: 'pi_123',
            amount: 10000,
            metadata: {
              buyer_id: 'buyer_123',
            },
          },
        },
      }

      vi.mocked(stripeServerClient.webhooks.constructEvent).mockReturnValue(
        mockEvent as Stripe.Event
      )

      const updateMock = vi.fn(() => ({
        eq: vi.fn(() => ({ error: null })),
      }))

      const fromMock = vi.fn(() => ({
        update: updateMock,
      }))

      vi.mocked(supabase.from).mockImplementation(fromMock as ReturnType<typeof vi.fn>)

      await handleStripeWebhook(mockRequest as Request, mockResponse as Response)

      expect(fromMock).toHaveBeenCalledWith('invoices')
      expect(updateMock).toHaveBeenCalledWith({
        status: 'paid',
        paid_at: expect.any(String),
        payment_method: 'stripe',
        stripe_payment_intent_id: 'pi_123',
      })

      expect(fromMock).toHaveBeenCalledWith('buyers')
      expect(jsonMock).toHaveBeenCalledWith({ received: true })
    })

    it('should handle payment_intent.payment_failed event', async () => {
      const mockEvent = {
        id: 'evt_123',
        type: 'payment_intent.payment_failed',
        data: {
          object: {
            id: 'pi_123',
            metadata: {
              buyer_id: 'buyer_123',
            },
            last_payment_error: {
              message: 'Card declined',
            },
          },
        },
      }

      vi.mocked(stripeServerClient.webhooks.constructEvent).mockReturnValue(
        mockEvent as Stripe.Event
      )

      await handleStripeWebhook(mockRequest as Request, mockResponse as Response)

      expect(jsonMock).toHaveBeenCalledWith({ received: true })
    })

    it('should handle charge.dispute.created event', async () => {
      const mockEvent = {
        id: 'evt_123',
        type: 'charge.dispute.created',
        data: {
          object: {
            id: 'dp_123',
            amount: 5000,
            charge: 'ch_123',
            reason: 'fraudulent',
            metadata: {
              call_id: 'call_123',
              buyer_id: 'buyer_123',
            },
            evidence_details: {},
          },
        },
      }

      vi.mocked(stripeServerClient.webhooks.constructEvent).mockReturnValue(
        mockEvent as Stripe.Event
      )

      const insertMock = vi.fn(() => ({ error: null }))
      const fromMock = vi.fn(() => ({
        insert: insertMock,
      }))

      vi.mocked(supabase.from).mockImplementation(fromMock as ReturnType<typeof vi.fn>)

      await handleStripeWebhook(mockRequest as Request, mockResponse as Response)

      expect(fromMock).toHaveBeenCalledWith('disputes')
      expect(insertMock).toHaveBeenCalledWith({
        call_id: 'call_123',
        raised_by: 'buyer_123',
        dispute_type: 'billing',
        reason: 'Stripe dispute: fraudulent',
        description: 'Dispute created for charge ch_123. Reason: fraudulent',
        amount_disputed: 50,
        status: 'open',
        priority: 'high',
        evidence: [
          {
            type: 'stripe_dispute',
            dispute_id: 'dp_123',
            reason: 'fraudulent',
            evidence_details: {},
          },
        ],
      })

      expect(jsonMock).toHaveBeenCalledWith({ received: true })
    })

    it('should handle account.updated event', async () => {
      const mockEvent = {
        id: 'evt_123',
        type: 'account.updated',
        data: {
          object: {
            id: 'acct_123',
            charges_enabled: true,
            payouts_enabled: true,
            details_submitted: true,
            requirements: {
              currently_due: [],
            },
          },
        },
      }

      vi.mocked(stripeServerClient.webhooks.constructEvent).mockReturnValue(
        mockEvent as Stripe.Event
      )

      const singleMock = vi.fn(() => ({
        data: { id: 'supplier_123', user_id: 'user_123' },
        error: null,
      }))

      const eqMock = vi.fn(() => ({
        single: singleMock,
      }))

      const selectMock = vi.fn(() => ({
        eq: eqMock,
      }))

      const updateMock = vi.fn(() => ({
        eq: vi.fn(() => ({ error: null })),
      }))

      const fromMock = vi.fn((table: string) => {
        if (table === 'suppliers' && !updateMock.mock.calls.length) {
          return { select: selectMock }
        }
        return { update: updateMock }
      })

      vi.mocked(supabase.from).mockImplementation(fromMock as ReturnType<typeof vi.fn>)

      await handleStripeWebhook(mockRequest as Request, mockResponse as Response)

      expect(jsonMock).toHaveBeenCalledWith({ received: true })
    })

    it('should handle unhandled event types', async () => {
      const mockEvent = {
        id: 'evt_123',
        type: 'unknown.event',
        data: {
          object: {},
        },
      }

      vi.mocked(stripeServerClient.webhooks.constructEvent).mockReturnValue(
        mockEvent as Stripe.Event
      )

      await handleStripeWebhook(mockRequest as Request, mockResponse as Response)

      expect(jsonMock).toHaveBeenCalledWith({ received: true })
    })

    it('should handle webhook handler errors', async () => {
      const mockEvent = {
        id: 'evt_123',
        type: 'payment_intent.succeeded',
        data: {
          object: {
            id: 'pi_123',
            metadata: {},
          },
        },
      }

      vi.mocked(stripeServerClient.webhooks.constructEvent).mockReturnValue(
        mockEvent as Stripe.Event
      )
      vi.mocked(supabase.from).mockImplementation(() => {
        throw new Error('Database error')
      })

      await handleStripeWebhook(mockRequest as Request, mockResponse as Response)

      expect(statusMock).toHaveBeenCalledWith(500)
      expect(sendMock).toHaveBeenCalledWith('Webhook handler error: Database error')
    })
  })

  describe('timingSafeEqual', () => {
    it('should return true for equal strings', () => {
      expect(timingSafeEqual('test123', 'test123')).toBe(true)
    })

    it('should return false for different strings', () => {
      expect(timingSafeEqual('test123', 'test456')).toBe(false)
    })

    it('should return false for strings of different lengths', () => {
      expect(timingSafeEqual('test', 'test123')).toBe(false)
    })
  })
})
</file>

<file path="tests/unit/store/buyerStore.test.ts">
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { useBuyerStore } from '@/store/buyerStore'
import { supabase } from '@/lib/supabase'

// Mock Supabase
vi.mock('@/lib/supabase', () => ({
  supabase: {
    from: vi.fn(() => ({
      select: vi.fn(() => ({
        eq: vi.fn(() => ({
          single: vi.fn(() => Promise.resolve({ data: null, error: null })),
        })),
        order: vi.fn(() => Promise.resolve({ data: [], error: null })),
      })),
    })),
  },
}))

describe('BuyerStore', () => {
  beforeEach(() => {
    // Reset store to initial state before each test
    useBuyerStore.getState().reset()
    vi.clearAllMocks()
  })

  it('should have initial state', () => {
    const state = useBuyerStore.getState()

    expect(state.currentBalance).toBe(0)
    expect(state.creditLimit).toBe(0)
    expect(state.campaigns).toEqual([])
    expect(state.isLoading).toBe(false)
    expect(state.error).toBe(null)
  })

  describe('fetchBalance', () => {
    it('should fetch and update balance successfully', async () => {
      const mockBalance = {
        current_balance: 1500.5,
        credit_limit: 5000.0,
      }

      vi.mocked(supabase.from).mockReturnValue({
        select: vi.fn().mockReturnValue({
          eq: vi.fn().mockReturnValue({
            single: vi.fn().mockResolvedValue({
              data: mockBalance,
              error: null,
            }),
          }),
        }),
      } as ReturnType<typeof vi.fn>)

      const store = useBuyerStore.getState()
      await store.fetchBalance('buyer_123')

      const updatedState = useBuyerStore.getState()
      expect(updatedState.currentBalance).toBe(1500.5)
      expect(updatedState.creditLimit).toBe(5000.0)
      expect(updatedState.isLoading).toBe(false)
      expect(updatedState.error).toBe(null)
    })

    it('should handle null balance values', async () => {
      const mockBalance = {
        current_balance: null,
        credit_limit: null,
      }

      vi.mocked(supabase.from).mockReturnValue({
        select: vi.fn().mockReturnValue({
          eq: vi.fn().mockReturnValue({
            single: vi.fn().mockResolvedValue({
              data: mockBalance,
              error: null,
            }),
          }),
        }),
      } as ReturnType<typeof vi.fn>)

      const store = useBuyerStore.getState()
      await store.fetchBalance('buyer_123')

      const updatedState = useBuyerStore.getState()
      expect(updatedState.currentBalance).toBe(0)
      expect(updatedState.creditLimit).toBe(0)
    })

    it('should handle fetch balance error', async () => {
      const mockError = new Error('Database error')

      vi.mocked(supabase.from).mockReturnValue({
        select: vi.fn().mockReturnValue({
          eq: vi.fn().mockReturnValue({
            single: vi.fn().mockResolvedValue({
              data: null,
              error: mockError,
            }),
          }),
        }),
      } as ReturnType<typeof vi.fn>)

      const store = useBuyerStore.getState()
      await store.fetchBalance('buyer_123')

      const updatedState = useBuyerStore.getState()
      expect(updatedState.error).toBe('Database error')
      expect(updatedState.isLoading).toBe(false)
    })
  })

  describe('updateBalance', () => {
    it('should update balance immediately', () => {
      const store = useBuyerStore.getState()
      store.updateBalance(2500.75)

      const updatedState = useBuyerStore.getState()
      expect(updatedState.currentBalance).toBe(2500.75)
    })
  })

  describe('fetchCampaigns', () => {
    it('should fetch campaigns successfully', async () => {
      const mockCampaigns = [
        { id: '1', name: 'Campaign 1', status: 'active' },
        { id: '2', name: 'Campaign 2', status: 'paused' },
      ]

      vi.mocked(supabase.from).mockReturnValue({
        select: vi.fn().mockReturnValue({
          eq: vi.fn().mockReturnValue({
            order: vi.fn().mockResolvedValue({
              data: mockCampaigns,
              error: null,
            }),
          }),
        }),
      } as ReturnType<typeof vi.fn>)

      const store = useBuyerStore.getState()
      await store.fetchCampaigns('buyer_123')

      const updatedState = useBuyerStore.getState()
      expect(updatedState.campaigns).toEqual(mockCampaigns)
      expect(updatedState.isLoading).toBe(false)
      expect(updatedState.error).toBe(null)
    })

    it('should handle empty campaigns array', async () => {
      vi.mocked(supabase.from).mockReturnValue({
        select: vi.fn().mockReturnValue({
          eq: vi.fn().mockReturnValue({
            order: vi.fn().mockResolvedValue({
              data: null,
              error: null,
            }),
          }),
        }),
      } as ReturnType<typeof vi.fn>)

      const store = useBuyerStore.getState()
      await store.fetchCampaigns('buyer_123')

      const updatedState = useBuyerStore.getState()
      expect(updatedState.campaigns).toEqual([])
    })

    it('should handle fetch campaigns error', async () => {
      const mockError = new Error('Failed to load campaigns')

      vi.mocked(supabase.from).mockReturnValue({
        select: vi.fn().mockReturnValue({
          eq: vi.fn().mockReturnValue({
            order: vi.fn().mockResolvedValue({
              data: null,
              error: mockError,
            }),
          }),
        }),
      } as ReturnType<typeof vi.fn>)

      const store = useBuyerStore.getState()
      await store.fetchCampaigns('buyer_123')

      const updatedState = useBuyerStore.getState()
      expect(updatedState.error).toBe('Failed to load campaigns')
      expect(updatedState.isLoading).toBe(false)
    })
  })

  describe('updateCampaign', () => {
    it('should update specific campaign', () => {
      // Set initial campaigns
      useBuyerStore.setState({
        campaigns: [
          { id: '1', name: 'Campaign 1', status: 'active' as const },
          { id: '2', name: 'Campaign 2', status: 'active' as const },
        ],
      })

      const store = useBuyerStore.getState()
      store.updateCampaign('2', { status: 'paused' })

      const updatedState = useBuyerStore.getState()
      expect(updatedState.campaigns[0].status).toBe('active')
      expect(updatedState.campaigns[1].status).toBe('paused')
    })

    it('should not modify campaigns if id not found', () => {
      const initialCampaigns = [{ id: '1', name: 'Campaign 1', status: 'active' as const }]

      useBuyerStore.setState({ campaigns: initialCampaigns })

      const store = useBuyerStore.getState()
      store.updateCampaign('999', { status: 'paused' })

      const updatedState = useBuyerStore.getState()
      expect(updatedState.campaigns).toEqual(initialCampaigns)
    })
  })

  describe('clearError', () => {
    it('should clear error message', () => {
      useBuyerStore.setState({ error: 'Test error' })

      const store = useBuyerStore.getState()
      store.clearError()

      const updatedState = useBuyerStore.getState()
      expect(updatedState.error).toBe(null)
    })
  })

  describe('reset', () => {
    it('should reset store to initial state', () => {
      // Set some state
      useBuyerStore.setState({
        currentBalance: 1000,
        creditLimit: 5000,
        campaigns: [{ id: '1', name: 'Test', status: 'active' as const }],
        isLoading: true,
        error: 'Some error',
      })

      const store = useBuyerStore.getState()
      store.reset()

      const updatedState = useBuyerStore.getState()
      expect(updatedState).toEqual({
        currentBalance: 0,
        creditLimit: 0,
        campaigns: [],
        isLoading: false,
        error: null,
        fetchBalance: expect.any(Function),
        updateBalance: expect.any(Function),
        fetchCampaigns: expect.any(Function),
        updateCampaign: expect.any(Function),
        clearError: expect.any(Function),
        reset: expect.any(Function),
      })
    })
  })

  describe('loading states', () => {
    it('should set isLoading during fetchBalance', async () => {
      const loadingStatesDuringFetch: boolean[] = []

      // Mock a delayed response
      vi.mocked(supabase.from).mockReturnValue({
        select: vi.fn().mockReturnValue({
          eq: vi.fn().mockReturnValue({
            single: vi.fn().mockImplementation(() => {
              loadingStatesDuringFetch.push(useBuyerStore.getState().isLoading)
              return Promise.resolve({
                data: { current_balance: 100, credit_limit: 500 },
                error: null,
              })
            }),
          }),
        }),
      } as ReturnType<typeof vi.fn>)

      const store = useBuyerStore.getState()
      expect(store.isLoading).toBe(false)

      await store.fetchBalance('buyer_123')

      expect(loadingStatesDuringFetch[0]).toBe(true)
      expect(useBuyerStore.getState().isLoading).toBe(false)
    })
  })
})
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

# Environment variables
.env
.env.local
.env.production

# Supabase
supabase/.branches
supabase/.temp

# Claude AI settings
.claude/

# Test outputs
coverage/
playwright-report/
test-results/
.nyc_output/

# Monitoring files
monitor.log
</file>

<file path="app.css">
@import "tailwindcss";

@theme {
  --color-primary-50: #eff6ff;
  --color-primary-100: #dbeafe;
  --color-primary-200: #bfdbfe;
  --color-primary-300: #93bbfd;
  --color-primary-400: #60a5fa;
  --color-primary-500: #3b82f6;
  --color-primary-600: #2563eb;
  --color-primary-700: #1d4ed8;
  --color-primary-800: #1e40af;
  --color-primary-900: #1e3a8a;
}

/* Ensure proper scrolling behavior */
html, body {
  height: 100%;
  overflow-x: hidden;
  overflow-y: auto;
  scroll-behavior: smooth;
}

#root {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

/* Offset for fixed header navigation */
.scroll-offset {
  scroll-margin-top: 80px;
}

/* Ensure main content expands properly */
main > * {
  flex: 1;
}
</file>

<file path="README.md">
# DCE Platform - Dependable Calls Exchange

A modern pay-per-call network platform connecting suppliers (traffic providers) with buyers (advertisers) for high-quality lead generation.

## ðŸš€ Overview

DCE Platform facilitates real-time call tracking, lead management, and automated billing for performance-based marketing campaigns. Built with cutting-edge technologies for reliability, scalability, and real-time performance.

### Key Features

- **Real-time Call Tracking** - Monitor calls as they happen with live status updates
- **Campaign Management** - Create and manage targeted campaigns with advanced filtering
- **Fraud Prevention** - Built-in fraud detection and quality scoring
- **Automated Billing** - Stripe integration for seamless payments and payouts
- **Role-based Access** - Separate interfaces for suppliers, buyers, and administrators
- **Analytics Dashboard** - Comprehensive reporting and performance metrics

## ðŸ› ï¸ Technology Stack

- **Frontend**: Vite 7.0 + React 19.1 + TypeScript 5.8
- **Styling**: Tailwind CSS 4.1 + Headless UI 2.2
- **Backend**: Supabase (PostgreSQL + Auth + Realtime)
- **State Management**: Zustand 5.0 + React Query 5.83
- **Payments**: Stripe 18.3
- **Testing**: Vitest 3.2 + Playwright 1.54
- **Hosting**: Netlify with Edge Functions

## ðŸ“‹ Prerequisites

- Node.js 22.15.0 or higher
- npm 10.x or higher
- Supabase CLI
- Stripe CLI (for webhook testing)

## ðŸš€ Quick Start

### 1. Clone the repository

```bash
git clone https://github.com/your-org/dce-website.git
cd dce-website
```

### 2. Install dependencies

```bash
npm install
```

### 3. Set up environment variables

```bash
cp .env.example .env.local
```

Edit `.env.local` with your credentials:

```env
# Supabase
VITE_SUPABASE_URL=your-supabase-url
VITE_SUPABASE_ANON_KEY=your-supabase-anon-key

# Stripe
VITE_STRIPE_PUBLIC_KEY=your-stripe-public-key
STRIPE_SECRET_KEY=your-stripe-secret-key
STRIPE_WEBHOOK_SECRET=your-webhook-secret

# Sentry (optional)
VITE_SENTRY_DSN=your-sentry-dsn
```

### 4. Set up the database

```bash
# Start Supabase locally
npx supabase start

# Run migrations
npx supabase db push

# Seed test data (optional)
npx supabase db seed
```

### 5. Start the development server

```bash
npm run dev
```

Visit [http://localhost:5173](http://localhost:5173)

## ðŸ—ï¸ Project Structure

```
dce-website/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ components/     # Reusable React components
â”‚   â”œâ”€â”€ pages/         # Route-based page components
â”‚   â”œâ”€â”€ hooks/         # Custom React hooks
â”‚   â”œâ”€â”€ lib/           # Shared utilities
â”‚   â”œâ”€â”€ store/         # Zustand state management
â”‚   â”œâ”€â”€ services/      # Business logic layer
â”‚   â”œâ”€â”€ integrations/  # Third-party integrations
â”‚   â”œâ”€â”€ types/         # TypeScript definitions
â”‚   â””â”€â”€ utils/         # Helper functions
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ unit/          # Unit tests
â”‚   â”œâ”€â”€ integration/   # Integration tests
â”‚   â”œâ”€â”€ e2e/          # End-to-end tests
â”‚   â””â”€â”€ fixtures/      # Test data
â”œâ”€â”€ supabase/
â”‚   â”œâ”€â”€ migrations/    # Database migrations
â”‚   â””â”€â”€ functions/     # Edge functions
â””â”€â”€ .github/
    â””â”€â”€ workflows/     # CI/CD pipelines
```

## ðŸ§ª Testing

```bash
# Run unit tests
npm test

# Run tests with coverage
npm run test:ci

# Run E2E tests
npm run test:e2e

# Open test UI
npm run test:ui
```

## ðŸ“¦ Building for Production

```bash
# Type check
npm run type-check

# Lint code
npm run lint

# Build production bundle
npm run build

# Preview production build
npm run preview
```

## ðŸš¢ Deployment

The project is configured for automatic deployment to Netlify:

1. Push to `main` branch triggers production deployment
2. Pull requests create preview deployments
3. Environment variables are managed in Netlify dashboard

### Manual deployment

```bash
# Install Netlify CLI
npm install -g netlify-cli

# Deploy to production
netlify deploy --prod
```

## ðŸ”§ Development Guidelines

### Code Quality Rules

- **NO regex patterns** - Use validator.js or zod for validation
- **NO any types** - Always use proper TypeScript types
- **Fix all TypeScript/ESLint errors** immediately
- **90% test coverage minimum** for all code
- **Commit every 30 minutes** during active development

### Available Scripts

- `npm run dev` - Start development server
- `npm run build` - Build for production
- `npm run lint` - Run ESLint
- `npm run lint:fix` - Fix ESLint issues
- `npm run type-check` - Check TypeScript types
- `npm test` - Run tests
- `npm run test:ci` - Run tests with coverage
- `npm run test:e2e` - Run E2E tests

## ðŸ›ï¸ Architecture Overview

### Frontend Architecture

- **Pages**: Route-based components for each major section
- **Components**: Reusable UI components following atomic design
- **Hooks**: Custom hooks for data fetching and business logic
- **Store**: Centralized state management with Zustand
- **Services**: Abstraction layer for API calls and business logic

### Backend Architecture

- **Database**: PostgreSQL with Row Level Security (RLS)
- **Authentication**: Supabase Auth with JWT tokens
- **Real-time**: WebSocket connections for live updates
- **Edge Functions**: Serverless functions for complex operations
- **Webhooks**: Stripe integration for payment processing

### Security Features

- Row Level Security (RLS) for data access control
- Role-based permissions (Supplier/Buyer/Admin)
- Fraud detection algorithms
- Rate limiting on API endpoints
- Secure webhook verification

## ðŸ¤ User Roles

### Suppliers (Traffic Providers)

- Browse active campaigns
- Generate tracking numbers
- Monitor call performance
- Track earnings and payouts

### Buyers (Advertisers)

- Create and manage campaigns
- Set targeting criteria
- Monitor lead quality
- Manage billing and budgets

### Administrators

- Platform oversight
- User management
- Fraud investigation
- System configuration

## ðŸ“Š Key Features

### Call Tracking

- Real-time call status updates
- Duration tracking
- Quality scoring
- Automatic payout calculation

### Campaign Management

- Geographic targeting
- Time-based restrictions
- Budget controls
- Performance optimization

### Billing & Payments

- Automated invoicing
- Scheduled payouts
- Multiple payment methods
- Transaction history

### Analytics & Reporting

- Real-time dashboards
- Historical reports
- Export functionality
- Custom metrics

## ðŸ› Troubleshooting

### Common Issues

1. **Supabase connection errors**
   - Verify environment variables
   - Check Supabase service status
   - Ensure migrations are applied

2. **Stripe webhook failures**
   - Verify webhook secret
   - Use Stripe CLI for local testing
   - Check webhook logs in Stripe dashboard

3. **Build errors**
   - Clear node_modules and reinstall
   - Check TypeScript errors with `npm run type-check`
   - Ensure all environment variables are set

## ðŸ“š Documentation

- See `/CLAUDE.md` files in each directory for detailed patterns
- API documentation available at `/api/docs`
- Component storybook (if configured) at `npm run storybook`

## ðŸ¤ Contributing

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

### Commit Convention

Follow conventional commits:

- `feat:` New features
- `fix:` Bug fixes
- `docs:` Documentation changes
- `style:` Code style changes
- `refactor:` Code refactoring
- `test:` Test additions/changes
- `chore:` Build process updates

## ðŸ“„ License

This project is proprietary and confidential. All rights reserved.

## ðŸ†˜ Support

- Technical issues: tech-support@dependablecalls.com
- Business inquiries: info@dependablecalls.com
- Documentation: See `/docs` directory

---

Built with â¤ï¸ by the DCE Team
</file>

<file path="tsconfig.app.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true,

    /* Path mappings */
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src", "src/**/*.test.tsx", "src/**/*.spec.tsx"]
}
</file>

<file path="vite.config.ts">
/// <reference types="vitest" />
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import { resolve } from 'path'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': resolve(__dirname, './src'),
    },
  },
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: ['./src/test/setup.ts'],
    include: ['tests/unit/**/*.{test,spec}.{js,mjs,cjs,ts,mts,cts,jsx,tsx}'],
    exclude: ['tests/e2e/**/*', 'tests/performance/**/*'],
    coverage: {
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/',
        'src/test/',
        'src/**/*.test.{ts,tsx}',
        'src/**/*.spec.{ts,tsx}',
        'src/vite-env.d.ts',
        'tests/**/*',
      ],
    },
  },
})
</file>

<file path="src/components/common/ErrorBoundaryExample.tsx">
import React, { useState } from 'react'
import ErrorBoundary from './ErrorBoundary'
import type { ErrorFallbackProps } from './ErrorBoundary'
import { withErrorBoundary } from './withErrorBoundary'

/**
 * Custom error fallback component example
 */
const CustomErrorFallback: React.FC<ErrorFallbackProps> = ({ error, resetError, level }) => (
  <div className="p-6 bg-red-50 border border-red-200 rounded-lg">
    <h3 className="text-lg font-semibold text-red-900 mb-2">Custom Error Handler ({level})</h3>
    <p className="text-red-700 mb-4">Something went wrong: {error.message}</p>
    <button
      onClick={resetError}
      className="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700"
      type="button"
    >
      Reset
    </button>
  </div>
)

/**
 * Component that intentionally throws an error for testing
 */
const ProblematicComponent: React.FC<{ shouldThrow: boolean }> = ({ shouldThrow }) => {
  if (shouldThrow) {
    throw new Error('This is a test error from ProblematicComponent')
  }

  return (
    <div className="p-4 bg-green-50 border border-green-200 rounded">
      <p className="text-green-800">This component is working fine!</p>
    </div>
  )
}

/**
 * Component wrapped with HOC error boundary
 */
const ComponentWithHOC = withErrorBoundary(
  ({ message }: { message: string }) => (
    <div className="p-4 bg-blue-50 border border-blue-200 rounded">
      <p className="text-blue-800">{message}</p>
    </div>
  ),
  {
    level: 'component',
    onError: (error: Error, errorInfo: React.ErrorInfo) => {
      console.log('HOC Error Handler:', error.message, errorInfo)
    },
  }
)

/**
 * Example component demonstrating various ErrorBoundary usage patterns
 */
export const ErrorBoundaryExample: React.FC = () => {
  const [shouldThrow, setShouldThrow] = useState(false)
  const [resetKey, setResetKey] = useState(0)

  const triggerError = () => setShouldThrow(true)
  const resetError = () => {
    setShouldThrow(false)
    setResetKey((prev) => prev + 1)
  }

  return (
    <div className="space-y-6 p-6">
      <div className="space-y-4">
        <h2 className="text-2xl font-bold">Error Boundary Examples</h2>

        <div className="flex gap-2">
          <button
            onClick={triggerError}
            className="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700"
            type="button"
          >
            Trigger Error
          </button>
          <button
            onClick={resetError}
            className="px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-700"
            type="button"
          >
            Reset All
          </button>
        </div>
      </div>

      {/* Example 1: Default Error Boundary */}
      <div className="space-y-2">
        <h3 className="text-lg font-semibold">1. Default Error Boundary</h3>
        <ErrorBoundary level="section" resetKeys={[resetKey]}>
          <ProblematicComponent shouldThrow={shouldThrow} />
        </ErrorBoundary>
      </div>

      {/* Example 2: Custom Fallback Component */}
      <div className="space-y-2">
        <h3 className="text-lg font-semibold">2. Custom Fallback Component</h3>
        <ErrorBoundary
          level="section"
          fallback={CustomErrorFallback}
          resetKeys={[resetKey]}
          onError={(error) => console.log('Custom handler:', error.message)}
        >
          <ProblematicComponent shouldThrow={shouldThrow} />
        </ErrorBoundary>
      </div>

      {/* Example 3: Component-level Error Boundary */}
      <div className="space-y-2">
        <h3 className="text-lg font-semibold">3. Component-level Boundary</h3>
        <ErrorBoundary level="component" resetKeys={[resetKey]}>
          <ProblematicComponent shouldThrow={shouldThrow} />
        </ErrorBoundary>
      </div>

      {/* Example 4: HOC Pattern */}
      <div className="space-y-2">
        <h3 className="text-lg font-semibold">4. Higher-Order Component Pattern</h3>
        <ComponentWithHOC message="This component is wrapped with withErrorBoundary HOC" />
      </div>

      {/* Example 5: Nested Error Boundaries */}
      <div className="space-y-2">
        <h3 className="text-lg font-semibold">5. Nested Error Boundaries</h3>
        <ErrorBoundary level="page" resetKeys={[resetKey]}>
          <div className="p-4 border rounded">
            <p className="mb-4">Page-level boundary</p>
            <ErrorBoundary level="section" resetKeys={[resetKey]}>
              <div className="p-4 bg-gray-50 border rounded">
                <p className="mb-4">Section-level boundary</p>
                <ErrorBoundary level="component" resetKeys={[resetKey]}>
                  <ProblematicComponent shouldThrow={shouldThrow} />
                </ErrorBoundary>
              </div>
            </ErrorBoundary>
          </div>
        </ErrorBoundary>
      </div>
    </div>
  )
}

export default ErrorBoundaryExample
</file>

<file path="src/components/forms/FormErrorBoundary.tsx">
import { Component } from 'react'
import type { ErrorInfo, ReactNode } from 'react'
import { FormSubmissionError, FormValidationError } from '../common/FallbackUI'
import { captureException } from '@sentry/react'
import { z } from 'zod'

interface FormErrorBoundaryProps {
  children: ReactNode
  onError?: (error: Error, errorInfo: ErrorInfo) => void
  onRetry?: () => void
  onSaveDraft?: (data: Record<string, unknown>) => void
  onReset?: () => void
  fallbackComponent?: ReactNode
  formName?: string
  enableDraftSaving?: boolean
  validationSchema?: z.ZodSchema
}

interface FormErrorBoundaryState {
  hasError: boolean
  error?: Error
  errorType?: 'validation' | 'submission' | 'network' | 'unknown'
  validationErrors?: Record<string, string>
  formData?: Record<string, unknown>
  retryCount: number
}

/**
 * FormErrorBoundary - Specialized error boundary for form components
 *
 * Features:
 * - Detects validation vs submission errors
 * - Preserves form data during errors
 * - Provides draft saving functionality
 * - Handles network timeouts gracefully
 * - Integrates with form validation schemas
 */
export class FormErrorBoundary extends Component<FormErrorBoundaryProps, FormErrorBoundaryState> {
  private readonly MAX_RETRY_COUNT = 3
  private formDataInterval?: NodeJS.Timeout

  constructor(props: FormErrorBoundaryProps) {
    super(props)
    this.state = {
      hasError: false,
      retryCount: 0,
      formData: {},
    }
  }

  componentDidMount() {
    // Set up periodic form data capture if draft saving is enabled
    if (this.props.enableDraftSaving) {
      this.formDataInterval = setInterval(this.captureFormData, 5000)
    }

    // Restore any saved drafts
    this.restoreDraft()
  }

  componentWillUnmount() {
    if (this.formDataInterval) {
      clearInterval(this.formDataInterval)
    }
  }

  static getDerivedStateFromError(error: Error): Partial<FormErrorBoundaryState> {
    const errorType = FormErrorBoundary.categorizeFormError(error)
    const validationErrors = FormErrorBoundary.extractValidationErrors(error)

    return {
      hasError: true,
      error,
      errorType,
      validationErrors,
    }
  }

  static categorizeFormError(error: Error): FormErrorBoundaryState['errorType'] {
    const errorMessage = error.message.toLowerCase()
    const errorName = error.name.toLowerCase()

    // Zod validation errors
    if (error instanceof z.ZodError || errorName.includes('validation')) {
      return 'validation'
    }

    // Network/submission errors
    if (
      errorMessage.includes('network') ||
      errorMessage.includes('timeout') ||
      errorMessage.includes('fetch') ||
      errorName.includes('network')
    ) {
      return 'network'
    }

    // Form submission errors
    if (
      errorMessage.includes('submit') ||
      errorMessage.includes('submission') ||
      errorMessage.includes('400') ||
      errorMessage.includes('422')
    ) {
      return 'submission'
    }

    return 'unknown'
  }

  static extractValidationErrors(error: Error): Record<string, string> | undefined {
    // Handle Zod errors
    if (error instanceof z.ZodError) {
      const errors: Record<string, string> = {}
      error.errors.forEach((err) => {
        const path = err.path.join('.')
        errors[path] = err.message
      })
      return errors
    }

    // Handle custom validation error format
    if ('validationErrors' in error && typeof error.validationErrors === 'object') {
      return error.validationErrors as Record<string, string>
    }

    return undefined
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    // Log to console with form context
    console.error(
      `FormErrorBoundary caught an error in ${this.props.formName || 'unknown'} form:`,
      error,
      errorInfo
    )

    // Capture current form data before error handling
    this.captureFormData()

    // Capture in Sentry with form context
    captureException(error, {
      contexts: {
        form: {
          formName: this.props.formName,
          errorType: this.state.errorType,
          hasValidationErrors: Boolean(this.state.validationErrors),
          retryCount: this.state.retryCount,
        },
      },
      tags: {
        component: 'FormErrorBoundary',
        form: this.props.formName || 'unknown',
        errorType: this.state.errorType || 'unknown',
      },
    })

    // Call custom error handler if provided
    if (this.props.onError) {
      this.props.onError(error, errorInfo)
    }
  }

  captureFormData = () => {
    try {
      const forms = document.querySelectorAll('form')
      const formData: Record<string, unknown> = {}

      forms.forEach((form) => {
        const data = new FormData(form)
        data.forEach((value, key) => {
          formData[key] = value
        })
      })

      this.setState({ formData })

      // Save to localStorage for draft functionality
      if (this.props.enableDraftSaving && this.props.formName) {
        const draftKey = `formDraft_${this.props.formName}`
        localStorage.setItem(
          draftKey,
          JSON.stringify({
            data: formData,
            timestamp: new Date().toISOString(),
          })
        )
      }
    } catch (err) {
      console.error('Failed to capture form data:', err)
    }
  }

  restoreDraft = () => {
    if (!this.props.enableDraftSaving || !this.props.formName) return

    try {
      const draftKey = `formDraft_${this.props.formName}`
      const draftData = localStorage.getItem(draftKey)

      if (draftData) {
        const { data, timestamp } = JSON.parse(draftData)

        // Check if draft is less than 24 hours old
        const draftAge = Date.now() - new Date(timestamp).getTime()
        if (draftAge < 24 * 60 * 60 * 1000) {
          this.setState({ formData: data })
          console.log('Draft restored for form:', this.props.formName)
        } else {
          // Clear old draft
          localStorage.removeItem(draftKey)
        }
      }
    } catch (err) {
      console.error('Failed to restore draft:', err)
    }
  }

  handleRetry = () => {
    const newRetryCount = this.state.retryCount + 1

    if (newRetryCount > this.MAX_RETRY_COUNT) {
      console.error('Max retry count reached for form submission')
      return
    }

    // Clear error state and increment retry count
    this.setState({
      hasError: false,
      error: undefined,
      errorType: undefined,
      validationErrors: undefined,
      retryCount: newRetryCount,
    })

    // Call custom retry handler if provided
    if (this.props.onRetry) {
      this.props.onRetry()
    }
  }

  handleSaveDraft = () => {
    if (this.state.formData && this.props.onSaveDraft) {
      this.props.onSaveDraft(this.state.formData)
    }
  }

  handleReset = () => {
    // Clear all state and drafts
    this.setState({
      hasError: false,
      error: undefined,
      errorType: undefined,
      validationErrors: undefined,
      formData: {},
      retryCount: 0,
    })

    // Clear saved draft
    if (this.props.formName) {
      const draftKey = `formDraft_${this.props.formName}`
      localStorage.removeItem(draftKey)
    }

    // Call custom reset handler if provided
    if (this.props.onReset) {
      this.props.onReset()
    }
  }

  componentDidUpdate(prevProps: FormErrorBoundaryProps) {
    // Reset error state if children change (e.g., navigating to a different form)
    if (prevProps.children !== this.props.children && this.state.hasError) {
      this.setState({
        hasError: false,
        error: undefined,
        errorType: undefined,
        validationErrors: undefined,
        retryCount: 0,
      })
    }
  }

  render() {
    if (this.state.hasError) {
      // Use custom fallback if provided
      if (this.props.fallbackComponent) {
        return this.props.fallbackComponent
      }

      // Show validation errors if present
      if (this.state.errorType === 'validation' && this.state.validationErrors) {
        return (
          <div className="space-y-4">
            <FormValidationError
              errors={this.state.validationErrors}
              onRetry={this.handleRetry}
              title="Please fix the following errors"
              message="Your form contains validation errors:"
              testId="form-validation-error"
            />

            {this.props.enableDraftSaving && (
              <div className="flex space-x-2 px-4">
                <button
                  onClick={this.handleSaveDraft}
                  className="text-sm text-primary-600 hover:text-primary-700 underline"
                >
                  Save as Draft
                </button>
                <button
                  onClick={this.handleReset}
                  className="text-sm text-gray-600 hover:text-gray-700 underline"
                >
                  Reset Form
                </button>
              </div>
            )}
          </div>
        )
      }

      // Show submission error for other error types
      const errorMessage =
        this.state.errorType === 'network'
          ? 'Network error occurred. Please check your connection and try again.'
          : 'There was an error submitting your form. Please try again.'

      return (
        <div className="space-y-4">
          <FormSubmissionError
            onRetry={this.handleRetry}
            message={errorMessage}
            testId="form-submission-error"
          />

          {this.state.retryCount > 0 && (
            <p className="text-sm text-gray-600 px-4">
              Retry attempt {this.state.retryCount} of {this.MAX_RETRY_COUNT}
            </p>
          )}

          {this.props.enableDraftSaving &&
            this.state.formData &&
            Object.keys(this.state.formData).length > 0 && (
              <div className="flex space-x-2 px-4">
                <button
                  onClick={this.handleSaveDraft}
                  className="text-sm text-primary-600 hover:text-primary-700 underline"
                >
                  Save as Draft
                </button>
                <span className="text-sm text-gray-500">Your form data has been preserved</span>
              </div>
            )}
        </div>
      )
    }

    return this.props.children
  }
}

// Export as default for easier imports
export default FormErrorBoundary
</file>

<file path="src/components/layout/AppLayout.tsx">
import { Outlet, Link, useLocation, useNavigate } from 'react-router-dom'
import { useState } from 'react'
import { useAuthStore } from '../../store/authStore'
import {
  HomeIcon,
  ChartBarIcon,
  PhoneIcon,
  DocumentTextIcon,
  CreditCardIcon,
  CogIcon,
  UserCircleIcon,
  Bars3Icon,
  XMarkIcon,
} from '@heroicons/react/24/outline'
import ErrorBoundary from '../common/ErrorBoundary'
import { AppLayoutSidebarFallbackUI, AppLayoutContentFallbackUI } from '../common/FallbackUI'

const navigation = [
  { name: 'Dashboard', href: '/app/dashboard', icon: HomeIcon },
  { name: 'Campaigns', href: '/app/campaigns', icon: ChartBarIcon },
  { name: 'Calls', href: '/app/calls', icon: PhoneIcon },
  { name: 'Reports', href: '/app/reports', icon: DocumentTextIcon },
  { name: 'Billing', href: '/app/billing', icon: CreditCardIcon },
  { name: 'Settings', href: '/app/settings', icon: CogIcon },
]

function classNames(...classes: string[]) {
  return classes.filter(Boolean).join(' ')
}

export default function AppLayout() {
  const location = useLocation()
  const navigate = useNavigate()
  const { user, userType, signOut } = useAuthStore()
  const [sidebarOpen, setSidebarOpen] = useState(false)
  const [userMenuOpen, setUserMenuOpen] = useState(false)

  const handleSignOut = async () => {
    await signOut()
    navigate('/')
  }

  return (
    <div className="flex min-h-screen bg-gray-100">
      {/* Mobile sidebar */}
      {sidebarOpen && (
        <div className="fixed inset-0 flex z-40 lg:hidden">
          <div
            className={classNames(
              'fixed inset-0 bg-gray-600 bg-opacity-75 transition-opacity ease-linear duration-300',
              sidebarOpen ? 'opacity-100' : 'opacity-0'
            )}
            onClick={() => setSidebarOpen(false)}
          />

          <div
            className={classNames(
              'relative flex-1 flex flex-col max-w-xs w-full pt-5 pb-4 bg-white transition ease-in-out duration-300 transform',
              sidebarOpen ? 'translate-x-0' : '-translate-x-full'
            )}
          >
            <div className="absolute top-0 right-0 -mr-12 pt-2">
              <button
                className="ml-1 flex items-center justify-center h-10 w-10 rounded-full focus:outline-none focus:ring-2 focus:ring-inset focus:ring-white"
                onClick={() => setSidebarOpen(false)}
              >
                <XMarkIcon className="h-6 w-6 text-white" />
              </button>
            </div>

            <div className="flex-shrink-0 flex items-center px-4">
              <span className="text-2xl font-bold text-primary-600">DependableCalls</span>
            </div>

            <div className="mt-5 flex-1 h-0 overflow-y-auto">
              <ErrorBoundary
                context="AppLayout - Mobile Sidebar Navigation"
                fallback={<AppLayoutSidebarFallbackUI />}
              >
                <nav className="px-2 space-y-1">
                  {navigation.map((item) => (
                    <Link
                      key={item.name}
                      to={item.href}
                      className={classNames(
                        location.pathname === item.href
                          ? 'bg-gray-100 text-gray-900'
                          : 'text-gray-600 hover:bg-gray-50 hover:text-gray-900',
                        'group flex items-center px-2 py-2 text-base font-medium rounded-md'
                      )}
                      onClick={() => setSidebarOpen(false)}
                    >
                      <item.icon
                        className={classNames(
                          location.pathname === item.href
                            ? 'text-gray-500'
                            : 'text-gray-400 group-hover:text-gray-500',
                          'mr-4 flex-shrink-0 h-6 w-6'
                        )}
                      />
                      {item.name}
                    </Link>
                  ))}
                </nav>
              </ErrorBoundary>
            </div>
          </div>
        </div>
      )}

      {/* Desktop sidebar */}
      <div className="hidden lg:flex lg:w-64 lg:flex-col lg:fixed lg:inset-y-0">
        <div className="flex flex-col flex-1 min-h-0 bg-white border-r border-gray-200">
          <div className="flex items-center h-16 flex-shrink-0 px-4 bg-white border-b border-gray-200">
            <span className="text-2xl font-bold text-primary-600">DependableCalls</span>
          </div>

          <div className="flex-1 flex flex-col overflow-y-auto">
            <ErrorBoundary
              context="AppLayout - Desktop Sidebar Navigation"
              fallback={<AppLayoutSidebarFallbackUI />}
            >
              <nav className="flex-1 px-2 py-4 space-y-1">
                {navigation.map((item) => (
                  <Link
                    key={item.name}
                    to={item.href}
                    className={classNames(
                      location.pathname === item.href
                        ? 'bg-gray-100 text-gray-900'
                        : 'text-gray-600 hover:bg-gray-50 hover:text-gray-900',
                      'group flex items-center px-2 py-2 text-sm font-medium rounded-md'
                    )}
                  >
                    <item.icon
                      className={classNames(
                        location.pathname === item.href
                          ? 'text-gray-500'
                          : 'text-gray-400 group-hover:text-gray-500',
                        'mr-3 flex-shrink-0 h-6 w-6'
                      )}
                    />
                    {item.name}
                  </Link>
                ))}
              </nav>
            </ErrorBoundary>
          </div>
        </div>
      </div>

      {/* Main content */}
      <div className="lg:pl-64 flex flex-col flex-1">
        {/* Top navigation */}
        <div className="sticky top-0 z-10 flex-shrink-0 flex h-16 bg-white shadow">
          <button
            type="button"
            className="px-4 border-r border-gray-200 text-gray-500 focus:outline-none focus:ring-2 focus:ring-inset focus:ring-primary-500 lg:hidden"
            onClick={() => setSidebarOpen(true)}
          >
            <Bars3Icon className="h-6 w-6" />
          </button>

          <div className="flex-1 px-4 flex justify-between">
            <div className="flex-1 flex">{/* Search can go here */}</div>

            <div className="ml-4 flex items-center md:ml-6">
              {/* User menu */}
              <div className="ml-3 relative">
                <div>
                  <button
                    className="max-w-xs bg-white flex items-center text-sm rounded-full focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500"
                    onClick={() => setUserMenuOpen(!userMenuOpen)}
                  >
                    <UserCircleIcon className="h-8 w-8 text-gray-400" />
                    <span className="ml-3 text-gray-700 text-sm font-medium">{user?.email}</span>
                  </button>
                </div>

                {userMenuOpen && (
                  <div className="origin-top-right absolute right-0 mt-2 w-48 rounded-md shadow-lg py-1 bg-white ring-1 ring-black ring-opacity-5 focus:outline-none">
                    <div className="px-4 py-2 text-xs text-gray-500">
                      {userType && userType.charAt(0).toUpperCase() + userType.slice(1)} Account
                    </div>
                    <Link
                      to="/app/settings"
                      className="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100"
                      onClick={() => setUserMenuOpen(false)}
                    >
                      Account Settings
                    </Link>
                    <button
                      onClick={handleSignOut}
                      className="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100"
                    >
                      Sign out
                    </button>
                  </div>
                )}
              </div>
            </div>
          </div>
        </div>

        {/* Page content */}
        <main className="flex-1">
          <ErrorBoundary
            context="AppLayout - Main Content"
            fallback={<AppLayoutContentFallbackUI />}
          >
            <Outlet />
          </ErrorBoundary>
        </main>
      </div>
    </div>
  )
}
</file>

<file path="src/components/monitoring/StatusPage.tsx">
import React, { useState, useEffect } from 'react'
import {
  CheckCircleIcon,
  XCircleIcon,
  ExclamationTriangleIcon,
  ArrowPathIcon,
} from '@heroicons/react/24/solid'
import { healthChecker, type HealthCheckResult } from '../../lib/health-check'
import { apm } from '../../lib/apm'

interface ServiceStatus {
  name: string
  status: 'operational' | 'degraded' | 'down'
  lastChecked: string
  responseTime?: number
  uptime?: number
}

export const StatusPage: React.FC = () => {
  const [healthData, setHealthData] = useState<HealthCheckResult | null>(null)
  const [isLoading, setIsLoading] = useState(true)
  const [services, setServices] = useState<ServiceStatus[]>([])
  const [incidents] = useState<Record<string, unknown>[]>([])
  const [refreshing, setRefreshing] = useState(false)

  useEffect(() => {
    checkHealth()
    const interval = setInterval(checkHealth, 30000) // Refresh every 30 seconds

    return () => clearInterval(interval)
  }, [])

  const checkHealth = async () => {
    setRefreshing(true)

    try {
      const result = await healthChecker.performHealthCheck()
      setHealthData(result)

      // Convert health checks to service status
      const serviceStatuses: ServiceStatus[] = [
        {
          name: 'Web Application',
          status: result.checks.api?.status === 'pass' ? 'operational' : 'down',
          lastChecked: result.timestamp,
          responseTime: result.checks.api?.duration,
          uptime: 99.9, // This would come from a real monitoring service
        },
        {
          name: 'Database (Supabase)',
          status: result.checks.supabase?.status === 'pass' ? 'operational' : 'down',
          lastChecked: result.timestamp,
          responseTime: result.checks.supabase?.duration,
          uptime: 99.95,
        },
        {
          name: 'Payment Processing (Stripe)',
          status: result.checks.stripe?.status === 'pass' ? 'operational' : 'degraded',
          lastChecked: result.timestamp,
          uptime: 100,
        },
        {
          name: 'Error Tracking (Sentry)',
          status: result.checks.sentry?.status === 'pass' ? 'operational' : 'degraded',
          lastChecked: result.timestamp,
          uptime: 99.99,
        },
      ]

      setServices(serviceStatuses)

      // Track metrics
      apm.trackMetric('health-check.duration', result.overall.duration)
      apm.trackMetric('health-check.failed', result.overall.failed)
    } catch (error) {
      console.error('Failed to check health:', error)
    } finally {
      setIsLoading(false)
      setRefreshing(false)
    }
  }

  const getOverallStatus = () => {
    if (!healthData) return 'unknown'
    return healthData.status
  }

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'operational':
      case 'healthy':
      case 'pass':
        return 'text-green-500'
      case 'degraded':
        return 'text-yellow-500'
      case 'down':
      case 'unhealthy':
      case 'fail':
        return 'text-red-500'
      default:
        return 'text-gray-500'
    }
  }

  const getStatusIcon = (status: string) => {
    switch (status) {
      case 'operational':
      case 'healthy':
      case 'pass':
        return <CheckCircleIcon className="h-5 w-5 text-green-500" />
      case 'degraded':
        return <ExclamationTriangleIcon className="h-5 w-5 text-yellow-500" />
      case 'down':
      case 'unhealthy':
      case 'fail':
        return <XCircleIcon className="h-5 w-5 text-red-500" />
      default:
        return <ExclamationTriangleIcon className="h-5 w-5 text-gray-500" />
    }
  }

  const formatResponseTime = (ms?: number) => {
    if (!ms) return 'N/A'
    if (ms < 1000) return `${Math.round(ms)}ms`
    return `${(ms / 1000).toFixed(2)}s`
  }

  if (isLoading) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center">
        <div className="text-center">
          <ArrowPathIcon className="h-8 w-8 animate-spin text-gray-400 mx-auto mb-4" />
          <p className="text-gray-600">Checking system status...</p>
        </div>
      </div>
    )
  }

  const overallStatus = getOverallStatus()

  return (
    <div className="min-h-screen bg-gray-50">
      {/* Header */}
      <div
        className={`${
          overallStatus === 'healthy'
            ? 'bg-green-500'
            : overallStatus === 'degraded'
              ? 'bg-yellow-500'
              : 'bg-red-500'
        } text-white`}
      >
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
          <div className="flex items-center justify-between">
            <div>
              <h1 className="text-3xl font-bold">System Status</h1>
              <p className="mt-2 text-white/90">
                {overallStatus === 'healthy' && 'All systems operational'}
                {overallStatus === 'degraded' && 'Experiencing minor issues'}
                {overallStatus === 'unhealthy' && 'Major outage in progress'}
              </p>
            </div>
            <button
              onClick={checkHealth}
              disabled={refreshing}
              className="flex items-center gap-2 px-4 py-2 bg-white/20 hover:bg-white/30 rounded-lg transition-colors"
            >
              <ArrowPathIcon className={`h-5 w-5 ${refreshing ? 'animate-spin' : ''}`} />
              Refresh
            </button>
          </div>
        </div>
      </div>

      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        {/* Current Status */}
        <div className="bg-white rounded-lg shadow-sm p-6 mb-8">
          <h2 className="text-xl font-semibold mb-4">Current Status</h2>
          <div className="space-y-4">
            {services.map((service) => (
              <div
                key={service.name}
                className="flex items-center justify-between py-3 border-b border-gray-100 last:border-0"
              >
                <div className="flex items-center gap-3">
                  {getStatusIcon(service.status)}
                  <div>
                    <h3 className="font-medium">{service.name}</h3>
                    <p className="text-sm text-gray-500">
                      Last checked: {new Date(service.lastChecked).toLocaleTimeString()}
                    </p>
                  </div>
                </div>
                <div className="text-right">
                  <p className={`font-medium ${getStatusColor(service.status)}`}>
                    {service.status.charAt(0).toUpperCase() + service.status.slice(1)}
                  </p>
                  {service.responseTime && (
                    <p className="text-sm text-gray-500">
                      Response time: {formatResponseTime(service.responseTime)}
                    </p>
                  )}
                  {service.uptime && (
                    <p className="text-sm text-gray-500">Uptime: {service.uptime}%</p>
                  )}
                </div>
              </div>
            ))}
          </div>
        </div>

        {/* Metrics */}
        {healthData && (
          <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
            <div className="bg-white rounded-lg shadow-sm p-6">
              <h3 className="text-sm font-medium text-gray-500 uppercase tracking-wide">
                Total Checks
              </h3>
              <p className="mt-2 text-3xl font-semibold">
                {healthData.overall.healthy + healthData.overall.failed}
              </p>
              <p className="mt-1 text-sm text-gray-600">
                {healthData.overall.healthy} passing, {healthData.overall.failed} failing
              </p>
            </div>

            <div className="bg-white rounded-lg shadow-sm p-6">
              <h3 className="text-sm font-medium text-gray-500 uppercase tracking-wide">
                Check Duration
              </h3>
              <p className="mt-2 text-3xl font-semibold">
                {formatResponseTime(healthData.overall.duration)}
              </p>
              <p className="mt-1 text-sm text-gray-600">Time to complete all checks</p>
            </div>

            <div className="bg-white rounded-lg shadow-sm p-6">
              <h3 className="text-sm font-medium text-gray-500 uppercase tracking-wide">
                Overall Health
              </h3>
              <div className="mt-2 flex items-center gap-2">
                {getStatusIcon(overallStatus)}
                <p className={`text-3xl font-semibold ${getStatusColor(overallStatus)}`}>
                  {Math.round(
                    (healthData.overall.healthy /
                      (healthData.overall.healthy + healthData.overall.failed)) *
                      100
                  )}
                  %
                </p>
              </div>
              <p className="mt-1 text-sm text-gray-600">System health score</p>
            </div>
          </div>
        )}

        {/* Recent Incidents */}
        <div className="bg-white rounded-lg shadow-sm p-6">
          <h2 className="text-xl font-semibold mb-4">Recent Incidents</h2>
          {incidents.length === 0 ? (
            <p className="text-gray-500">No recent incidents to report.</p>
          ) : (
            <div className="space-y-4">
              {incidents.map((incident, index) => (
                <div key={index} className="border-l-4 border-yellow-400 pl-4 py-2">
                  <h3 className="font-medium">{String(incident.title)}</h3>
                  <p className="text-sm text-gray-600 mt-1">{String(incident.description)}</p>
                  <p className="text-xs text-gray-500 mt-2">
                    {new Date(String(incident.timestamp)).toLocaleString()}
                  </p>
                </div>
              ))}
            </div>
          )}
        </div>

        {/* Technical Details */}
        {import.meta.env.DEV && healthData && (
          <details className="mt-8">
            <summary className="cursor-pointer text-sm text-gray-500 hover:text-gray-700">
              Technical Details
            </summary>
            <pre className="mt-4 p-4 bg-gray-900 text-gray-100 rounded-lg overflow-x-auto text-xs">
              {JSON.stringify(healthData, null, 2)}
            </pre>
          </details>
        )}
      </div>
    </div>
  )
}
</file>

<file path="src/components/payments/WebhookHandler.tsx">
import { useEffect, useRef, useCallback, useState } from 'react'
import { supabase } from '@/lib/supabase'
import { logger } from '@/lib/logger'
import { toError } from '@/lib/error-utils'
import type Stripe from 'stripe'
import { RealtimeErrorBoundary } from '../realtime/RealtimeErrorBoundary'

interface WebhookPayload {
  id: string
  type: string
  data: {
    object: Stripe.Event.Data.Object
  }
  created: number
}

interface WebhookHandlerProps {
  onWebhookReceived?: (event: WebhookPayload) => void
}

// Inner component without error boundary
const WebhookHandlerInner: React.FC<WebhookHandlerProps> = ({ onWebhookReceived }) => {
  const handledEvents = useRef<Set<string>>(new Set())

  const handleWebhookEvent = useCallback(
    async (payload: { new: WebhookPayload }) => {
      const event = payload.new as WebhookPayload

      // Prevent duplicate processing
      if (handledEvents.current.has(event.id)) {
        return
      }
      handledEvents.current.add(event.id)

      try {
        logger.info('Processing webhook event', {
          type: event.type,
          id: event.id,
        })

        await processWebhookEvent(event)
        onWebhookReceived?.(event)
      } catch (error) {
        const errorDetails = toError(error)
        logger.error('Error processing webhook event', errorDetails, {
          eventId: event.id,
          eventType: event.type,
          component: 'webhook-handler',
        })
      }
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [onWebhookReceived]
  )

  useEffect(() => {
    // Subscribe to real-time webhook events from Supabase
    const channel = supabase
      .channel('webhook-events')
      .on(
        'postgres_changes',
        {
          event: 'INSERT',
          schema: 'public',
          table: 'webhook_events',
        },
        handleWebhookEvent
      )
      .subscribe((status) => {
        if (status === 'SUBSCRIBED') {
          logger.info('Webhook handler connected to real-time events')
        } else if (status === 'CLOSED') {
          logger.warn('Webhook handler disconnected from real-time events')
        } else if (status === 'CHANNEL_ERROR') {
          logger.error('Webhook handler channel error')
        }
      })

    return () => {
      supabase.removeChannel(channel)
    }
  }, [handleWebhookEvent])

  const processWebhookEvent = async (event: WebhookPayload) => {
    switch (event.type) {
      case 'payment_intent.succeeded':
        await handlePaymentSucceeded(event.data.object as Stripe.PaymentIntent)
        break

      case 'payment_intent.payment_failed':
        await handlePaymentFailed(event.data.object as Stripe.PaymentIntent)
        break

      case 'charge.dispute.created':
        await handleDisputeCreated(event.data.object as Stripe.Dispute)
        break

      case 'account.updated':
        await handleAccountUpdated(event.data.object as Stripe.Account)
        break

      case 'account.application.authorized':
        await handleAccountAuthorized(event.data.object as Stripe.Account)
        break

      case 'account.application.deauthorized':
        await handleAccountDeauthorized(event.data.object as Stripe.Account)
        break

      case 'payout.created':
        await handlePayoutCreated(event.data.object as Stripe.Payout)
        break

      case 'payout.paid':
        await handlePayoutPaid(event.data.object as Stripe.Payout)
        break

      case 'payout.failed':
        await handlePayoutFailed(event.data.object as Stripe.Payout)
        break

      case 'transfer.created':
        await handleTransferCreated(event.data.object as Stripe.Transfer)
        break

      case 'transfer.reversed':
        await handleTransferReversed(event.data.object as Stripe.Transfer)
        break

      default:
        logger.warn('Unhandled webhook event type', { type: event.type })
    }
  }

  const handlePaymentSucceeded = async (paymentIntent: Stripe.PaymentIntent) => {
    const { metadata } = paymentIntent

    try {
      // Update transaction status
      const { error: transactionError } = await supabase
        .from('transactions')
        .update({
          status: 'succeeded',
          stripe_payment_intent_id: paymentIntent.id,
          updated_at: new Date().toISOString(),
        })
        .eq('stripe_payment_intent_id', paymentIntent.id)

      if (transactionError) {
        logger.error('Failed to update transaction status', toError(transactionError), {
          paymentIntentId: paymentIntent.id,
          component: 'webhook-handler',
          action: 'update-transaction-status',
        })
      }

      // Update buyer account balance if applicable
      if (metadata.buyerId) {
        const { error: balanceError } = await supabase.rpc('add_buyer_credits', {
          buyer_id: metadata.buyerId,
          amount: paymentIntent.amount / 100,
        })

        if (balanceError) {
          logger.error('Failed to update buyer balance', toError(balanceError), {
            paymentIntentId: paymentIntent.id,
            buyerId: metadata.buyerId,
            component: 'webhook-handler',
            action: 'update-buyer-balance',
          })
        }
      }

      // Update campaign budget if applicable
      if (metadata.invoiceId) {
        const { error: campaignError } = await supabase
          .from('invoices')
          .update({
            status: 'paid',
            paid_at: new Date().toISOString(),
          })
          .eq('id', metadata.invoiceId)

        if (campaignError) {
          logger.error('Failed to update invoice status', toError(campaignError), {
            paymentIntentId: paymentIntent.id,
            component: 'webhook-handler',
            action: 'update-invoice-status',
            metadata: { invoiceId: metadata.invoiceId },
          })
        }
      }

      logger.info('Payment succeeded processed', {
        paymentIntentId: paymentIntent.id,
        amount: paymentIntent.amount / 100,
        buyerId: metadata.buyerId,
      })
    } catch (error) {
      const errorDetails = toError(error)
      logger.error('Error processing payment success', errorDetails, {
        paymentIntentId: paymentIntent.id,
        component: 'webhook-handler',
        action: 'process-payment-success',
      })
      throw errorDetails
    }
  }

  const handlePaymentFailed = async (paymentIntent: Stripe.PaymentIntent) => {
    const { metadata } = paymentIntent

    try {
      // Update transaction status
      const { error: transactionError } = await supabase
        .from('transactions')
        .update({
          status: 'failed',
          failure_reason: paymentIntent.last_payment_error?.message,
          updated_at: new Date().toISOString(),
        })
        .eq('stripe_payment_intent_id', paymentIntent.id)

      if (transactionError) {
        logger.error('Failed to update failed transaction', toError(transactionError), {
          paymentIntentId: paymentIntent.id,
          component: 'webhook-handler',
          action: 'update-failed-transaction',
        })
      }

      // Notify buyer of failed payment
      if (metadata.buyerId) {
        await supabase.from('notifications').insert({
          user_id: metadata.buyerId,
          type: 'payment_failed',
          title: 'Payment Failed',
          message: `Payment of $${(paymentIntent.amount / 100).toFixed(2)} failed. Please update your payment method.`,
          data: {
            payment_intent_id: paymentIntent.id,
            amount: paymentIntent.amount / 100,
            error: paymentIntent.last_payment_error?.message,
          },
        })
      }

      logger.info('Payment failed processed', {
        paymentIntentId: paymentIntent.id,
        error: paymentIntent.last_payment_error?.message,
      })
    } catch (error) {
      const errorDetails = toError(error)
      logger.error('Error processing payment failure', errorDetails, {
        paymentIntentId: paymentIntent.id,
        component: 'webhook-handler',
        action: 'process-payment-failure',
      })
      throw errorDetails
    }
  }

  const handleDisputeCreated = async (dispute: Stripe.Dispute) => {
    try {
      // Record dispute in database
      const { error } = await supabase.from('disputes').insert({
        stripe_charge_id: dispute.charge as string,
        amount: dispute.amount / 100,
        currency: dispute.currency,
        reason: dispute.reason,
        status: dispute.status,
        evidence_due_by: dispute.evidence_details?.due_by
          ? new Date(dispute.evidence_details.due_by * 1000).toISOString()
          : null,
        created_at: new Date().toISOString(),
      })

      if (error) {
        logger.error('Failed to record dispute', toError(error), {
          chargeId: dispute.charge as string,
          component: 'webhook-handler',
          action: 'record-dispute',
          amount: dispute.amount / 100,
          reason: dispute.reason,
        })
      }

      // Notify admin team
      await supabase.from('notifications').insert({
        user_id: null, // System notification
        type: 'dispute_created',
        title: 'Payment Dispute Created',
        message: `A dispute has been created for charge ${dispute.charge}`,
        data: {
          charge_id: dispute.charge,
          amount: dispute.amount / 100,
          reason: dispute.reason,
        },
      })

      logger.info('Dispute created', {
        chargeId: typeof dispute.charge === 'string' ? dispute.charge : dispute.charge.id,
        amount: dispute.amount / 100,
        reason: dispute.reason,
      })
    } catch (error) {
      const errorDetails = toError(error)
      logger.error('Error processing dispute creation', errorDetails, {
        chargeId: dispute.charge as string,
        component: 'webhook-handler',
        action: 'process-dispute-creation',
      })
      throw errorDetails
    }
  }

  const handleAccountUpdated = async (account: Stripe.Account) => {
    try {
      // Update connected account status
      const { error } = await supabase
        .from('users')
        .update({
          stripe_account_status: {
            charges_enabled: account.charges_enabled,
            payouts_enabled: account.payouts_enabled,
            details_submitted: account.details_submitted,
            requirements_currently_due: account.requirements?.currently_due || [],
            updated_at: new Date().toISOString(),
          },
        })
        .eq('stripe_account_id', account.id)

      if (error) {
        logger.error('Failed to update account status', toError(error), {
          accountId: account.id,
          component: 'webhook-handler',
          action: 'update-account-status',
          chargesEnabled: account.charges_enabled,
          payoutsEnabled: account.payouts_enabled,
        })
      }

      logger.info('Account updated', {
        accountId: account.id,
        chargesEnabled: account.charges_enabled,
        payoutsEnabled: account.payouts_enabled,
      })
    } catch (error) {
      const errorDetails = toError(error)
      logger.error('Error processing account update', errorDetails, {
        accountId: account.id,
        component: 'webhook-handler',
        action: 'process-account-update',
      })
      throw errorDetails
    }
  }

  const handleAccountAuthorized = async (account: Stripe.Account) => {
    try {
      // Mark account as authorized
      const { error } = await supabase
        .from('users')
        .update({
          stripe_account_authorized: true,
          authorized_at: new Date().toISOString(),
        })
        .eq('stripe_account_id', account.id)

      if (error) {
        logger.error('Failed to mark account as authorized', toError(error), {
          accountId: account.id,
          component: 'webhook-handler',
          action: 'mark-account-authorized',
        })
      }

      logger.info('Account authorized', { accountId: account.id })
    } catch (error) {
      const errorDetails = toError(error)
      logger.error('Error processing account authorization', errorDetails, {
        accountId: account.id,
        component: 'webhook-handler',
        action: 'process-account-authorization',
      })
      throw errorDetails
    }
  }

  const handleAccountDeauthorized = async (account: Stripe.Account) => {
    try {
      // Mark account as deauthorized
      const { error } = await supabase
        .from('users')
        .update({
          stripe_account_authorized: false,
          deauthorized_at: new Date().toISOString(),
        })
        .eq('stripe_account_id', account.id)

      if (error) {
        logger.error('Failed to mark account as deauthorized', toError(error), {
          accountId: account.id,
          component: 'webhook-handler',
          action: 'mark-account-deauthorized',
        })
      }

      logger.info('Account deauthorized', { accountId: account.id })
    } catch (error) {
      const errorDetails = toError(error)
      logger.error('Error processing account deauthorization', errorDetails, {
        accountId: account.id,
        component: 'webhook-handler',
        action: 'process-account-deauthorization',
      })
      throw errorDetails
    }
  }

  const handlePayoutCreated = async (payout: Stripe.Payout) => {
    try {
      // Record payout creation
      const { error } = await supabase.from('payouts').insert({
        stripe_payout_id: payout.id,
        stripe_account_id: payout.destination as string,
        amount: payout.amount / 100,
        currency: payout.currency,
        status: 'created',
        arrival_date: payout.arrival_date
          ? new Date(payout.arrival_date * 1000).toISOString()
          : null,
        created_at: new Date().toISOString(),
      })

      if (error) {
        logger.error('Failed to record payout creation', toError(error), {
          payoutId: payout.id,
          component: 'webhook-handler',
          action: 'record-payout-creation',
          amount: payout.amount / 100,
        })
      }

      logger.info('Payout created', {
        payoutId: payout.id,
        amount: payout.amount / 100,
        arrivalDate: payout.arrival_date,
      })
    } catch (error) {
      const errorDetails = toError(error)
      logger.error('Error processing payout creation', errorDetails, {
        payoutId: payout.id,
        component: 'webhook-handler',
        action: 'process-payout-creation',
      })
      throw errorDetails
    }
  }

  const handlePayoutPaid = async (payout: Stripe.Payout) => {
    try {
      // Update payout status
      const { error } = await supabase
        .from('payouts')
        .update({
          status: 'paid',
          paid_at: new Date().toISOString(),
        })
        .eq('stripe_payout_id', payout.id)

      if (error) {
        logger.error('Failed to update payout status', toError(error), {
          payoutId: payout.id,
          component: 'webhook-handler',
          action: 'update-payout-status',
          amount: payout.amount / 100,
        })
      }

      logger.info('Payout paid', {
        payoutId: payout.id,
        amount: payout.amount / 100,
      })
    } catch (error) {
      const errorDetails = toError(error)
      logger.error('Error processing payout payment', errorDetails, {
        payoutId: payout.id,
        component: 'webhook-handler',
        action: 'process-payout-payment',
      })
      throw errorDetails
    }
  }

  const handlePayoutFailed = async (payout: Stripe.Payout) => {
    try {
      // Update payout status with failure info
      const { error } = await supabase
        .from('payouts')
        .update({
          status: 'failed',
          failure_code: payout.failure_code,
          failure_message: payout.failure_message,
          failed_at: new Date().toISOString(),
        })
        .eq('stripe_payout_id', payout.id)

      if (error) {
        logger.error('Failed to update failed payout', toError(error), {
          payoutId: payout.id,
          component: 'webhook-handler',
          action: 'update-failed-payout',
          failureCode: payout.failure_code,
          failureMessage: payout.failure_message,
        })
      }

      // Notify supplier of failed payout
      const { data: user } = await supabase
        .from('users')
        .select('id')
        .eq('stripe_account_id', payout.destination)
        .single()

      if (user) {
        await supabase.from('notifications').insert({
          user_id: user.id,
          type: 'payout_failed',
          title: 'Payout Failed',
          message: `Payout of $${(payout.amount / 100).toFixed(2)} failed: ${payout.failure_message}`,
          data: {
            payout_id: payout.id,
            amount: payout.amount / 100,
            failure_code: payout.failure_code,
            failure_message: payout.failure_message,
          },
        })
      }

      logger.info('Payout failed', {
        payoutId: payout.id,
        failureCode: payout.failure_code,
        failureMessage: payout.failure_message,
      })
    } catch (error) {
      const errorDetails = toError(error)
      logger.error('Error processing payout failure', errorDetails, {
        payoutId: payout.id,
        component: 'webhook-handler',
        action: 'process-payout-failure',
      })
      throw errorDetails
    }
  }

  const handleTransferCreated = async (transfer: Stripe.Transfer) => {
    try {
      // Record transfer creation
      const { error } = await supabase.from('transfers').insert({
        stripe_transfer_id: transfer.id,
        destination_account_id: transfer.destination as string,
        amount: transfer.amount / 100,
        currency: transfer.currency,
        status: 'created',
        metadata: transfer.metadata,
        created_at: new Date().toISOString(),
      })

      if (error) {
        logger.error('Failed to record transfer creation', toError(error), {
          transferId: transfer.id,
          component: 'webhook-handler',
          action: 'record-transfer-creation',
          amount: transfer.amount / 100,
          destination: transfer.destination as string,
        })
      }

      logger.info('Transfer created', {
        transferId: transfer.id,
        amount: transfer.amount / 100,
        destination: typeof transfer.destination === 'string' ? transfer.destination : transfer.destination?.id || 'unknown',
      })
    } catch (error) {
      const errorDetails = toError(error)
      logger.error('Error processing transfer creation', errorDetails, {
        transferId: transfer.id,
        component: 'webhook-handler',
        action: 'process-transfer-creation',
      })
      throw errorDetails
    }
  }

  const handleTransferReversed = async (transfer: Stripe.Transfer) => {
    try {
      // Update transfer status
      const { error } = await supabase
        .from('transfers')
        .update({
          status: 'reversed',
          reversed_at: new Date().toISOString(),
        })
        .eq('stripe_transfer_id', transfer.id)

      if (error) {
        logger.error('Failed to update reversed transfer', toError(error), {
          transferId: transfer.id,
          component: 'webhook-handler',
          action: 'update-reversed-transfer',
          amount: transfer.amount / 100,
        })
      }

      logger.info('Transfer reversed', {
        transferId: transfer.id,
        amount: transfer.amount / 100,
      })
    } catch (error) {
      const errorDetails = toError(error)
      logger.error('Error processing transfer reversal', errorDetails, {
        transferId: transfer.id,
        component: 'webhook-handler',
        action: 'process-transfer-reversal',
      })
      throw errorDetails
    }
  }

  // This component doesn't render anything visible
  return null
}

// Wrapped version with error boundary
export const WebhookHandler: React.FC<WebhookHandlerProps> = ({ onWebhookReceived }) => {
  const [retryKey, setRetryKey] = useState(0)

  const handleReconnect = async () => {
    // Force component re-mount to reconnect
    setRetryKey((prev) => prev + 1)
    logger.info('Attempting to reconnect webhook handler')
  }

  const handleFallbackToPolling = () => {
    // In a real implementation, this would switch to polling mode
    logger.info('Falling back to polling mode for webhook events')
    // You could implement a polling mechanism here
  }

  return (
    <RealtimeErrorBoundary
      featureName="Webhook Processing"
      enableAutoReconnect={true}
      maxReconnectAttempts={5}
      reconnectDelay={2000}
      onReconnect={handleReconnect}
      onFallbackToPolling={handleFallbackToPolling}
      onError={(error) => {
        logger.error('Webhook handler error boundary caught error', toError(error), {
          component: 'webhook-handler-error-boundary',
        })
      }}
    >
      <WebhookHandlerInner key={retryKey} onWebhookReceived={onWebhookReceived} />
    </RealtimeErrorBoundary>
  )
}

export default WebhookHandler
</file>

<file path="src/components/realtime/RealtimeErrorBoundary.tsx">
import { Component } from 'react'
import type { ErrorInfo, ReactNode } from 'react'
import { TimeoutError, ErrorFallback } from '../common/FallbackUI'
import { captureException } from '@sentry/react'
import { WifiIcon, ArrowPathIcon } from '@heroicons/react/24/outline'

interface RealtimeErrorBoundaryProps {
  children: ReactNode
  onError?: (error: Error, errorInfo: ErrorInfo) => void
  onReconnect?: () => void
  onFallbackToPolling?: () => void
  onRefresh?: () => void
  fallbackComponent?: ReactNode
  featureName?: string
  enableAutoReconnect?: boolean
  maxReconnectAttempts?: number
  reconnectDelay?: number
}

interface RealtimeErrorBoundaryState {
  hasError: boolean
  error?: Error
  errorType?: 'websocket' | 'timeout' | 'connection' | 'data_sync' | 'unknown'
  connectionStatus: 'connected' | 'disconnected' | 'reconnecting' | 'error'
  reconnectAttempts: number
  lastSuccessfulConnection?: Date
}

/**
 * RealtimeErrorBoundary - Specialized error boundary for real-time features
 *
 * Features:
 * - Handles WebSocket disconnections gracefully
 * - Automatic reconnection with exponential backoff
 * - Shows connection status to users
 * - Falls back to polling when WebSocket fails
 * - Preserves application state during reconnection
 */
export class RealtimeErrorBoundary extends Component<
  RealtimeErrorBoundaryProps,
  RealtimeErrorBoundaryState
> {
  private reconnectTimer?: NodeJS.Timeout
  private connectionMonitor?: NodeJS.Timeout

  constructor(props: RealtimeErrorBoundaryProps) {
    super(props)
    this.state = {
      hasError: false,
      connectionStatus: 'connected',
      reconnectAttempts: 0,
    }
  }

  componentDidMount() {
    // Set up connection monitoring
    this.startConnectionMonitoring()

    // Listen for WebSocket events if available
    this.setupWebSocketListeners()
  }

  componentWillUnmount() {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer)
    }
    if (this.connectionMonitor) {
      clearInterval(this.connectionMonitor)
    }
  }

  static getDerivedStateFromError(error: Error): Partial<RealtimeErrorBoundaryState> {
    const errorType = RealtimeErrorBoundary.categorizeRealtimeError(error)

    return {
      hasError: true,
      error,
      errorType,
      connectionStatus: 'error',
    }
  }

  static categorizeRealtimeError(error: Error): RealtimeErrorBoundaryState['errorType'] {
    const errorMessage = error.message.toLowerCase()
    const errorName = error.name.toLowerCase()

    // WebSocket specific errors
    if (
      errorMessage.includes('websocket') ||
      errorMessage.includes('ws://') ||
      errorMessage.includes('wss://') ||
      errorName.includes('websocket')
    ) {
      return 'websocket'
    }

    // Timeout errors
    if (
      errorMessage.includes('timeout') ||
      errorMessage.includes('timed out') ||
      errorName.includes('timeout')
    ) {
      return 'timeout'
    }

    // Connection errors
    if (
      errorMessage.includes('connection') ||
      errorMessage.includes('network') ||
      errorMessage.includes('offline')
    ) {
      return 'connection'
    }

    // Data synchronization errors
    if (
      errorMessage.includes('sync') ||
      errorMessage.includes('out of sync') ||
      errorMessage.includes('data mismatch')
    ) {
      return 'data_sync'
    }

    return 'unknown'
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    // Log to console with real-time context
    console.error(
      `RealtimeErrorBoundary caught an error in ${this.props.featureName || 'unknown'} feature:`,
      error,
      errorInfo
    )

    // Capture in Sentry with real-time context
    captureException(error, {
      contexts: {
        realtime: {
          featureName: this.props.featureName,
          errorType: this.state.errorType,
          connectionStatus: this.state.connectionStatus,
          reconnectAttempts: this.state.reconnectAttempts,
          lastSuccessfulConnection: this.state.lastSuccessfulConnection?.toISOString(),
        },
      },
      tags: {
        component: 'RealtimeErrorBoundary',
        feature: this.props.featureName || 'unknown',
        errorType: this.state.errorType || 'unknown',
      },
    })

    // Call custom error handler if provided
    if (this.props.onError) {
      this.props.onError(error, errorInfo)
    }

    // Start automatic reconnection if enabled
    if (this.props.enableAutoReconnect && this.shouldAttemptReconnect()) {
      this.scheduleReconnect()
    }
  }

  setupWebSocketListeners = () => {
    // This would integrate with your WebSocket implementation
    // Example with global WebSocket events
    if (typeof window !== 'undefined') {
      window.addEventListener('online', this.handleOnline)
      window.addEventListener('offline', this.handleOffline)
    }
  }

  startConnectionMonitoring = () => {
    // Monitor connection status periodically
    this.connectionMonitor = setInterval(() => {
      // This would check your actual WebSocket/real-time connection
      // For now, we'll use navigator.onLine as a proxy
      if (!navigator.onLine && this.state.connectionStatus === 'connected') {
        this.setState({ connectionStatus: 'disconnected' })
      }
    }, 5000)
  }

  handleOnline = () => {
    console.log('Connection restored')
    if (this.state.connectionStatus === 'disconnected') {
      this.handleReconnect()
    }
  }

  handleOffline = () => {
    console.log('Connection lost')
    this.setState({ connectionStatus: 'disconnected' })
  }

  shouldAttemptReconnect = (): boolean => {
    const maxAttempts = this.props.maxReconnectAttempts || 5
    return this.state.reconnectAttempts < maxAttempts
  }

  scheduleReconnect = () => {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer)
    }

    // Exponential backoff: 1s, 2s, 4s, 8s, 16s...
    const baseDelay = this.props.reconnectDelay || 1000
    const delay = Math.min(baseDelay * Math.pow(2, this.state.reconnectAttempts), 30000)

    console.log(`Scheduling reconnect in ${delay}ms (attempt ${this.state.reconnectAttempts + 1})`)

    this.setState({ connectionStatus: 'reconnecting' })

    this.reconnectTimer = setTimeout(() => {
      this.handleReconnect()
    }, delay)
  }

  handleReconnect = async () => {
    try {
      this.setState((prevState) => ({
        reconnectAttempts: prevState.reconnectAttempts + 1,
        connectionStatus: 'reconnecting',
      }))

      // Call custom reconnect handler if provided
      if (this.props.onReconnect) {
        await this.props.onReconnect()
      }

      // If successful, reset error state
      this.setState({
        hasError: false,
        error: undefined,
        errorType: undefined,
        connectionStatus: 'connected',
        reconnectAttempts: 0,
        lastSuccessfulConnection: new Date(),
      })
    } catch (error) {
      console.error('Reconnection failed:', error)

      if (this.shouldAttemptReconnect()) {
        this.scheduleReconnect()
      } else {
        this.setState({ connectionStatus: 'error' })
      }
    }
  }

  handleFallbackToPolling = () => {
    // Clear error state
    this.setState({
      hasError: false,
      error: undefined,
      errorType: undefined,
      connectionStatus: 'connected',
    })

    // Call custom fallback handler if provided
    if (this.props.onFallbackToPolling) {
      this.props.onFallbackToPolling()
    }
  }

  handleRefresh = () => {
    if (this.props.onRefresh) {
      this.props.onRefresh()
    } else {
      window.location.reload()
    }
  }

  renderConnectionStatus = () => {
    if (
      this.state.connectionStatus === 'disconnected' ||
      this.state.connectionStatus === 'reconnecting'
    ) {
      return (
        <div className="fixed bottom-4 right-4 z-50 animate-fade-in">
          <div className="bg-yellow-50 border border-yellow-200 rounded-lg shadow-lg p-4 max-w-sm">
            <div className="flex items-start">
              <div className="flex-shrink-0">
                <WifiIcon className="h-5 w-5 text-yellow-600 animate-pulse" />
              </div>
              <div className="ml-3">
                <h3 className="text-sm font-medium text-yellow-800">
                  {this.state.connectionStatus === 'reconnecting'
                    ? 'Reconnecting...'
                    : 'Connection Lost'}
                </h3>
                <p className="mt-1 text-sm text-yellow-700">
                  {this.state.connectionStatus === 'reconnecting'
                    ? `Attempt ${this.state.reconnectAttempts} of ${this.props.maxReconnectAttempts || 5}`
                    : 'Real-time updates are temporarily unavailable'}
                </p>
              </div>
            </div>
          </div>
        </div>
      )
    }
    return null
  }

  render() {
    if (this.state.hasError) {
      // Use custom fallback if provided
      if (this.props.fallbackComponent) {
        return (
          <>
            {this.props.fallbackComponent}
            {this.renderConnectionStatus()}
          </>
        )
      }

      // Show timeout-specific error
      if (this.state.errorType === 'timeout') {
        return (
          <>
            <TimeoutError
              onRetry={this.handleReconnect}
              onCancel={() => this.setState({ hasError: false })}
              timeoutDuration={30}
              testId="realtime-timeout-error"
            />
            {this.renderConnectionStatus()}
          </>
        )
      }

      // Show connection-specific error
      if (this.state.errorType === 'websocket' || this.state.errorType === 'connection') {
        return (
          <>
            <div className="min-h-[400px] flex items-center justify-center p-6">
              <div className="max-w-md w-full text-center">
                <div className="flex justify-center mb-6">
                  <div className="rounded-full bg-yellow-100 p-3">
                    <WifiIcon className="h-8 w-8 text-yellow-600" aria-hidden="true" />
                  </div>
                </div>

                <h2 className="text-xl font-semibold text-gray-900 mb-2">
                  Real-time Connection Error
                </h2>

                <p className="text-gray-600 mb-6 leading-relaxed">
                  {this.props.featureName
                    ? `The ${this.props.featureName} feature is temporarily unavailable.`
                    : 'Real-time features are temporarily unavailable.'}{' '}
                  We're working to restore the connection.
                </p>

                <div className="space-y-3">
                  {this.state.reconnectAttempts < (this.props.maxReconnectAttempts || 5) && (
                    <button
                      onClick={this.handleReconnect}
                      className="w-full flex items-center justify-center px-4 py-2 bg-primary-600 text-white rounded-lg hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2 transition-colors"
                      disabled={this.state.connectionStatus === 'reconnecting'}
                    >
                      <ArrowPathIcon
                        className={`h-4 w-4 mr-2 ${this.state.connectionStatus === 'reconnecting' ? 'animate-spin' : ''}`}
                      />
                      {this.state.connectionStatus === 'reconnecting'
                        ? 'Reconnecting...'
                        : 'Reconnect Now'}
                    </button>
                  )}

                  {this.props.onFallbackToPolling && (
                    <button
                      onClick={this.handleFallbackToPolling}
                      className="w-full flex items-center justify-center px-4 py-2 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 transition-colors"
                    >
                      Continue with Limited Features
                    </button>
                  )}

                  <button
                    onClick={this.handleRefresh}
                    className="w-full flex items-center justify-center px-4 py-2 text-primary-600 bg-primary-50 rounded-lg hover:bg-primary-100 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2 transition-colors"
                  >
                    Refresh Page
                  </button>
                </div>

                {this.state.lastSuccessfulConnection && (
                  <p className="mt-4 text-xs text-gray-500">
                    Last connected: {this.state.lastSuccessfulConnection.toLocaleTimeString()}
                  </p>
                )}
              </div>
            </div>
            {this.renderConnectionStatus()}
          </>
        )
      }

      // Generic real-time error
      return (
        <>
          <ErrorFallback
            title="Real-time Feature Error"
            message={`The ${this.props.featureName || 'real-time'} feature encountered an error. You can continue using other features while we resolve this issue.`}
            onRetry={this.handleReconnect}
            onGoHome={() => (window.location.href = '/app/dashboard')}
            showHomeButton={true}
            showBackButton={false}
            retryLabel="Try Reconnecting"
            testId="realtime-generic-error"
          />
          {this.renderConnectionStatus()}
        </>
      )
    }

    return (
      <>
        {this.props.children}
        {this.renderConnectionStatus()}
      </>
    )
  }
}

// Export as default for easier imports
export default RealtimeErrorBoundary
</file>

<file path="src/hooks/useRealtimeSubscription.ts">
import { useEffect, useState, useCallback, useRef, useMemo } from 'react'
import { throttle } from 'lodash'
import { useSupabase } from './useSupabase'
import type { RealtimeChannel, RealtimePostgresChangesPayload } from '@supabase/supabase-js'
import type { Database } from '@/types/database'

type Tables = Database['public']['Tables']
type TableName = keyof Tables

interface UseRealtimeSubscriptionOptions<T extends TableName> {
  table: T
  filter?: string
  event?: 'INSERT' | 'UPDATE' | 'DELETE' | '*'
  enabled?: boolean
  onInsert?: (payload: RealtimePostgresChangesPayload<Tables[T]['Row']>) => void
  onUpdate?: (payload: RealtimePostgresChangesPayload<Tables[T]['Row']>) => void
  onDelete?: (payload: RealtimePostgresChangesPayload<Tables[T]['Row']>) => void
  onChange?: (payload: RealtimePostgresChangesPayload<Tables[T]['Row']>) => void
}

interface RealtimeState {
  isConnected: boolean
  isConnecting: boolean
  error: Error | null
  lastEvent: Date | null
}

/**
 * useRealtimeSubscription â€“ safe & resilient (Supabase v2.42+)
 */
export function useRealtimeSubscription<T extends TableName>({
  table,
  filter,
  event = '*',
  enabled = true,
  onInsert,
  onUpdate,
  onDelete,
  onChange,
}: UseRealtimeSubscriptionOptions<T>) {
  const supabase = useSupabase()
  const channelRef = useRef<RealtimeChannel | null>(null)
  const reconnectRef = useRef<ReturnType<typeof setTimeout> | undefined>(undefined)
  const [state, setState] = useState<RealtimeState>({
    isConnected: false,
    isConnecting: false,
    error: null,
    lastEvent: null,
  })

  /** 1ï¸âƒ£ Single throttled state update to avoid render-storm */
  const commitLastEvent = useCallback(() => {
    setState(p => ({ ...p, lastEvent: new Date() }))
  }, [])
  
  const throttledLastEvent = useMemo(
    () => throttle(commitLastEvent, 100, { leading: true, trailing: true }),
    [commitLastEvent]
  )

  /** 2ï¸âƒ£ Unified event router */
  const routeEvent = useCallback(
    (payload: RealtimePostgresChangesPayload<Tables[T]['Row']>) => {
      throttledLastEvent()
      switch (payload.eventType) {
        case 'INSERT': 
          onInsert?.(payload)
          break
        case 'UPDATE': 
          onUpdate?.(payload)
          break
        case 'DELETE': 
          onDelete?.(payload)
          break
      }
      onChange?.(payload)
    },
    [onInsert, onUpdate, onDelete, onChange, throttledLastEvent]
  )

  /** 3ï¸âƒ£ (Async) subscribe with guaranteed cleanup */
  const openChannel = useCallback(async () => {
    if (!enabled || channelRef.current) return

    setState(p => ({ ...p, isConnecting: true, error: null }))
    
    // Sanitize filter to prevent log injection
    const sanitizedFilter = filter?.replace(/[^\w.=(),]/g, '')
    const name = `rt:${table}:${sanitizedFilter ?? 'all'}:${Date.now()}`
    
    const config = { 
      event, 
      schema: 'public', 
      table, 
      ...(sanitizedFilter && { filter: sanitizedFilter }) 
    }

    channelRef.current = supabase
      .channel(name)
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      .on('postgres_changes' as any, config, routeEvent)

    channelRef.current.subscribe((status) => {
      switch (status) {
        case 'SUBSCRIBED':
          setState(p => ({ ...p, isConnected: true, isConnecting: false }))
          break
        case 'CHANNEL_ERROR':
        case 'TIMED_OUT':
        case 'CLOSED':
          setState(p => ({
            ...p,
            isConnected: false,
            isConnecting: false,
            error: new Error(`Channel ${status}`),
          }))
          break
      }
    })
  }, [enabled, table, filter, event, routeEvent, supabase])

  /** 4ï¸âƒ£ Reliable unsubscribe */
  const closeChannel = useCallback(async () => {
    if (!channelRef.current) return
    await supabase.removeChannel(channelRef.current) // await avoids race
    channelRef.current = null
  }, [supabase])

  /** 5ï¸âƒ£ Lifecycle */
  useEffect(() => { 
    openChannel()
    return () => { closeChannel() }
  }, [openChannel, closeChannel])

  /** 6ï¸âƒ£ Exponential back-off reconnect */
  const backoff = useRef(1000)
  
  useEffect(() => {
    if (state.isConnected) { 
      backoff.current = 1000
      return
    }
    if (state.isConnecting) return

    reconnectRef.current = setTimeout(async () => {
      await closeChannel()
      await openChannel()
      backoff.current = Math.min(backoff.current * 2, 30_000) // cap 30s
    }, backoff.current)

    return () => clearTimeout(reconnectRef.current)
  }, [state.isConnected, state.isConnecting, openChannel, closeChannel])

  return { 
    ...state, 
    subscribe: openChannel, 
    unsubscribe: closeChannel, 
    channel: channelRef.current 
  }
}

// Specialized hook for campaign subscriptions
export function useCampaignSubscription(
  campaignId?: string,
  options?: Partial<UseRealtimeSubscriptionOptions<'campaigns'>>
) {
  return useRealtimeSubscription({
    table: 'campaigns',
    filter: campaignId ? `id=eq.${campaignId}` : undefined,
    ...options,
  })
}

// Specialized hook for call subscriptions
export function useCallSubscription(
  filters?: {
    campaignId?: string
    status?: string[]
  },
  options?: Partial<UseRealtimeSubscriptionOptions<'calls'>>
) {
  const filterStrings: string[] = []

  if (filters?.campaignId) {
    filterStrings.push(`campaign_id=eq.${filters.campaignId}`)
  }

  if (filters?.status && filters.status.length > 0) {
    // Fix: Use proper IN syntax for multiple values
    const statusFilter = `status=in.(${filters.status.join(',')})`
    filterStrings.push(statusFilter)
  }

  return useRealtimeSubscription({
    table: 'calls',
    filter: filterStrings.length > 0 ? filterStrings.join(' AND ') : undefined,
    ...options,
  })
}

// Hook for aggregated stats subscriptions
export function useStatsSubscription<T extends TableName>(
  table: T,
  entityId: string,
  aggregationWindow?: number
) {
  const [stats, setStats] = useState<Tables[T]['Row'] | null>(null)
  const aggregationBuffer = useRef<Array<RealtimePostgresChangesPayload<Tables[T]['Row']>>>([])
  const aggregationTimer = useRef<ReturnType<typeof setTimeout> | undefined>(undefined)

  const processAggregation = useCallback(() => {
    if (aggregationBuffer.current.length === 0) return

    // Process buffered events
    const latestEvent = aggregationBuffer.current[aggregationBuffer.current.length - 1]
    if (latestEvent.new) {
      setStats(latestEvent.new as Tables[T]['Row'])
    }

    // Clear buffer
    aggregationBuffer.current = []
  }, [])

  const handleStatsChange = useCallback(
    (payload: RealtimePostgresChangesPayload<Tables[T]['Row']>) => {
      if (aggregationWindow && aggregationWindow > 0) {
        // Buffer events for aggregation
        aggregationBuffer.current.push(payload)

        // Reset timer
        if (aggregationTimer.current) {
          clearTimeout(aggregationTimer.current)
          aggregationTimer.current = undefined
        }

        // Set new timer
        aggregationTimer.current = setTimeout(processAggregation, aggregationWindow)
      } else {
        // Immediate update
        if (payload.new) {
          setStats(payload.new as Tables[T]['Row'])
        }
      }
    },
    [aggregationWindow, processAggregation]
  )

  const subscription = useRealtimeSubscription({
    table,
    filter: `id=eq.${entityId}`,
    onChange: handleStatsChange,
  })

  // Cleanup timer on unmount
  useEffect(() => {
    return () => {
      if (aggregationTimer.current) {
        clearTimeout(aggregationTimer.current)
        aggregationTimer.current = undefined
      }
    }
  }, [])

  return {
    stats,
    ...subscription,
  }
}
</file>

<file path="src/integrations/stripe/client.ts">
import Stripe from 'stripe'
import { loadStripe } from '@stripe/stripe-js'

const STRIPE_API_VERSION = '2025-06-30.basil' as const

export const stripeServerClient = new Stripe(import.meta.env.VITE_STRIPE_SECRET_KEY || '', {
  apiVersion: STRIPE_API_VERSION,
  typescript: true,
})

let stripePromise: Promise<import('@stripe/stripe-js').Stripe | null> | null = null

export const getStripeClient = () => {
  if (!stripePromise) {
    stripePromise = loadStripe(import.meta.env.VITE_STRIPE_PUBLISHABLE_KEY || '')
  }
  return stripePromise
}

export const stripeConfig = {
  webhookSecret: import.meta.env.VITE_STRIPE_WEBHOOK_SECRET || '',
  connectClientId: import.meta.env.VITE_STRIPE_CONNECT_CLIENT_ID || '',
  apiVersion: STRIPE_API_VERSION,
}

export const isStripeConfigured = () => {
  return !!(import.meta.env.VITE_STRIPE_SECRET_KEY && import.meta.env.VITE_STRIPE_PUBLISHABLE_KEY)
}
</file>

<file path="src/integrations/stripe/customers.ts">
import { stripeServerClient } from './client'
import type Stripe from 'stripe'
import { v4 as uuid } from 'uuid'

/**
 * Centralized error handler for Stripe operations
 * Prevents leaking sensitive information and provides type-safe error handling
 */
function handleStripeError(err: unknown, context: string): never {
  if (err instanceof stripeServerClient.errors.StripeError) {
    console.error(`${context} failed`, {
      type: err.type,
      code: err.code,
      param: err.param,
      requestId: err.requestId,
    })

    // Return generic error messages to prevent information leakage
    if (err.code === 'resource_missing') {
      throw new Error(`Resource not found. Please check your request and try again.`)
    }

    throw new Error(`Customer service error. Please retry or contact support.`)
  }

  console.error(`${context} unexpected error`, err)
  throw new Error('Internal server error. Please try again later.')
}

export const createStripeCustomer = async (
  email: string,
  metadata: {
    userId: string
    userType: 'buyer' | 'supplier'
    companyName?: string
  },
  additionalData?: {
    name?: string
    phone?: string
    address?: {
      line1?: string
      line2?: string
      city?: string
      state?: string
      postal_code?: string
      country?: string
    }
  }
): Promise<Stripe.Customer> => {
  try {
    const customer = await stripeServerClient.customers.create(
      {
        email,
        name: additionalData?.name,
        phone: additionalData?.phone,
        address: additionalData?.address,
        metadata: {
          ...metadata,
          platform: 'dependablecalls',
        },
      },
      {
        idempotencyKey: uuid(), // Prevent duplicate customer creation
      }
    )

    return customer
  } catch (error: unknown) {
    handleStripeError(error, 'create Stripe customer')
  }
}

export const updateStripeCustomer = async (
  customerId: string,
  updates: Stripe.CustomerUpdateParams
): Promise<Stripe.Customer> => {
  try {
    const customer = await stripeServerClient.customers.update(customerId, updates, {
      idempotencyKey: uuid(), // Prevent duplicate updates
    })

    return customer
  } catch (error: unknown) {
    handleStripeError(error, 'update Stripe customer')
  }
}

export const getStripeCustomer = async (customerId: string): Promise<Stripe.Customer | null> => {
  try {
    const customer = await stripeServerClient.customers.retrieve(customerId)

    if (customer.deleted) {
      return null
    }

    return customer as Stripe.Customer
  } catch (error: unknown) {
    if (
      error instanceof stripeServerClient.errors.StripeError &&
      error.code === 'resource_missing'
    ) {
      return null
    }
    handleStripeError(error, 'retrieve Stripe customer')
  }
}

export const deleteStripeCustomer = async (customerId: string): Promise<boolean> => {
  try {
    const result = await stripeServerClient.customers.del(customerId)
    return result.deleted
  } catch (error: unknown) {
    handleStripeError(error, 'delete Stripe customer')
  }
}

/**
 * List all payment methods for a customer with automatic pagination
 * Specifying type improves performance by 3-4x for large merchants
 */
export const listCustomerPaymentMethods = async (
  customerId: string,
  type: 'card' | 'us_bank_account' = 'card',
  limit = 100
): Promise<Stripe.PaymentMethod[]> => {
  try {
    const paymentMethods: Stripe.PaymentMethod[] = []

    // Use auto-pagination to ensure we get all payment methods
    for await (const paymentMethod of stripeServerClient.paymentMethods.list({
      customer: customerId,
      type, // Always specify type for better performance
      limit,
    })) {
      paymentMethods.push(paymentMethod)
    }

    return paymentMethods
  } catch (error: unknown) {
    handleStripeError(error, 'list payment methods')
  }
}

/**
 * Save a payment method using SetupIntent for SCA optimization
 * This replaces direct attachment and reduces decline rates by 10-20%
 * @deprecated Use savePaymentMethod instead of attachPaymentMethod
 */
export const attachPaymentMethod = async (
  paymentMethodId: string,
  customerId: string
): Promise<Stripe.PaymentMethod> => {
  console.warn(
    'attachPaymentMethod is deprecated. Use savePaymentMethod for better SCA compliance.'
  )
  return savePaymentMethod(customerId, paymentMethodId)
}

/**
 * Save a payment method using SetupIntent for proper SCA optimization
 * Reduces decline rates by 10-20% compared to direct attachment
 */
export const savePaymentMethod = async (
  customerId: string,
  paymentMethodId: string,
  metadata?: Record<string, string>
): Promise<Stripe.PaymentMethod> => {
  try {
    // Create a SetupIntent with the payment method
    const setupIntent = await stripeServerClient.setupIntents.create(
      {
        customer: customerId,
        payment_method_types: ['card', 'us_bank_account'],
        payment_method: paymentMethodId,
        confirm: true, // Immediately confirms and attaches
        usage: 'off_session',
        metadata: {
          ...metadata,
          platform: 'dependablecalls',
        },
      },
      { idempotencyKey: uuid() } // Prevents duplicate setup
    )

    if (setupIntent.status !== 'succeeded') {
      throw new Error(`SetupIntent failed with status: ${setupIntent.status}`)
    }

    // The PaymentMethod is now attached and 3DS optimized
    return stripeServerClient.paymentMethods.retrieve(paymentMethodId)
  } catch (error: unknown) {
    handleStripeError(error, 'save payment method')
  }
}

export const detachPaymentMethod = async (
  paymentMethodId: string
): Promise<Stripe.PaymentMethod> => {
  try {
    const paymentMethod = await stripeServerClient.paymentMethods.detach(paymentMethodId)

    return paymentMethod
  } catch (error: unknown) {
    handleStripeError(error, 'detach payment method')
  }
}

export const setDefaultPaymentMethod = async (
  customerId: string,
  paymentMethodId: string
): Promise<Stripe.Customer> => {
  try {
    const customer = await stripeServerClient.customers.update(
      customerId,
      {
        invoice_settings: {
          default_payment_method: paymentMethodId,
        },
      },
      {
        idempotencyKey: uuid(), // Prevent duplicate default method updates
      }
    )

    return customer
  } catch (error: unknown) {
    handleStripeError(error, 'set default payment method')
  }
}

export const createSetupIntent = async (
  customerId: string,
  metadata?: Record<string, string>
): Promise<Stripe.SetupIntent> => {
  try {
    const setupIntent = await stripeServerClient.setupIntents.create(
      {
        customer: customerId,
        payment_method_types: ['card', 'us_bank_account'],
        usage: 'off_session',
        metadata: {
          ...metadata,
          platform: 'dependablecalls',
        },
      },
      {
        idempotencyKey: uuid(), // Prevent duplicate setup intent creation
      }
    )

    return setupIntent
  } catch (error: unknown) {
    handleStripeError(error, 'create setup intent')
  }
}
</file>

<file path="src/integrations/stripe/payments.ts">
import { stripeServerClient } from './client'
import type { CreatePaymentIntentParams, PaymentStatus } from './types'
import type Stripe from 'stripe'
import { v4 as uuid } from 'uuid'

/**
 * Centralized error handler for Stripe operations
 * Prevents leaking sensitive information and provides type-safe error handling
 */
function handleStripeError(err: unknown, context: string): never {
  if (err instanceof stripeServerClient.errors.StripeError) {
    console.error(`${context} failed`, {
      type: err.type,
      code: err.code,
      param: err.param,
      requestId: err.requestId,
    })

    // Return generic error messages to prevent information leakage
    if (err.code === 'resource_missing') {
      throw new Error(`Resource not found. Please check your request and try again.`)
    }

    throw new Error(`Payment service error. Please retry or contact support.`)
  }

  console.error(`${context} unexpected error`, err)
  throw new Error('Internal server error. Please try again later.')
}

export const createPaymentIntent = async (
  params: CreatePaymentIntentParams
): Promise<Stripe.PaymentIntent> => {
  try {
    const paymentIntent = await stripeServerClient.paymentIntents.create(
      {
        amount: params.amount,
        currency: params.currency,
        customer: params.customerId,
        payment_method_types: params.paymentMethodTypes ?? ['card', 'us_bank_account'],
        metadata: {
          ...params.metadata,
          platform: 'dependablecalls',
        },
        setup_future_usage: 'off_session',
        automatic_payment_methods: {
          enabled: true, // Enable for better payment method management
        },
      },
      {
        idempotencyKey: uuid(), // Prevent duplicate payment intent creation
      }
    )

    return paymentIntent
  } catch (error: unknown) {
    handleStripeError(error, 'create payment intent')
  }
}

export const confirmPaymentIntent = async (
  paymentIntentId: string,
  paymentMethodId: string,
  returnUrl: string
): Promise<Stripe.PaymentIntent> => {
  try {
    const paymentIntent = await stripeServerClient.paymentIntents.confirm(
      paymentIntentId,
      {
        payment_method: paymentMethodId,
        return_url: returnUrl, // Required for payment methods that need redirect
      },
      {
        idempotencyKey: uuid(), // Prevent duplicate confirmation
      }
    )

    return paymentIntent
  } catch (error: unknown) {
    handleStripeError(error, 'confirm payment intent')
  }
}

export const cancelPaymentIntent = async (
  paymentIntentId: string
): Promise<Stripe.PaymentIntent> => {
  try {
    const paymentIntent = await stripeServerClient.paymentIntents.cancel(
      paymentIntentId,
      {},
      {
        idempotencyKey: uuid(), // Prevent duplicate cancellation
      }
    )

    return paymentIntent
  } catch (error: unknown) {
    handleStripeError(error, 'cancel payment intent')
  }
}

export const getPaymentIntent = async (
  paymentIntentId: string
): Promise<Stripe.PaymentIntent | null> => {
  try {
    const paymentIntent = await stripeServerClient.paymentIntents.retrieve(paymentIntentId)

    return paymentIntent
  } catch (error: unknown) {
    if (
      error instanceof stripeServerClient.errors.StripeError &&
      error.code === 'resource_missing'
    ) {
      return null
    }
    handleStripeError(error, 'retrieve payment intent')
  }
}

export const updatePaymentIntent = async (
  paymentIntentId: string,
  updates: Stripe.PaymentIntentUpdateParams
): Promise<Stripe.PaymentIntent> => {
  try {
    const paymentIntent = await stripeServerClient.paymentIntents.update(paymentIntentId, updates, {
      idempotencyKey: uuid(), // Prevent duplicate updates
    })

    return paymentIntent
  } catch (error: unknown) {
    handleStripeError(error, 'update payment intent')
  }
}

export const createRefund = async (
  paymentIntentId: string,
  amount?: number,
  reason?: 'duplicate' | 'fraudulent' | 'requested_by_customer',
  metadata?: Record<string, string>
): Promise<Stripe.Refund> => {
  try {
    const refund = await stripeServerClient.refunds.create(
      {
        payment_intent: paymentIntentId,
        amount,
        reason,
        metadata: {
          ...metadata,
          platform: 'dependablecalls',
        },
      },
      {
        idempotencyKey: uuid(), // Prevent duplicate refunds
      }
    )

    return refund
  } catch (error: unknown) {
    handleStripeError(error, 'create refund')
  }
}

export const getPaymentStatus = (paymentIntent: Stripe.PaymentIntent): PaymentStatus => {
  let status: PaymentStatus['status'] = 'pending'
  let error: string | undefined

  switch (paymentIntent.status) {
    case 'succeeded':
      status = 'succeeded'
      break
    case 'processing':
      status = 'processing'
      break
    case 'canceled':
    case 'requires_payment_method':
      status = 'failed'
      error = paymentIntent.last_payment_error?.message
      break
    default:
      status = 'pending'
  }

  return {
    id: paymentIntent.id,
    status,
    amount: paymentIntent.amount,
    currency: paymentIntent.currency,
    error,
  }
}

/**
 * List all payment intents for a customer with automatic pagination
 * This ensures we get ALL payments, not just the first page
 */
export const listCustomerPayments = async (
  customerId: string,
  limit = 1000 // Increased from 100 for better performance
): Promise<Stripe.PaymentIntent[]> => {
  try {
    const payments: Stripe.PaymentIntent[] = []

    // Use auto-pagination to ensure we get all payment intents
    for await (const paymentIntent of stripeServerClient.paymentIntents.list({
      customer: customerId,
      limit, // Page size
    })) {
      payments.push(paymentIntent)
    }

    return payments
  } catch (error: unknown) {
    handleStripeError(error, 'list customer payments')
  }
}

/**
 * Create and immediately capture a payment using PaymentIntents
 * This replaces the legacy charges.create API for SCA compliance
 * @deprecated Use createPaymentIntent with automatic capture instead
 */
export const createAndCapturePayment = async (
  amount: number,
  currency: string,
  paymentMethodId: string,
  customerId?: string,
  metadata?: Record<string, string>
): Promise<Stripe.PaymentIntent> => {
  try {
    // Create and confirm payment intent in one API call
    const paymentIntent = await stripeServerClient.paymentIntents.create(
      {
        amount,
        currency,
        payment_method: paymentMethodId,
        customer: customerId,
        confirm: true, // Immediately attempt to confirm
        capture_method: 'automatic', // Capture funds immediately on confirmation
        automatic_payment_methods: {
          enabled: true,
          allow_redirects: 'never', // For immediate capture, don't allow redirects
        },
        metadata: {
          ...metadata,
          platform: 'dependablecalls',
        },
      },
      {
        idempotencyKey: uuid(), // Prevent duplicate charges
      }
    )

    return paymentIntent
  } catch (error: unknown) {
    handleStripeError(error, 'create and capture payment')
  }
}

/**
 * Helper function to handle off-session payments (e.g., recurring charges)
 */
export const createOffSessionPayment = async (
  amount: number,
  currency: string,
  customerId: string,
  paymentMethodId: string,
  metadata?: Record<string, string>
): Promise<Stripe.PaymentIntent> => {
  try {
    const paymentIntent = await stripeServerClient.paymentIntents.create(
      {
        amount,
        currency,
        customer: customerId,
        payment_method: paymentMethodId,
        off_session: true,
        confirm: true,
        metadata: {
          ...metadata,
          platform: 'dependablecalls',
        },
      },
      {
        idempotencyKey: uuid(), // Prevent duplicate charges
      }
    )

    return paymentIntent
  } catch (error: unknown) {
    handleStripeError(error, 'create off-session payment')
  }
}
</file>

<file path="src/lib/apm.ts">
import React from 'react'
import * as Sentry from '@sentry/react'
// BrowserTracing is imported from Sentry package if needed

/**
 * Performance monitoring configuration
 */
export interface PerformanceConfig {
  enableWebVitals: boolean
  enableResourceTiming: boolean
  enableLongTasks: boolean
  enablePaintTiming: boolean
  sampleRate: number
}

/**
 * Web Vitals tracking
 */
export interface WebVitals {
  CLS: number // Cumulative Layout Shift
  FID: number // First Input Delay
  LCP: number // Largest Contentful Paint
  FCP: number // First Contentful Paint
  TTFB: number // Time to First Byte
  INP: number // Interaction to Next Paint
}

/**
 * Initialize Application Performance Monitoring
 */
export function initAPM(config: PerformanceConfig): void {
  // Web Vitals Observer
  if (config.enableWebVitals && 'PerformanceObserver' in window) {
    observeWebVitals()
  }

  // Resource Timing
  if (config.enableResourceTiming) {
    observeResourceTiming()
  }

  // Long Tasks
  if (config.enableLongTasks) {
    observeLongTasks()
  }

  // Paint Timing
  if (config.enablePaintTiming) {
    observePaintTiming()
  }
}

/**
 * Observe and track Web Vitals
 */
function observeWebVitals(): void {
  // LCP - Largest Contentful Paint
  new PerformanceObserver((list) => {
    const entries = list.getEntries()
    const lastEntry = entries[entries.length - 1]
    if (lastEntry) {
      trackMetric('web-vitals.lcp', lastEntry.startTime)
    }
  }).observe({ entryTypes: ['largest-contentful-paint'] })

  // FID - First Input Delay
  new PerformanceObserver((list) => {
    const entries = list.getEntries()
    entries.forEach((entry) => {
      if ('processingStart' in entry && 'startTime' in entry) {
        const fid = (entry as PerformanceEventTiming).processingStart - entry.startTime
        trackMetric('web-vitals.fid', fid)
      }
    })
  }).observe({ entryTypes: ['first-input'] })

  // CLS - Cumulative Layout Shift
  let clsValue = 0
  const clsEntries: PerformanceEntry[] = []
  new PerformanceObserver((list) => {
    const entries = list.getEntries() as LayoutShift[]
    entries.forEach((entry) => {
      if (!entry.hadRecentInput) {
        clsValue += entry.value
        clsEntries.push(entry)
      }
    })
    trackMetric('web-vitals.cls', clsValue)
  }).observe({ entryTypes: ['layout-shift'] })

  // INP - Interaction to Next Paint
  let inpValue = 0
  new PerformanceObserver((list) => {
    const entries = list.getEntries() as PerformanceEventTiming[]
    entries.forEach((entry) => {
      if (entry.duration > inpValue) {
        inpValue = entry.duration
        trackMetric('web-vitals.inp', inpValue)
      }
    })
  }).observe({ entryTypes: ['event'] })
}

/**
 * Track resource loading performance
 */
function observeResourceTiming(): void {
  new PerformanceObserver((list) => {
    const entries = list.getEntries() as PerformanceResourceTiming[]
    entries.forEach((entry) => {
      // Track slow resources
      if (entry.duration > 1000) {
        trackMetric('resource.slow', entry.duration, {
          name: entry.name,
          type: entry.initiatorType,
          size: entry.transferSize,
        })
      }

      // Track resource types
      trackMetric(`resource.${entry.initiatorType}`, entry.duration)
    })
  }).observe({ entryTypes: ['resource'] })
}

/**
 * Track long running tasks
 */
function observeLongTasks(): void {
  if (!('PerformanceLongTaskTiming' in window)) return

  new PerformanceObserver((list) => {
    const entries = list.getEntries()
    entries.forEach((entry) => {
      trackMetric('longtask', entry.duration, {
        startTime: entry.startTime,
      })
    })
  }).observe({ entryTypes: ['longtask'] })
}

/**
 * Track paint timing
 */
function observePaintTiming(): void {
  new PerformanceObserver((list) => {
    const entries = list.getEntries()
    entries.forEach((entry) => {
      if (entry.name === 'first-paint') {
        trackMetric('paint.fp', entry.startTime)
      } else if (entry.name === 'first-contentful-paint') {
        trackMetric('paint.fcp', entry.startTime)
      }
    })
  }).observe({ entryTypes: ['paint'] })
}

/**
 * Track custom performance metrics
 */
export function trackMetric(
  name: string,
  value: number,
  tags?: Record<string, string | number>
): void {
  // Send to Sentry
  Sentry.addBreadcrumb({
    category: 'performance',
    message: name,
    level: 'info',
    data: {
      value,
      ...tags,
    },
  })

  // Log to console in development
  if (import.meta.env.DEV) {
    console.log(`[APM] ${name}: ${value}ms`, tags)
  }

  // Send to custom analytics if configured
  if (window.analytics?.track) {
    window.analytics.track('Performance Metric', {
      metric_name: name,
      metric_value: value,
      ...tags,
    })
  }
}

/**
 * Measure component render performance
 */
export function measureComponentPerformance(componentName: string) {
  return function <T extends React.ComponentType<Record<string, unknown>>>(Component: T): T {
    const MeasuredComponent = (props: Record<string, unknown>) => {
      const startTime = performance.now()

      React.useEffect(() => {
        const renderTime = performance.now() - startTime
        trackMetric(`component.${componentName}.render`, renderTime)
      }, [startTime])

      return React.createElement(Component, props)
    }

    MeasuredComponent.displayName = `Measured(${componentName})`
    return MeasuredComponent as T
  }
}

/**
 * Track API call performance
 */
export async function trackAPICall<T>(endpoint: string, operation: () => Promise<T>): Promise<T> {
  const startTime = performance.now()

  try {
    const result = await operation()
    const duration = performance.now() - startTime

    trackMetric('api.success', duration, {
      endpoint,
    })

    return result
  } catch (error) {
    const duration = performance.now() - startTime

    trackMetric('api.error', duration, {
      endpoint,
      error: error instanceof Error ? error.message : 'Unknown error',
    })

    throw error
  }
}

/**
 * Bundle size tracking
 */
export function trackBundleSize(): void {
  if ('connection' in navigator) {
    const connection = (navigator as Navigator & { connection: NetworkInformation }).connection
    trackMetric('bundle.connection', 0, {
      effectiveType: connection.effectiveType,
      downlink: connection.downlink,
      rtt: connection.rtt,
    })
  }

  // Track total JS size
  const resources = performance.getEntriesByType('resource') as PerformanceResourceTiming[]
  const jsResources = resources.filter((r) => r.name.endsWith('.js'))
  const totalJsSize = jsResources.reduce((sum, r) => sum + r.transferSize, 0)

  trackMetric('bundle.js.total', totalJsSize)
}

/**
 * Memory usage tracking with modern API support
 */
export async function trackMemoryUsage(): Promise<void> {
  // Try modern API first (Chrome 115+)
  if ('measureUserAgentSpecificMemory' in performance) {
    try {
      const result = await (
        performance as unknown as {
          measureUserAgentSpecificMemory: () => Promise<{ bytes: number }>
        }
      ).measureUserAgentSpecificMemory()
      trackMetric('memory.used', result.bytes)
      return
    } catch {
      // Fall through to legacy API
    }
  }

  // Fall back to deprecated API for older browsers
  if ('memory' in performance) {
    const memory = (performance as Performance & { memory: MemoryInfo }).memory
    trackMetric('memory.used', memory.usedJSHeapSize)
    trackMetric('memory.total', memory.totalJSHeapSize)
    trackMetric('memory.limit', memory.jsHeapSizeLimit)
  }
  // Gracefully degrade - no error if neither API is available
}

/**
 * User timing API wrapper
 */
export function startMeasure(name: string): void {
  performance.mark(`${name}-start`)
}

export function endMeasure(name: string): number {
  performance.mark(`${name}-end`)
  performance.measure(name, `${name}-start`, `${name}-end`)

  const entries = performance.getEntriesByName(name)
  const duration = entries[entries.length - 1]?.duration || 0

  trackMetric(`measure.${name}`, duration)
  return duration
}

// Export singleton APM instance
export const apm = {
  init: initAPM,
  trackMetric,
  trackAPICall,
  trackBundleSize,
  trackMemoryUsage,
  startMeasure,
  endMeasure,
  measureComponentPerformance,
}

// TypeScript declarations for window.analytics
declare global {
  interface Window {
    analytics?: {
      track: (event: string, properties: Record<string, unknown>) => void
    }
  }

  interface LayoutShift extends PerformanceEntry {
    value: number
    hadRecentInput: boolean
  }

  interface PerformanceEventTiming extends PerformanceEntry {
    readonly processingStart: number
    duration: number
  }

  interface NetworkInformation {
    effectiveType: string
    downlink: number
    rtt: number
  }

  interface MemoryInfo {
    usedJSHeapSize: number
    totalJSHeapSize: number
    jsHeapSizeLimit: number
  }
}
</file>

<file path="src/lib/logger.ts">
import * as Sentry from '@sentry/react'

export type LogLevel = 'debug' | 'info' | 'warn' | 'error' | 'fatal'

export interface LogContext {
  userId?: string
  sessionId?: string
  requestId?: string
  component?: string
  action?: string
  paymentIntentId?: string
  chargeId?: string
  accountId?: string
  payoutId?: string
  transferId?: string
  // Additional properties for webhook handler
  type?: string
  id?: string
  eventId?: string
  eventType?: string
  error?: string
  amount?: number
  buyerId?: string
  reason?: string
  chargesEnabled?: boolean
  payoutsEnabled?: boolean
  arrivalDate?: number
  failureCode?: string | null
  failureMessage?: string | null
  destination?: string
  metadata?: Record<string, unknown>
}

export interface LogEntry {
  timestamp: string
  level: LogLevel
  message: string
  context?: LogContext
  error?: Error
  stack?: string
}

class Logger {
  private logBuffer: LogEntry[] = []
  private maxBufferSize = 100
  private flushInterval = 5000 // 5 seconds
  private flushTimer?: NodeJS.Timeout
  private endpoint = import.meta.env.VITE_LOG_ENDPOINT || '/api/logs'

  constructor() {
    // Start flush timer
    this.startFlushTimer()

    // Flush logs on page unload
    if (typeof window !== 'undefined') {
      window.addEventListener('beforeunload', () => this.flush())

      // Also handle visibility change for mobile
      document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'hidden') {
          this.flush()
        }
      })
    }
  }

  private startFlushTimer() {
    this.flushTimer = setInterval(() => {
      if (this.logBuffer.length > 0) {
        this.flush()
      }
    }, this.flushInterval)
  }

  private createLogEntry(
    level: LogLevel,
    message: string,
    context?: LogContext,
    error?: Error
  ): LogEntry {
    return {
      timestamp: new Date().toISOString(),
      level,
      message,
      context: {
        ...context,
        userAgent: navigator.userAgent,
        url: window.location.href,
        viewport: {
          width: window.innerWidth,
          height: window.innerHeight,
        },
      },
      error: error
        ? {
            name: error.name,
            message: error.message,
            stack: error.stack,
          }
        : undefined,
    } as LogEntry
  }

  private shouldLog(level: LogLevel): boolean {
    const levels = ['debug', 'info', 'warn', 'error', 'fatal']
    const currentLevel = import.meta.env.VITE_LOG_LEVEL || 'info'
    const currentLevelIndex = levels.indexOf(currentLevel)
    const messageLevelIndex = levels.indexOf(level)

    return messageLevelIndex >= currentLevelIndex
  }

  private addToBuffer(entry: LogEntry) {
    this.logBuffer.push(entry)

    // Flush if buffer is full
    if (this.logBuffer.length >= this.maxBufferSize) {
      this.flush()
    }
  }

  private async flush() {
    if (this.logBuffer.length === 0) return

    const logs = [...this.logBuffer]
    this.logBuffer = []

    try {
      // Send logs to backend
      if (import.meta.env.PROD) {
        await fetch(this.endpoint, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ logs }),
          keepalive: true, // Ensure request completes even on page unload
        })
      }
    } catch (error) {
      // Failed to send logs, re-add to buffer if not too large
      if (this.logBuffer.length + logs.length < this.maxBufferSize * 2) {
        this.logBuffer = [...logs, ...this.logBuffer]
      }
      console.error('Failed to flush logs:', error)
    }
  }

  debug(message: string, context?: LogContext) {
    if (!this.shouldLog('debug')) return

    const entry = this.createLogEntry('debug', message, context)
    console.debug(message, context)
    this.addToBuffer(entry)
  }

  info(message: string, context?: LogContext) {
    if (!this.shouldLog('info')) return

    const entry = this.createLogEntry('info', message, context)
    console.info(message, context)
    this.addToBuffer(entry)

    // Add breadcrumb to Sentry
    Sentry.addBreadcrumb({
      message,
      level: 'info',
      category: context?.component || 'general',
      data: context?.metadata,
    })
  }

  warn(message: string, context?: LogContext) {
    if (!this.shouldLog('warn')) return

    const entry = this.createLogEntry('warn', message, context)
    console.warn(message, context)
    this.addToBuffer(entry)

    // Add breadcrumb to Sentry
    Sentry.addBreadcrumb({
      message,
      level: 'warning',
      category: context?.component || 'general',
      data: context?.metadata,
    })
  }

  error(message: string, error?: Error, context?: LogContext) {
    if (!this.shouldLog('error')) return

    const entry = this.createLogEntry('error', message, context, error)
    console.error(message, error, context)
    this.addToBuffer(entry)

    // Send to Sentry
    if (error) {
      Sentry.captureException(error, {
        contexts: {
          log: context as Record<string, unknown>,
        },
      })
    } else {
      Sentry.captureMessage(message, 'error')
    }
  }

  fatal(message: string, error?: Error, context?: LogContext) {
    const entry = this.createLogEntry('fatal', message, context, error)
    console.error('FATAL:', message, error, context)
    this.addToBuffer(entry)

    // Immediately flush on fatal errors
    this.flush()

    // Send to Sentry with high priority
    if (error) {
      Sentry.captureException(error, {
        level: 'fatal',
        contexts: {
          log: context as Record<string, unknown>,
        },
      })
    } else {
      Sentry.captureMessage(message, 'fatal')
    }
  }

  // Structured logging for specific events
  logApiCall(endpoint: string, method: string, status: number, duration: number, error?: Error) {
    const context: LogContext = {
      component: 'api',
      action: `${method} ${endpoint}`,
      metadata: {
        endpoint,
        method,
        status,
        duration,
      },
    }

    if (error || status >= 400) {
      this.error(`API call failed: ${method} ${endpoint} - ${status}`, error, context)
    } else if (duration > 1000) {
      this.warn(`Slow API call: ${method} ${endpoint} - ${duration}ms`, context)
    } else {
      this.info(`API call: ${method} ${endpoint} - ${status}`, context)
    }
  }

  logUserAction(action: string, metadata?: Record<string, unknown>) {
    this.info(`User action: ${action}`, {
      component: 'user-interaction',
      action,
      metadata,
    })
  }

  logPerformance(metric: string, value: number, metadata?: Record<string, unknown>) {
    const context: LogContext = {
      component: 'performance',
      action: metric,
      metadata: {
        ...metadata,
        value,
      },
    }

    if (metric === 'page-load' && value > 3000) {
      this.warn(`Slow page load: ${value}ms`, context)
    } else {
      this.info(`Performance metric: ${metric} = ${value}`, context)
    }
  }

  logSecurityEvent(
    event: string,
    severity: 'low' | 'medium' | 'high',
    details?: Record<string, unknown>
  ) {
    const context: LogContext = {
      component: 'security',
      action: event,
      metadata: {
        severity,
        ...details,
      },
    }

    if (severity === 'high') {
      this.error(`Security event: ${event}`, undefined, context)
    } else if (severity === 'medium') {
      this.warn(`Security event: ${event}`, context)
    } else {
      this.info(`Security event: ${event}`, context)
    }
  }

  // Clean up
  destroy() {
    if (this.flushTimer) {
      clearInterval(this.flushTimer)
    }
    this.flush()
  }
}

// Export singleton instance
export const logger = new Logger()

// Export for use in error boundaries
export function logErrorBoundary(error: Error, errorInfo: React.ErrorInfo) {
  logger.error('React Error Boundary', error, {
    component: 'error-boundary',
    metadata: {
      componentStack: errorInfo.componentStack,
    },
  })
}

// Export for use in async error handlers
export function logUnhandledRejection(event: PromiseRejectionEvent) {
  logger.error('Unhandled Promise Rejection', new Error(event.reason), {
    component: 'global-error-handler',
    metadata: {
      reason: event.reason,
      promise: event.promise,
    },
  })
}

// Set up global error handlers
if (typeof window !== 'undefined') {
  window.addEventListener('unhandledrejection', logUnhandledRejection)

  window.addEventListener('error', (event) => {
    logger.error('Global error', event.error || new Error(event.message), {
      component: 'global-error-handler',
      metadata: {
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno,
      },
    })
  })
}
</file>

<file path="src/pages/auth/LoginPage.tsx">
import { useState } from 'react'
import { Link, useNavigate } from 'react-router-dom'
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { z } from 'zod'
import { useAuthStore } from '../../store/authStore'

const loginSchema = z.object({
  email: z.string().email('Please enter a valid email address'),
  password: z.string().min(6, 'Password must be at least 6 characters'),
  rememberMe: z.boolean().optional(),
})

type LoginFormData = z.infer<typeof loginSchema>

export default function LoginPage() {
  const navigate = useNavigate()
  const { signIn } = useAuthStore()
  const [error, setError] = useState('')
  const [loading, setLoading] = useState(false)

  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<LoginFormData>({
    resolver: zodResolver(loginSchema),
  })

  const onSubmit = async (data: LoginFormData) => {
    setError('')
    setLoading(true)

    try {
      await signIn(data.email, data.password)
      navigate('/app/dashboard')
    } catch (err: unknown) {
      const errorMessage = err instanceof Error ? err.message : 'Invalid email or password'
      setError(errorMessage)
    } finally {
      setLoading(false)
    }
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
      <div className="max-w-md w-full space-y-8">
        <div>
          <h2 className="mt-6 text-center text-3xl font-extrabold text-gray-900">
            Sign in to your account
          </h2>
          <p className="mt-2 text-center text-sm text-gray-600">
            Or{' '}
            <Link to="/register" className="font-medium text-primary-600 hover:text-primary-500">
              create a new account
            </Link>
          </p>
        </div>

        <form className="mt-8 space-y-6" onSubmit={handleSubmit(onSubmit)}>
          <div className="rounded-md shadow-sm -space-y-px">
            <div>
              <label htmlFor="email" className="sr-only">
                Email address
              </label>
              <input
                {...register('email')}
                type="email"
                autoComplete="email"
                className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-t-md focus:outline-none focus:ring-primary-500 focus:border-primary-500 focus:z-10 sm:text-sm"
                placeholder="Email address"
              />
              {errors.email && <p className="mt-1 text-sm text-red-600">{errors.email.message}</p>}
            </div>
            <div>
              <label htmlFor="password" className="sr-only">
                Password
              </label>
              <input
                {...register('password')}
                type="password"
                autoComplete="current-password"
                className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-b-md focus:outline-none focus:ring-primary-500 focus:border-primary-500 focus:z-10 sm:text-sm"
                placeholder="Password"
              />
              {errors.password && (
                <p className="mt-1 text-sm text-red-600">{errors.password.message}</p>
              )}
            </div>
          </div>

          {error && (
            <div className="rounded-md bg-red-50 p-4">
              <div className="flex">
                <div className="ml-3">
                  <h3 className="text-sm font-medium text-red-800">{error}</h3>
                </div>
              </div>
            </div>
          )}

          <div className="flex items-center justify-between">
            <div className="flex items-center">
              <input
                {...register('rememberMe')}
                id="remember-me"
                type="checkbox"
                className="h-4 w-4 text-primary-600 focus:ring-primary-500 border-gray-300 rounded"
              />
              <label htmlFor="remember-me" className="ml-2 block text-sm text-gray-900">
                Remember me
              </label>
            </div>

            <div className="text-sm">
              <Link
                to="/forgot-password"
                className="font-medium text-primary-600 hover:text-primary-500"
              >
                Forgot your password?
              </Link>
            </div>
          </div>

          <div>
            <button
              type="submit"
              disabled={loading}
              className="group relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-primary-600 hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {loading ? 'Signing in...' : 'Sign in'}
            </button>
          </div>
        </form>
      </div>
    </div>
  )
}
</file>

<file path="src/pages/auth/RegisterPage.tsx">
import { useState } from 'react'
import { Link, useNavigate, useLocation } from 'react-router-dom'
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { z } from 'zod'
import { useAuthStore } from '../../store/authStore'

const registerSchema = z
  .object({
    email: z.string().email('Please enter a valid email address'),
    password: z
      .string()
      .min(8, 'Password must be at least 8 characters')
      .regex(/[A-Z]/, 'Password must contain at least one uppercase letter')
      .regex(/[a-z]/, 'Password must contain at least one lowercase letter')
      .regex(/[0-9]/, 'Password must contain at least one number'),
    confirmPassword: z.string(),
    userType: z.enum(['supplier', 'buyer'], {
      message: 'Please select whether you are a supplier or buyer',
    }),
    acceptTerms: z.boolean().refine((val) => val === true, {
      message: 'You must accept the terms and conditions',
    }),
  })
  .refine((data) => data.password === data.confirmPassword, {
    message: "Passwords don't match",
    path: ['confirmPassword'],
  })

type RegisterFormData = z.infer<typeof registerSchema>

export default function RegisterPage() {
  const navigate = useNavigate()
  const location = useLocation()
  const { signUp } = useAuthStore()
  const [error, setError] = useState('')
  const [loading, setLoading] = useState(false)

  // Get selected plan from location state
  const selectedPlan = location.state?.selectedPlan

  const {
    register,
    handleSubmit,
    formState: { errors },
    watch,
  } = useForm<RegisterFormData>({
    resolver: zodResolver(registerSchema),
    defaultValues: {
      userType: 'supplier',
    },
  })

  const userType = watch('userType')

  const onSubmit = async (data: RegisterFormData) => {
    setError('')
    setLoading(true)

    try {
      await signUp(data.email, data.password, data.userType)
      navigate('/app/dashboard')
    } catch (err: unknown) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to create account'
      setError(errorMessage)
    } finally {
      setLoading(false)
    }
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
      <div className="max-w-md w-full space-y-8">
        <div>
          <h2 className="mt-6 text-center text-3xl font-extrabold text-gray-900">
            Create your account
          </h2>
          {selectedPlan && (
            <div className="mt-2 text-center">
              <span className="text-sm text-gray-600">Selected plan: </span>
              <span className="text-sm font-medium text-primary-600 capitalize">
                {selectedPlan}
              </span>
            </div>
          )}
          <p className="mt-2 text-center text-sm text-gray-600">
            Or{' '}
            <Link to="/login" className="font-medium text-primary-600 hover:text-primary-500">
              sign in to existing account
            </Link>
          </p>
        </div>

        <form className="mt-8 space-y-6" onSubmit={handleSubmit(onSubmit)}>
          {/* Account Type Selection */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">I am a...</label>
            <div className="grid grid-cols-2 gap-3">
              <label className="relative">
                <input
                  {...register('userType')}
                  type="radio"
                  value="supplier"
                  className="sr-only"
                />
                <div
                  className={`border rounded-lg p-4 cursor-pointer text-center ${
                    userType === 'supplier'
                      ? 'border-primary-500 bg-primary-50 text-primary-700'
                      : 'border-gray-300'
                  }`}
                >
                  <span className="block font-medium">Supplier</span>
                  <span className="block text-sm mt-1 text-gray-500">I have traffic to send</span>
                </div>
              </label>
              <label className="relative">
                <input {...register('userType')} type="radio" value="buyer" className="sr-only" />
                <div
                  className={`border rounded-lg p-4 cursor-pointer text-center ${
                    userType === 'buyer'
                      ? 'border-primary-500 bg-primary-50 text-primary-700'
                      : 'border-gray-300'
                  }`}
                >
                  <span className="block font-medium">Buyer</span>
                  <span className="block text-sm mt-1 text-gray-500">I need quality calls</span>
                </div>
              </label>
            </div>
          </div>
          {errors.userType && (
            <p className="mt-1 text-sm text-red-600">{errors.userType.message}</p>
          )}

          <div className="space-y-4">
            <div>
              <label htmlFor="email" className="block text-sm font-medium text-gray-700">
                Email address
              </label>
              <input
                {...register('email')}
                type="email"
                autoComplete="email"
                className="mt-1 appearance-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-md focus:outline-none focus:ring-primary-500 focus:border-primary-500 focus:z-10 sm:text-sm"
                placeholder="Enter your email"
              />
              {errors.email && <p className="mt-1 text-sm text-red-600">{errors.email.message}</p>}
            </div>

            <div>
              <label htmlFor="password" className="block text-sm font-medium text-gray-700">
                Password
              </label>
              <input
                {...register('password')}
                type="password"
                autoComplete="new-password"
                className="mt-1 appearance-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-md focus:outline-none focus:ring-primary-500 focus:border-primary-500 focus:z-10 sm:text-sm"
                placeholder="Create a password"
              />
              {errors.password && (
                <p className="mt-1 text-sm text-red-600">{errors.password.message}</p>
              )}
            </div>

            <div>
              <label htmlFor="confirmPassword" className="block text-sm font-medium text-gray-700">
                Confirm Password
              </label>
              <input
                {...register('confirmPassword')}
                type="password"
                autoComplete="new-password"
                className="mt-1 appearance-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-md focus:outline-none focus:ring-primary-500 focus:border-primary-500 focus:z-10 sm:text-sm"
                placeholder="Confirm your password"
              />
              {errors.confirmPassword && (
                <p className="mt-1 text-sm text-red-600">{errors.confirmPassword.message}</p>
              )}
            </div>
          </div>

          <div className="flex items-start">
            <input
              {...register('acceptTerms')}
              type="checkbox"
              className="h-4 w-4 text-primary-600 focus:ring-primary-500 border-gray-300 rounded"
            />
            <label className="ml-2 block text-sm text-gray-900">
              I agree to the{' '}
              <Link to="/terms" className="text-primary-600 hover:text-primary-500">
                Terms and Conditions
              </Link>{' '}
              and{' '}
              <Link to="/privacy" className="text-primary-600 hover:text-primary-500">
                Privacy Policy
              </Link>
            </label>
          </div>
          {errors.acceptTerms && (
            <p className="mt-1 text-sm text-red-600">{errors.acceptTerms.message}</p>
          )}

          {error && (
            <div className="rounded-md bg-red-50 p-4">
              <div className="flex">
                <div className="ml-3">
                  <h3 className="text-sm font-medium text-red-800">{error}</h3>
                </div>
              </div>
            </div>
          )}

          <div>
            <button
              type="submit"
              disabled={loading}
              className="group relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-primary-600 hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {loading ? 'Creating account...' : 'Create account'}
            </button>
          </div>
        </form>
      </div>
    </div>
  )
}
</file>

<file path="src/pages/public/ContactPage.tsx">
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { z } from 'zod'
import { useLocation } from 'react-router-dom'
import { EnvelopeIcon, PhoneIcon, MapPinIcon } from '@heroicons/react/24/outline'
import { useFormSubmission } from '../../hooks/useFormSubmission'

const contactSchema = z.object({
  firstName: z
    .string()
    .min(1, 'First name is required')
    .max(50, 'First name must be less than 50 characters'),
  lastName: z
    .string()
    .min(1, 'Last name is required')
    .max(50, 'Last name must be less than 50 characters'),
  email: z.string().email('Please enter a valid email address'),
  company: z.string().max(100, 'Company name must be less than 100 characters').optional(),
  phone: z.string().optional(),
  subject: z
    .string()
    .min(1, 'Subject is required')
    .max(200, 'Subject must be less than 200 characters'),
  message: z
    .string()
    .min(10, 'Message must be at least 10 characters')
    .max(2000, 'Message must be less than 2000 characters'),
})

type ContactFormData = z.infer<typeof contactSchema>

export default function ContactPage() {
  const location = useLocation()
  const { isLoading, error, isSuccess, handleSubmit: handleFormSubmit } = useFormSubmission()

  // Get inquiry type from location state
  const inquiryType = location.state?.inquiry
  const isEnterpriseInquiry = inquiryType === 'enterprise-pricing'

  const {
    register,
    handleSubmit,
    reset,
    formState: { errors },
  } = useForm<ContactFormData>({
    resolver: zodResolver(contactSchema),
    defaultValues: {
      subject: isEnterpriseInquiry ? 'Enterprise Pricing Inquiry' : '',
    },
  })

  const submitContactForm = async (data: ContactFormData) => {
    // Here you would normally send to your backend API
    // For now, we'll simulate the submission
    console.log('Contact form submitted:', data)

    // Simulate API call
    await new Promise((resolve) => setTimeout(resolve, 1500))

    // In a real app, you might want to send to an API endpoint:
    // const response = await fetch('/api/contact', {
    //   method: 'POST',
    //   headers: { 'Content-Type': 'application/json' },
    //   body: JSON.stringify(data),
    // })
    // if (!response.ok) throw new Error('Failed to send message')
  }

  const onSubmit = (data: ContactFormData) => {
    handleFormSubmit(data, submitContactForm, {
      onSuccess: () => {
        reset()
      },
      resetSuccessAfter: 5000,
    })
  }

  return (
    <div className="bg-white">
      {/* Header */}
      <div className="bg-gray-50">
        <div className="max-w-7xl mx-auto py-12 px-4 sm:px-6 lg:py-16 lg:px-8">
          <div className="text-center">
            <h1 className="text-4xl font-extrabold text-gray-900 sm:text-5xl">
              {isEnterpriseInquiry ? 'Enterprise Sales' : 'Contact Us'}
            </h1>
            <p className="mt-4 text-xl text-gray-500 max-w-2xl mx-auto">
              {isEnterpriseInquiry
                ? "Ready to scale your business? Let's discuss a custom enterprise solution tailored to your needs."
                : "Have questions? We'd love to hear from you. Send us a message and we'll respond as soon as possible."}
            </p>
          </div>
        </div>
      </div>

      {/* Contact Information and Form */}
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-12">
        <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
          {/* Contact Information */}
          <div className="lg:col-span-1">
            <div className="bg-gray-50 rounded-lg p-8">
              <h2 className="text-2xl font-bold text-gray-900 mb-6">Get in Touch</h2>

              <div className="space-y-6">
                <div className="flex items-start">
                  <PhoneIcon className="h-6 w-6 text-primary-600 mt-1" />
                  <div className="ml-4">
                    <h3 className="text-lg font-medium text-gray-900">Phone</h3>
                    <p className="mt-1 text-gray-600">+1 (555) 123-4567</p>
                    <p className="text-sm text-gray-500">Mon-Fri 9AM-6PM PST</p>
                  </div>
                </div>

                <div className="flex items-start">
                  <EnvelopeIcon className="h-6 w-6 text-primary-600 mt-1" />
                  <div className="ml-4">
                    <h3 className="text-lg font-medium text-gray-900">Email</h3>
                    <p className="mt-1 text-gray-600">support@dependablecalls.com</p>
                    <p className="text-sm text-gray-500">Response within 24 hours</p>
                  </div>
                </div>

                <div className="flex items-start">
                  <MapPinIcon className="h-6 w-6 text-primary-600 mt-1" />
                  <div className="ml-4">
                    <h3 className="text-lg font-medium text-gray-900">Office</h3>
                    <p className="mt-1 text-gray-600">
                      123 Business Center
                      <br />
                      Suite 400
                      <br />
                      San Francisco, CA 94105
                    </p>
                  </div>
                </div>
              </div>

              <div className="mt-8 pt-8 border-t border-gray-200">
                <h3 className="text-lg font-medium text-gray-900 mb-4">Business Hours</h3>
                <div className="space-y-2 text-gray-600">
                  <p>Monday - Friday: 9:00 AM - 6:00 PM PST</p>
                  <p>Saturday: 10:00 AM - 4:00 PM PST</p>
                  <p>Sunday: Closed</p>
                </div>
              </div>
            </div>
          </div>

          {/* Contact Form */}
          <div className="lg:col-span-2">
            <form onSubmit={handleSubmit(onSubmit)} className="bg-white shadow-lg rounded-lg p-8">
              <h2 className="text-2xl font-bold text-gray-900 mb-6">
                {isEnterpriseInquiry ? 'Request Enterprise Pricing' : 'Send us a Message'}
              </h2>

              {isEnterpriseInquiry && (
                <div className="mb-6 p-4 bg-blue-50 border border-blue-200 rounded-md">
                  <p className="text-blue-800 text-sm">
                    Interested in our Enterprise plan? We'll provide you with custom pricing and
                    dedicated support options.
                  </p>
                </div>
              )}

              {isSuccess && (
                <div className="mb-6 p-4 bg-green-50 border border-green-200 rounded-md">
                  <p className="text-green-800">
                    Thank you for your message! We'll get back to you soon.
                  </p>
                </div>
              )}

              {error && (
                <div className="mb-6 p-4 bg-red-50 border border-red-200 rounded-md">
                  <p className="text-red-800">{error}</p>
                </div>
              )}

              <div className="grid grid-cols-1 sm:grid-cols-2 gap-6">
                <div>
                  <label htmlFor="firstName" className="block text-sm font-medium text-gray-700">
                    First Name *
                  </label>
                  <input
                    type="text"
                    {...register('firstName')}
                    className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-primary-500 focus:ring-primary-500"
                  />
                  {errors.firstName && (
                    <p className="mt-1 text-sm text-red-600">{errors.firstName.message}</p>
                  )}
                </div>

                <div>
                  <label htmlFor="lastName" className="block text-sm font-medium text-gray-700">
                    Last Name *
                  </label>
                  <input
                    type="text"
                    {...register('lastName')}
                    className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-primary-500 focus:ring-primary-500"
                  />
                  {errors.lastName && (
                    <p className="mt-1 text-sm text-red-600">{errors.lastName.message}</p>
                  )}
                </div>

                <div>
                  <label htmlFor="email" className="block text-sm font-medium text-gray-700">
                    Email *
                  </label>
                  <input
                    type="email"
                    {...register('email')}
                    className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-primary-500 focus:ring-primary-500"
                  />
                  {errors.email && (
                    <p className="mt-1 text-sm text-red-600">{errors.email.message}</p>
                  )}
                </div>

                <div>
                  <label htmlFor="phone" className="block text-sm font-medium text-gray-700">
                    Phone
                  </label>
                  <input
                    type="tel"
                    {...register('phone')}
                    className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-primary-500 focus:ring-primary-500"
                  />
                </div>

                <div className="sm:col-span-2">
                  <label htmlFor="company" className="block text-sm font-medium text-gray-700">
                    Company
                  </label>
                  <input
                    type="text"
                    {...register('company')}
                    className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-primary-500 focus:ring-primary-500"
                  />
                </div>

                <div className="sm:col-span-2">
                  <label htmlFor="subject" className="block text-sm font-medium text-gray-700">
                    Subject *
                  </label>
                  <input
                    type="text"
                    {...register('subject')}
                    className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-primary-500 focus:ring-primary-500"
                  />
                  {errors.subject && (
                    <p className="mt-1 text-sm text-red-600">{errors.subject.message}</p>
                  )}
                </div>

                <div className="sm:col-span-2">
                  <label htmlFor="message" className="block text-sm font-medium text-gray-700">
                    Message *
                  </label>
                  <textarea
                    {...register('message')}
                    rows={6}
                    className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-primary-500 focus:ring-primary-500"
                  />
                  {errors.message && (
                    <p className="mt-1 text-sm text-red-600">{errors.message.message}</p>
                  )}
                </div>
              </div>

              <div className="mt-6">
                <button
                  type="submit"
                  disabled={isLoading}
                  className="w-full sm:w-auto px-6 py-3 border border-transparent text-base font-medium rounded-md text-white bg-primary-600 hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500 disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  {isLoading ? 'Sending...' : 'Send Message'}
                </button>
              </div>
            </form>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/pages/public/HomePage.tsx">
import { Link, useNavigate } from 'react-router-dom'
import { useEffect } from 'react'
import { handleHashChange } from '../../utils/navigation'
import {
  PhoneIcon,
  ChartBarIcon,
  ShieldCheckIcon,
  CurrencyDollarIcon,
  BoltIcon,
  GlobeAltIcon,
} from '@heroicons/react/24/outline'

const features = [
  {
    name: 'Real-Time Call Tracking',
    description:
      'Monitor your calls as they happen with our advanced real-time dashboard and analytics.',
    icon: PhoneIcon,
  },
  {
    name: 'Fraud Prevention',
    description:
      'Industry-leading fraud detection powered by machine learning protects your campaigns.',
    icon: ShieldCheckIcon,
  },
  {
    name: 'Quality Scoring',
    description:
      'Automatic call quality scoring ensures you only pay for high-intent, qualified leads.',
    icon: ChartBarIcon,
  },
  {
    name: 'Flexible Payouts',
    description: 'Choose from daily, weekly, or monthly payouts with multiple payment methods.',
    icon: CurrencyDollarIcon,
  },
  {
    name: 'Instant Routing',
    description: 'Calls are routed to the best buyer in milliseconds based on your criteria.',
    icon: BoltIcon,
  },
  {
    name: 'Global Coverage',
    description: 'Accept calls from anywhere with support for international numbers and routing.',
    icon: GlobeAltIcon,
  },
]

const stats = [
  { label: 'Active Campaigns', value: '10,000+' },
  { label: 'Calls Per Month', value: '2.5M+' },
  { label: 'Average Quality Score', value: '94%' },
  { label: 'Uptime SLA', value: '99.9%' },
]

export default function HomePage() {
  const navigate = useNavigate()

  const handlePricingClick = (plan: string) => {
    // Track the pricing plan selection and navigate to registration
    console.log(`Selected pricing plan: ${plan}`)
    navigate('/register', { state: { selectedPlan: plan } })
  }

  const handleContactSales = () => {
    navigate('/contact', { state: { inquiry: 'enterprise-pricing' } })
  }

  useEffect(() => {
    // Handle hash navigation on page load
    handleHashChange()

    // Listen for hash changes
    const handleHashChangeEvent = () => handleHashChange()
    window.addEventListener('hashchange', handleHashChangeEvent)

    return () => {
      window.removeEventListener('hashchange', handleHashChangeEvent)
    }
  }, [])

  return (
    <div>
      {/* Hero Section */}
      <div className="relative bg-white">
        <div className="max-w-7xl mx-auto">
          <div className="relative z-10 pb-8 bg-white sm:pb-16 md:pb-20 lg:max-w-2xl lg:w-full lg:pb-28 xl:pb-32">
            <main className="mt-10 mx-auto max-w-7xl px-4 sm:mt-12 sm:px-6 md:mt-16 lg:mt-20 lg:px-8 xl:mt-28">
              <div className="sm:text-center lg:text-left">
                <h1 className="text-4xl tracking-tight font-extrabold text-gray-900 sm:text-5xl md:text-6xl">
                  <span className="block">The Most Trusted</span>
                  <span className="block text-primary-600">Pay-Per-Call Network</span>
                </h1>
                <p className="mt-3 text-base text-gray-500 sm:mt-5 sm:text-lg sm:max-w-xl sm:mx-auto md:mt-5 md:text-xl lg:mx-0">
                  Connect quality callers with businesses that need them. Real-time tracking, fraud
                  prevention, and instant payouts make DependableCalls the platform of choice for
                  performance marketers.
                </p>
                <div className="mt-5 sm:mt-8 sm:flex sm:justify-center lg:justify-start">
                  <div className="rounded-md shadow">
                    <Link
                      to="/register"
                      className="w-full flex items-center justify-center px-8 py-3 border border-transparent text-base font-medium rounded-md text-white bg-primary-600 hover:bg-primary-700 md:py-4 md:text-lg md:px-10"
                    >
                      Get Started
                    </Link>
                  </div>
                  <div className="mt-3 sm:mt-0 sm:ml-3">
                    <Link
                      to="/login"
                      className="w-full flex items-center justify-center px-8 py-3 border border-transparent text-base font-medium rounded-md text-primary-700 bg-primary-100 hover:bg-primary-200 md:py-4 md:text-lg md:px-10"
                    >
                      Login
                    </Link>
                  </div>
                </div>
              </div>
            </main>
          </div>
        </div>
        <div className="lg:absolute lg:inset-y-0 lg:right-0 lg:w-1/2">
          <div className="h-56 w-full bg-gradient-to-br from-primary-500 to-primary-700 sm:h-72 md:h-96 lg:w-full lg:h-full" />
        </div>
      </div>

      {/* Stats Section */}
      <div className="bg-primary-700">
        <div className="max-w-7xl mx-auto py-12 px-4 sm:py-16 sm:px-6 lg:px-8 lg:py-20">
          <div className="max-w-4xl mx-auto text-center">
            <h2 className="text-3xl font-extrabold text-white sm:text-4xl">
              Trusted by thousands of performance marketers
            </h2>
          </div>
          <dl className="mt-10 text-center sm:max-w-3xl sm:mx-auto sm:grid sm:grid-cols-2 sm:gap-8 lg:max-w-none lg:grid-cols-4">
            {stats.map((stat) => (
              <div key={stat.label} className="flex flex-col mt-10 sm:mt-0">
                <dt className="order-2 mt-2 text-lg leading-6 font-medium text-primary-200">
                  {stat.label}
                </dt>
                <dd className="order-1 text-5xl font-extrabold text-white">{stat.value}</dd>
              </div>
            ))}
          </dl>
        </div>
      </div>

      {/* Features Section */}
      <div id="features" className="py-12 bg-white scroll-offset">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="lg:text-center">
            <h2 className="text-base text-primary-600 font-semibold tracking-wide uppercase">
              Features
            </h2>
            <p className="mt-2 text-3xl leading-8 font-extrabold tracking-tight text-gray-900 sm:text-4xl">
              Everything you need to succeed
            </p>
            <p className="mt-4 max-w-2xl text-xl text-gray-500 lg:mx-auto">
              Our platform provides all the tools and features you need to run successful
              pay-per-call campaigns.
            </p>
          </div>

          <div className="mt-10">
            <dl className="space-y-10 md:space-y-0 md:grid md:grid-cols-2 lg:grid-cols-3 md:gap-x-8 md:gap-y-10">
              {features.map((feature) => (
                <div key={feature.name} className="relative">
                  <dt>
                    <div className="absolute flex items-center justify-center h-12 w-12 rounded-md bg-primary-500 text-white">
                      <feature.icon className="h-6 w-6" aria-hidden="true" />
                    </div>
                    <p className="ml-16 text-lg leading-6 font-medium text-gray-900">
                      {feature.name}
                    </p>
                  </dt>
                  <dd className="mt-2 ml-16 text-base text-gray-500">{feature.description}</dd>
                </div>
              ))}
            </dl>
          </div>
        </div>
      </div>

      {/* Pricing Section */}
      <div id="pricing" className="py-12 bg-gray-50 scroll-offset">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="lg:text-center">
            <h2 className="text-base text-primary-600 font-semibold tracking-wide uppercase">
              Pricing
            </h2>
            <p className="mt-2 text-3xl leading-8 font-extrabold tracking-tight text-gray-900 sm:text-4xl">
              Simple, transparent pricing
            </p>
            <p className="mt-4 max-w-2xl text-xl text-gray-500 lg:mx-auto">
              Choose the plan that fits your business needs. All plans include our core features.
            </p>
          </div>

          <div className="mt-10">
            <div className="space-y-4 sm:space-y-0 sm:grid sm:grid-cols-3 sm:gap-6 lg:gap-8">
              {/* Basic Plan */}
              <div className="bg-white border border-gray-200 rounded-lg shadow-sm divide-y divide-gray-200">
                <div className="p-6">
                  <h3 className="text-lg leading-6 font-medium text-gray-900">Basic</h3>
                  <p className="mt-4 text-sm text-gray-500">Perfect for getting started</p>
                  <p className="mt-8">
                    <span className="text-4xl font-extrabold text-gray-900">$0</span>
                    <span className="text-base font-medium text-gray-500">/month</span>
                  </p>
                  <button
                    onClick={() => handlePricingClick('basic')}
                    className="mt-8 block w-full bg-gray-800 py-2 text-center text-sm font-semibold text-white rounded-md hover:bg-gray-900 transition-colors duration-200"
                  >
                    Get started
                  </button>
                </div>
                <div className="pt-6 pb-8 px-6">
                  <h4 className="text-xs font-medium text-gray-900 tracking-wide uppercase">
                    What's included
                  </h4>
                  <ul className="mt-6 space-y-4">
                    <li className="flex space-x-3">
                      <span className="text-green-500">âœ“</span>
                      <span className="text-sm text-gray-500">Up to 100 calls/month</span>
                    </li>
                    <li className="flex space-x-3">
                      <span className="text-green-500">âœ“</span>
                      <span className="text-sm text-gray-500">Basic analytics</span>
                    </li>
                    <li className="flex space-x-3">
                      <span className="text-green-500">âœ“</span>
                      <span className="text-sm text-gray-500">Email support</span>
                    </li>
                  </ul>
                </div>
              </div>

              {/* Professional Plan */}
              <div className="bg-white border border-primary-500 rounded-lg shadow-sm divide-y divide-gray-200">
                <div className="p-6">
                  <h3 className="text-lg leading-6 font-medium text-gray-900">Professional</h3>
                  <p className="mt-4 text-sm text-gray-500">Best for growing businesses</p>
                  <p className="mt-8">
                    <span className="text-4xl font-extrabold text-gray-900">$299</span>
                    <span className="text-base font-medium text-gray-500">/month</span>
                  </p>
                  <button
                    onClick={() => handlePricingClick('professional')}
                    className="mt-8 block w-full bg-primary-600 py-2 text-center text-sm font-semibold text-white rounded-md hover:bg-primary-700 transition-colors duration-200"
                  >
                    Start free trial
                  </button>
                </div>
                <div className="pt-6 pb-8 px-6">
                  <h4 className="text-xs font-medium text-gray-900 tracking-wide uppercase">
                    What's included
                  </h4>
                  <ul className="mt-6 space-y-4">
                    <li className="flex space-x-3">
                      <span className="text-green-500">âœ“</span>
                      <span className="text-sm text-gray-500">Up to 1,000 calls/month</span>
                    </li>
                    <li className="flex space-x-3">
                      <span className="text-green-500">âœ“</span>
                      <span className="text-sm text-gray-500">Advanced analytics</span>
                    </li>
                    <li className="flex space-x-3">
                      <span className="text-green-500">âœ“</span>
                      <span className="text-sm text-gray-500">Priority support</span>
                    </li>
                    <li className="flex space-x-3">
                      <span className="text-green-500">âœ“</span>
                      <span className="text-sm text-gray-500">API access</span>
                    </li>
                  </ul>
                </div>
              </div>

              {/* Enterprise Plan */}
              <div className="bg-white border border-gray-200 rounded-lg shadow-sm divide-y divide-gray-200">
                <div className="p-6">
                  <h3 className="text-lg leading-6 font-medium text-gray-900">Enterprise</h3>
                  <p className="mt-4 text-sm text-gray-500">For high-volume operations</p>
                  <p className="mt-8">
                    <span className="text-4xl font-extrabold text-gray-900">Custom</span>
                  </p>
                  <button
                    onClick={handleContactSales}
                    className="mt-8 block w-full bg-gray-800 py-2 text-center text-sm font-semibold text-white rounded-md hover:bg-gray-900 transition-colors duration-200"
                  >
                    Contact sales
                  </button>
                </div>
                <div className="pt-6 pb-8 px-6">
                  <h4 className="text-xs font-medium text-gray-900 tracking-wide uppercase">
                    What's included
                  </h4>
                  <ul className="mt-6 space-y-4">
                    <li className="flex space-x-3">
                      <span className="text-green-500">âœ“</span>
                      <span className="text-sm text-gray-500">Unlimited calls</span>
                    </li>
                    <li className="flex space-x-3">
                      <span className="text-green-500">âœ“</span>
                      <span className="text-sm text-gray-500">Custom integrations</span>
                    </li>
                    <li className="flex space-x-3">
                      <span className="text-green-500">âœ“</span>
                      <span className="text-sm text-gray-500">Dedicated account manager</span>
                    </li>
                    <li className="flex space-x-3">
                      <span className="text-green-500">âœ“</span>
                      <span className="text-sm text-gray-500">24/7 phone support</span>
                    </li>
                  </ul>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* About Section */}
      <div id="about" className="py-12 bg-white scroll-offset">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="lg:text-center">
            <h2 className="text-base text-primary-600 font-semibold tracking-wide uppercase">
              About Us
            </h2>
            <p className="mt-2 text-3xl leading-8 font-extrabold tracking-tight text-gray-900 sm:text-4xl">
              The trusted pay-per-call network
            </p>
            <p className="mt-4 max-w-2xl text-xl text-gray-500 lg:mx-auto">
              We've been connecting quality traffic providers with serious advertisers since 2020,
              building a reputation for transparency, reliability, and exceptional results.
            </p>
          </div>

          <div className="mt-10">
            <div className="space-y-10 md:space-y-0 md:grid md:grid-cols-2 md:gap-x-8 md:gap-y-10">
              <div className="bg-gray-50 rounded-lg p-6">
                <h3 className="text-lg font-medium text-gray-900">Our Mission</h3>
                <p className="mt-2 text-base text-gray-500">
                  To create a transparent, fraud-free marketplace where traffic suppliers and
                  advertisers can build mutually beneficial relationships based on quality and
                  performance.
                </p>
              </div>
              <div className="bg-gray-50 rounded-lg p-6">
                <h3 className="text-lg font-medium text-gray-900">Why Choose Us</h3>
                <p className="mt-2 text-base text-gray-500">
                  With industry-leading fraud detection, real-time analytics, and a commitment to
                  partner success, we're the platform of choice for serious performance marketers.
                </p>
              </div>
            </div>

            <div className="mt-10 grid grid-cols-2 gap-4 md:grid-cols-4">
              <div className="text-center">
                <p className="text-4xl font-extrabold text-primary-600">$50M+</p>
                <p className="mt-2 text-base text-gray-500">Revenue Generated</p>
              </div>
              <div className="text-center">
                <p className="text-4xl font-extrabold text-primary-600">10K+</p>
                <p className="mt-2 text-base text-gray-500">Active Campaigns</p>
              </div>
              <div className="text-center">
                <p className="text-4xl font-extrabold text-primary-600">500+</p>
                <p className="mt-2 text-base text-gray-500">Trusted Partners</p>
              </div>
              <div className="text-center">
                <p className="text-4xl font-extrabold text-primary-600">24/7</p>
                <p className="mt-2 text-base text-gray-500">Support Available</p>
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* CTA Section */}
      <div className="bg-gray-50">
        <div className="max-w-7xl mx-auto py-12 px-4 sm:px-6 lg:py-16 lg:px-8 lg:flex lg:items-center lg:justify-between">
          <h2 className="text-3xl font-extrabold tracking-tight text-gray-900 sm:text-4xl">
            <span className="block">Ready to get started?</span>
            <span className="block text-primary-600">Start your free trial today.</span>
          </h2>
          <div className="mt-8 flex lg:mt-0 lg:flex-shrink-0">
            <div className="inline-flex rounded-md shadow">
              <Link
                to="/register"
                className="inline-flex items-center justify-center px-5 py-3 border border-transparent text-base font-medium rounded-md text-white bg-primary-600 hover:bg-primary-700 transition-colors duration-200"
              >
                Get started
              </Link>
            </div>
            <div className="ml-3 inline-flex rounded-md shadow">
              <Link
                to="/contact"
                className="inline-flex items-center justify-center px-5 py-3 border border-transparent text-base font-medium rounded-md text-primary-600 bg-white hover:bg-primary-50 transition-colors duration-200"
              >
                Contact sales
              </Link>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/store/authStore.ts">
import { create } from 'zustand'
import { persist } from 'zustand/middleware'
import type { Session } from '@supabase/supabase-js'
import { supabase } from '../lib/supabase'
import { type User, createExtendedUser } from '../types/auth'

interface AuthState {
  user: User | null
  session: Session | null
  userType: 'supplier' | 'buyer' | 'admin' | null
  loading: boolean
  isAuthenticated: boolean
  setUser: (user: User | null) => void
  setSession: (session: Session | null) => void
  setUserType: (userType: 'supplier' | 'buyer' | 'admin' | null) => void
  signIn: (email: string, password: string) => Promise<void>
  signUp: (email: string, password: string, userType: 'supplier' | 'buyer') => Promise<void>
  signOut: () => Promise<void>
  checkSession: () => Promise<void>
}

export const useAuthStore = create<AuthState>()(
  persist(
    (set, get) => ({
      user: null,
      session: null,
      userType: null,
      loading: true,

      get isAuthenticated() {
        return !!get().user && !!get().session
      },

      setUser: (user) => set({ user }),
      setSession: (session) => set({ session }),
      setUserType: (userType) => set({ userType }),

      signIn: async (email, password) => {
        const { data, error } = await supabase.auth.signInWithPassword({
          email,
          password,
        })

        if (error) throw error

        if (data.user && data.session) {
          // Determine user type by checking related tables
          const [supplierCheck, buyerCheck, adminCheck] = await Promise.all([
            supabase.from('suppliers').select('*').eq('user_id', data.user.id).single(),
            supabase.from('buyers').select('*').eq('user_id', data.user.id).single(),
            supabase.from('admins').select('*').eq('user_id', data.user.id).single(),
          ])

          const extendedUser = createExtendedUser(
            data.user,
            supplierCheck.data,
            buyerCheck.data,
            adminCheck.data
          )

          let userType: 'supplier' | 'buyer' | 'admin' | null = null
          if (adminCheck.data) {
            userType = 'admin'
          } else if (buyerCheck.data) {
            userType = 'buyer'
          } else if (supplierCheck.data) {
            userType = 'supplier'
          }

          set({ user: extendedUser, session: data.session, userType })
        }
      },

      signUp: async (email, password, userType) => {
        const { data, error } = await supabase.auth.signUp({
          email,
          password,
          options: {
            data: { user_type: userType },
          },
        })

        if (error) throw error

        if (data.user && data.session) {
          // For signup, create a basic extended user (additional data will be added later)
          const extendedUser = createExtendedUser(data.user)
          extendedUser.userType = userType
          set({ user: extendedUser, session: data.session, userType })
        }
      },

      signOut: async () => {
        await supabase.auth.signOut()
        set({ user: null, session: null, userType: null })
      },

      checkSession: async () => {
        set({ loading: true })

        const {
          data: { session },
        } = await supabase.auth.getSession()

        if (session) {
          // Determine user type by checking related tables
          const [supplierCheck, buyerCheck, adminCheck] = await Promise.all([
            supabase.from('suppliers').select('*').eq('user_id', session.user.id).single(),
            supabase.from('buyers').select('*').eq('user_id', session.user.id).single(),
            supabase.from('admins').select('*').eq('user_id', session.user.id).single(),
          ])

          const extendedUser = createExtendedUser(
            session.user,
            supplierCheck.data,
            buyerCheck.data,
            adminCheck.data
          )

          let userType: 'supplier' | 'buyer' | 'admin' | null = null
          if (adminCheck.data) {
            userType = 'admin'
          } else if (buyerCheck.data) {
            userType = 'buyer'
          } else if (supplierCheck.data) {
            userType = 'supplier'
          }

          set({ user: extendedUser, session, userType })
        }

        set({ loading: false })
      },
    }),
    {
      name: 'auth-storage',
      partialize: (state) => ({
        user: state.user,
        session: state.session,
        userType: state.userType,
      }),
    }
  )
)
</file>

<file path="src/test/test-utils.tsx">
import React from 'react'
import { render } from '@testing-library/react'
import type { RenderOptions } from '@testing-library/react'
import { QueryClient } from '@tanstack/react-query'
import { AllTheProviders } from './providers'

interface CustomRenderOptions extends Omit<RenderOptions, 'wrapper'> {
  queryClient?: QueryClient
}

const customRender = (ui: React.ReactElement, options: CustomRenderOptions = {}) => {
  const { queryClient, ...renderOptions } = options

  return render(ui, {
    wrapper: ({ children }) => (
      <AllTheProviders queryClient={queryClient}>{children}</AllTheProviders>
    ),
    ...renderOptions,
  })
}

// Re-export specific exports instead of using export *
export {
  act,
  cleanup,
  fireEvent,
  screen,
  waitFor,
  waitForElementToBeRemoved,
  within,
  configure,
  prettyDOM,
  queries,
  queryHelpers,
  getDefaultNormalizer,
  getRoles,
  getQueriesForElement,
  getNodeText,
  findAllByDisplayValue,
  findByDisplayValue,
  getAllByDisplayValue,
  getByDisplayValue,
  queryAllByDisplayValue,
  queryByDisplayValue,
  findAllByRole,
  findByRole,
  getAllByRole,
  getByRole,
  queryAllByRole,
  queryByRole,
  findAllByTestId,
  findByTestId,
  getAllByTestId,
  getByTestId,
  queryAllByTestId,
  queryByTestId,
  findAllByText,
  findByText,
  getAllByText,
  getByText,
  queryAllByText,
  queryByText,
  findAllByTitle,
  findByTitle,
  getAllByTitle,
  getByTitle,
  queryAllByTitle,
  queryByTitle,
  findAllByLabelText,
  findByLabelText,
  getAllByLabelText,
  getByLabelText,
  queryAllByLabelText,
  queryByLabelText,
  findAllByPlaceholderText,
  findByPlaceholderText,
  getAllByPlaceholderText,
  getByPlaceholderText,
  queryAllByPlaceholderText,
  queryByPlaceholderText,
  findAllByAltText,
  findByAltText,
  getAllByAltText,
  getByAltText,
  queryAllByAltText,
  queryByAltText,
  buildQueries,
  createEvent,
  isInaccessible,
} from '@testing-library/react'

export { customRender as render }
</file>

<file path="supabase/config.toml">
# For detailed configuration reference documentation, visit:
# https://supabase.com/docs/guides/local-development/cli/config
# A string used to distinguish different Supabase projects on the same host. Defaults to the
# working directory name when running `supabase init`.
project_id = "dce-website"

[api]
enabled = true
# Port to use for the API URL.
port = 54321
# Schemas to expose in your API. Tables, views and stored procedures in this schema will get API
# endpoints. `public` and `graphql_public` schemas are included by default.
schemas = ["public", "graphql_public"]
# Extra schemas to add to the search_path of every request.
extra_search_path = ["public", "extensions"]
# The maximum number of rows returns from a view, table, or stored procedure. Limits payload size
# for accidental or malicious requests.
max_rows = 1000

[api.tls]
# Enable HTTPS endpoints locally using a self-signed certificate.
enabled = false

[db]
# Port to use for the local database URL.
port = 54322
# Port used by db diff command to initialize the shadow database.
shadow_port = 54320
# The database major version to use. This has to be the same as your remote database's. Run `SHOW
# server_version;` on the remote database to check.
major_version = 17

[db.pooler]
enabled = false
# Port to use for the local connection pooler.
port = 54329
# Specifies when a server connection can be reused by other clients.
# Configure one of the supported pooler modes: `transaction`, `session`.
pool_mode = "transaction"
# How many server connections to allow per user/database pair.
default_pool_size = 20
# Maximum number of client connections allowed.
max_client_conn = 100

# [db.vault]
# secret_key = "env(SECRET_VALUE)"

[db.migrations]
# If disabled, migrations will be skipped during a db push or reset.
enabled = true
# Specifies an ordered list of schema files that describe your database.
# Supports glob patterns relative to supabase directory: "./schemas/*.sql"
schema_paths = []

[db.seed]
# If enabled, seeds the database after migrations during a db reset.
enabled = false
# Specifies an ordered list of seed files to load during db reset.
# Supports glob patterns relative to supabase directory: "./seeds/*.sql"
sql_paths = ["./seed.sql"]

# Network restrictions are now managed at the project level

[realtime]
enabled = true
# Bind realtime via either IPv4 or IPv6. (default: IPv4)
# ip_version = "IPv6"
# The maximum length in bytes of HTTP request headers. (default: 4096)
# max_header_length = 4096

[studio]
enabled = true
# Port to use for Supabase Studio.
port = 54323
# External URL of the API server that frontend connects to.
api_url = "http://127.0.0.1"
# OpenAI API Key to use for Supabase AI in the Supabase Studio.
openai_api_key = "env(OPENAI_API_KEY)"

# Email testing server. Emails sent with the local dev setup are not actually sent - rather, they
# are monitored, and you can view the emails that would have been sent from the web interface.
[inbucket]
enabled = true
# Port to use for the email testing server web interface.
port = 54324
# Uncomment to expose additional ports for testing user applications that send emails.
# smtp_port = 54325
# pop3_port = 54326
# admin_email = "admin@email.com"
# sender_name = "Admin"

[storage]
enabled = true
# The maximum file size allowed (e.g. "5MB", "500KB").
file_size_limit = "50MiB"

# Image transformation API is available to Supabase Pro plan.
# [storage.image_transformation]
# enabled = true

# Uncomment to configure local storage buckets
# [storage.buckets.images]
# public = false
# file_size_limit = "50MiB"
# allowed_mime_types = ["image/png", "image/jpeg"]
# objects_path = "./images"

[auth]
enabled = true
# The base URL of your website. Used as an allow-list for redirects and for constructing URLs used
# in emails.
site_url = "http://localhost:5173"
# A list of *exact* URLs that auth providers are permitted to redirect to post authentication.
additional_redirect_urls = ["http://localhost:5173", "http://127.0.0.1:5173"]
# How long tokens are valid for, in seconds. Defaults to 3600 (1 hour), maximum 604,800 (1 week).
jwt_expiry = 3600
# If disabled, the refresh token will never expire.
enable_refresh_token_rotation = true
# Allows refresh tokens to be reused after expiry, up to the specified interval in seconds.
# Requires enable_refresh_token_rotation = true.
refresh_token_reuse_interval = 10
# Allow/disallow new user signups to your project.
enable_signup = true
# Allow/disallow anonymous sign-ins to your project.
enable_anonymous_sign_ins = false
# Allow/disallow testing manual linking of accounts
enable_manual_linking = false
# Passwords shorter than this value will be rejected as weak. Minimum 6, recommended 8 or more.
minimum_password_length = 8
# Passwords that do not meet the following requirements will be rejected as weak. Supported values
# are: `letters_digits`, `lower_upper_letters_digits`, `lower_upper_letters_digits_symbols`
password_requirements = "lower_upper_letters_digits"

[auth.rate_limit]
# Number of emails that can be sent per hour. Requires auth.email.smtp to be enabled.
email_sent = 2
# Number of SMS messages that can be sent per hour. Requires auth.sms to be enabled.
sms_sent = 30
# Number of anonymous sign-ins that can be made per hour per IP address. Requires enable_anonymous_sign_ins = true.
anonymous_users = 30
# Number of sessions that can be refreshed in a 5 minute interval per IP address.
token_refresh = 150
# Number of sign up and sign-in requests that can be made in a 5 minute interval per IP address (excludes anonymous users).
sign_in_sign_ups = 30
# Number of OTP / Magic link verifications that can be made in a 5 minute interval per IP address.
token_verifications = 30
# Number of Web3 logins that can be made in a 5 minute interval per IP address.
web3 = 30

# Configure one of the supported captcha providers: `hcaptcha`, `turnstile`.
# [auth.captcha]
# enabled = true
# provider = "hcaptcha"
# secret = ""

[auth.email]
# Allow/disallow new user signups via email to your project.
enable_signup = true
# If enabled, a user will be required to confirm any email change on both the old, and new email
# addresses. If disabled, only the new email is required to confirm.
double_confirm_changes = true
# If enabled, users need to confirm their email address before signing in.
enable_confirmations = true
# If enabled, users will need to reauthenticate or have logged in recently to change their password.
secure_password_change = false
# Controls the minimum amount of time that must pass before sending another signup confirmation or password reset email.
max_frequency = "1s"
# Number of characters used in the email OTP.
otp_length = 6
# Number of seconds before the email OTP expires (defaults to 1 hour).
otp_expiry = 3600

# Use a production-ready SMTP server
# [auth.email.smtp]
# enabled = true
# host = "smtp.sendgrid.net"
# port = 587
# user = "apikey"
# pass = "env(SENDGRID_API_KEY)"
# admin_email = "admin@email.com"
# sender_name = "Admin"

# Uncomment to customize email template
# [auth.email.template.invite]
# subject = "You have been invited"
# content_path = "./supabase/templates/invite.html"

[auth.sms]
# Allow/disallow new user signups via SMS to your project.
enable_signup = false
# If enabled, users need to confirm their phone number before signing in.
enable_confirmations = false
# Template for sending OTP to users
template = "Your code is {{ .Code }}"
# Controls the minimum amount of time that must pass before sending another sms otp.
max_frequency = "5s"

# Use pre-defined map of phone number to OTP for testing.
# [auth.sms.test_otp]
# 4152127777 = "123456"

# Configure logged in session timeouts.
# [auth.sessions]
# Force log out after the specified duration.
# timebox = "24h"
# Force log out if the user has been inactive longer than the specified duration.
# inactivity_timeout = "8h"

# This hook runs before a new user is created and allows developers to reject the request based on the incoming user object.
# [auth.hook.before_user_created]
# enabled = true
# uri = "pg-functions://postgres/auth/before-user-created-hook"

# This hook runs before a token is issued and allows you to add additional claims based on the authentication method used.
# [auth.hook.custom_access_token]
# enabled = true
# uri = "pg-functions://<database>/<schema>/<hook_name>"

# Configure one of the supported SMS providers: `twilio`, `twilio_verify`, `messagebird`, `textlocal`, `vonage`.
[auth.sms.twilio]
enabled = false
account_sid = ""
message_service_sid = ""
# DO NOT commit your Twilio auth token to git. Use environment variable substitution instead:
auth_token = "env(SUPABASE_AUTH_SMS_TWILIO_AUTH_TOKEN)"

# Multi-factor-authentication is available to Supabase Pro plan.
[auth.mfa]
# Control how many MFA factors can be enrolled at once per user.
max_enrolled_factors = 10

# Control MFA via App Authenticator (TOTP)
[auth.mfa.totp]
enroll_enabled = false
verify_enabled = false

# Configure MFA via Phone Messaging
[auth.mfa.phone]
enroll_enabled = false
verify_enabled = false
otp_length = 6
template = "Your code is {{ .Code }}"
max_frequency = "5s"

# Configure MFA via WebAuthn
# [auth.mfa.web_authn]
# enroll_enabled = true
# verify_enabled = true

# Use an external OAuth provider. The full list of providers are: `apple`, `azure`, `bitbucket`,
# `discord`, `facebook`, `github`, `gitlab`, `google`, `keycloak`, `linkedin_oidc`, `notion`, `twitch`,
# `twitter`, `slack`, `spotify`, `workos`, `zoom`.
[auth.external.apple]
enabled = false
client_id = ""
# DO NOT commit your OAuth provider secret to git. Use environment variable substitution instead:
secret = "env(SUPABASE_AUTH_EXTERNAL_APPLE_SECRET)"
# Overrides the default auth redirectUrl.
redirect_uri = ""
# Overrides the default auth provider URL. Used to support self-hosted gitlab, single-tenant Azure,
# or any other third-party OIDC providers.
url = ""
# If enabled, the nonce check will be skipped. Required for local sign in with Google auth.
skip_nonce_check = false

# Allow Solana wallet holders to sign in to your project via the Sign in with Solana (SIWS, EIP-4361) standard.
# You can configure "web3" rate limit in the [auth.rate_limit] section and set up [auth.captcha] if self-hosting.
[auth.web3.solana]
enabled = false

# Use Firebase Auth as a third-party provider alongside Supabase Auth.
[auth.third_party.firebase]
enabled = false
# project_id = "my-firebase-project"

# Use Auth0 as a third-party provider alongside Supabase Auth.
[auth.third_party.auth0]
enabled = false
# tenant = "my-auth0-tenant"
# tenant_region = "us"

# Use AWS Cognito (Amplify) as a third-party provider alongside Supabase Auth.
[auth.third_party.aws_cognito]
enabled = false
# user_pool_id = "my-user-pool-id"
# user_pool_region = "us-east-1"

# Use Clerk as a third-party provider alongside Supabase Auth.
[auth.third_party.clerk]
enabled = false
# Obtain from https://clerk.com/setup/supabase
# domain = "example.clerk.accounts.dev"

[edge_runtime]
enabled = true
# Configure one of the supported request policies: `oneshot`, `per_worker`.
# Use `oneshot` for hot reload, or `per_worker` for load testing.
policy = "oneshot"
# Port to attach the Chrome inspector for debugging edge functions.
inspector_port = 8083
# The Deno major version to use.
deno_version = 1

# [edge_runtime.secrets]
# secret_key = "env(SECRET_VALUE)"

[analytics]
enabled = true
port = 54327
# Configure one of the supported backends: `postgres`, `bigquery`.
backend = "postgres"

# Experimental features may be deprecated any time
[experimental]
# Configures Postgres storage engine to use OrioleDB (S3)
orioledb_version = ""
# Configures S3 bucket URL, eg. <bucket_name>.s3-<region>.amazonaws.com
s3_host = "env(S3_HOST)"
# Configures S3 bucket region, eg. us-east-1
s3_region = "env(S3_REGION)"
# Configures AWS_ACCESS_KEY_ID for S3 bucket
s3_access_key = "env(S3_ACCESS_KEY)"
# Configures AWS_SECRET_ACCESS_KEY for S3 bucket
s3_secret_key = "env(S3_SECRET_KEY)"
</file>

<file path="postcss.config.js">
export default {
  plugins: {
    '@tailwindcss/postcss': {},
    autoprefixer: {},
  },
}
</file>

<file path="src/components/dashboard/RealTimeDashboard.tsx">
import { useEffect, useState, useCallback } from 'react'
import { supabase } from '@/lib/supabase'
import { RealtimeErrorBoundary } from '../realtime/RealtimeErrorBoundary'
import { ActiveCampaignsTable } from './supplier/ActiveCampaignsTable'
import { CallVolumeChart } from './supplier/CallVolumeChart'
import { RecentCallsList } from './supplier/RecentCallsList'
import { QuickStatsBar } from './supplier/QuickStatsBar'
import { logger } from '@/lib/logger'

interface RealTimeDashboardProps {
  userId: string
  userType: 'supplier' | 'buyer'
}

// Inner component that handles real-time data
function RealTimeDashboardInner({ userId, userType }: RealTimeDashboardProps) {
  const [, setCallData] = useState<
    Array<{ id: string; created_at: string; payout_amount: number; [key: string]: unknown }>
  >([])
  // Note: Stats are handled by QuickStatsBar component
  const [connectionStatus, setConnectionStatus] = useState<'connected' | 'disconnected'>(
    'connected'
  )

  const loadInitialData = useCallback(async () => {
    try {
      // Load recent calls
      const { data: calls, error: callsError } = await supabase
        .from('calls')
        .select('*')
        .eq(userType === 'supplier' ? 'supplier_id' : 'buyer_id', userId)
        .order('created_at', { ascending: false })
        .limit(50)

      if (callsError) throw callsError
      setCallData(calls || [])

      // Stats data is handled by QuickStatsBar component
    } catch (error) {
      logger.error('Error loading initial dashboard data', error as Error)
      throw error
    }
  }, [userId, userType])

  // Note: Stats updates are handled by QuickStatsBar component via real-time subscriptions

  useEffect(() => {
    // Subscribe to real-time call updates
    const callChannel = supabase
      .channel(`calls-${userId}`)
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'calls',
          filter: userType === 'supplier' ? `supplier_id=eq.${userId}` : `buyer_id=eq.${userId}`,
        },
        (payload) => {
          logger.info('Real-time call update received', payload)

          if (payload.eventType === 'INSERT') {
            setCallData((prev) => [payload.new as (typeof prev)[0], ...prev].slice(0, 50)) // Keep last 50 calls
            // Stats are updated via QuickStatsBar real-time subscription
          } else if (payload.eventType === 'UPDATE') {
            setCallData((prev) =>
              prev.map((call) =>
                call.id === (payload.new as typeof call).id ? (payload.new as typeof call) : call
              )
            )
            // Stats are updated via QuickStatsBar real-time subscription
          }
        }
      )
      .subscribe((status) => {
        setConnectionStatus(status === 'SUBSCRIBED' ? 'connected' : 'disconnected')
      })

    // Subscribe to campaign updates
    const campaignChannel = supabase
      .channel(`campaigns-${userId}`)
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'campaigns',
          filter:
            userType === 'buyer'
              ? `buyer_id=eq.${userId}`
              : `id=in.(select campaign_id from campaign_suppliers where supplier_id='${userId}')`,
        },
        (payload) => {
          logger.info('Real-time campaign update received', payload)
          // Update campaign-related stats
        }
      )
      .subscribe()

    // Load initial data
    loadInitialData()

    return () => {
      supabase.removeChannel(callChannel)
      supabase.removeChannel(campaignChannel)
    }
  }, [userId, userType, loadInitialData])

  return (
    <div className="space-y-6">
      {/* Connection Status Indicator */}
      {connectionStatus === 'disconnected' && (
        <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-4">
          <p className="text-sm text-yellow-800">
            Real-time updates are temporarily unavailable. Data shown may be delayed.
          </p>
        </div>
      )}

      {/* Quick Stats */}
      <QuickStatsBar timeRange="24h" supplierId={userType === 'supplier' ? userId : ''} />

      {/* Main Content Grid */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        {/* Call Volume Chart */}
        <div className="bg-white rounded-lg shadow p-6">
          <h2 className="text-lg font-semibold text-gray-900 mb-4">Call Volume</h2>
          <CallVolumeChart timeRange="24h" supplierId={userType === 'supplier' ? userId : ''} />
        </div>

        {/* Recent Calls */}
        <div className="bg-white rounded-lg shadow p-6">
          <h2 className="text-lg font-semibold text-gray-900 mb-4">Recent Calls</h2>
          <RecentCallsList supplierId={userType === 'supplier' ? userId : ''} />
        </div>
      </div>

      {/* Active Campaigns Table */}
      <div className="bg-white rounded-lg shadow">
        <div className="px-6 py-4 border-b border-gray-200">
          <h2 className="text-lg font-semibold text-gray-900">Active Campaigns</h2>
        </div>
        <ActiveCampaignsTable supplierId={userType === 'supplier' ? userId : ''} />
      </div>
    </div>
  )
}

// Export wrapped component with error boundary
export function RealTimeDashboard({ userId, userType }: RealTimeDashboardProps) {
  const [retryKey, setRetryKey] = useState(0)

  const handleReconnect = async () => {
    setRetryKey((prev) => prev + 1)
    logger.info('Reconnecting real-time dashboard')
  }

  const handleFallbackToPolling = () => {
    // In production, this would implement a polling mechanism
    logger.info('Switching to polling mode for dashboard updates')
  }

  const handleRefresh = () => {
    window.location.reload()
  }

  return (
    <RealtimeErrorBoundary
      featureName="Real-Time Dashboard"
      enableAutoReconnect={true}
      maxReconnectAttempts={5}
      reconnectDelay={1000}
      onReconnect={handleReconnect}
      onFallbackToPolling={handleFallbackToPolling}
      onRefresh={handleRefresh}
      onError={(error) => {
        logger.error('Real-time dashboard error', error)
      }}
    >
      <RealTimeDashboardInner key={retryKey} userId={userId} userType={userType} />
    </RealtimeErrorBoundary>
  )
}

export default RealTimeDashboard
</file>

<file path="src/pages/campaigns/CampaignsPage.tsx">
import { useState, useEffect } from 'react'
import { Link, useNavigate } from 'react-router-dom'
import { useAuthStore } from '../../store/authStore'
import {
  PlusIcon,
  FunnelIcon,
  MagnifyingGlassIcon,
  EllipsisVerticalIcon,
  PlayIcon,
  PauseIcon,
  PencilSquareIcon,
  DocumentDuplicateIcon,
  ChartBarIcon,
  EyeIcon,
  PhoneIcon,
  CurrencyDollarIcon,
  ClockIcon,
  CheckCircleIcon,
  XCircleIcon,
  ExclamationTriangleIcon,
} from '@heroicons/react/24/outline'

// Mock data - In real app, this would come from API/database
interface Campaign {
  id: string
  name: string
  status: 'active' | 'paused' | 'draft' | 'archived'
  type: 'supplier' | 'buyer'
  calls_today: number
  calls_this_month: number
  conversion_rate: number
  revenue_today: number
  revenue_this_month: number
  quality_score: number
  created_at: string
  updated_at: string
  tracking_numbers: string[]
  budget_remaining?: number
  daily_budget?: number
}

const MOCK_CAMPAIGNS: Campaign[] = [
  {
    id: '1',
    name: 'Home Insurance Leads - Northeast',
    status: 'active',
    type: 'supplier',
    calls_today: 47,
    calls_this_month: 1234,
    conversion_rate: 78.5,
    revenue_today: 1880,
    revenue_this_month: 49360,
    quality_score: 92,
    created_at: '2024-01-15',
    updated_at: '2024-01-22',
    tracking_numbers: ['+1-555-0123', '+1-555-0124'],
  },
  {
    id: '2',
    name: 'Auto Insurance - California',
    status: 'active',
    type: 'buyer',
    calls_today: 23,
    calls_this_month: 567,
    conversion_rate: 65.2,
    revenue_today: 0,
    revenue_this_month: 0,
    quality_score: 89,
    budget_remaining: 2340,
    daily_budget: 500,
    created_at: '2024-01-10',
    updated_at: '2024-01-22',
    tracking_numbers: ['+1-555-0125'],
  },
  {
    id: '3',
    name: 'Solar Panel Leads - Texas',
    status: 'paused',
    type: 'supplier',
    calls_today: 0,
    calls_this_month: 234,
    conversion_rate: 82.1,
    revenue_today: 0,
    revenue_this_month: 9360,
    quality_score: 94,
    created_at: '2024-01-08',
    updated_at: '2024-01-20',
    tracking_numbers: ['+1-555-0126', '+1-555-0127', '+1-555-0128'],
  },
]

type CampaignFilter = 'all' | 'active' | 'paused' | 'draft' | 'archived'
type CampaignSort = 'name' | 'created_at' | 'calls_today' | 'revenue_today' | 'quality_score'

export default function CampaignsPage() {
  const navigate = useNavigate()
  const { user } = useAuthStore()
  const [campaigns] = useState<Campaign[]>(MOCK_CAMPAIGNS)
  const [filteredCampaigns, setFilteredCampaigns] = useState<Campaign[]>(campaigns)
  const [selectedFilter, setSelectedFilter] = useState<CampaignFilter>('all')
  const [searchQuery, setSearchQuery] = useState('')
  const [sortBy, setSortBy] = useState<CampaignSort>('created_at')
  const [selectedCampaigns, setSelectedCampaigns] = useState<string[]>([])
  const [showFilters, setShowFilters] = useState(false)

  // Filter and search campaigns
  useEffect(() => {
    let filtered = campaigns

    // Apply status filter
    if (selectedFilter !== 'all') {
      filtered = filtered.filter((campaign) => campaign.status === selectedFilter)
    }

    // Apply search filter
    if (searchQuery.trim()) {
      const query = searchQuery.toLowerCase()
      filtered = filtered.filter(
        (campaign) =>
          campaign.name.toLowerCase().includes(query) ||
          campaign.tracking_numbers.some((number) => number.includes(query))
      )
    }

    // Apply sorting
    filtered.sort((a, b) => {
      switch (sortBy) {
        case 'name':
          return a.name.localeCompare(b.name)
        case 'created_at':
          return new Date(b.created_at).getTime() - new Date(a.created_at).getTime()
        case 'calls_today':
          return b.calls_today - a.calls_today
        case 'revenue_today':
          return b.revenue_today - a.revenue_today
        case 'quality_score':
          return b.quality_score - a.quality_score
        default:
          return 0
      }
    })

    setFilteredCampaigns(filtered)
  }, [campaigns, selectedFilter, searchQuery, sortBy])

  const handleCampaignAction = async (action: string, campaignId: string) => {
    try {
      switch (action) {
        case 'pause':
          console.log('Pausing campaign:', campaignId)
          // await campaignService.pauseCampaign(campaignId)
          break
        case 'resume':
          console.log('Resuming campaign:', campaignId)
          // await campaignService.resumeCampaign(campaignId)
          break
        case 'duplicate':
          console.log('Duplicating campaign:', campaignId)
          // await campaignService.duplicateCampaign(campaignId)
          break
        case 'delete':
          console.log('Deleting campaign:', campaignId)
          // await campaignService.deleteCampaign(campaignId)
          break
      }
    } catch (error) {
      console.error('Campaign action failed:', error)
    }
  }

  const getStatusBadge = (status: Campaign['status']) => {
    const baseClasses = 'inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium'

    switch (status) {
      case 'active':
        return `${baseClasses} bg-green-100 text-green-800`
      case 'paused':
        return `${baseClasses} bg-yellow-100 text-yellow-800`
      case 'draft':
        return `${baseClasses} bg-gray-100 text-gray-800`
      case 'archived':
        return `${baseClasses} bg-red-100 text-red-800`
      default:
        return `${baseClasses} bg-gray-100 text-gray-800`
    }
  }

  const getStatusIcon = (status: Campaign['status']) => {
    switch (status) {
      case 'active':
        return <CheckCircleIcon className="h-4 w-4 text-green-500" />
      case 'paused':
        return <ExclamationTriangleIcon className="h-4 w-4 text-yellow-500" />
      case 'draft':
        return <ClockIcon className="h-4 w-4 text-gray-500" />
      case 'archived':
        return <XCircleIcon className="h-4 w-4 text-red-500" />
      default:
        return <ClockIcon className="h-4 w-4 text-gray-500" />
    }
  }

  const formatCurrency = (amount: number) => {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
      minimumFractionDigits: 0,
      maximumFractionDigits: 0,
    }).format(amount)
  }

  const formatDate = (dateString: string) => {
    return new Intl.DateTimeFormat('en-US', {
      month: 'short',
      day: 'numeric',
      year: 'numeric',
    }).format(new Date(dateString))
  }

  const userRole = user?.user_metadata?.role || 'supplier'

  return (
    <div className="py-6">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        {/* Page Header */}
        <div className="md:flex md:items-center md:justify-between">
          <div className="min-w-0 flex-1">
            <h1 className="text-2xl font-bold leading-7 text-gray-900 sm:truncate sm:text-3xl">
              Campaign Management
            </h1>
            <p className="mt-1 text-sm text-gray-600">
              {userRole === 'supplier'
                ? 'Manage your traffic campaigns and track performance'
                : 'Manage your lead acquisition campaigns and monitor quality'}
            </p>
          </div>
          <div className="mt-4 flex md:ml-4 md:mt-0">
            <button
              type="button"
              onClick={() => setShowFilters(!showFilters)}
              className="inline-flex items-center rounded-md bg-white px-3 py-2 text-sm font-semibold text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300 hover:bg-gray-50"
            >
              <FunnelIcon className="-ml-0.5 mr-1.5 h-5 w-5 text-gray-400" />
              Filters
            </button>
            <Link
              to="/app/campaigns/create"
              className="ml-3 inline-flex items-center rounded-md bg-blue-600 px-3 py-2 text-sm font-semibold text-white shadow-sm hover:bg-blue-500 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-blue-600"
            >
              <PlusIcon className="-ml-0.5 mr-1.5 h-5 w-5" />
              New Campaign
            </Link>
          </div>
        </div>

        {/* Quick Stats */}
        <div className="mt-8 grid grid-cols-1 gap-5 sm:grid-cols-2 lg:grid-cols-4">
          <div className="overflow-hidden rounded-lg bg-white px-4 py-5 shadow sm:p-6">
            <dt className="truncate text-sm font-medium text-gray-500">Total Campaigns</dt>
            <dd className="mt-1 text-3xl font-semibold tracking-tight text-gray-900">
              {campaigns.length}
            </dd>
          </div>
          <div className="overflow-hidden rounded-lg bg-white px-4 py-5 shadow sm:p-6">
            <dt className="truncate text-sm font-medium text-gray-500">Calls Today</dt>
            <dd className="mt-1 text-3xl font-semibold tracking-tight text-gray-900">
              {campaigns.reduce((sum, c) => sum + c.calls_today, 0)}
            </dd>
          </div>
          <div className="overflow-hidden rounded-lg bg-white px-4 py-5 shadow sm:p-6">
            <dt className="truncate text-sm font-medium text-gray-500">
              {userRole === 'supplier' ? 'Revenue Today' : 'Spend Today'}
            </dt>
            <dd className="mt-1 text-3xl font-semibold tracking-tight text-gray-900">
              {formatCurrency(campaigns.reduce((sum, c) => sum + c.revenue_today, 0))}
            </dd>
          </div>
          <div className="overflow-hidden rounded-lg bg-white px-4 py-5 shadow sm:p-6">
            <dt className="truncate text-sm font-medium text-gray-500">Avg Quality Score</dt>
            <dd className="mt-1 text-3xl font-semibold tracking-tight text-gray-900">
              {Math.round(
                campaigns.reduce((sum, c) => sum + c.quality_score, 0) / campaigns.length
              )}
              %
            </dd>
          </div>
        </div>

        {/* Filters and Search */}
        <div className="mt-8">
          <div className="sm:flex sm:items-center">
            <div className="sm:flex-auto">
              <div className="flex rounded-md shadow-sm">
                <div className="relative flex flex-grow items-stretch focus-within:z-10">
                  <div className="pointer-events-none absolute inset-y-0 left-0 flex items-center pl-3">
                    <MagnifyingGlassIcon className="h-5 w-5 text-gray-400" />
                  </div>
                  <input
                    type="text"
                    value={searchQuery}
                    onChange={(e) => setSearchQuery(e.target.value)}
                    className="block w-full rounded-none rounded-l-md border-0 py-1.5 pl-10 text-gray-900 ring-1 ring-inset ring-gray-300 placeholder:text-gray-400 focus:ring-2 focus:ring-inset focus:ring-blue-600 sm:text-sm sm:leading-6"
                    placeholder="Search campaigns or tracking numbers..."
                  />
                </div>
              </div>
            </div>
          </div>

          {showFilters && (
            <div className="mt-4 bg-gray-50 p-4 rounded-lg">
              <div className="flex flex-wrap items-center gap-4">
                <div className="flex items-center space-x-2">
                  <label className="text-sm font-medium text-gray-700">Status:</label>
                  <select
                    value={selectedFilter}
                    onChange={(e) => setSelectedFilter(e.target.value as CampaignFilter)}
                    className="rounded-md border-gray-300 text-sm focus:border-blue-500 focus:ring-blue-500"
                  >
                    <option value="all">All Statuses</option>
                    <option value="active">Active</option>
                    <option value="paused">Paused</option>
                    <option value="draft">Draft</option>
                    <option value="archived">Archived</option>
                  </select>
                </div>
                <div className="flex items-center space-x-2">
                  <label className="text-sm font-medium text-gray-700">Sort by:</label>
                  <select
                    value={sortBy}
                    onChange={(e) => setSortBy(e.target.value as CampaignSort)}
                    className="rounded-md border-gray-300 text-sm focus:border-blue-500 focus:ring-blue-500"
                  >
                    <option value="created_at">Created Date</option>
                    <option value="name">Name</option>
                    <option value="calls_today">Calls Today</option>
                    <option value="revenue_today">Revenue Today</option>
                    <option value="quality_score">Quality Score</option>
                  </select>
                </div>
              </div>
            </div>
          )}
        </div>

        {/* Campaigns List */}
        <div className="mt-8">
          {filteredCampaigns.length === 0 ? (
            <div className="text-center py-12">
              <PhoneIcon className="mx-auto h-12 w-12 text-gray-400" />
              <h3 className="mt-2 text-sm font-semibold text-gray-900">No campaigns found</h3>
              <p className="mt-1 text-sm text-gray-500">
                {searchQuery
                  ? 'Try adjusting your search terms.'
                  : 'Get started by creating a new campaign.'}
              </p>
              {!searchQuery && (
                <div className="mt-6">
                  <Link
                    to="/app/campaigns/create"
                    className="inline-flex items-center rounded-md bg-blue-600 px-3 py-2 text-sm font-semibold text-white shadow-sm hover:bg-blue-500"
                  >
                    <PlusIcon className="-ml-0.5 mr-1.5 h-5 w-5" />
                    New Campaign
                  </Link>
                </div>
              )}
            </div>
          ) : (
            <div className="bg-white shadow overflow-hidden sm:rounded-md">
              <ul role="list" className="divide-y divide-gray-200">
                {filteredCampaigns.map((campaign) => (
                  <li key={campaign.id} className="hover:bg-gray-50">
                    <div className="px-4 py-4 sm:px-6">
                      <div className="flex items-center justify-between">
                        <div className="flex items-center">
                          <input
                            type="checkbox"
                            checked={selectedCampaigns.includes(campaign.id)}
                            onChange={(e) => {
                              if (e.target.checked) {
                                setSelectedCampaigns([...selectedCampaigns, campaign.id])
                              } else {
                                setSelectedCampaigns(
                                  selectedCampaigns.filter((id) => id !== campaign.id)
                                )
                              }
                            }}
                            className="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500"
                          />
                          <div className="ml-4 min-w-0 flex-1">
                            <div className="flex items-center">
                              {getStatusIcon(campaign.status)}
                              <p className="ml-2 text-sm font-medium text-gray-900 truncate">
                                {campaign.name}
                              </p>
                              <span className={`ml-2 ${getStatusBadge(campaign.status)}`}>
                                {campaign.status}
                              </span>
                            </div>
                            <div className="mt-2 flex">
                              <div className="flex items-center text-sm text-gray-500">
                                <PhoneIcon className="flex-shrink-0 mr-1.5 h-4 w-4" />
                                {campaign.calls_today} calls today ({campaign.calls_this_month} this
                                month)
                              </div>
                              <div className="ml-6 flex items-center text-sm text-gray-500">
                                <CurrencyDollarIcon className="flex-shrink-0 mr-1.5 h-4 w-4" />
                                {userRole === 'supplier'
                                  ? `${formatCurrency(campaign.revenue_today)} today`
                                  : campaign.budget_remaining
                                    ? `${formatCurrency(campaign.budget_remaining)} remaining`
                                    : `${formatCurrency(campaign.revenue_today)} spent today`}
                              </div>
                              <div className="ml-6 flex items-center text-sm text-gray-500">
                                <ChartBarIcon className="flex-shrink-0 mr-1.5 h-4 w-4" />
                                {campaign.quality_score}% quality
                              </div>
                            </div>
                          </div>
                        </div>
                        <div className="flex items-center space-x-2">
                          <div className="text-right">
                            <p className="text-sm font-medium text-gray-900">
                              {campaign.conversion_rate}% conversion
                            </p>
                            <p className="text-sm text-gray-500">
                              Updated {formatDate(campaign.updated_at)}
                            </p>
                          </div>
                          <div className="flex items-center space-x-1">
                            <button
                              onClick={() => navigate(`/campaigns/${campaign.id}`)}
                              className="p-1 text-gray-400 hover:text-gray-600"
                              title="View Details"
                            >
                              <EyeIcon className="h-4 w-4" />
                            </button>
                            <button
                              onClick={() => navigate(`/app/campaigns/${campaign.id}/edit`)}
                              className="p-1 text-gray-400 hover:text-gray-600"
                              title="Edit Campaign"
                            >
                              <PencilSquareIcon className="h-4 w-4" />
                            </button>
                            {campaign.status === 'active' ? (
                              <button
                                onClick={() => handleCampaignAction('pause', campaign.id)}
                                className="p-1 text-gray-400 hover:text-yellow-600"
                                title="Pause Campaign"
                              >
                                <PauseIcon className="h-4 w-4" />
                              </button>
                            ) : (
                              <button
                                onClick={() => handleCampaignAction('resume', campaign.id)}
                                className="p-1 text-gray-400 hover:text-green-600"
                                title="Resume Campaign"
                              >
                                <PlayIcon className="h-4 w-4" />
                              </button>
                            )}
                            <div className="relative">
                              <button className="p-1 text-gray-400 hover:text-gray-600">
                                <EllipsisVerticalIcon className="h-4 w-4" />
                              </button>
                              {/* Dropdown menu would go here */}
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </li>
                ))}
              </ul>
            </div>
          )}
        </div>

        {/* Bulk Actions */}
        {selectedCampaigns.length > 0 && (
          <div className="mt-4 bg-blue-50 p-4 rounded-lg">
            <div className="flex items-center justify-between">
              <p className="text-sm text-blue-700">
                {selectedCampaigns.length} campaign{selectedCampaigns.length > 1 ? 's' : ''}{' '}
                selected
              </p>
              <div className="flex space-x-2">
                <button
                  onClick={() => console.log('Bulk pause:', selectedCampaigns)}
                  className="inline-flex items-center px-3 py-1.5 border border-transparent text-xs font-medium rounded-md text-blue-700 bg-blue-100 hover:bg-blue-200"
                >
                  <PauseIcon className="mr-1 h-3 w-3" />
                  Pause
                </button>
                <button
                  onClick={() => console.log('Bulk resume:', selectedCampaigns)}
                  className="inline-flex items-center px-3 py-1.5 border border-transparent text-xs font-medium rounded-md text-blue-700 bg-blue-100 hover:bg-blue-200"
                >
                  <PlayIcon className="mr-1 h-3 w-3" />
                  Resume
                </button>
                <button
                  onClick={() => console.log('Bulk duplicate:', selectedCampaigns)}
                  className="inline-flex items-center px-3 py-1.5 border border-transparent text-xs font-medium rounded-md text-blue-700 bg-blue-100 hover:bg-blue-200"
                >
                  <DocumentDuplicateIcon className="mr-1 h-3 w-3" />
                  Duplicate
                </button>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  )
}
</file>

<file path="src/types/database.ts">
export type Json = string | number | boolean | null | { [key: string]: Json | undefined } | Json[]

export interface Database {
  public: {
    Tables: {
      users: {
        Row: {
          id: string
          email: string
          phone: string | null
          first_name: string | null
          last_name: string | null
          avatar_url: string | null
          metadata: Json
          status: 'pending' | 'active' | 'suspended' | 'banned'
          is_active: boolean
          last_login: string | null
          created_at: string
          updated_at: string
        }
        Insert: {
          id: string
          email: string
          phone?: string | null
          first_name?: string | null
          last_name?: string | null
          avatar_url?: string | null
          metadata?: Json
          status?: 'pending' | 'active' | 'suspended' | 'banned'
          is_active?: boolean
          last_login?: string | null
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: string
          email?: string
          phone?: string | null
          first_name?: string | null
          last_name?: string | null
          avatar_url?: string | null
          metadata?: Json
          status?: 'pending' | 'active' | 'suspended' | 'banned'
          is_active?: boolean
          last_login?: string | null
          created_at?: string
          updated_at?: string
        }
      }
      admins: {
        Row: {
          id: string
          user_id: string | null
          role: string | null
          permissions: Json
          is_active: boolean
          appointed_by: string | null
          created_at: string
        }
        Insert: {
          id?: string
          user_id?: string | null
          role?: string | null
          permissions?: Json
          is_active?: boolean
          appointed_by?: string | null
          created_at?: string
        }
        Update: {
          id?: string
          user_id?: string | null
          role?: string | null
          permissions?: Json
          is_active?: boolean
          appointed_by?: string | null
          created_at?: string
        }
      }
      suppliers: {
        Row: {
          id: string
          user_id: string | null
          company_name: string
          business_type: string | null
          tax_id: string | null
          website_url: string | null
          credit_balance: number
          minimum_payout: number
          payout_frequency: string
          verification_data: Json
          status: 'pending' | 'active' | 'suspended' | 'banned'
          settings: Json
          approved_at: string | null
          approved_by: string | null
          created_at: string
          updated_at: string
          stripe_account_id: string | null
          stripe_onboarding_completed: boolean
          stripe_charges_enabled: boolean
          stripe_payouts_enabled: boolean
        }
        Insert: {
          id?: string
          user_id?: string | null
          company_name: string
          business_type?: string | null
          tax_id?: string | null
          website_url?: string | null
          credit_balance?: number
          minimum_payout?: number
          payout_frequency?: string
          verification_data?: Json
          status?: 'pending' | 'active' | 'suspended' | 'banned'
          settings?: Json
          approved_at?: string | null
          approved_by?: string | null
          created_at?: string
          updated_at?: string
          stripe_account_id?: string | null
          stripe_onboarding_completed?: boolean
          stripe_charges_enabled?: boolean
          stripe_payouts_enabled?: boolean
        }
        Update: {
          id?: string
          user_id?: string | null
          company_name?: string
          business_type?: string | null
          tax_id?: string | null
          website_url?: string | null
          credit_balance?: number
          minimum_payout?: number
          payout_frequency?: string
          verification_data?: Json
          status?: 'pending' | 'active' | 'suspended' | 'banned'
          settings?: Json
          approved_at?: string | null
          approved_by?: string | null
          created_at?: string
          updated_at?: string
          stripe_account_id?: string | null
          stripe_onboarding_completed?: boolean
          stripe_charges_enabled?: boolean
          stripe_payouts_enabled?: boolean
        }
      }
      buyers: {
        Row: {
          id: string
          user_id: string | null
          company_name: string
          business_type: string | null
          tax_id: string | null
          website_url: string | null
          credit_limit: number
          current_balance: number
          auto_recharge_enabled: boolean
          auto_recharge_threshold: number
          auto_recharge_amount: number
          verification_data: Json
          status: 'pending' | 'active' | 'suspended' | 'banned'
          settings: Json
          approved_at: string | null
          approved_by: string | null
          created_at: string
          updated_at: string
          stripe_customer_id: string | null
          stripe_payment_method_id: string | null
        }
        Insert: {
          id?: string
          user_id?: string | null
          company_name: string
          business_type?: string | null
          tax_id?: string | null
          website_url?: string | null
          credit_limit?: number
          current_balance?: number
          auto_recharge_enabled?: boolean
          auto_recharge_threshold?: number
          auto_recharge_amount?: number
          verification_data?: Json
          status?: 'pending' | 'active' | 'suspended' | 'banned'
          settings?: Json
          approved_at?: string | null
          approved_by?: string | null
          created_at?: string
          updated_at?: string
          stripe_customer_id?: string | null
          stripe_payment_method_id?: string | null
        }
        Update: {
          id?: string
          user_id?: string | null
          company_name?: string
          business_type?: string | null
          tax_id?: string | null
          website_url?: string | null
          credit_limit?: number
          current_balance?: number
          auto_recharge_enabled?: boolean
          auto_recharge_threshold?: number
          auto_recharge_amount?: number
          verification_data?: Json
          status?: 'pending' | 'active' | 'suspended' | 'banned'
          settings?: Json
          approved_at?: string | null
          approved_by?: string | null
          created_at?: string
          updated_at?: string
          stripe_customer_id?: string | null
          stripe_payment_method_id?: string | null
        }
      }
      buyer_campaigns: {
        Row: {
          id: string
          buyer_id: string | null
          name: string
          description: string | null
          targeting_criteria: Json
          max_bid: number
          daily_budget: number | null
          monthly_budget: number | null
          daily_cap: number | null
          monthly_cap: number | null
          schedule: Json
          quality_requirements: Json
          exclude_suppliers: string[]
          preferred_suppliers: string[]
          status: 'draft' | 'active' | 'paused' | 'completed' | 'cancelled'
          auto_approval_enabled: boolean
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: string
          buyer_id?: string | null
          name: string
          description?: string | null
          targeting_criteria?: Json
          max_bid: number
          daily_budget?: number | null
          monthly_budget?: number | null
          daily_cap?: number | null
          monthly_cap?: number | null
          schedule?: Json
          quality_requirements?: Json
          exclude_suppliers?: string[]
          preferred_suppliers?: string[]
          status?: 'draft' | 'active' | 'paused' | 'completed' | 'cancelled'
          auto_approval_enabled?: boolean
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: string
          buyer_id?: string | null
          name?: string
          description?: string | null
          targeting_criteria?: Json
          max_bid?: number
          daily_budget?: number | null
          monthly_budget?: number | null
          daily_cap?: number | null
          monthly_cap?: number | null
          schedule?: Json
          quality_requirements?: Json
          exclude_suppliers?: string[]
          preferred_suppliers?: string[]
          status?: 'draft' | 'active' | 'paused' | 'completed' | 'cancelled'
          auto_approval_enabled?: boolean
          created_at?: string
          updated_at?: string
        }
      }
      campaigns: {
        Row: {
          id: string
          supplier_id: string | null
          name: string
          description: string | null
          category: string | null
          vertical: string | null
          targeting: Json
          routing_rules: Json
          bid_floor: number
          max_concurrent_calls: number | null
          daily_cap: number | null
          total_cap: number | null
          start_date: string | null
          end_date: string | null
          status: 'draft' | 'active' | 'paused' | 'completed' | 'cancelled'
          is_active: boolean
          stats: Json
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: string
          supplier_id?: string | null
          name: string
          description?: string | null
          category?: string | null
          vertical?: string | null
          targeting?: Json
          routing_rules?: Json
          bid_floor?: number
          max_concurrent_calls?: number | null
          daily_cap?: number | null
          total_cap?: number | null
          start_date?: string | null
          end_date?: string | null
          status?: 'draft' | 'active' | 'paused' | 'completed' | 'cancelled'
          is_active?: boolean
          stats?: Json
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: string
          supplier_id?: string | null
          name?: string
          description?: string | null
          category?: string | null
          vertical?: string | null
          targeting?: Json
          routing_rules?: Json
          bid_floor?: number
          max_concurrent_calls?: number | null
          daily_cap?: number | null
          total_cap?: number | null
          start_date?: string | null
          end_date?: string | null
          status?: 'draft' | 'active' | 'paused' | 'completed' | 'cancelled'
          is_active?: boolean
          stats?: Json
          created_at?: string
          updated_at?: string
        }
      }
      calls: {
        Row: {
          id: string
          campaign_id: string | null
          buyer_id: string | null
          supplier_id: string | null
          tracking_number: string | null
          caller_number: string | null
          destination_number: string | null
          call_sid: string | null
          start_time: string | null
          end_time: string | null
          duration: number | null
          status: 'initiated' | 'ringing' | 'connected' | 'completed' | 'failed' | 'rejected'
          recording_url: string | null
          transcription: string | null
          quality_score: number | null
          fraud_score: number | null
          metadata: Json
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: string
          campaign_id?: string | null
          buyer_id?: string | null
          supplier_id?: string | null
          tracking_number?: string | null
          caller_number?: string | null
          destination_number?: string | null
          call_sid?: string | null
          start_time?: string | null
          end_time?: string | null
          duration?: number | null
          status?: 'initiated' | 'ringing' | 'connected' | 'completed' | 'failed' | 'rejected'
          recording_url?: string | null
          transcription?: string | null
          quality_score?: number | null
          fraud_score?: number | null
          metadata?: Json
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: string
          campaign_id?: string | null
          buyer_id?: string | null
          supplier_id?: string | null
          tracking_number?: string | null
          caller_number?: string | null
          destination_number?: string | null
          call_sid?: string | null
          start_time?: string | null
          end_time?: string | null
          duration?: number | null
          status?: 'initiated' | 'ringing' | 'connected' | 'completed' | 'failed' | 'rejected'
          recording_url?: string | null
          transcription?: string | null
          quality_score?: number | null
          fraud_score?: number | null
          metadata?: Json
          created_at?: string
          updated_at?: string
        }
      }
      transactions: {
        Row: {
          id: string
          supplier_id: string | null
          buyer_id: string | null
          call_id: string | null
          amount: number
          type: string
          status: string
          payment_method: string | null
          stripe_payment_intent_id: string | null
          stripe_charge_id: string | null
          stripe_transfer_id: string | null
          metadata: Json
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: string
          supplier_id?: string | null
          buyer_id?: string | null
          call_id?: string | null
          amount: number
          type: string
          status: string
          payment_method?: string | null
          stripe_payment_intent_id?: string | null
          stripe_charge_id?: string | null
          stripe_transfer_id?: string | null
          metadata?: Json
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: string
          supplier_id?: string | null
          buyer_id?: string | null
          call_id?: string | null
          amount?: number
          type?: string
          status?: string
          payment_method?: string | null
          stripe_payment_intent_id?: string | null
          stripe_charge_id?: string | null
          stripe_transfer_id?: string | null
          metadata?: Json
          created_at?: string
          updated_at?: string
        }
      }
      payouts: {
        Row: {
          id: string
          supplier_id: string | null
          amount: number
          currency: string
          status: 'pending' | 'processing' | 'completed' | 'failed' | 'cancelled'
          stripe_payout_id: string | null
          stripe_transfer_id: string | null
          batch_id: string | null
          paid_at: string | null
          failed_at: string | null
          failure_reason: string | null
          metadata: Json
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: string
          supplier_id?: string | null
          amount: number
          currency?: string
          status?: 'pending' | 'processing' | 'completed' | 'failed' | 'cancelled'
          stripe_payout_id?: string | null
          stripe_transfer_id?: string | null
          batch_id?: string | null
          paid_at?: string | null
          failed_at?: string | null
          failure_reason?: string | null
          metadata?: Json
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: string
          supplier_id?: string | null
          amount?: number
          currency?: string
          status?: 'pending' | 'processing' | 'completed' | 'failed' | 'cancelled'
          stripe_payout_id?: string | null
          stripe_transfer_id?: string | null
          batch_id?: string | null
          paid_at?: string | null
          failed_at?: string | null
          failure_reason?: string | null
          metadata?: Json
          created_at?: string
          updated_at?: string
        }
      }
    }
    Views: {
      supplier_stats_view: {
        Row: {
          supplier_id: string | null
          total_calls: number | null
          total_minutes: number | null
          total_earnings: number | null
          average_call_duration: number | null
          conversion_rate: number | null
          quality_score: number | null
        }
      }
      buyer_stats_view: {
        Row: {
          buyer_id: string | null
          total_campaigns: number | null
          total_calls: number | null
          total_spent: number | null
          average_cost_per_call: number | null
          conversion_rate: number | null
        }
      }
      campaign_performance_view: {
        Row: {
          campaign_id: string | null
          campaign_name: string | null
          supplier_id: string | null
          status: string | null
          total_calls: number | null
          connected_calls: number | null
          total_minutes: number | null
          total_revenue: number | null
          average_call_duration: number | null
          connection_rate: number | null
        }
      }
    }
    Functions: {
      get_user_stats: {
        Args: {
          user_id: string
        }
        Returns: {
          total_calls: number
          total_minutes: number
          total_revenue: number
          average_call_duration: number
        }
      }
      calculate_supplier_payout: {
        Args: {
          supplier_id: string
          start_date: string
          end_date: string
        }
        Returns: {
          total_amount: number
          call_count: number
          calls: Json
        }
      }
      add_buyer_credits: {
        Args: {
          buyer_id: string
          amount: number
          payment_intent_id: string
        }
        Returns: {
          new_balance: number
          transaction_id: string
        }
      }
      deduct_buyer_balance: {
        Args: {
          buyer_id: string
          amount: number
          call_id: string
        }
        Returns: {
          new_balance: number
          transaction_id: string
        }
      }
    }
    Enums: {
      user_status: 'pending' | 'active' | 'suspended' | 'banned'
      campaign_status: 'draft' | 'active' | 'paused' | 'completed' | 'cancelled'
      call_status: 'initiated' | 'ringing' | 'connected' | 'completed' | 'failed' | 'rejected'
      payout_status: 'pending' | 'processing' | 'completed' | 'failed' | 'cancelled'
      invoice_status: 'draft' | 'open' | 'paid' | 'overdue' | 'cancelled'
      dispute_status: 'open' | 'investigating' | 'resolved' | 'closed'
    }
  }
}
</file>

<file path="src/components/common/ErrorBoundary.tsx">
import { Component } from 'react'
import type { ErrorInfo, ReactNode } from 'react'
import {
  shouldShowTechnicalDetails,
  shouldLogToConsole,
  getEnvironmentErrorMessage,
} from '../../utils/environment'

interface Props {
  children: ReactNode
  fallback?: ReactNode | React.ComponentType<ErrorFallbackProps>
  onError?: (error: Error, errorInfo: ErrorInfo) => void
  context?: string
  showTechnicalDetails?: boolean
  level?: 'page' | 'section' | 'component'
  resetKeys?: unknown[]
}

// Interface for error fallback components
export interface ErrorFallbackProps {
  error: Error
  resetError: () => void
  level?: 'page' | 'section' | 'component'
  errorInfo?: ErrorInfo
}

interface State {
  hasError: boolean
  error?: Error
  errorInfo?: ErrorInfo
  errorId: number
}

export class ErrorBoundary extends Component<Props, State> {
  private resetTimeoutId: number | null = null

  constructor(props: Props) {
    super(props)
    this.state = { hasError: false, errorId: 0 }
  }

  static getDerivedStateFromError(error: Error): Partial<State> {
    return {
      hasError: true,
      error,
      errorInfo: undefined,
    }
  }

  componentDidUpdate(prevProps: Props) {
    const { resetKeys } = this.props
    const prevResetKeys = prevProps.resetKeys

    if (
      this.state.hasError &&
      resetKeys &&
      prevResetKeys &&
      (resetKeys.length !== prevResetKeys.length ||
        resetKeys.some((resetKey, idx) => resetKey !== prevResetKeys[idx]))
    ) {
      this.resetErrorBoundary()
    }
  }

  componentWillUnmount() {
    if (this.resetTimeoutId) {
      clearTimeout(this.resetTimeoutId)
    }
  }

  resetErrorBoundary = () => {
    if (this.resetTimeoutId) {
      clearTimeout(this.resetTimeoutId)
    }

    this.setState({
      hasError: false,
      error: undefined,
      errorInfo: undefined,
      errorId: this.state.errorId + 1,
    })
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    // Update state with error info for development display
    this.setState({ errorInfo })

    // Log error with context only in appropriate environments
    if (shouldLogToConsole()) {
      console.error(
        `ErrorBoundary caught an error${this.props.context ? ` in ${this.props.context}` : ''}:`,
        error,
        errorInfo
      )
    }

    // Call custom error handler if provided
    if (this.props.onError) {
      this.props.onError(error, errorInfo)
    }
  }

  render() {
    if (this.state.hasError) {
      // Use custom fallback if provided, otherwise use default
      if (this.props.fallback) {
        const { fallback: FallbackComponent } = this.props

        if (typeof FallbackComponent === 'function') {
          return (
            <FallbackComponent
              error={this.state.error!}
              resetError={this.resetErrorBoundary}
              level={this.props.level}
              errorInfo={this.state.errorInfo}
            />
          )
        }

        return FallbackComponent
      }

      // Default fallback UI
      const showDetails = this.props.showTechnicalDetails ?? shouldShowTechnicalDetails()
      const error = this.state.error
      const errorInfo = this.state.errorInfo

      return (
        <div className="min-h-[200px] flex items-center justify-center p-8">
          <div className="text-center max-w-2xl">
            <div className="w-16 h-16 mx-auto mb-4 text-red-500">
              <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" className="w-full h-full">
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z"
                />
              </svg>
            </div>
            <h3 className="text-lg font-medium text-gray-900 mb-2">Something went wrong</h3>
            <p className="text-gray-600 mb-4">
              {getEnvironmentErrorMessage(
                error,
                "We're sorry, but something unexpected happened. Please try refreshing the page."
              )}
            </p>

            {showDetails && error && (
              <details className="mb-4 text-left">
                <summary className="cursor-pointer text-sm text-gray-500 hover:text-gray-700 mb-2">
                  Technical Details
                </summary>
                <div className="mt-2 p-4 bg-gray-50 rounded-lg overflow-auto">
                  <div className="mb-4">
                    <h4 className="text-xs font-semibold text-gray-700 mb-1">Error Message:</h4>
                    <pre className="text-xs text-gray-600 whitespace-pre-wrap">{error.message}</pre>
                  </div>

                  {error.stack && (
                    <div className="mb-4">
                      <h4 className="text-xs font-semibold text-gray-700 mb-1">Stack Trace:</h4>
                      <pre className="text-xs text-gray-600 whitespace-pre-wrap overflow-x-auto">
                        {error.stack}
                      </pre>
                    </div>
                  )}

                  {errorInfo?.componentStack && (
                    <div>
                      <h4 className="text-xs font-semibold text-gray-700 mb-1">Component Stack:</h4>
                      <pre className="text-xs text-gray-600 whitespace-pre-wrap overflow-x-auto">
                        {errorInfo.componentStack}
                      </pre>
                    </div>
                  )}

                  {this.props.context && (
                    <div className="mt-4">
                      <h4 className="text-xs font-semibold text-gray-700 mb-1">Error Context:</h4>
                      <p className="text-xs text-gray-600">{this.props.context}</p>
                    </div>
                  )}
                </div>
              </details>
            )}

            <button
              onClick={() => window.location.reload()}
              className="bg-primary-600 hover:bg-primary-700 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors"
            >
              Refresh Page
            </button>
          </div>
        </div>
      )
    }

    return this.props.children
  }
}

export default ErrorBoundary
</file>

<file path=".env.example">
# Supabase Configuration
VITE_SUPABASE_URL=your_supabase_project_url
VITE_SUPABASE_ANON_KEY=your_supabase_anon_key
SUPABASE_SERVICE_ROLE_KEY=your_supabase_service_role_key_here

# Stripe Configuration
VITE_STRIPE_PUBLISHABLE_KEY=pk_test_your_publishable_key_here
VITE_STRIPE_SECRET_KEY=sk_test_your_secret_key_here
VITE_STRIPE_WEBHOOK_SECRET=whsec_your_webhook_secret_here
VITE_STRIPE_CONNECT_CLIENT_ID=ca_your_connect_client_id_here

# App Configuration
VITE_APP_NAME=DependableCalls
VITE_APP_URL=http://localhost:5173
VITE_APP_VERSION=1.0.0

# Monitoring & Analytics
VITE_SENTRY_DSN=https://your_sentry_dsn_here@sentry.io/project_id

# Staging Environment (for staging deployments)
VITE_STAGING_SUPABASE_URL=your_staging_supabase_url
VITE_STAGING_SUPABASE_ANON_KEY=your_staging_supabase_anon_key
VITE_STAGING_STRIPE_PUBLISHABLE_KEY=pk_test_staging_key
VITE_STAGING_SENTRY_DSN=https://staging_sentry_dsn@sentry.io/project_id

# Fraud Detection Services
VITE_TRUECALLER_API_KEY=your_truecaller_api_key_here
VITE_IPQUALITY_API_KEY=your_ipquality_api_key_here
VITE_FRAUDLABS_API_KEY=your_fraudlabs_api_key_here
VITE_SIFT_API_KEY=your_sift_api_key_here
VITE_MAXMIND_API_KEY=your_maxmind_license_key_here

# Feature Flags
VITE_ENABLE_MFA=true
VITE_ENABLE_REAL_TIME=true

# Telephony Webhook Configuration
TELEPHONY_WEBHOOK_SECRET=your_telephony_webhook_secret_here
</file>

<file path="src/integrations/stripe/webhooks.ts">
import crypto from 'crypto'
import Stripe from 'stripe'
import { stripeServerClient, stripeConfig } from './client'
import { supabase } from '../../lib/supabase'
import { getErrorMessage } from '../../lib/error-utils'
import type { WebhookHandlerMap } from './types'

interface Request {
  body: unknown
  headers: Record<string, string | string[] | undefined>
}

interface Response {
  status: (code: number) => Response
  json: (data: unknown) => Response
  send: (data: unknown) => Response
}

export const verifyWebhookSignature = (
  payload: string | Buffer,
  signature: string
): Stripe.Event => {
  try {
    return stripeServerClient.webhooks.constructEvent(
      payload,
      signature,
      stripeConfig.webhookSecret
    )
  } catch (err) {
    const errorMessage = err instanceof Error ? err.message : 'Unknown error'
    throw new Error(`Webhook signature verification failed: ${errorMessage}`)
  }
}

const webhookHandlers: WebhookHandlerMap = {
  'payment_intent.succeeded': async (event) => {
    const paymentIntent = event.data.object as Stripe.PaymentIntent
    console.log('Payment succeeded:', paymentIntent.id)

    try {
      // Update invoice status in database
      const { error: updateError } = await supabase
        .from('invoices')
        .update({
          status: 'paid',
          paid_at: new Date().toISOString(),
          payment_method: 'stripe',
          stripe_payment_intent_id: paymentIntent.id,
        })
        .eq('stripe_payment_intent_id', paymentIntent.id)

      if (updateError) {
        console.error('Failed to update invoice status:', updateError)
        return
      }

      // Get buyer information from metadata
      const buyerId = paymentIntent.metadata.buyer_id
      if (!buyerId) {
        console.error('No buyer_id in payment intent metadata')
        return
      }

      // Update buyer's current balance (add to credit)
      const { data: balanceResult, error: balanceError } = await supabase.rpc('add_buyer_credits', {
        buyer_id: buyerId,
        amount: paymentIntent.amount / 100,
        payment_intent_id: paymentIntent.id,
      })

      if (balanceError) {
        console.error('Failed to update buyer balance:', balanceError)
      } else if (balanceResult) {
        console.log(
          `Updated buyer ${buyerId} balance to ${balanceResult.new_balance} (transaction: ${balanceResult.transaction_id})`
        )
      }

      console.log(`Payment processed successfully for buyer ${buyerId}`)
    } catch (error) {
      console.error('Error processing payment success:', getErrorMessage(error))
    }
  },

  'payment_intent.payment_failed': async (event) => {
    const paymentIntent = event.data.object as Stripe.PaymentIntent
    console.error('Payment failed:', paymentIntent.id)

    try {
      // Mark invoice as failed
      const { error } = await supabase
        .from('invoices')
        .update({
          status: 'overdue',
          metadata: {
            ...paymentIntent.metadata,
            failure_reason: paymentIntent.last_payment_error?.message,
          },
        })
        .eq('stripe_payment_intent_id', paymentIntent.id)

      if (error) {
        console.error('Failed to update invoice status:', error)
        return
      }

      // Get buyer information and check for recurring failures
      const buyerId = paymentIntent.metadata.buyer_id
      if (buyerId) {
        const { data: recentFailures } = await supabase
          .from('invoices')
          .select('id')
          .eq('buyer_id', buyerId)
          .eq('status', 'overdue')
          .gte('created_at', new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString())

        // If 3+ failures in last week, pause campaigns
        if (recentFailures && recentFailures.length >= 3) {
          await supabase
            .from('buyer_campaigns')
            .update({ status: 'paused' })
            .eq('buyer_id', buyerId)
            .eq('status', 'active')

          console.log(`Paused campaigns for buyer ${buyerId} due to recurring payment failures`)
        }
      }
    } catch (error) {
      console.error('Error processing payment failure:', getErrorMessage(error))
    }
  },

  'charge.dispute.created': async (event) => {
    const dispute = event.data.object as Stripe.Dispute
    console.warn('Dispute created:', dispute.id)

    try {
      // Create dispute record in database
      const { error } = await supabase.from('disputes').insert({
        call_id: dispute.metadata?.call_id,
        raised_by: dispute.metadata?.buyer_id,
        dispute_type: 'billing',
        reason: `Stripe dispute: ${dispute.reason}`,
        description: `Dispute created for charge ${dispute.charge}. Reason: ${dispute.reason}`,
        amount_disputed: dispute.amount / 100,
        status: 'open',
        priority: 'high',
        evidence: [
          {
            type: 'stripe_dispute',
            dispute_id: dispute.id,
            reason: dispute.reason,
            evidence_details: dispute.evidence_details,
          },
        ],
      })

      if (error) {
        console.error('Failed to create dispute record:', error)
      }
    } catch (error) {
      console.error('Error processing dispute creation:', getErrorMessage(error))
    }
  },

  'account.updated': async (event) => {
    const account = event.data.object as Stripe.Account
    console.log('Connected account updated:', account.id)

    try {
      // Find supplier with this Stripe account
      const { data: supplier, error: findError } = await supabase
        .from('suppliers')
        .select('id, user_id')
        .eq('metadata->stripe_account_id', account.id)
        .maybeSingle()

      if (findError || !supplier) {
        console.error('Could not find supplier for account:', account.id)
        return
      }

      // Update supplier status based on account capabilities
      const canReceivePayouts = account.charges_enabled && account.payouts_enabled
      const requiresAction =
        account.requirements?.currently_due && account.requirements.currently_due.length > 0

      const { error: updateError } = await supabase
        .from('suppliers')
        .update({
          status: canReceivePayouts && !requiresAction ? 'active' : 'pending',
          settings: {
            stripe_account_status: {
              charges_enabled: account.charges_enabled,
              payouts_enabled: account.payouts_enabled,
              details_submitted: account.details_submitted,
              requirements_due: account.requirements?.currently_due || [],
            },
          },
        })
        .eq('id', supplier.id)

      if (updateError) {
        console.error('Failed to update supplier status:', updateError)
      }

      console.log(`Updated supplier ${supplier.id} status based on Stripe account ${account.id}`)
    } catch (error) {
      console.error('Error processing account update:', getErrorMessage(error))
    }
  },

  'payout.created': async (event) => {
    const payout = event.data.object as Stripe.Payout
    console.log('Payout created:', payout.id)

    try {
      // Create payout record in database
      const { error } = await supabase.from('payouts').insert({
        supplier_id: payout.metadata?.supplier_id || '',
        amount: payout.amount / 100,
        fee_amount: 0, // Stripe fees are handled separately
        net_amount: payout.amount / 100,
        status: 'processing',
        period_start: payout.metadata?.period_start || '',
        period_end: payout.metadata?.period_end || '',
        payment_method: 'stripe',
        transaction_id: payout.id,
        payment_details: {
          stripe_payout_id: payout.id,
          currency: payout.currency,
          method: payout.method,
          bank_account: payout.destination,
        },
      })

      if (error) {
        console.error('Failed to create payout record:', error)
      }
    } catch (error) {
      console.error('Error processing payout creation:', getErrorMessage(error))
    }
  },

  'payout.paid': async (event) => {
    const payout = event.data.object as Stripe.Payout
    console.log('Payout completed:', payout.id)

    try {
      // Mark payout as completed
      const { error } = await supabase
        .from('payouts')
        .update({
          status: 'completed',
          paid_at: new Date().toISOString(),
          processed_at: new Date().toISOString(),
        })
        .eq('transaction_id', payout.id)

      if (error) {
        console.error('Failed to update payout status:', error)
      }
    } catch (error) {
      console.error('Error processing payout completion:', getErrorMessage(error))
    }
  },

  'payout.failed': async (event) => {
    const payout = event.data.object as Stripe.Payout
    console.error('Payout failed:', payout.id)

    try {
      // Mark payout as failed
      const { error } = await supabase
        .from('payouts')
        .update({
          status: 'failed',
          notes: `Payout failed: ${payout.failure_message || 'Unknown error'}`,
        })
        .eq('transaction_id', payout.id)

      if (error) {
        console.error('Failed to update payout status:', error)
      }

      // TODO: Send notification to supplier and admin
      // TODO: Schedule retry or manual intervention
    } catch (error) {
      console.error('Error processing payout failure:', getErrorMessage(error))
    }
  },

  'transfer.created': async (event) => {
    const transfer = event.data.object as Stripe.Transfer
    console.log('Transfer created:', transfer.id)

    // Transfers are handled by payout events
    // This is mainly for logging and audit trail
  },

  'transfer.reversed': async (event) => {
    const transfer = event.data.object as Stripe.Transfer
    console.warn('Transfer reversed:', transfer.id)

    try {
      // Find and update related payout
      const { error } = await supabase
        .from('payouts')
        .update({
          status: 'cancelled',
          notes: `Transfer reversed: Unknown reason`,
        })
        .eq('transaction_id', transfer.id)

      if (error) {
        console.error('Failed to update payout for reversed transfer:', error)
      }
    } catch (error) {
      console.error('Error processing transfer reversal:', getErrorMessage(error))
    }
  },
}

export const handleStripeWebhook = async (req: Request, res: Response): Promise<void> => {
  const signature = req.headers['stripe-signature'] as string

  if (!signature) {
    res.status(400).send('Missing stripe-signature header')
    return
  }

  let event: Stripe.Event

  try {
    event = verifyWebhookSignature(req.body as string | Buffer, signature)
  } catch (err) {
    console.error('Webhook signature verification failed:', getErrorMessage(err))
    res.status(400).send(`Webhook Error: ${getErrorMessage(err)}`)
    return
  }

  const handler = webhookHandlers[event.type]

  if (handler) {
    try {
      await handler(event)
      res.json({ received: true })
    } catch (err) {
      console.error(`Error handling webhook ${event.type}:`, getErrorMessage(err))
      res.status(500).send(`Webhook handler error: ${getErrorMessage(err)}`)
    }
  } else {
    console.log(`Unhandled webhook event type: ${event.type}`)
    res.json({ received: true })
  }
}

export const timingSafeEqual = (a: string, b: string): boolean => {
  const bufferA = Buffer.from(a)
  const bufferB = Buffer.from(b)

  if (bufferA.length !== bufferB.length) {
    return false
  }

  return crypto.timingSafeEqual(bufferA, bufferB)
}
</file>

<file path="src/main.tsx">
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'
import { initSentry, SentryErrorBoundary, captureError } from './lib/monitoring'
import { apm } from './lib/apm'
import { AppErrorFallback } from './components/ui/AppErrorFallback'

// Initialize Sentry monitoring
initSentry()

// Initialize Application Performance Monitoring
apm.init({
  enableWebVitals: true,
  enableResourceTiming: true,
  enableLongTasks: true,
  enablePaintTiming: true,
  sampleRate: import.meta.env.PROD ? 0.1 : 1.0,
})

// Track initial bundle size (skip in StrictMode double-invocation)
if (!import.meta.env.DEV) {
  apm.trackBundleSize()
}

// Track memory usage periodically with proper disposal
let memInterval: number | undefined
if (import.meta.env.DEV) {
  memInterval = window.setInterval(() => apm.trackMemoryUsage(), 30_000)
}

// Attach global handlers with cleanup function
function attachGlobalHandlers() {
  const onError = (event: ErrorEvent) => {
    // Sentry SDK already captures these, but we add custom context
    captureError(event.error || new Error(event.message), {
      filename: event.filename,
      lineno: event.lineno,
      colno: event.colno,
      type: 'global_error',
    })
  }

  const onRejection = (event: PromiseRejectionEvent) => {
    // Sentry SDK already captures these, but we add custom context
    captureError(event.reason instanceof Error ? event.reason : new Error(String(event.reason)), {
      type: 'unhandled_promise_rejection',
    })
  }

  window.addEventListener('error', onError)
  window.addEventListener('unhandledrejection', onRejection)

  return () => {
    window.removeEventListener('error', onError)
    window.removeEventListener('unhandledrejection', onRejection)
    if (memInterval) clearInterval(memInterval)
  }
}

const detach = attachGlobalHandlers()

// Hot-module reload cleanup
if (import.meta.hot) {
  import.meta.hot.dispose(detach)
}

// Prevent multiple React roots on HMR
const container = document.getElementById('root')!

interface ContainerWithRoot extends HTMLElement {
  _reactRoot?: ReturnType<typeof createRoot>
}

const containerWithRoot = container as ContainerWithRoot
const root = containerWithRoot._reactRoot ?? (containerWithRoot._reactRoot = createRoot(container))

root.render(
  <StrictMode>
    <SentryErrorBoundary
      showDialog={false} // Prevent duplicate error dialogs
      fallback={({ error, resetError, eventId }) => (
        <AppErrorFallback
          error={error instanceof Error ? error : new Error(String(error))}
          resetErrorBoundary={resetError}
          errorInfo={{ eventId }}
        />
      )}
    >
      <App />
    </SentryErrorBoundary>
  </StrictMode>
)
</file>

<file path="package.json">
{
  "name": "dce-website",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "lint:fix": "eslint . --fix",
    "type-check": "tsc --noEmit",
    "test": "vitest",
    "test:ci": "vitest run --coverage",
    "test:ui": "vitest --ui",
    "test:e2e": "playwright test",
    "test:e2e:ui": "playwright test --ui",
    "preview": "vite preview",
    "prepare": "husky"
  },
  "dependencies": {
    "@headlessui/react": "^2.2.4",
    "@heroicons/react": "^2.2.0",
    "@hookform/resolvers": "^3.10.0",
    "@radix-ui/react-slot": "^1.2.3",
    "@sentry/react": "^8.52.0",
    "@sentry/tracing": "^7.117.0",
    "@stripe/react-stripe-js": "^3.7.0",
    "@stripe/stripe-js": "^7.6.1",
    "@supabase/supabase-js": "^2.52.0",
    "@tanstack/react-query": "^5.83.0",
    "@types/express": "^5.0.3",
    "@types/lodash": "^4.17.20",
    "@types/uuid": "^10.0.0",
    "axios": "^1.10.0",
    "express": "^5.1.0",
    "lodash": "^4.17.21",
    "playwright": "^1.54.1",
    "react": "^19.1.0",
    "react-dom": "^19.1.0",
    "react-error-boundary": "^6.0.0",
    "react-hook-form": "^7.60.0",
    "react-router-dom": "^7.7.0",
    "stripe": "^18.3.0",
    "tailwindcss": "^4.1.11",
    "uuid": "^11.1.0",
    "zod": "^3.25.76",
    "zustand": "^5.0.6"
  },
  "devDependencies": {
    "@eslint/js": "^9.30.1",
    "@playwright/test": "^1.54.1",
    "@tailwindcss/postcss": "^4.1.11",
    "@testing-library/jest-dom": "^6.6.3",
    "@testing-library/react": "^16.3.0",
    "@testing-library/user-event": "^14.6.1",
    "@types/react": "^19.1.8",
    "@types/react-dom": "^19.1.6",
    "@types/react-router-dom": "^5.3.3",
    "@typescript-eslint/eslint-plugin": "^8.38.0",
    "@typescript-eslint/parser": "^8.38.0",
    "@vitejs/plugin-react": "^4.6.0",
    "@vitest/coverage-v8": "^3.2.4",
    "autoprefixer": "^10.4.21",
    "eslint": "^9.30.1",
    "eslint-config-prettier": "^10.1.8",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.20",
    "globals": "^16.3.0",
    "husky": "^9.1.7",
    "jsdom": "^26.1.0",
    "lint-staged": "^16.1.2",
    "postcss": "^8.5.6",
    "prettier": "^3.6.2",
    "typescript": "~5.8.3",
    "typescript-eslint": "^8.35.1",
    "vite": "^7.0.4",
    "vitest": "^3.2.4"
  },
  "lint-staged": {
    "*.{js,jsx,ts,tsx}": [
      "eslint --fix",
      "prettier --write"
    ],
    "*.{json,md,yml,yaml}": [
      "prettier --write"
    ]
  }
}
</file>

<file path="src/components/common/FallbackUI.tsx">
import React from 'react'
import {
  ExclamationTriangleIcon,
  XCircleIcon,
  ShieldExclamationIcon,
  WifiIcon,
  ArrowPathIcon,
  HomeIcon,
  PhoneIcon,
  CreditCardIcon,
  DocumentTextIcon,
  EyeSlashIcon,
  ClockIcon,
  CheckCircleIcon,
  ChevronDownIcon,
  ChevronUpIcon,
} from '@heroicons/react/24/outline'
import {
  shouldShowTechnicalDetails,
  getEnvironmentName,
  getEnvironmentErrorMessage,
} from '../../utils/environment'

// Base error interfaces
interface BaseErrorProps {
  className?: string
  testId?: string
}

interface ErrorActionProps {
  onRetry?: () => void
  onGoHome?: () => void
  onGoBack?: () => void
  onContactSupport?: () => void
  retryLabel?: string
  showHomeButton?: boolean
  showBackButton?: boolean
  showSupportButton?: boolean
}

interface ErrorDetailsProps {
  title: string
  message: string
  details?: string
  errorCode?: string
  showTechnicalDetails?: boolean
  error?: Error | unknown
  errorInfo?: { componentStack?: string; [key: string]: unknown }
  timestamp?: Date
}

type ErrorFallbackProps = BaseErrorProps & ErrorActionProps & ErrorDetailsProps

// Generic Error Fallback Component
export function ErrorFallback({
  title,
  message,
  details,
  errorCode,
  showTechnicalDetails,
  error,
  errorInfo,
  timestamp = new Date(),
  onRetry,
  onGoHome,
  onGoBack,
  onContactSupport,
  retryLabel = 'Try Again',
  showHomeButton = false,
  showBackButton = false,
  showSupportButton = true,
  className = '',
  testId = 'error-fallback',
}: ErrorFallbackProps) {
  const [showDetails, setShowDetails] = React.useState(false)
  const shouldShowDetails = showTechnicalDetails ?? shouldShowTechnicalDetails()
  const environment = getEnvironmentName()

  return (
    <div
      className={`min-h-[400px] flex items-center justify-center p-6 ${className}`}
      data-testid={testId}
      role="alert"
      aria-live="polite"
    >
      <div className="max-w-md w-full text-center">
        <div className="flex justify-center mb-6">
          <div className="rounded-full bg-red-100 p-3">
            <ExclamationTriangleIcon className="h-8 w-8 text-red-600" aria-hidden="true" />
          </div>
        </div>

        <h2 className="text-xl font-semibold text-gray-900 mb-2">{title}</h2>

        <p className="text-gray-600 mb-6 leading-relaxed">{message}</p>

        {errorCode && <div className="mb-4 text-sm text-gray-500">Error Code: {errorCode}</div>}

        <div className="space-y-3">
          {onRetry && (
            <button
              onClick={onRetry}
              className="w-full flex items-center justify-center px-4 py-2 bg-primary-600 text-white rounded-lg hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2 transition-colors"
              data-testid="retry-button"
            >
              <ArrowPathIcon className="h-4 w-4 mr-2" />
              {retryLabel}
            </button>
          )}

          <div className="flex space-x-3">
            {showHomeButton && onGoHome && (
              <button
                onClick={onGoHome}
                className="flex-1 flex items-center justify-center px-4 py-2 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 transition-colors"
                data-testid="home-button"
              >
                <HomeIcon className="h-4 w-4 mr-2" />
                Home
              </button>
            )}

            {showBackButton && onGoBack && (
              <button
                onClick={onGoBack}
                className="flex-1 flex items-center justify-center px-4 py-2 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 transition-colors"
                data-testid="back-button"
              >
                â† Back
              </button>
            )}
          </div>

          {showSupportButton && onContactSupport && (
            <button
              onClick={onContactSupport}
              className="w-full flex items-center justify-center px-4 py-2 text-primary-600 bg-primary-50 rounded-lg hover:bg-primary-100 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2 transition-colors"
              data-testid="support-button"
            >
              <PhoneIcon className="h-4 w-4 mr-2" />
              Contact Support
            </button>
          )}
        </div>

        {!!(shouldShowDetails && (details || error)) && (
          <div className="mt-6 pt-4 border-t border-gray-200">
            <button
              onClick={() => setShowDetails(!showDetails)}
              className="flex items-center gap-1 text-sm text-gray-500 hover:text-gray-700 focus:outline-none focus:underline mx-auto"
              aria-expanded={showDetails}
              aria-label={showDetails ? 'Hide technical details' : 'Show technical details'}
              data-testid="technical-details-toggle"
            >
              {showDetails ? 'Hide' : 'Show'} Technical Details
              {showDetails ? (
                <ChevronUpIcon className="h-4 w-4" />
              ) : (
                <ChevronDownIcon className="h-4 w-4" />
              )}
            </button>

            {showDetails && (
              <div className="mt-3 p-4 bg-gray-50 rounded-lg text-left space-y-4">
                {/* Environment Info */}
                <div className="text-xs text-gray-500 flex items-center justify-between">
                  <span>
                    Environment: <span className="font-medium">{environment}</span>
                  </span>
                  <span>Time: {timestamp.toLocaleString()}</span>
                </div>

                {/* Error Details */}
                {details && typeof details === 'string' && details.trim() !== '' && (
                  <div>
                    <h4 className="text-xs font-semibold text-gray-700 mb-1">Error Details:</h4>
                    <pre className="text-xs text-gray-600 whitespace-pre-wrap overflow-auto bg-white p-2 rounded border border-gray-200">
                      {details}
                    </pre>
                  </div>
                )}

                {/* Error Object */}
                {!!error && error instanceof Error && (
                  <>
                    <div>
                      <h4 className="text-xs font-semibold text-gray-700 mb-1">Error Message:</h4>
                      <pre className="text-xs text-gray-600 whitespace-pre-wrap bg-white p-2 rounded border border-gray-200">
                        {error.message}
                      </pre>
                    </div>

                    {error.stack && (
                      <div>
                        <h4 className="text-xs font-semibold text-gray-700 mb-1">Stack Trace:</h4>
                        <pre className="text-xs text-gray-600 whitespace-pre-wrap overflow-auto bg-white p-2 rounded border border-gray-200 max-h-48">
                          {error.stack}
                        </pre>
                      </div>
                    )}
                  </>
                )}

                {/* Component Stack */}
                {errorInfo?.componentStack && (
                  <div>
                    <h4 className="text-xs font-semibold text-gray-700 mb-1">Component Stack:</h4>
                    <pre className="text-xs text-gray-600 whitespace-pre-wrap overflow-auto bg-white p-2 rounded border border-gray-200 max-h-48">
                      {errorInfo.componentStack}
                    </pre>
                  </div>
                )}

                {/* Additional Error Info */}
                {!!errorInfo && Object.keys(errorInfo).length > 1 && (
                  <div>
                    <h4 className="text-xs font-semibold text-gray-700 mb-1">Additional Info:</h4>
                    <pre className="text-xs text-gray-600 whitespace-pre-wrap overflow-auto bg-white p-2 rounded border border-gray-200">
                      {(() => {
                        try {
                          const filteredInfo = Object.fromEntries(
                            Object.entries(errorInfo).filter(([key]) => key !== 'componentStack')
                          )
                          return JSON.stringify(filteredInfo, null, 2) || 'No additional info available'
                        } catch {
                          return 'Error serializing additional info'
                        }
                      })()}
                    </pre>
                  </div>
                )}

                {/* Dev Tools Hint */}
                {environment === 'development' && (
                  <div className="text-xs text-gray-500 italic">
                    ðŸ’¡ Tip: Check your browser console for more detailed debugging information.
                  </div>
                )}
              </div>
            )}
          </div>
        )}
      </div>
    </div>
  )
}

// Route-Specific Error Components

interface RouteErrorProps extends BaseErrorProps {
  onRetry?: () => void
  onGoHome?: () => void
  error?: Error | unknown
  errorInfo?: { componentStack?: string; [key: string]: unknown }
}

export function NotFoundError({ onGoHome, className, testId }: RouteErrorProps) {
  return (
    <ErrorFallback
      title="Page Not Found"
      message="The page you're looking for doesn't exist or may have been moved."
      onGoHome={onGoHome}
      showHomeButton={true}
      showSupportButton={false}
      className={className}
      testId={testId}
      errorCode="404"
    />
  )
}

export function InternalServerError({
  onRetry,
  onGoHome,
  error,
  errorInfo,
  className,
  testId,
}: RouteErrorProps) {
  return (
    <ErrorFallback
      title="Server Error"
      message={getEnvironmentErrorMessage(
        error,
        "We're experiencing technical difficulties. Our team has been notified and is working to resolve this issue."
      )}
      onRetry={onRetry}
      onGoHome={onGoHome}
      showHomeButton={true}
      showBackButton={false}
      retryLabel="Refresh Page"
      className={className}
      testId={testId}
      errorCode="500"
      error={error}
      errorInfo={errorInfo}
    />
  )
}

export function UnauthorizedError({ onGoHome, className, testId }: RouteErrorProps) {
  return (
    <div
      className={`min-h-[400px] flex items-center justify-center p-6 ${className}`}
      data-testid={testId}
      role="alert"
    >
      <div className="max-w-md w-full text-center">
        <div className="flex justify-center mb-6">
          <div className="rounded-full bg-yellow-100 p-3">
            <ShieldExclamationIcon className="h-8 w-8 text-yellow-600" aria-hidden="true" />
          </div>
        </div>

        <h2 className="text-xl font-semibold text-gray-900 mb-2">Access Denied</h2>

        <p className="text-gray-600 mb-6 leading-relaxed">
          You don't have permission to access this page. Please log in or contact your
          administrator.
        </p>

        <div className="space-y-3">
          <button
            onClick={() => (window.location.href = '/login')}
            className="w-full flex items-center justify-center px-4 py-2 bg-primary-600 text-white rounded-lg hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2 transition-colors"
          >
            Sign In
          </button>

          {onGoHome && (
            <button
              onClick={onGoHome}
              className="w-full flex items-center justify-center px-4 py-2 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 transition-colors"
            >
              <HomeIcon className="h-4 w-4 mr-2" />
              Go Home
            </button>
          )}
        </div>
      </div>
    </div>
  )
}

export function NetworkError({ onRetry, className, testId }: RouteErrorProps) {
  return (
    <div
      className={`min-h-[400px] flex items-center justify-center p-6 ${className}`}
      data-testid={testId}
      role="alert"
    >
      <div className="max-w-md w-full text-center">
        <div className="flex justify-center mb-6">
          <div className="rounded-full bg-red-100 p-3">
            <WifiIcon className="h-8 w-8 text-red-600" aria-hidden="true" />
          </div>
        </div>

        <h2 className="text-xl font-semibold text-gray-900 mb-2">Connection Problem</h2>

        <p className="text-gray-600 mb-6 leading-relaxed">
          Unable to connect to our servers. Please check your internet connection and try again.
        </p>

        {onRetry && (
          <button
            onClick={onRetry}
            className="w-full flex items-center justify-center px-4 py-2 bg-primary-600 text-white rounded-lg hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2 transition-colors"
          >
            <ArrowPathIcon className="h-4 w-4 mr-2" />
            Try Again
          </button>
        )}
      </div>
    </div>
  )
}

// Form-Specific Error Components

interface FormErrorProps extends BaseErrorProps {
  errors: Record<string, string>
  onRetry?: () => void
  title?: string
  message?: string
}

export function FormValidationError({
  errors,
  onRetry,
  title = 'Form Validation Error',
  message = 'Please correct the following errors and try again:',
  className,
  testId,
}: FormErrorProps) {
  return (
    <div
      className={`p-4 bg-red-50 border border-red-200 rounded-lg ${className}`}
      data-testid={testId}
      role="alert"
      aria-live="polite"
    >
      <div className="flex">
        <div className="flex-shrink-0">
          <XCircleIcon className="h-5 w-5 text-red-400" aria-hidden="true" />
        </div>
        <div className="ml-3 flex-1">
          <h3 className="text-sm font-medium text-red-800">{title}</h3>
          <div className="mt-2 text-sm text-red-700">
            <p className="mb-2">{message}</p>
            <ul className="list-disc list-inside space-y-1">
              {Object.entries(errors).map(([field, error]) => (
                <li key={field}>
                  <span className="font-medium capitalize">
                    {field.replace(/([A-Z])/g, ' $1').trim()}:
                  </span>{' '}
                  {typeof error === 'string' ? error : String(error)}
                </li>
              ))}
            </ul>
          </div>
          {onRetry && (
            <div className="mt-4">
              <button
                onClick={onRetry}
                className="text-sm bg-red-100 text-red-800 px-3 py-1 rounded hover:bg-red-200 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 transition-colors"
              >
                Try Again
              </button>
            </div>
          )}
        </div>
      </div>
    </div>
  )
}

interface FormSubmissionErrorProps extends BaseErrorProps {
  onRetry?: () => void
  message?: string
}

export function FormSubmissionError({
  onRetry,
  message = 'There was an error submitting your form. Please try again.',
  className,
  testId,
}: FormSubmissionErrorProps) {
  return (
    <div
      className={`p-4 bg-red-50 border border-red-200 rounded-lg ${className}`}
      data-testid={testId}
      role="alert"
    >
      <div className="flex items-center">
        <XCircleIcon className="h-5 w-5 text-red-400 mr-3" aria-hidden="true" />
        <div className="flex-1">
          <p className="text-sm text-red-700">{message}</p>
        </div>
        {onRetry && (
          <button
            onClick={onRetry}
            className="ml-3 text-sm bg-red-100 text-red-800 px-3 py-1 rounded hover:bg-red-200 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 transition-colors"
          >
            Retry
          </button>
        )}
      </div>
    </div>
  )
}

// Payment/Transaction Error Components

interface PaymentErrorProps extends BaseErrorProps {
  errorType:
    | 'card_declined'
    | 'insufficient_funds'
    | 'payment_failed'
    | 'connection_error'
    | 'invalid_card'
  onRetry?: () => void
  onUpdatePaymentMethod?: () => void
  onContactSupport?: () => void
}

export function PaymentError({
  errorType,
  onRetry,
  onUpdatePaymentMethod,
  onContactSupport,
  className,
  testId,
}: PaymentErrorProps) {
  const getErrorContent = () => {
    switch (errorType) {
      case 'card_declined':
        return {
          title: 'Card Declined',
          message:
            'Your card was declined. Please try a different payment method or contact your bank.',
          showUpdatePayment: true,
        }
      case 'insufficient_funds':
        return {
          title: 'Insufficient Funds',
          message: 'Your card has insufficient funds. Please use a different payment method.',
          showUpdatePayment: true,
        }
      case 'invalid_card':
        return {
          title: 'Invalid Card Information',
          message: 'The card information you entered is invalid. Please check and try again.',
          showUpdatePayment: true,
        }
      case 'connection_error':
        return {
          title: 'Connection Error',
          message: 'Unable to process payment due to connection issues. Please try again.',
          showUpdatePayment: false,
        }
      default:
        return {
          title: 'Payment Failed',
          message: 'We were unable to process your payment. Please try again or contact support.',
          showUpdatePayment: true,
        }
    }
  }

  const { title, message, showUpdatePayment } = getErrorContent()

  return (
    <div
      className={`p-6 bg-red-50 border border-red-200 rounded-lg ${className}`}
      data-testid={testId}
      role="alert"
    >
      <div className="flex">
        <div className="flex-shrink-0">
          <div className="rounded-full bg-red-100 p-2">
            <CreditCardIcon className="h-6 w-6 text-red-600" aria-hidden="true" />
          </div>
        </div>
        <div className="ml-4 flex-1">
          <h3 className="text-lg font-medium text-red-800 mb-2">{title}</h3>
          <p className="text-red-700 mb-4">{message}</p>

          <div className="space-y-2">
            {showUpdatePayment && onUpdatePaymentMethod && (
              <button
                onClick={onUpdatePaymentMethod}
                className="w-full sm:w-auto inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-lg hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2 transition-colors mr-3"
              >
                <CreditCardIcon className="h-4 w-4 mr-2" />
                Update Payment Method
              </button>
            )}

            {onRetry && (
              <button
                onClick={onRetry}
                className="w-full sm:w-auto inline-flex items-center px-4 py-2 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 transition-colors mr-3"
              >
                <ArrowPathIcon className="h-4 w-4 mr-2" />
                Try Again
              </button>
            )}

            {onContactSupport && (
              <button
                onClick={onContactSupport}
                className="w-full sm:w-auto inline-flex items-center px-4 py-2 text-red-700 bg-red-100 rounded-lg hover:bg-red-200 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 transition-colors"
              >
                <PhoneIcon className="h-4 w-4 mr-2" />
                Contact Support
              </button>
            )}
          </div>
        </div>
      </div>
    </div>
  )
}

// Loading State Error Fallbacks

interface LoadingErrorProps extends BaseErrorProps {
  type: 'data' | 'page' | 'component'
  onRetry?: () => void
  message?: string
}

export function LoadingError({ type, onRetry, message, className, testId }: LoadingErrorProps) {
  const getDefaultMessage = () => {
    switch (type) {
      case 'data':
        return 'Failed to load data. Please try again.'
      case 'page':
        return 'Failed to load page content. Please refresh and try again.'
      case 'component':
        return 'This section failed to load. Please try again.'
      default:
        return 'Loading failed. Please try again.'
    }
  }

  return (
    <div
      className={`flex items-center justify-center p-6 ${className}`}
      data-testid={testId}
      role="alert"
    >
      <div className="text-center">
        <div className="flex justify-center mb-4">
          <div className="rounded-full bg-gray-100 p-3">
            <DocumentTextIcon className="h-6 w-6 text-gray-500" aria-hidden="true" />
          </div>
        </div>

        <p className="text-gray-600 mb-4">{message || getDefaultMessage()}</p>

        {onRetry && (
          <button
            onClick={onRetry}
            className="inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-lg hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2 transition-colors"
          >
            <ArrowPathIcon className="h-4 w-4 mr-2" />
            Try Again
          </button>
        )}
      </div>
    </div>
  )
}

// Empty State with Error Context

interface EmptyStateErrorProps extends BaseErrorProps {
  title: string
  message: string
  icon?: React.ComponentType<{ className?: string }>
  actionLabel?: string
  onAction?: () => void
}

export function EmptyStateError({
  title,
  message,
  icon: Icon = EyeSlashIcon,
  actionLabel,
  onAction,
  className,
  testId,
}: EmptyStateErrorProps) {
  return (
    <div className={`flex items-center justify-center p-12 ${className}`} data-testid={testId}>
      <div className="text-center max-w-md">
        <div className="flex justify-center mb-6">
          <div className="rounded-full bg-gray-100 p-4">
            <Icon className="h-8 w-8 text-gray-400" aria-hidden="true" />
          </div>
        </div>

        <h3 className="text-lg font-medium text-gray-900 mb-2">{title}</h3>

        <p className="text-gray-500 mb-6">{message}</p>

        {actionLabel && onAction && (
          <button
            onClick={onAction}
            className="inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-lg hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2 transition-colors"
          >
            {actionLabel}
          </button>
        )}
      </div>
    </div>
  )
}

// Timeout Error Component

interface TimeoutErrorProps extends BaseErrorProps {
  onRetry?: () => void
  onCancel?: () => void
  timeoutDuration?: number
}

export function TimeoutError({
  onRetry,
  onCancel,
  timeoutDuration,
  className,
  testId,
}: TimeoutErrorProps) {
  return (
    <div
      className={`flex items-center justify-center p-6 ${className}`}
      data-testid={testId}
      role="alert"
    >
      <div className="text-center max-w-md">
        <div className="flex justify-center mb-6">
          <div className="rounded-full bg-yellow-100 p-3">
            <ClockIcon className="h-8 w-8 text-yellow-600" aria-hidden="true" />
          </div>
        </div>

        <h3 className="text-lg font-medium text-gray-900 mb-2">Request Timeout</h3>

        <p className="text-gray-600 mb-6">
          The request took too long to complete
          {timeoutDuration && ` (${timeoutDuration}s)`}. Please try again or check your connection.
        </p>

        <div className="space-y-3">
          {onRetry && (
            <button
              onClick={onRetry}
              className="w-full flex items-center justify-center px-4 py-2 bg-primary-600 text-white rounded-lg hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2 transition-colors"
            >
              <ArrowPathIcon className="h-4 w-4 mr-2" />
              Try Again
            </button>
          )}

          {onCancel && (
            <button
              onClick={onCancel}
              className="w-full flex items-center justify-center px-4 py-2 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 transition-colors"
            >
              Cancel
            </button>
          )}
        </div>
      </div>
    </div>
  )
}

// Success State with Action Options

interface SuccessStateProps extends BaseErrorProps {
  title: string
  message: string
  onPrimaryAction?: () => void
  onSecondaryAction?: () => void
  primaryActionLabel?: string
  secondaryActionLabel?: string
}

export function SuccessState({
  title,
  message,
  onPrimaryAction,
  onSecondaryAction,
  primaryActionLabel = 'Continue',
  secondaryActionLabel = 'Done',
  className,
  testId,
}: SuccessStateProps) {
  return (
    <div
      className={`flex items-center justify-center p-6 ${className}`}
      data-testid={testId}
      role="status"
      aria-live="polite"
    >
      <div className="text-center max-w-md">
        <div className="flex justify-center mb-6">
          <div className="rounded-full bg-green-100 p-3">
            <CheckCircleIcon className="h-8 w-8 text-green-600" aria-hidden="true" />
          </div>
        </div>

        <h3 className="text-lg font-medium text-gray-900 mb-2">{title}</h3>

        <p className="text-gray-600 mb-6">{message}</p>

        <div className="space-y-3">
          {onPrimaryAction && (
            <button
              onClick={onPrimaryAction}
              className="w-full flex items-center justify-center px-4 py-2 bg-primary-600 text-white rounded-lg hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2 transition-colors"
            >
              {primaryActionLabel}
            </button>
          )}

          {onSecondaryAction && (
            <button
              onClick={onSecondaryAction}
              className="w-full flex items-center justify-center px-4 py-2 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 transition-colors"
            >
              {secondaryActionLabel}
            </button>
          )}
        </div>
      </div>
    </div>
  )
}

// Layout-Specific Error Fallback Components

export function PublicLayoutFallbackUI({ className, testId }: BaseErrorProps) {
  return (
    <div
      className={`min-h-[400px] flex items-center justify-center p-6 bg-gray-50 ${className}`}
      data-testid={testId}
      role="alert"
    >
      <div className="max-w-md w-full text-center">
        <div className="flex justify-center mb-6">
          <div className="rounded-full bg-red-100 p-3">
            <ExclamationTriangleIcon className="h-8 w-8 text-red-600" aria-hidden="true" />
          </div>
        </div>

        <h2 className="text-xl font-semibold text-gray-900 mb-2">Page Error</h2>

        <p className="text-gray-600 mb-6 leading-relaxed">
          We're sorry, but this page encountered an error. Please try refreshing the page or return
          to our homepage.
        </p>

        <div className="space-y-3">
          <button
            onClick={() => window.location.reload()}
            className="w-full flex items-center justify-center px-4 py-2 bg-primary-600 text-white rounded-lg hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2 transition-colors"
          >
            <ArrowPathIcon className="h-4 w-4 mr-2" />
            Refresh Page
          </button>

          <button
            onClick={() => (window.location.href = '/')}
            className="w-full flex items-center justify-center px-4 py-2 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 transition-colors"
          >
            <HomeIcon className="h-4 w-4 mr-2" />
            Go to Homepage
          </button>
        </div>
      </div>
    </div>
  )
}

export function AppLayoutSidebarFallbackUI({ className, testId }: BaseErrorProps) {
  return (
    <div
      className={`p-4 bg-red-50 border border-red-200 rounded-lg m-2 ${className}`}
      data-testid={testId}
      role="alert"
    >
      <div className="flex items-center">
        <div className="flex-shrink-0">
          <ExclamationTriangleIcon className="h-5 w-5 text-red-400" aria-hidden="true" />
        </div>
        <div className="ml-3">
          <h3 className="text-sm font-medium text-red-800">Navigation Error</h3>
          <p className="mt-1 text-sm text-red-700">
            The navigation menu encountered an error. Please refresh the page.
          </p>
          <div className="mt-3">
            <button
              onClick={() => window.location.reload()}
              className="text-sm bg-red-100 text-red-800 px-3 py-1 rounded hover:bg-red-200 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 transition-colors"
            >
              Refresh
            </button>
          </div>
        </div>
      </div>
    </div>
  )
}

export function AppLayoutContentFallbackUI({ className, testId }: BaseErrorProps) {
  return (
    <div
      className={`min-h-[500px] flex items-center justify-center p-6 bg-white ${className}`}
      data-testid={testId}
      role="alert"
    >
      <div className="max-w-lg w-full text-center">
        <div className="flex justify-center mb-6">
          <div className="rounded-full bg-red-100 p-4">
            <ExclamationTriangleIcon className="h-10 w-10 text-red-600" aria-hidden="true" />
          </div>
        </div>

        <h2 className="text-2xl font-semibold text-gray-900 mb-2">Content Error</h2>

        <p className="text-gray-600 mb-8 leading-relaxed">
          The main content area encountered an error and cannot be displayed. This might be a
          temporary issue.
        </p>

        <div className="space-y-4">
          <button
            onClick={() => window.location.reload()}
            className="w-full flex items-center justify-center px-6 py-3 bg-primary-600 text-white rounded-lg hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2 transition-colors text-base font-medium"
          >
            <ArrowPathIcon className="h-5 w-5 mr-2" />
            Refresh Page
          </button>

          <button
            onClick={() => (window.location.href = '/app/dashboard')}
            className="w-full flex items-center justify-center px-6 py-3 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 transition-colors text-base font-medium"
          >
            <HomeIcon className="h-5 w-5 mr-2" />
            Go to Dashboard
          </button>
        </div>

        <div className="mt-8 text-sm text-gray-500">
          <p>If this problem persists, please contact support.</p>
        </div>
      </div>
    </div>
  )
}

// Export ErrorFallback as FallbackUI for backward compatibility
export { ErrorFallback as FallbackUI }

// Export all error interfaces for external use
export type {
  ErrorFallbackProps,
  BaseErrorProps,
  ErrorActionProps,
  ErrorDetailsProps,
  RouteErrorProps,
  FormErrorProps,
  FormSubmissionErrorProps,
  PaymentErrorProps,
  LoadingErrorProps,
  EmptyStateErrorProps,
  TimeoutErrorProps,
  SuccessStateProps,
}

// Export all components as default
export default {
  ErrorFallback,
  NotFoundError,
  InternalServerError,
  UnauthorizedError,
  NetworkError,
  FormValidationError,
  FormSubmissionError,
  PaymentError,
  LoadingError,
  EmptyStateError,
  TimeoutError,
  SuccessState,
  PublicLayoutFallbackUI,
  AppLayoutSidebarFallbackUI,
  AppLayoutContentFallbackUI,
}
</file>

<file path="src/App.tsx">
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom'
import { QueryClientProvider, QueryErrorResetBoundary } from '@tanstack/react-query'
import { queryClient } from './lib/queryClient'
import { ErrorBoundary } from 'react-error-boundary'
import { ErrorBoundary as CustomErrorBoundary } from './components/common/ErrorBoundary'
import { UnauthorizedError } from './components/common/FallbackUI'
import React, { useEffect, Suspense } from 'react'
import { useAuthStore } from './store/authStore'
import { captureError } from './lib/monitoring'
import { QueryErrorFallback } from './components/ui/QueryErrorFallback'

// Layouts
import PublicLayout from './components/layout/PublicLayout'
import AppLayout from './components/layout/AppLayout'

// Public Pages
import HomePage from './pages/public/HomePage'
import BlogPage from './pages/public/BlogPage'
import BlogPostPage from './pages/public/BlogPostPage'
import ContactPage from './pages/public/ContactPage'
import CareersPage from './pages/public/CareersPage'
import AboutPage from './pages/public/AboutPage'
import LoginPage from './pages/auth/LoginPage'
import RegisterPage from './pages/auth/RegisterPage'
import ForgotPasswordPage from './pages/auth/ForgotPasswordPage'

// Legal Pages
import PrivacyPage from './pages/legal/PrivacyPage'
import TermsPage from './pages/legal/TermsPage'
import CompliancePage from './pages/legal/CompliancePage'

// Demo Pages (Development Only)
const ErrorDemoPage = import.meta.env.DEV ? React.lazy(() => import('./pages/ErrorDemo')) : null

// Authenticated Pages
import DashboardPage from './pages/dashboard/DashboardPage'
import CampaignsPage from './pages/campaigns/CampaignsPage'
import CreateCampaignPage from './pages/campaigns/CreateCampaignPage'
import EditCampaignPage from './pages/campaigns/EditCampaignPage'
import CallsPage from './pages/calls/CallsPage'
import ReportsPage from './pages/reports/ReportsPage'
import BillingPage from './pages/billing/BillingPage'
import SettingsPage from './pages/settings/SettingsPage'

// Protected Route Component
function ProtectedRoute({ children }: { children: React.ReactNode }) {
  const { user, loading } = useAuthStore()

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-center">
          <div className="inline-flex items-center justify-center w-16 h-16 border-4 border-primary-600 border-t-transparent rounded-full animate-spin"></div>
          <p className="mt-4 text-gray-600">Loading...</p>
        </div>
      </div>
    )
  }

  if (!user) {
    return <Navigate to="/login" replace />
  }

  return (
    <CustomErrorBoundary
      context="ProtectedRoute - Authentication"
      fallback={<UnauthorizedError onGoHome={() => (window.location.href = '/')} />}
      onError={(error, errorInfo) => {
        // Log authentication-related errors
        captureError(error, {
          errorBoundary: 'protected-route',
          componentStack: errorInfo.componentStack,
          context: 'authentication',
          user: user?.id || 'unknown',
        })
      }}
    >
      {children}
    </CustomErrorBoundary>
  )
}

function App() {
  const { checkSession } = useAuthStore()

  useEffect(() => {
    checkSession()
  }, [checkSession])

  return (
    <div className="min-h-screen flex flex-col">
      <QueryClientProvider client={queryClient}>
        <QueryErrorResetBoundary>
          {({ reset }) => (
            <ErrorBoundary
              FallbackComponent={QueryErrorFallback}
              onError={(error, errorInfo) => {
                // Capture React Query related errors
                captureError(error, {
                  errorBoundary: 'query-level',
                  componentStack: errorInfo.componentStack,
                  context: 'react-query-boundary',
                })
              }}
              onReset={reset}
            >
              <Router>
                <Routes>
                  {/* Public routes */}
                  <Route path="/" element={<PublicLayout />}>
                    <Route index element={<HomePage />} />
                    <Route path="login" element={<LoginPage />} />
                    <Route path="register" element={<RegisterPage />} />
                    <Route path="forgot-password" element={<ForgotPasswordPage />} />
                    <Route path="about" element={<AboutPage />} />
                    <Route path="blog" element={<BlogPage />} />
                    <Route path="blog/:slug" element={<BlogPostPage />} />
                    <Route path="contact" element={<ContactPage />} />
                    <Route path="careers" element={<CareersPage />} />
                    <Route path="privacy" element={<PrivacyPage />} />
                    <Route path="terms" element={<TermsPage />} />
                    <Route path="compliance" element={<CompliancePage />} />
                    {/* Development-only demo routes */}
                    {import.meta.env.DEV && ErrorDemoPage && (
                      <Route
                        path="error-demo"
                        element={
                          <Suspense fallback={<div>Loading demo...</div>}>
                            <ErrorDemoPage />
                          </Suspense>
                        }
                      />
                    )}
                  </Route>

                  {/* Protected app routes */}
                  <Route
                    path="/app"
                    element={
                      <ProtectedRoute>
                        <AppLayout />
                      </ProtectedRoute>
                    }
                  >
                    <Route index element={<Navigate to="/app/dashboard" replace />} />
                    <Route path="dashboard" element={<DashboardPage />} />
                    <Route path="campaigns" element={<CampaignsPage />} />
                    <Route path="campaigns/create" element={<CreateCampaignPage />} />
                    <Route path="campaigns/:id/edit" element={<EditCampaignPage />} />
                    <Route path="calls" element={<CallsPage />} />
                    <Route path="reports" element={<ReportsPage />} />
                    <Route path="billing" element={<BillingPage />} />
                    <Route path="settings" element={<SettingsPage />} />
                  </Route>

                  {/* Catch all */}
                  <Route path="*" element={<Navigate to="/" replace />} />
                </Routes>
              </Router>
            </ErrorBoundary>
          )}
        </QueryErrorResetBoundary>
      </QueryClientProvider>
    </div>
  )
}

export default App
</file>

</files>
