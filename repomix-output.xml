This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.github/
  workflows/
    deploy-production.yml
    deploy-staging.yml
    pr-validation.yml
    security-scan.yml
  CLAUDE.md
  README.md
.husky/
  pre-commit
public/
  vite.svg
src/
  assets/
    CLAUDE.md
    react.svg
  components/
    layout/
      AppLayout.tsx
      PublicLayout.tsx
    CLAUDE.md
  hooks/
    CLAUDE.md
    useStripe.ts
  integrations/
    fraud/
      blocking.ts
      config.ts
      fraudlabs.ts
      index.ts
      ipquality.ts
      maxmind.ts
      scoring.ts
      sift.ts
      truecaller.ts
      types.ts
    stripe/
      billing.ts
      client.ts
      connected-accounts.ts
      customers.ts
      index.ts
      payments.ts
      payouts.ts
      README.md
      subscriptions.ts
      types.ts
      webhooks.ts
    CLAUDE.md
  lib/
    CLAUDE.md
    monitoring.ts
    supabase.ts
  pages/
    auth/
      ForgotPasswordPage.tsx
      LoginPage.tsx
      RegisterPage.tsx
    billing/
      BillingPage.tsx
    calls/
      CallsPage.tsx
    campaigns/
      CampaignsPage.tsx
    dashboard/
      DashboardPage.tsx
    public/
      HomePage.tsx
    reports/
      ReportsPage.tsx
    settings/
      SettingsPage.tsx
    CLAUDE.md
  services/
    CLAUDE.md
  store/
    authStore.ts
    CLAUDE.md
  test/
    providers.tsx
    setup.ts
    test-utils.tsx
  types/
    CLAUDE.md
    database.ts
  utils/
    CLAUDE.md
  App.tsx
  CLAUDE.md
  index.css
  main.tsx
  vite-env.d.ts
supabase/
  migrations/
    001_initial_schema.sql
    002_security_policies.sql
    003_functions.sql
    004_triggers.sql
    005_indexes.sql
  .gitignore
  CLAUDE.md
  config.toml
  README.md
  seed.sql
tests/
  e2e/
    auth/
      example.spec.ts
    CLAUDE.md
  fixtures/
    calls.ts
    campaigns.ts
    CLAUDE.md
    index.ts
    users.ts
  integration/
    CLAUDE.md
  performance/
    CLAUDE.md
  unit/
    components/
      example.test.tsx
    integrations/
      stripe/
        billing.test.ts
        client.test.ts
        customers.test.ts
        payments.test.ts
        webhooks.test.ts
    pages/
      auth/
        ForgotPasswordPage.test.tsx
        LoginPage.test.tsx
        RegisterPage.test.tsx
    CLAUDE.md
  CLAUDE.md
.env.example
.gitignore
.prettierignore
.prettierrc.json
BACKEND_SETUP.md
CLAUDE.md
eslint.config.js
index.html
netlify.toml
package.json
playwright.config.ts
postcss.config.js
README.md
tailwind.config.js
tsconfig.app.json
tsconfig.json
tsconfig.node.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/deploy-production.yml">
name: Deploy to Production

on:
  push:
    branches: [main]
  workflow_dispatch:

jobs:
  test-and-build:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Run linting
        run: npm run lint
        
      - name: Run type checking
        run: npm run type-check
        
      - name: Run tests
        run: npm run test:ci
        
      - name: Build for production
        run: npm run build
        env:
          VITE_SUPABASE_URL: ${{ secrets.VITE_SUPABASE_URL }}
          VITE_SUPABASE_ANON_KEY: ${{ secrets.VITE_SUPABASE_ANON_KEY }}
          VITE_STRIPE_PUBLISHABLE_KEY: ${{ secrets.VITE_STRIPE_PUBLISHABLE_KEY }}
          VITE_SENTRY_DSN: ${{ secrets.VITE_SENTRY_DSN }}
        
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: production-build
          path: dist/
          retention-days: 30

  deploy:
    needs: test-and-build
    runs-on: ubuntu-latest
    environment: production
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: production-build
          path: dist/
          
      - name: Deploy to Netlify
        uses: nwtgck/actions-netlify@v3.0
        with:
          publish-dir: './dist'
          production-branch: main
          github-token: ${{ secrets.GITHUB_TOKEN }}
          deploy-message: "Production deployment from commit ${{ github.sha }}"
          enable-pull-request-comment: false
          enable-commit-comment: true
          overwrites-pull-request-comment: false
        env:
          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
          NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID }}
          
      - name: Notify Sentry of release
        uses: getsentry/action-release@v1
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
          SENTRY_ORG: ${{ secrets.SENTRY_ORG }}
          SENTRY_PROJECT: ${{ secrets.SENTRY_PROJECT }}
        with:
          environment: production
          version: ${{ github.sha }}
          
      - name: Health check
        run: |
          echo "Waiting for deployment to be ready..."
          sleep 30
          curl -f https://dependablecalls.com/health || exit 1
</file>

<file path=".github/workflows/deploy-staging.yml">
name: Deploy to Staging

on:
  push:
    branches: [develop]
  workflow_dispatch:

jobs:
  test-and-build:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Run linting
        run: npm run lint
        
      - name: Run type checking
        run: npm run type-check
        
      - name: Run tests
        run: npm run test:ci
        
      - name: Build for staging
        run: npm run build
        env:
          VITE_SUPABASE_URL: ${{ secrets.VITE_STAGING_SUPABASE_URL }}
          VITE_SUPABASE_ANON_KEY: ${{ secrets.VITE_STAGING_SUPABASE_ANON_KEY }}
          VITE_STRIPE_PUBLISHABLE_KEY: ${{ secrets.VITE_STAGING_STRIPE_PUBLISHABLE_KEY }}
          VITE_SENTRY_DSN: ${{ secrets.VITE_STAGING_SENTRY_DSN }}
        
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: staging-build
          path: dist/
          retention-days: 7

  deploy:
    needs: test-and-build
    runs-on: ubuntu-latest
    environment: staging
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: staging-build
          path: dist/
          
      - name: Deploy to Netlify Staging
        uses: nwtgck/actions-netlify@v3.0
        with:
          publish-dir: './dist'
          production-branch: develop
          github-token: ${{ secrets.GITHUB_TOKEN }}
          deploy-message: "Staging deployment from commit ${{ github.sha }}"
          enable-pull-request-comment: false
          enable-commit-comment: true
        env:
          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
          NETLIFY_SITE_ID: ${{ secrets.NETLIFY_STAGING_SITE_ID }}
          
      - name: Notify Sentry of staging release
        uses: getsentry/action-release@v1
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
          SENTRY_ORG: ${{ secrets.SENTRY_ORG }}
          SENTRY_PROJECT: ${{ secrets.SENTRY_PROJECT }}
        with:
          environment: staging
          version: ${{ github.sha }}
          
      - name: Run smoke tests
        run: |
          echo "Running smoke tests against staging..."
          sleep 15
          # Add actual smoke test commands here when available
          echo "Smoke tests completed"
</file>

<file path=".github/workflows/pr-validation.yml">
name: PR Validation

on:
  pull_request:
    branches: [main, develop]

jobs:
  validate:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Lint code
        run: npm run lint
        
      - name: Type check
        run: npm run type-check
        
      - name: Run tests
        run: npm run test:ci
        
      - name: Build application
        run: npm run build
        
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-files
          path: dist/
          retention-days: 7
          
      - name: Security audit
        run: npm audit --audit-level=high
        
      - name: Dependency vulnerability scan
        uses: snyk/actions/node@master
        continue-on-error: true
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          args: --severity-threshold=high
</file>

<file path=".github/workflows/security-scan.yml">
name: Security Scanning

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]
  schedule:
    # Run daily at 2 AM UTC
    - cron: '0 2 * * *'
  workflow_dispatch:

jobs:
  dependency-scan:
    name: Dependency Vulnerability Scan
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Run npm audit
        run: npm audit --audit-level=moderate
        continue-on-error: true
        
      - name: Snyk vulnerability scan
        uses: snyk/actions/node@master
        continue-on-error: true
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          args: --severity-threshold=medium --file=package.json
          
      - name: Upload Snyk results to GitHub Code Scanning
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: snyk.sarif

  sast-scan:
    name: Static Application Security Testing
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Initialize CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: javascript-typescript
          queries: security-extended,security-and-quality
          
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Build application
        run: npm run build
        
      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3
        
      - name: ESLint security scan
        run: npm run lint
        continue-on-error: true

  secret-scan:
    name: Secret Detection
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: TruffleHog OSS
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          base: main
          head: HEAD
          extra_args: --debug --only-verified

  license-scan:
    name: License Compliance
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: License check
        run: npx license-checker --summary --excludePrivatePackages
        continue-on-error: true
</file>

<file path=".github/CLAUDE.md">
# CI/CD & GitHub Workflows

# Workflow Structure
```
.github/
├── workflows/        # GitHub Actions workflows
├── templates/        # Issue and PR templates
├── CODEOWNERS       # Code review assignments
└── dependabot.yml   # Dependency updates
```

# Core Workflows

## Main Workflow (`ci.yml`)
```yaml
name: CI/CD Pipeline
on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'
      
      - run: npm ci
      - run: npm run lint
      - run: npm run type-check
      - run: npm run test:ci
      - run: npm run test:e2e
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
```

## Deployment Workflow (`deploy.yml`)
```yaml
name: Deploy
on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'
      
      - run: npm ci
      - run: npm run build
      
      - name: Deploy to Netlify
        uses: nwtgck/actions-netlify@v2
        with:
          publish-dir: './dist'
          production-branch: main
          github-token: ${{ secrets.GITHUB_TOKEN }}
          deploy-message: 'Deploy from GitHub Actions'
        env:
          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
          NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID }}
```

# Quality Gates
- All tests must pass (unit, integration, E2E)
- Code coverage must be ≥90%
- TypeScript compilation must succeed
- ESLint checks must pass
- No security vulnerabilities allowed

# Environment Variables
Store secrets in GitHub repository settings:
- `NETLIFY_AUTH_TOKEN`
- `NETLIFY_SITE_ID`
- `SUPABASE_SERVICE_ROLE_KEY`
- `STRIPE_WEBHOOK_SECRET`

# Branch Protection Rules
```yaml
main:
  required_status_checks:
    - ci/test
    - ci/build
    - ci/security-scan
  require_pull_request_reviews: true
  required_reviewers: 2
  dismiss_stale_reviews: true
  require_code_owner_reviews: true
```

# Pull Request Template
```markdown
## Description
Brief description of the changes

## Type of Change
- [ ] Bug fix
- [ ] New feature
- [ ] Breaking change
- [ ] Documentation update

## Testing
- [ ] Unit tests added/updated
- [ ] Integration tests added/updated
- [ ] E2E tests added/updated
- [ ] Manual testing completed

## Checklist
- [ ] Code follows style guidelines
- [ ] Self-review completed
- [ ] Comments added for complex code
- [ ] Documentation updated
- [ ] No secrets in code
```

# Security Scanning
```yaml
name: Security Scan
on: [push, pull_request]

jobs:
  security:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Run Snyk to check for vulnerabilities
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
```

# Performance Monitoring
```yaml
- name: Lighthouse CI
  uses: treosh/lighthouse-ci-action@v10
  with:
    configPath: './lighthouserc.js'
    uploadArtifacts: true
    temporaryPublicStorage: true
```

# Database Migration Workflow
```yaml
name: Database Migration
on:
  push:
    branches: [main]
    paths: ['supabase/migrations/**']

jobs:
  migrate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: supabase/setup-cli@v1
        with:
          version: latest
      
      - name: Apply migrations
        run: supabase db push
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
          SUPABASE_PROJECT_ID: ${{ secrets.SUPABASE_PROJECT_ID }}
```

# Code Quality Workflow
```yaml
name: Code Quality
on: [push, pull_request]

jobs:
  quality:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: SonarCloud Scan
        uses: SonarSource/sonarcloud-github-action@master
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
```

# Dependency Updates
```yaml
# dependabot.yml
version: 2
updates:
  - package-ecosystem: "npm"
    directory: "/"
    schedule:
      interval: "weekly"
    open-pull-requests-limit: 5
    reviewers:
      - "tech-team"
```

# CODEOWNERS File
```
# Global owners
* @tech-team

# Frontend specific
/src/components/ @frontend-team
/src/pages/ @frontend-team

# Backend specific
/supabase/ @backend-team
/src/integrations/ @backend-team

# DevOps specific
/.github/ @devops-team
/netlify.toml @devops-team
```

# Release Workflow
```yaml
name: Release
on:
  push:
    tags: ['v*']

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Create Release
        uses: actions/create-release@v1
        with:
          tag_name: ${{ github.ref }}
          release_name: Release ${{ github.ref }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

# Monitoring & Alerting
```yaml
- name: Slack Notification
  uses: 8398a7/action-slack@v3
  if: failure()
  with:
    status: ${{ job.status }}
    channel: '#deployments'
    webhook_url: ${{ secrets.SLACK_WEBHOOK }}
```

# DCE-Specific Workflows

## Call Volume Monitoring
```yaml
name: Monitor Call Volume
on:
  schedule:
    - cron: '*/15 * * * *'  # Every 15 minutes

jobs:
  monitor:
    runs-on: ubuntu-latest
    steps:
      - name: Check Call Volume
        run: |
          # Script to check call volume and alert if anomalies
```

## Fraud Detection Updates
```yaml
name: Update Fraud Models
on:
  schedule:
    - cron: '0 2 * * *'  # Daily at 2 AM

jobs:
  update-models:
    runs-on: ubuntu-latest
    steps:
      - name: Retrain fraud detection model
        run: |
          # Update fraud detection algorithms
```

# Environment Management
- **Development**: Auto-deploy on develop branch
- **Staging**: Auto-deploy on release branches
- **Production**: Manual deployment approval required

# Rollback Strategy
```yaml
- name: Rollback on Failure
  if: failure()
  run: |
    # Rollback to previous stable version
    netlify deploy --dir=dist --prod --alias=rollback
```

# Secrets Management
- Use GitHub Secrets for sensitive data
- Rotate secrets regularly
- Use different secrets per environment
- Never log secret values

# CRITICAL RULES
- NO secrets in workflow files or code
- ALL deployments must pass quality gates
- ALWAYS require code reviews for main branch
- NEVER deploy without testing
- ALWAYS use environment-specific configurations
- MONITOR deployment success/failure
- IMPLEMENT automated rollback on critical failures
- USE semantic versioning for releases
- SCAN for security vulnerabilities automatically
</file>

<file path=".github/README.md">
# GitHub Actions CI/CD Pipeline

This directory contains the CI/CD pipeline configuration for the DCE platform.

## Workflows

### PR Validation (`pr-validation.yml`)

- Runs on every pull request
- Executes: linting, type checking, tests, build, and security scans
- Must pass before merging

### Production Deployment (`deploy-production.yml`)

- Triggered on push to `main` branch
- Deploys to production environment
- Includes health checks and Sentry release tracking

### Staging Deployment (`deploy-staging.yml`)

- Triggered on push to `develop` branch
- Deploys to staging environment
- Runs smoke tests after deployment

### Security Scanning (`security-scan.yml`)

- Runs on push, PR, and daily schedule
- Includes:
  - Dependency vulnerability scanning (npm audit, Snyk)
  - Static Application Security Testing (CodeQL)
  - Secret detection (TruffleHog)
  - License compliance checks

## Required Secrets

Configure these in GitHub repository settings:

### Netlify

- `NETLIFY_AUTH_TOKEN`: Netlify authentication token
- `NETLIFY_SITE_ID`: Production site ID
- `NETLIFY_STAGING_SITE_ID`: Staging site ID

### Supabase

- `VITE_SUPABASE_URL`: Production Supabase URL
- `VITE_SUPABASE_ANON_KEY`: Production anonymous key
- `VITE_STAGING_SUPABASE_URL`: Staging Supabase URL
- `VITE_STAGING_SUPABASE_ANON_KEY`: Staging anonymous key

### Stripe

- `VITE_STRIPE_PUBLISHABLE_KEY`: Production publishable key
- `VITE_STAGING_STRIPE_PUBLISHABLE_KEY`: Staging publishable key

### Monitoring

- `VITE_SENTRY_DSN`: Production Sentry DSN
- `VITE_STAGING_SENTRY_DSN`: Staging Sentry DSN
- `SENTRY_AUTH_TOKEN`: Sentry authentication token
- `SENTRY_ORG`: Sentry organization slug
- `SENTRY_PROJECT`: Sentry project slug

### Security

- `SNYK_TOKEN`: Snyk authentication token
- `GITHUB_TOKEN`: Automatically provided by GitHub Actions

## Local Development

### Pre-commit Hooks

The project uses husky and lint-staged for pre-commit validation:

- ESLint fixes and formatting
- Prettier formatting
- TypeScript type checking

To skip pre-commit hooks (not recommended):

```bash
git commit --no-verify
```

### Running Workflows Locally

Test workflows locally using [act](https://github.com/nektos/act):

```bash
act pull_request  # Test PR validation
act push         # Test deployment workflows
```
</file>

<file path="public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="src/assets/CLAUDE.md">
# Asset Management

# Asset Structure

```
assets/
├── images/        # Static images
├── icons/         # SVG icons
├── fonts/         # Custom fonts
├── videos/        # Video files
└── data/          # Static JSON data
```

# Image Guidelines

- Use WebP format for photos (fallback to JPG)
- Use SVG for logos and icons
- Use PNG for images requiring transparency
- Optimize all images before committing

# Image Optimization

```bash
# Use these tools before adding images:
# - imageoptim (Mac)
# - squoosh.app (Web)
# - sharp-cli (Node.js)
```

# SVG Best Practices

- Remove unnecessary metadata
- Use currentColor for dynamic colors
- Optimize with SVGO
- Inline critical SVGs

```tsx
// Using SVG as React component
import { ReactComponent as Logo } from '@/assets/icons/logo.svg'

export function Header() {
  return <Logo className="h-8 w-8 text-primary" />
}
```

# Image Imports

```tsx
// Static imports for build optimization
import heroImage from '@/assets/images/hero.webp'
import heroImageFallback from '@/assets/images/hero.jpg'

// Use in component
;<picture>
  <source srcSet={heroImage} type="image/webp" />
  <img src={heroImageFallback} alt="Hero" />
</picture>
```

# Responsive Images

```tsx
// Define srcset for different screen sizes
const imageSizes = {
  small: '/assets/images/hero-400w.webp',
  medium: '/assets/images/hero-800w.webp',
  large: '/assets/images/hero-1200w.webp',
}

;<img
  srcSet={`
    ${imageSizes.small} 400w,
    ${imageSizes.medium} 800w,
    ${imageSizes.large} 1200w
  `}
  sizes="(max-width: 640px) 100vw, (max-width: 1024px) 50vw, 33vw"
  src={imageSizes.medium}
  alt="Responsive image"
/>
```

# Icon System

- Use Heroicons for UI icons
- Custom icons as SVG components
- Consistent 24x24 viewBox
- Support dark mode

```tsx
// Icon wrapper component
export function Icon({ name, className = 'h-6 w-6' }: IconProps) {
  const IconComponent = iconMap[name]
  return <IconComponent className={className} />
}
```

# Font Loading

```css
/* Use font-display: swap for performance */
@font-face {
  font-family: 'CustomFont';
  src: url('/assets/fonts/custom.woff2') format('woff2');
  font-weight: 400;
  font-display: swap;
}
```

# Static Data Files

```tsx
// Import JSON data
import campaignTypes from '@/assets/data/campaign-types.json'
import statesList from '@/assets/data/states.json'

// Type-safe imports
interface CampaignType {
  id: string
  name: string
  category: string
}

const typedCampaignTypes: CampaignType[] = campaignTypes
```

# Asset Loading Strategies

```tsx
// Lazy load non-critical images
const LazyImage = ({ src, alt }: ImageProps) => {
  return <img loading="lazy" src={src} alt={alt} decoding="async" />
}

// Preload critical assets
;<link rel="preload" as="image" href="/assets/images/hero.webp" />
```

# File Naming Conventions

- Lowercase with hyphens: `user-avatar.svg`
- Include dimensions: `hero-1920x1080.jpg`
- Version large files: `video-v2.mp4`
- Descriptive names: `call-tracking-dashboard.png`

# Asset Size Limits

- Images: Max 500KB (optimize larger)
- Icons: Max 5KB per SVG
- Videos: Use external CDN
- Total bundle: Monitor with build tools

# CDN Integration

```tsx
// Use CDN for large assets
const CDN_URL = import.meta.env.VITE_CDN_URL

export function getAssetUrl(path: string): string {
  if (import.meta.env.PROD) {
    return `${CDN_URL}${path}`
  }
  return path
}
```

# Dark Mode Assets

```tsx
// Provide dark mode variants
const logo = {
  light: '/assets/images/logo-light.svg',
  dark: '/assets/images/logo-dark.svg',
}

export function Logo() {
  const { theme } = useTheme()
  return <img src={logo[theme]} alt="Logo" />
}
```

# Performance Monitoring

```tsx
// Track asset loading performance
export function trackAssetPerformance() {
  window.addEventListener('load', () => {
    const resources = performance.getEntriesByType('resource')
    const images = resources.filter((r) => r.name.includes('/assets/images/'))

    images.forEach((img) => {
      if (img.duration > 1000) {
        console.warn(`Slow asset: ${img.name} (${img.duration}ms)`)
      }
    })
  })
}
```

# Build Optimization

- Vite automatically optimizes assets
- Use dynamic imports for large assets
- Enable compression in production
- Monitor bundle analyzer output

# DCE-Specific Assets

- Call tracking flow diagrams
- Campaign category icons
- User role badges
- Quality score indicators
- Fraud alert icons
- Payment method logos

# Asset Security

- Sanitize SVG uploads
- Validate file types
- Limit file sizes
- Use CSP headers for assets
- No sensitive data in filenames

# Testing Assets

```tsx
// Test asset loading
describe('Asset Loading', () => {
  it('should load critical images', async () => {
    const img = screen.getByAltText('Hero')
    await waitFor(() => {
      expect(img).toHaveAttribute('src')
      expect(img.complete).toBe(true)
    })
  })
})
```

# CRITICAL RULES

- NO unoptimized images in repository
- NO assets over 1MB without approval
- ALWAYS provide alt text for images
- ALWAYS optimize SVGs before use
- ALWAYS use appropriate format
- NEVER commit sensitive data in assets
- USE lazy loading for non-critical images
- MONITOR asset performance impact
- PROVIDE dark mode variants when needed
</file>

<file path="src/assets/react.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
</file>

<file path="src/components/layout/PublicLayout.tsx">
import { Outlet, Link } from 'react-router-dom'
import { useAuthStore } from '../../store/authStore'

export default function PublicLayout() {
  const { user } = useAuthStore()

  return (
    <div className="min-h-screen bg-gray-50">
      {/* Navigation */}
      <nav className="bg-white shadow-sm">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="flex justify-between items-center h-16">
            <div className="flex items-center">
              <Link to="/" className="text-2xl font-bold text-primary-600">
                DependableCalls
              </Link>
            </div>
            
            <div className="flex items-center space-x-4">
              <Link 
                to="/#features" 
                className="text-gray-700 hover:text-primary-600 px-3 py-2 rounded-md text-sm font-medium"
              >
                Features
              </Link>
              <Link 
                to="/#pricing" 
                className="text-gray-700 hover:text-primary-600 px-3 py-2 rounded-md text-sm font-medium"
              >
                Pricing
              </Link>
              <Link 
                to="/#about" 
                className="text-gray-700 hover:text-primary-600 px-3 py-2 rounded-md text-sm font-medium"
              >
                About
              </Link>
              
              {user ? (
                <Link 
                  to="/app/dashboard"
                  className="bg-primary-600 text-white hover:bg-primary-700 px-4 py-2 rounded-md text-sm font-medium"
                >
                  Dashboard
                </Link>
              ) : (
                <>
                  <Link 
                    to="/login"
                    className="text-gray-700 hover:text-primary-600 px-3 py-2 rounded-md text-sm font-medium"
                  >
                    Login
                  </Link>
                  <Link 
                    to="/register"
                    className="bg-primary-600 text-white hover:bg-primary-700 px-4 py-2 rounded-md text-sm font-medium"
                  >
                    Get Started
                  </Link>
                </>
              )}
            </div>
          </div>
        </div>
      </nav>

      {/* Main Content */}
      <main>
        <Outlet />
      </main>

      {/* Footer */}
      <footer className="bg-gray-800 text-white mt-20">
        <div className="max-w-7xl mx-auto px-4 py-12 sm:px-6 lg:px-8">
          <div className="grid grid-cols-1 md:grid-cols-4 gap-8">
            <div>
              <h3 className="text-2xl font-bold mb-4">DependableCalls</h3>
              <p className="text-gray-400">
                The most trusted pay-per-call network for quality lead generation.
              </p>
            </div>
            
            <div>
              <h4 className="text-lg font-semibold mb-4">Product</h4>
              <ul className="space-y-2">
                <li>
                  <Link to="/#features" className="text-gray-400 hover:text-white">
                    Features
                  </Link>
                </li>
                <li>
                  <Link to="/#pricing" className="text-gray-400 hover:text-white">
                    Pricing
                  </Link>
                </li>
                <li>
                  <Link to="/blog" className="text-gray-400 hover:text-white">
                    Blog
                  </Link>
                </li>
              </ul>
            </div>
            
            <div>
              <h4 className="text-lg font-semibold mb-4">Company</h4>
              <ul className="space-y-2">
                <li>
                  <Link to="/about" className="text-gray-400 hover:text-white">
                    About Us
                  </Link>
                </li>
                <li>
                  <Link to="/contact" className="text-gray-400 hover:text-white">
                    Contact
                  </Link>
                </li>
                <li>
                  <Link to="/careers" className="text-gray-400 hover:text-white">
                    Careers
                  </Link>
                </li>
              </ul>
            </div>
            
            <div>
              <h4 className="text-lg font-semibold mb-4">Legal</h4>
              <ul className="space-y-2">
                <li>
                  <Link to="/privacy" className="text-gray-400 hover:text-white">
                    Privacy Policy
                  </Link>
                </li>
                <li>
                  <Link to="/terms" className="text-gray-400 hover:text-white">
                    Terms of Service
                  </Link>
                </li>
                <li>
                  <Link to="/compliance" className="text-gray-400 hover:text-white">
                    Compliance
                  </Link>
                </li>
              </ul>
            </div>
          </div>
          
          <div className="mt-8 pt-8 border-t border-gray-700 text-center text-gray-400">
            <p>&copy; {new Date().getFullYear()} DependableCalls. All rights reserved.</p>
          </div>
        </div>
      </footer>
    </div>
  )
}
</file>

<file path="src/components/CLAUDE.md">
# Component Patterns

# Naming Conventions
- PascalCase for components: `UserProfile`, `CallTracker`
- camelCase for props: `isLoading`, `onCallEnd`
- kebab-case for CSS classes: `call-status`, `user-card`

# File Structure
```
ComponentName/
├── index.tsx          # Main component
├── ComponentName.tsx  # Alternative: direct export
├── types.ts          # Component-specific types
└── __tests__/        # Component tests
```

# TypeScript Requirements
- ALL props interfaces: `interface ComponentNameProps {}`
- NO any types - use proper typing
- Export prop types for reuse
- Use generic types for flexible components

# Component Template
```tsx
interface ComponentProps {
  title: string;
  isActive?: boolean;
  onAction: (id: string) => void;
}

export function ComponentName({ 
  title, 
  isActive = false, 
  onAction 
}: ComponentProps) {
  return (
    <div className="component-wrapper">
      {/* Component content */}
    </div>
  );
}
```

# Styling Guidelines
- Tailwind CSS classes only
- Use Headless UI for complex interactions
- Heroicons for all icons
- Mobile-first responsive design
- Dark mode support via CSS variables

# State Management
- Local state: `useState` for component-only data
- Global state: Zustand stores for shared data
- Server state: React Query for API data
- Forms: React Hook Form + Zod validation

# Accessibility Requirements
- ARIA labels on interactive elements
- Keyboard navigation support
- Screen reader compatibility
- Focus management for modals/dropdowns

# Testing Requirements
- Unit tests for all logic
- Component tests with Testing Library
- Snapshot tests for UI stability
- Accessibility tests with axe

# Performance Patterns
- React.memo for expensive renders
- useMemo for calculated values
- useCallback for event handlers
- Lazy loading for large components

# DCE-Specific Patterns
- Call status indicators with real-time updates
- Fraud detection UI components
- Supplier/Buyer role-based rendering
- Campaign management interfaces

# CRITICAL RULES
- NO regex in components
- NO any types allowed
- ALWAYS handle loading/error states
- ALWAYS validate props with TypeScript
</file>

<file path="src/hooks/CLAUDE.md">
# Custom Hook Patterns

# Naming Conventions
- ALL hooks start with "use": `useAuth`, `useApi`, `useCampaign`
- Be descriptive: `useRealTimeCallTracking` vs `useRealTime`
- Group related hooks: `useAuth`, `useAuthActions`, `useAuthState`

# File Structure
```
hooks/
├── useAuth.ts          # Authentication hooks
├── useApi.ts           # API data fetching
├── useLocalStorage.ts  # Browser storage
├── useRealtime.ts      # Supabase real-time
├── useForm.ts          # Form management
├── useStripe.ts        # Payment processing
├── useCampaign.ts      # Campaign management
├── useCall.ts          # Call tracking
└── index.ts            # Hook exports
```

# Basic Hook Template
```tsx
import { useState, useEffect } from 'react';

interface UseHookResult<T> {
  data: T | null;
  loading: boolean;
  error: string | null;
}

export function useHookName<T>(params: HookParams): UseHookResult<T> {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  useEffect(() => {
    // Hook logic here
  }, [/* dependencies */]);
  
  return { data, loading, error };
}
```

# API Data Fetching Hooks
```tsx
import { useQuery } from '@tanstack/react-query';
import { fetchUser } from '@/lib/api';

export function useUser(userId: string) {
  return useQuery({
    queryKey: ['user', userId],
    queryFn: () => fetchUser(userId),
    enabled: !!userId,
  });
}

// Mutation hook
export function useUpdateUser() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: updateUser,
    onSuccess: (user) => {
      queryClient.setQueryData(['user', user.id], user);
      queryClient.invalidateQueries({ queryKey: ['users'] });
    },
  });
}
```

# Authentication Hooks
```tsx
export function useAuth() {
  const user = useAuthStore(state => state.user);
  const isAuthenticated = useAuthStore(state => state.isAuthenticated);
  const login = useAuthStore(state => state.login);
  const logout = useAuthStore(state => state.logout);
  
  return {
    user,
    isAuthenticated,
    login,
    logout,
    isSupplier: user?.role === 'supplier',
    isBuyer: user?.role === 'buyer',
    isAdmin: user?.role === 'admin',
  };
}
```

# Real-time Data Hooks
```tsx
export function useRealTimeCall(callId: string) {
  const [call, setCall] = useState<Call | null>(null);
  
  useEffect(() => {
    if (!callId) return;
    
    const channel = supabase
      .channel(`call-${callId}`)
      .on('postgres_changes', {
        event: 'UPDATE',
        schema: 'public',
        table: 'calls',
        filter: `id=eq.${callId}`,
      }, (payload) => {
        setCall(payload.new as Call);
      })
      .subscribe();
    
    return () => {
      supabase.removeChannel(channel);
    };
  }, [callId]);
  
  return call;
}
```

# Form Hooks
```tsx
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { loginSchema, type LoginFormData } from '@/types/auth';

export function useLoginForm() {
  const { login } = useAuth();
  
  const form = useForm<LoginFormData>({
    resolver: zodResolver(loginSchema),
    defaultValues: {
      email: '',
      password: '',
    },
  });
  
  const onSubmit = async (data: LoginFormData) => {
    try {
      await login(data.email, data.password);
    } catch (error) {
      form.setError('root', {
        message: handleApiError(error),
      });
    }
  };
  
  return {
    ...form,
    onSubmit: form.handleSubmit(onSubmit),
  };
}
```

# Local Storage Hooks
```tsx
export function useLocalStorage<T>(
  key: string,
  initialValue: T
): [T, (value: T | ((prev: T) => T)) => void] {
  const [storedValue, setStoredValue] = useState<T>(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(`Error reading localStorage key "${key}":`, error);
      return initialValue;
    }
  });
  
  const setValue = (value: T | ((prev: T) => T)) => {
    try {
      const valueToStore = value instanceof Function 
        ? value(storedValue) 
        : value;
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(`Error setting localStorage key "${key}":`, error);
    }
  };
  
  return [storedValue, setValue];
}
```

# Performance Optimization Hooks
```tsx
import { useMemo, useCallback } from 'react';

export function useOptimizedData<T>(
  data: T[],
  filterFn: (item: T) => boolean,
  sortFn: (a: T, b: T) => number
) {
  const filteredAndSorted = useMemo(() => {
    return data.filter(filterFn).sort(sortFn);
  }, [data, filterFn, sortFn]);
  
  return filteredAndSorted;
}

// Debounced value hook
export function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState(value);
  
  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);
    
    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);
  
  return debouncedValue;
}
```

# DCE-Specific Hooks

## Campaign Management
```tsx
export function useCampaignStats(campaignId: string) {
  return useQuery({
    queryKey: ['campaign-stats', campaignId],
    queryFn: () => fetchCampaignStats(campaignId),
    refetchInterval: 30000, // Refresh every 30 seconds
  });
}
```

## Call Tracking
```tsx
export function useActiveCallCount() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    const channel = supabase
      .channel('active-calls')
      .on('postgres_changes', {
        event: '*',
        schema: 'public',
        table: 'calls',
        filter: 'status=eq.active',
      }, () => {
        // Refetch active call count
        fetchActiveCallCount().then(setCount);
      })
      .subscribe();
    
    return () => supabase.removeChannel(channel);
  }, []);
  
  return count;
}
```

# Error Handling in Hooks
```tsx
export function useApiWithErrorHandling<T>(
  fetcher: () => Promise<T>
) {
  const [state, setState] = useState<{
    data: T | null;
    loading: boolean;
    error: string | null;
  }>({
    data: null,
    loading: false,
    error: null,
  });
  
  const execute = useCallback(async () => {
    setState(prev => ({ ...prev, loading: true, error: null }));
    
    try {
      const data = await fetcher();
      setState({ data, loading: false, error: null });
    } catch (error) {
      setState(prev => ({
        ...prev,
        loading: false,
        error: handleApiError(error),
      }));
    }
  }, [fetcher]);
  
  return { ...state, execute };
}
```

# Testing Custom Hooks
```tsx
import { renderHook, act } from '@testing-library/react';
import { useLocalStorage } from './useLocalStorage';

describe('useLocalStorage', () => {
  beforeEach(() => {
    localStorage.clear();
  });
  
  it('should return initial value', () => {
    const { result } = renderHook(() => 
      useLocalStorage('test-key', 'initial')
    );
    
    expect(result.current[0]).toBe('initial');
  });
  
  it('should update value', () => {
    const { result } = renderHook(() => 
      useLocalStorage('test-key', 'initial')
    );
    
    act(() => {
      result.current[1]('updated');
    });
    
    expect(result.current[0]).toBe('updated');
  });
});
```

# CRITICAL RULES
- NO regex in custom hooks
- NO any types in hook parameters or returns
- ALWAYS handle cleanup in useEffect
- ALWAYS provide proper TypeScript types
- ALWAYS handle error states explicitly
- USE useCallback for functions returned from hooks
- USE useMemo for expensive calculations
- TEST all custom hooks thoroughly
- FOLLOW React hooks rules (no conditional hooks)
</file>

<file path="src/integrations/fraud/blocking.ts">
import { supabase } from '../../lib/supabase'
import type { BlockingRule, UnifiedFraudScore } from './types'

export class AutoBlockingService {
  private blockingThreshold = 85 // Auto-block threshold
  private temporaryBlockDuration = 24 * 60 * 60 * 1000 // 24 hours in ms

  async checkBlocked(type: 'phone' | 'ip' | 'email', value: string): Promise<BlockingRule | null> {
    try {
      const { data, error } = await supabase
        .from('blocking_rules')
        .select('*')
        .eq('type', type)
        .eq('value', value)
        .or('expires_at.is.null,expires_at.gt.now()')
        .single()

      if (error && error.code !== 'PGRST116') {
        // Not found error
        console.error('Error checking blocking rule:', error)
        return null
      }

      if (data) {
        return {
          id: data.id,
          type: data.type,
          value: data.value,
          reason: data.reason,
          createdAt: new Date(data.created_at),
          expiresAt: data.expires_at ? new Date(data.expires_at) : undefined,
          autoBlocked: data.auto_blocked,
        }
      }

      return null
    } catch (error) {
      console.error('Error in checkBlocked:', error)
      return null
    }
  }

  async createBlockingRule(
    type: 'phone' | 'ip' | 'email' | 'pattern',
    value: string,
    reason: string,
    temporary: boolean = false,
    autoBlocked: boolean = true
  ): Promise<BlockingRule | null> {
    try {
      const expiresAt = temporary ? new Date(Date.now() + this.temporaryBlockDuration) : null

      const { data, error } = await supabase
        .from('blocking_rules')
        .insert({
          type,
          value,
          reason,
          expires_at: expiresAt,
          auto_blocked: autoBlocked,
        })
        .select()
        .single()

      if (error) {
        console.error('Error creating blocking rule:', error)
        return null
      }

      return {
        id: data.id,
        type: data.type,
        value: data.value,
        reason: data.reason,
        createdAt: new Date(data.created_at),
        expiresAt: data.expires_at ? new Date(data.expires_at) : undefined,
        autoBlocked: data.auto_blocked,
      }
    } catch (error) {
      console.error('Error in createBlockingRule:', error)
      return null
    }
  }

  async removeBlockingRule(id: string): Promise<boolean> {
    try {
      const { error } = await supabase.from('blocking_rules').delete().eq('id', id)

      if (error) {
        console.error('Error removing blocking rule:', error)
        return false
      }

      return true
    } catch (error) {
      console.error('Error in removeBlockingRule:', error)
      return false
    }
  }

  async processAutoBlocking(
    fraudScore: UnifiedFraudScore,
    request: {
      phone?: string
      ip?: string
      email?: string
    }
  ): Promise<void> {
    // Only auto-block if score exceeds threshold
    if (fraudScore.overallScore < this.blockingThreshold) {
      return
    }

    const blockingPromises: Promise<BlockingRule | null>[] = []

    // Block phone if it contributed significantly to high score
    if (request.phone && fraudScore.phoneScore && fraudScore.phoneScore >= 70) {
      const reason =
        fraudScore.reasons.filter((r) => r.toLowerCase().includes('phone')).join(', ') ||
        'High fraud score on phone verification'

      blockingPromises.push(this.createBlockingRule('phone', request.phone, reason, true))
    }

    // Block IP if it's high risk
    if (request.ip && fraudScore.ipScore && fraudScore.ipScore >= 80) {
      const reason =
        fraudScore.reasons
          .filter(
            (r) =>
              r.toLowerCase().includes('ip') ||
              r.toLowerCase().includes('proxy') ||
              r.toLowerCase().includes('vpn') ||
              r.toLowerCase().includes('tor')
          )
          .join(', ') || 'High risk IP address'

      blockingPromises.push(this.createBlockingRule('ip', request.ip, reason, true))
    }

    // Block email if flagged
    if (
      request.email &&
      fraudScore.reasons.some(
        (r) =>
          r.toLowerCase().includes('email') ||
          r.toLowerCase().includes('disposable') ||
          r.toLowerCase().includes('blacklisted')
      )
    ) {
      const reason =
        fraudScore.reasons.filter((r) => r.toLowerCase().includes('email')).join(', ') ||
        'Suspicious email address'

      blockingPromises.push(this.createBlockingRule('email', request.email, reason, false))
    }

    // Execute all blocking operations
    await Promise.allSettled(blockingPromises)
  }

  async listActiveBlocks(type?: 'phone' | 'ip' | 'email' | 'pattern'): Promise<BlockingRule[]> {
    try {
      let query = supabase
        .from('blocking_rules')
        .select('*')
        .or('expires_at.is.null,expires_at.gt.now()')
        .order('created_at', { ascending: false })

      if (type) {
        query = query.eq('type', type)
      }

      const { data, error } = await query

      if (error) {
        console.error('Error listing blocking rules:', error)
        return []
      }

      return data.map((rule) => ({
        id: rule.id,
        type: rule.type,
        value: rule.value,
        reason: rule.reason,
        createdAt: new Date(rule.created_at),
        expiresAt: rule.expires_at ? new Date(rule.expires_at) : undefined,
        autoBlocked: rule.auto_blocked,
      }))
    } catch (error) {
      console.error('Error in listActiveBlocks:', error)
      return []
    }
  }

  async cleanupExpiredRules(): Promise<number> {
    try {
      const { data, error } = await supabase
        .from('blocking_rules')
        .delete()
        .lt('expires_at', new Date().toISOString())
        .select()

      if (error) {
        console.error('Error cleaning up expired rules:', error)
        return 0
      }

      return data?.length || 0
    } catch (error) {
      console.error('Error in cleanupExpiredRules:', error)
      return 0
    }
  }

  // Pattern matching for advanced blocking
  async checkPatternBlock(value: string, type: 'phone' | 'ip' | 'email'): Promise<boolean> {
    try {
      const { data, error } = await supabase
        .from('blocking_rules')
        .select('value')
        .eq('type', 'pattern')
        .or('expires_at.is.null,expires_at.gt.now()')

      if (error || !data) {
        return false
      }

      // Check if value matches any patterns
      for (const rule of data) {
        if (this.matchesPattern(value, rule.value, type)) {
          return true
        }
      }

      return false
    } catch (error) {
      console.error('Error in checkPatternBlock:', error)
      return false
    }
  }

  private matchesPattern(value: string, pattern: string, type: string): boolean {
    // Simple pattern matching without regex
    switch (type) {
      case 'phone':
        // Check for area code patterns (e.g., "+1555*")
        if (pattern.endsWith('*')) {
          const prefix = pattern.slice(0, -1)
          return value.startsWith(prefix)
        }
        break

      case 'ip':
        // Check for IP range patterns (e.g., "192.168.*")
        if (pattern.includes('*')) {
          const parts = pattern.split('.')
          const valueParts = value.split('.')

          for (let i = 0; i < parts.length; i++) {
            if (parts[i] !== '*' && parts[i] !== valueParts[i]) {
              return false
            }
          }
          return true
        }
        break

      case 'email':
        // Check for domain patterns (e.g., "*@spam.com")
        if (pattern.startsWith('*@')) {
          const domain = pattern.slice(2)
          return value.endsWith(`@${domain}`)
        }
        break
    }

    return value === pattern
  }
}

// Export singleton instance
export const autoBlockingService = new AutoBlockingService()
</file>

<file path="src/integrations/fraud/fraudlabs.ts">
import axios from 'axios'
import { fraudConfig } from './config'
import type { TransactionScreeningResult, FraudCheckRequest } from './types'

export class FraudLabsClient {
  private client = axios.create({
    baseURL: fraudConfig.fraudlabs.baseUrl,
    timeout: fraudConfig.fraudlabs.timeout,
  })

  async screenTransaction(request: FraudCheckRequest): Promise<TransactionScreeningResult> {
    try {
      const response = await this.client.post('/screen', {
        key: fraudConfig.fraudlabs.apiKey,
        format: 'json',
        ip: request.ip,
        email: request.email,
        phone: request.phone,
        amount: request.amount,
        currency: request.currency || 'USD',
        user_order_id: request.campaignId,
        user_order_memo: request.userId,
        // Additional parameters for better fraud detection
        payment_mode: 'creditcard',
        flp_checksum: '',
      })

      const data = response.data

      // Parse the fraud score
      const fraudScore = parseFloat(data.fraudlabspro_score) || 0

      // Determine status based on score and rules
      const status = this.determineStatus(fraudScore, data)

      // Extract triggered rules
      const rules = this.extractTriggeredRules(data)

      // Build risk factors
      const riskFactors = {
        ip: data.ip_address,
        email: data.email_address,
        phone: data.phone_number,
        billing: data.billing_address,
        shipping: data.shipping_address,
      }

      return {
        fraudScore,
        status,
        rules,
        riskFactors,
      }
    } catch (error) {
      console.error('FraudLabs screening error:', error)

      if (axios.isAxiosError(error)) {
        return {
          fraudScore: 0,
          status: 'review',
          rules: [],
          riskFactors: {},
          error: `Transaction screening failed: ${error.response?.data?.message || error.message}`,
        }
      }

      return {
        fraudScore: 0,
        status: 'review',
        rules: [],
        riskFactors: {},
        error: 'Transaction screening service unavailable',
      }
    }
  }

  private determineStatus(
    score: number,
    data: Record<string, unknown>
  ): 'approve' | 'review' | 'reject' {
    // Check if FraudLabs already made a decision
    const flpStatus = String(data.fraudlabspro_status || '').toLowerCase()

    if (flpStatus === 'approve') return 'approve'
    if (flpStatus === 'reject') return 'reject'
    if (flpStatus === 'review') return 'review'

    // Otherwise, use score-based decision
    if (score >= 90) return 'reject'
    if (score >= 60) return 'review'
    return 'approve'
  }

  private extractTriggeredRules(data: Record<string, unknown>): string[] {
    const rules: string[] = []

    // Check various risk indicators
    const riskIndicators = [
      { field: 'is_proxy_ip', message: 'Proxy IP detected' },
      { field: 'is_free_email', message: 'Free email provider' },
      { field: 'is_disposable_email', message: 'Disposable email detected' },
      { field: 'is_new_domain_name', message: 'Newly registered domain' },
      { field: 'is_phone_blacklisted', message: 'Phone number blacklisted' },
      { field: 'is_email_blacklisted', message: 'Email blacklisted' },
      { field: 'is_high_risk_country', message: 'High risk country' },
      { field: 'is_ip_country_mismatch', message: 'IP country mismatch' },
      { field: 'is_phone_country_mismatch', message: 'Phone country mismatch' },
    ]

    for (const indicator of riskIndicators) {
      if (data[indicator.field] === 'Y' || data[indicator.field] === true) {
        rules.push(indicator.message)
      }
    }

    // Check velocity rules
    if (Number(data.ip_velocity) > 5) {
      rules.push(`High IP velocity: ${data.ip_velocity} orders`)
    }
    if (Number(data.email_velocity) > 5) {
      rules.push(`High email velocity: ${data.email_velocity} orders`)
    }

    // Check credit usage
    if (Number(data.remaining_credits) < 100) {
      console.warn('FraudLabs Pro credits running low:', data.remaining_credits)
    }

    return rules
  }

  // Utility methods
  async quickCheck(ip: string, email: string): Promise<number> {
    const result = await this.screenTransaction({ ip, email })
    return result.fraudScore
  }

  async isBlacklisted(email?: string, phone?: string): Promise<boolean> {
    if (!email && !phone) return false

    const result = await this.screenTransaction({ email, phone })
    return result.rules.some((rule) => rule.includes('blacklisted') || rule.includes('blocked'))
  }

  async checkEmailReputation(email: string): Promise<{
    isFree: boolean
    isDisposable: boolean
    isValid: boolean
  }> {
    const result = await this.screenTransaction({ email })

    // Extract email-specific indicators from the response
    const isFree = result.rules.includes('Free email provider')
    const isDisposable = result.rules.includes('Disposable email detected')
    const isValid = !result.error && result.fraudScore < 80

    return { isFree, isDisposable, isValid }
  }
}

// Export singleton instance
export const fraudLabsClient = new FraudLabsClient()
</file>

<file path="src/integrations/fraud/ipquality.ts">
import axios from 'axios'
import { fraudConfig } from './config'
import type { IPReputationResult } from './types'

export class IPQualityClient {
  private client = axios.create({
    baseURL: fraudConfig.ipquality.baseUrl,
    timeout: fraudConfig.ipquality.timeout,
  })

  async checkIPReputation(ipAddress: string): Promise<IPReputationResult> {
    try {
      const response = await this.client.get(`/ip/${fraudConfig.ipquality.apiKey}/${ipAddress}`, {
        params: {
          strictness: 1, // Medium strictness level
          user_agent: '', // Optional user agent
          user_language: 'en-US', // Optional language
          fast: false, // Perform full check
          mobile: true, // Check mobile networks
          allow_public_access_points: false,
          lighter_penalties: false,
        },
      })

      const data = response.data

      // Calculate fraud score based on multiple factors
      const fraudScore = this.calculateFraudScore(data)

      return {
        fraudScore,
        countryCode: data.country_code,
        region: data.region,
        city: data.city,
        isp: data.ISP,
        proxy: data.proxy || false,
        vpn: data.vpn || false,
        tor: data.tor || false,
        recentAbuse: data.recent_abuse || false,
        botStatus: data.bot_status || false,
      }
    } catch (error) {
      console.error('IPQuality check error:', error)

      if (axios.isAxiosError(error)) {
        return {
          fraudScore: 0,
          error: `IP reputation check failed: ${error.response?.data?.message || error.message}`,
        }
      }

      return {
        fraudScore: 0,
        error: 'IP reputation service unavailable',
      }
    }
  }

  private calculateFraudScore(data: Record<string, unknown>): number {
    let score = Number(data.fraud_score) || 0

    // Additional factors that increase fraud risk
    const riskFactors = [
      { condition: data.proxy === true, penalty: 20 },
      { condition: data.vpn === true, penalty: 15 },
      { condition: data.tor === true, penalty: 30 },
      { condition: data.recent_abuse === true, penalty: 25 },
      { condition: data.bot_status === true, penalty: 20 },
      { condition: data.active_vpn === true, penalty: 15 },
      { condition: data.active_tor === true, penalty: 30 },
      { condition: data.mobile === true && data.connection_type === 'Premium', penalty: 10 },
    ]

    // Apply penalties
    for (const factor of riskFactors) {
      if (factor.condition) {
        score = Math.min(100, score + factor.penalty)
      }
    }

    // Reduce score for positive indicators
    const positiveFactors = [
      { condition: data.success === true, bonus: -5 },
      { condition: data.timezone && data.timezone === 'America/New_York', bonus: -5 },
      { condition: Number(data.abuse_velocity) < 1, bonus: -10 },
    ]

    // Apply bonuses
    for (const factor of positiveFactors) {
      if (factor.condition) {
        score = Math.max(0, score + factor.bonus)
      }
    }

    return Math.round(score)
  }

  // Utility methods
  async isHighRiskIP(ipAddress: string): Promise<boolean> {
    const result = await this.checkIPReputation(ipAddress)
    return result.fraudScore >= 75
  }

  async isProxyOrVPN(ipAddress: string): Promise<boolean> {
    const result = await this.checkIPReputation(ipAddress)
    return !!(result.proxy || result.vpn || result.tor)
  }

  async getIPLocation(ipAddress: string): Promise<{
    country?: string
    region?: string
    city?: string
  }> {
    const result = await this.checkIPReputation(ipAddress)
    return {
      country: result.countryCode,
      region: result.region,
      city: result.city,
    }
  }
}

// Export singleton instance
export const ipQualityClient = new IPQualityClient()
</file>

<file path="src/integrations/fraud/maxmind.ts">
import axios from 'axios'
import { fraudConfig } from './config'
import type { MaxMindGeoResult } from './types'

export class MaxMindClient {
  private client = axios.create({
    baseURL: fraudConfig.maxmind.baseUrl,
    timeout: fraudConfig.maxmind.timeout,
    auth: {
      username: fraudConfig.maxmind.apiKey,
      password: '', // MaxMind uses account ID as username and license key as password
    },
    headers: {
      Accept: 'application/json',
    },
  })

  async checkIPLocation(ipAddress: string): Promise<MaxMindGeoResult> {
    try {
      // Get both insights and country data
      const [insightsResponse, countryResponse] = await Promise.allSettled([
        this.getInsights(ipAddress),
        this.getCountry(ipAddress),
      ])

      let insightsData: Record<string, unknown> = {}
      let countryData: Record<string, unknown> = {}

      if (insightsResponse.status === 'fulfilled') {
        insightsData = insightsResponse.value.data as Record<string, unknown>
      }

      if (countryResponse.status === 'fulfilled') {
        countryData = countryResponse.value.data as Record<string, unknown>
      }

      return this.processGeoData(insightsData, countryData)
    } catch (error) {
      console.error('MaxMind GeoIP check error:', error)

      if (axios.isAxiosError(error)) {
        return {
          fraudScore: 0,
          riskLevel: 'low',
          error: `MaxMind check failed: ${error.response?.data?.error || error.message}`,
        }
      }

      return {
        fraudScore: 0,
        riskLevel: 'low',
        error: 'MaxMind GeoIP service unavailable',
      }
    }
  }

  private async getInsights(ip: string): Promise<{ data: unknown }> {
    return this.client.get(`/insights/${ip}`)
  }

  private async getCountry(ip: string): Promise<{ data: unknown }> {
    return this.client.get(`/country/${ip}`)
  }

  private processGeoData(
    insights: Record<string, unknown>,
    country: Record<string, unknown>
  ): MaxMindGeoResult {
    // Extract location data
    const countryInfo = (insights.country || country.country || {}) as Record<string, unknown>
    const city = (insights.city as Record<string, unknown>) || {}
    const location = (insights.location as Record<string, unknown>) || {}
    const traits = (insights.traits as Record<string, unknown>) || {}

    const countryCode = countryInfo.iso_code as string
    const region = (city.names as Record<string, unknown>)?.en as string
    const cityName = (city.names as Record<string, unknown>)?.en as string

    // Extract risk indicators
    const riskScore = Number(traits.risk_score) || 0
    const isAnonymousProxy = Boolean(traits.is_anonymous_proxy)
    const isSatelliteProvider = Boolean(traits.is_satellite_provider)
    const userType = traits.user_type as string

    // Calculate fraud score based on various factors
    let fraudScore = riskScore * 10 // MaxMind risk score is 0-10, convert to 0-100

    // Apply additional risk factors
    const riskFactors = [
      { condition: isAnonymousProxy, penalty: 30 },
      { condition: isSatelliteProvider, penalty: 15 },
      { condition: userType === 'hosting', penalty: 20 },
      { condition: userType === 'cellular', penalty: 5 },
      { condition: this.isHighRiskCountry(countryCode), penalty: 25 },
      { condition: Number(location.accuracy_radius) > 1000, penalty: 10 },
    ]

    for (const factor of riskFactors) {
      if (factor.condition) {
        fraudScore = Math.min(100, fraudScore + factor.penalty)
      }
    }

    // Determine risk level
    let riskLevel: 'low' | 'medium' | 'high' = 'low'
    if (fraudScore >= 70) {
      riskLevel = 'high'
    } else if (fraudScore >= 40) {
      riskLevel = 'medium'
    }

    return {
      fraudScore: Math.round(fraudScore),
      countryCode,
      region,
      city: cityName,
      riskLevel,
      isVpn: userType === 'hosting' || isAnonymousProxy,
      isProxy: isAnonymousProxy,
      isp: traits.isp as string,
      accuracyRadius: Number(location.accuracy_radius),
    }
  }

  private isHighRiskCountry(countryCode?: string): boolean {
    // List of countries commonly associated with higher fraud risk
    const highRiskCountries = [
      'CN',
      'RU',
      'NG',
      'PK',
      'BD',
      'ID',
      'VN',
      'IN',
      'MY',
      'TH',
      'PH',
      'EG',
      'MA',
      'RO',
      'BG',
      'UA',
    ]

    return countryCode ? highRiskCountries.includes(countryCode) : false
  }

  // Utility methods
  async isVpnOrProxy(ipAddress: string): Promise<boolean> {
    const result = await this.checkIPLocation(ipAddress)
    return !!(result.isVpn || result.isProxy)
  }

  async getCountryRisk(ipAddress: string): Promise<{
    country?: string
    riskLevel: 'low' | 'medium' | 'high'
  }> {
    const result = await this.checkIPLocation(ipAddress)
    return {
      country: result.countryCode,
      riskLevel: result.riskLevel,
    }
  }

  async validateIPLocation(
    ipAddress: string,
    expectedCountry: string
  ): Promise<{
    matches: boolean
    actualCountry?: string
    distance?: number
  }> {
    const result = await this.checkIPLocation(ipAddress)

    const matches = result.countryCode === expectedCountry.toUpperCase()

    return {
      matches,
      actualCountry: result.countryCode,
      distance: result.accuracyRadius,
    }
  }

  async detectAnomalousLocation(
    ipAddress: string,
    previousLocations: Array<{ country: string; timestamp: Date }>
  ): Promise<{
    isAnomalous: boolean
    reason?: string
    newLocation?: string
  }> {
    const result = await this.checkIPLocation(ipAddress)

    if (result.error || !result.countryCode) {
      return { isAnomalous: false }
    }

    // Check for rapid location changes
    const recentLocations = previousLocations.filter(
      (loc) => Date.now() - loc.timestamp.getTime() < 24 * 60 * 60 * 1000 // Last 24 hours
    )

    const uniqueCountries = new Set(recentLocations.map((loc) => loc.country))

    if (uniqueCountries.size > 3 && !uniqueCountries.has(result.countryCode)) {
      return {
        isAnomalous: true,
        reason: 'Multiple countries accessed within 24 hours',
        newLocation: result.countryCode,
      }
    }

    // Check for impossible travel
    const lastLocation = recentLocations[recentLocations.length - 1]
    if (lastLocation && lastLocation.country !== result.countryCode) {
      const timeDiff = Date.now() - lastLocation.timestamp.getTime()
      const hoursDiff = timeDiff / (1000 * 60 * 60)

      // If location changed in less than 2 hours, flag as suspicious
      if (hoursDiff < 2) {
        return {
          isAnomalous: true,
          reason: 'Impossible travel time between locations',
          newLocation: result.countryCode,
        }
      }
    }

    return { isAnomalous: false, newLocation: result.countryCode }
  }
}

// Export singleton instance
export const maxMindClient = new MaxMindClient()
</file>

<file path="src/integrations/fraud/sift.ts">
import axios from 'axios'
import { fraudConfig } from './config'
import type { SiftFraudResult, FraudCheckRequest } from './types'

export class SiftClient {
  private client = axios.create({
    baseURL: fraudConfig.sift.baseUrl,
    timeout: fraudConfig.sift.timeout,
    headers: {
      'Content-Type': 'application/json',
    },
  })

  async screenTransaction(request: FraudCheckRequest): Promise<SiftFraudResult> {
    try {
      // Create user if needed and send events
      if (request.userId) {
        await this.sendUserEvent(request)
      }

      // Send transaction event for payment fraud detection
      if (request.amount) {
        await this.sendTransactionEvent(request)
      }

      // Get fraud score
      const scoreResponse = await this.getScore(request.userId || 'anonymous')

      return this.processScoreResponse(scoreResponse.data as Record<string, unknown>)
    } catch (error) {
      console.error('Sift fraud check error:', error)

      if (axios.isAxiosError(error)) {
        return {
          fraudScore: 0,
          status: 'review',
          reasons: [],
          error: `Sift screening failed: ${error.response?.data?.message || error.message}`,
        }
      }

      return {
        fraudScore: 0,
        status: 'review',
        reasons: [],
        error: 'Sift fraud detection service unavailable',
      }
    }
  }

  private async sendUserEvent(request: FraudCheckRequest): Promise<void> {
    const eventData = {
      $type: '$create_account',
      $api_key: fraudConfig.sift.apiKey,
      $user_id: request.userId,
      $session_id: this.generateSessionId(),
      $ip: request.ip,
      $user_email: request.email,
      $phone: request.phone,
      $time: Math.floor(Date.now() / 1000),
      // Additional context
      $brand_name: 'DependableCalls',
      $site_country: 'US',
      $site_domain: 'dependablecalls.com',
    }

    await this.client.post('/events', eventData)
  }

  private async sendTransactionEvent(request: FraudCheckRequest): Promise<void> {
    const eventData = {
      $type: '$transaction',
      $api_key: fraudConfig.sift.apiKey,
      $user_id: request.userId || 'anonymous',
      $session_id: this.generateSessionId(),
      $ip: request.ip,
      $time: Math.floor(Date.now() / 1000),
      $amount: Math.round((request.amount || 0) * 1000000), // Convert to micros
      $currency_code: request.currency || 'USD',
      $transaction_type: '$sale',
      $transaction_status: '$pending',
      $order_id: request.campaignId,
      // Payment method details
      $payment_method: {
        $payment_type: '$credit_card',
        $payment_gateway: '$stripe',
      },
      // Additional fraud signals
      $digital_goods: false,
      $shipping_address: {
        $country: 'US', // Default for call platform
      },
      $billing_address: {
        $country: 'US',
      },
    }

    await this.client.post('/events', eventData)
  }

  private async getScore(userId: string): Promise<{ data: unknown }> {
    const params = new URLSearchParams({
      api_key: fraudConfig.sift.apiKey,
      abuse_types: 'payment_abuse,account_abuse',
    })

    const response = await this.client.get(`/score/${userId}?${params.toString()}`)
    return response
  }

  private processScoreResponse(data: Record<string, unknown>): SiftFraudResult {
    const scores = (data.scores as Record<string, unknown>) || {}
    const paymentAbuse = (scores.payment_abuse as Record<string, unknown>) || {}
    const accountAbuse = (scores.account_abuse as Record<string, unknown>) || {}

    const paymentScore = Number(paymentAbuse.score) || 0
    const accountScore = Number(accountAbuse.score) || 0

    // Take the higher of the two scores
    const fraudScore = Math.max(paymentScore, accountScore) * 100 // Convert to 0-100 scale

    const reasons: string[] = []
    const workflowStatus = (data.workflow_statuses as Record<string, unknown>) || {}

    // Extract reasons from workflow decisions
    Object.entries(workflowStatus).forEach(([key, value]) => {
      if (value && typeof value === 'object') {
        const decision = value as Record<string, unknown>
        if (decision.decision === 'block' || decision.decision === 'review') {
          reasons.push(`Sift ${key} triggered: ${decision.decision}`)
        }
      }
    })

    // Determine status based on score and workflow
    let status: 'approve' | 'review' | 'reject' = 'approve'

    if (
      Object.values(workflowStatus).some(
        (w) => w && typeof w === 'object' && (w as Record<string, unknown>).decision === 'block'
      )
    ) {
      status = 'reject'
    } else if (
      fraudScore >= 80 ||
      Object.values(workflowStatus).some(
        (w) => w && typeof w === 'object' && (w as Record<string, unknown>).decision === 'review'
      )
    ) {
      status = 'review'
    }

    return {
      fraudScore: Math.round(fraudScore),
      status,
      workflowStatus: JSON.stringify(workflowStatus),
      reasons,
      paymentAbuseScore: paymentScore * 100,
      accountAbuseScore: accountScore * 100,
    }
  }

  private generateSessionId(): string {
    return `sess_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  }

  // Utility methods
  async reportGoodTransaction(userId: string): Promise<void> {
    const eventData = {
      $type: '$label',
      $api_key: fraudConfig.sift.apiKey,
      $is_fraud: false,
      $abuse_type: 'payment_abuse',
      $description: 'Confirmed good transaction',
      $source: 'manual_review',
      $analyst: 'system',
      $time: Math.floor(Date.now() / 1000),
    }

    await this.client.post(`/users/${userId}/labels`, eventData)
  }

  async reportFraudulentTransaction(userId: string, reason: string): Promise<void> {
    const eventData = {
      $type: '$label',
      $api_key: fraudConfig.sift.apiKey,
      $is_fraud: true,
      $abuse_type: 'payment_abuse',
      $description: `Fraudulent transaction: ${reason}`,
      $source: 'manual_review',
      $analyst: 'system',
      $time: Math.floor(Date.now() / 1000),
    }

    await this.client.post(`/users/${userId}/labels`, eventData)
  }

  async sendCallEvent(phoneNumber: string, campaignId: string, ip: string): Promise<void> {
    const eventData = {
      $type: '$create_content',
      $api_key: fraudConfig.sift.apiKey,
      $user_id: `phone_${phoneNumber}`,
      $session_id: this.generateSessionId(),
      $ip: ip,
      $time: Math.floor(Date.now() / 1000),
      $content_id: campaignId,
      $contact_phone: phoneNumber,
      // Custom properties for call fraud detection
      $custom: {
        event_type: 'incoming_call',
        campaign_id: campaignId,
        call_source: 'external',
      },
    }

    await this.client.post('/events', eventData)
  }
}

// Export singleton instance
export const siftClient = new SiftClient()
</file>

<file path="src/integrations/fraud/truecaller.ts">
import axios from 'axios'
import { fraudConfig } from './config'
import type { PhoneVerificationResult } from './types'

export class TruecallerClient {
  private client = axios.create({
    baseURL: fraudConfig.truecaller.baseUrl,
    timeout: fraudConfig.truecaller.timeout,
    headers: {
      Authorization: `Bearer ${fraudConfig.truecaller.apiKey}`,
      'Content-Type': 'application/json',
    },
  })

  async verifyPhone(phoneNumber: string): Promise<PhoneVerificationResult> {
    try {
      // Format phone number to E.164 format if needed
      const formattedPhone = this.formatPhoneNumber(phoneNumber)

      const response = await this.client.get('/search', {
        params: {
          q: formattedPhone,
          countryCode: 'US',
        },
      })

      const data = response.data?.data?.[0]

      if (!data) {
        return {
          valid: false,
          error: 'Phone number not found',
        }
      }

      return {
        valid: true,
        carrier: data.carrier,
        country: data.countryCode,
        lineType: this.mapPhoneType(data.phoneType),
        name: data.name,
        spamScore: data.spamScore || 0,
        isActive: data.isActive !== false,
      }
    } catch (error) {
      console.error('TrueCaller verification error:', error)

      if (axios.isAxiosError(error)) {
        if (error.response?.status === 404) {
          return {
            valid: false,
            error: 'Phone number not found',
          }
        }
        return {
          valid: false,
          error: `Verification failed: ${error.response?.data?.message || error.message}`,
        }
      }

      return {
        valid: false,
        error: 'Phone verification service unavailable',
      }
    }
  }

  private formatPhoneNumber(phone: string): string {
    // Remove all non-numeric characters
    const cleaned = phone.replace(/\D/g, '')

    // Add country code if missing (assume US)
    if (cleaned.length === 10) {
      return `+1${cleaned}`
    } else if (cleaned.length === 11 && cleaned.startsWith('1')) {
      return `+${cleaned}`
    }

    // If already has country code or different format, return as is
    return phone.startsWith('+') ? phone : `+${cleaned}`
  }

  private mapPhoneType(type?: string): 'mobile' | 'landline' | 'voip' | 'unknown' {
    switch (type?.toLowerCase()) {
      case 'mobile':
      case 'cellular':
        return 'mobile'
      case 'fixed':
      case 'landline':
        return 'landline'
      case 'voip':
      case 'virtual':
        return 'voip'
      default:
        return 'unknown'
    }
  }

  // Additional utility methods
  async checkSpamScore(phoneNumber: string): Promise<number> {
    const result = await this.verifyPhone(phoneNumber)
    return result.spamScore || 0
  }

  async isPhoneActive(phoneNumber: string): Promise<boolean> {
    const result = await this.verifyPhone(phoneNumber)
    return result.valid && (result.isActive ?? false)
  }
}

// Export singleton instance
export const truecallerClient = new TruecallerClient()
</file>

<file path="src/integrations/stripe/README.md">
# Stripe Integration

This directory contains the complete Stripe integration for the Dependable Call Exchange platform.

## Setup

1. Create a Stripe account at https://stripe.com
2. Get your API keys from the Stripe Dashboard
3. Copy `.env.example` to `.env` and fill in your Stripe keys:
   ```
   VITE_STRIPE_PUBLISHABLE_KEY=pk_test_...
   VITE_STRIPE_SECRET_KEY=sk_test_...
   VITE_STRIPE_WEBHOOK_SECRET=whsec_...
   VITE_STRIPE_CONNECT_CLIENT_ID=ca_...
   ```

## Architecture

### Core Modules

- **client.ts** - Stripe SDK initialization and configuration
- **types.ts** - TypeScript interfaces for Stripe operations
- **customers.ts** - Customer and payment method management
- **connected-accounts.ts** - Stripe Connect for supplier payouts
- **payments.ts** - Payment intent creation and management
- **subscriptions.ts** - Subscription handling for buyers
- **billing.ts** - Invoice and usage-based billing
- **payouts.ts** - Transfer and payout management for suppliers
- **webhooks.ts** - Webhook event handlers

### Key Features

1. **Buyer Payments**
   - Credit card and ACH support
   - Subscription management
   - Usage-based billing
   - Invoice generation

2. **Supplier Payouts**
   - Stripe Connect Express accounts
   - Automatic weekly payouts (Fridays)
   - Real-time balance tracking
   - Payout history

3. **Security**
   - Webhook signature verification
   - PCI compliance through Stripe
   - Secure payment method storage

## Usage Examples

### Creating a Customer

```typescript
import { createStripeCustomer } from '@/integrations/stripe';

const customer = await createStripeCustomer(email, {
  userId: user.id,
  userType: 'buyer',
  companyName: user.company_name,
});
```

### Creating a Payment Intent

```typescript
import { createPaymentIntent } from '@/integrations/stripe';

const paymentIntent = await createPaymentIntent({
  amount: 10000, // $100.00 in cents
  currency: 'usd',
  customerId: customer.id,
  metadata: {
    invoiceId: invoice.id,
    buyerId: buyer.id,
    billingPeriod: '2024-01',
  },
});
```

### Setting up Supplier Payouts

```typescript
import { createConnectedAccount, createAccountLink } from '@/integrations/stripe';

// Create connected account
const account = await createConnectedAccount({
  email: supplier.email,
  metadata: {
    supplierId: supplier.id,
    companyName: supplier.company_name,
  },
});

// Generate onboarding link
const accountLink = await createAccountLink(
  account.id,
  'https://app.dependablecalls.com/suppliers/onboarding/refresh',
  'https://app.dependablecalls.com/suppliers/onboarding/return'
);
```

### Processing Weekly Payouts

```typescript
import { scheduleWeeklyPayouts } from '@/integrations/stripe';

const suppliers = await getSupplierPayoutData();
const transfers = await scheduleWeeklyPayouts(suppliers);
```

## Webhook Configuration

1. Set up webhook endpoint in Stripe Dashboard
2. Point to: `https://yourdomain.com/.netlify/functions/stripe-webhook`
3. Select events:
   - payment_intent.succeeded
   - payment_intent.payment_failed
   - charge.dispute.created
   - account.updated
   - account.application.authorized
   - account.application.deauthorized
   - payout.created
   - payout.paid
   - payout.failed
   - transfer.created
   - transfer.reversed

## Testing

Use Stripe test cards:
- Success: 4242 4242 4242 4242
- Decline: 4000 0000 0000 0002
- 3D Secure: 4000 0000 0000 3220

Test bank accounts (ACH):
- Success: 000123456789
- Failure: 000111111113

## Error Handling

All functions include proper error handling and will throw descriptive errors. Wrap calls in try-catch blocks:

```typescript
try {
  const result = await stripeOperation();
} catch (error) {
  console.error('Stripe error:', error.message);
  // Handle error appropriately
}
```

## Security Considerations

1. Never expose secret keys in client-side code
2. Always verify webhook signatures
3. Use HTTPS in production
4. Implement rate limiting on payment endpoints
5. Log all payment-related activities
6. Monitor for suspicious patterns
</file>

<file path="src/integrations/CLAUDE.md">
# API Integration Patterns

# File Structure
```
integrations/
├── stripe/           # Stripe payment integration
├── supabase/         # Database and auth
├── sentry/           # Error monitoring
├── analytics/        # Tracking and analytics
└── webhooks/         # Webhook handlers
```

# API Client Pattern
```tsx
import axios, { AxiosInstance, AxiosError } from 'axios';

class ApiClient {
  private client: AxiosInstance;
  
  constructor(baseURL: string) {
    this.client = axios.create({
      baseURL,
      headers: {
        'Content-Type': 'application/json',
      },
    });
    
    this.setupInterceptors();
  }
  
  private setupInterceptors() {
    // Request interceptor for auth
    this.client.interceptors.request.use((config) => {
      const token = getAuthToken();
      if (token) {
        config.headers.Authorization = `Bearer ${token}`;
      }
      return config;
    });
    
    // Response interceptor for errors
    this.client.interceptors.response.use(
      (response) => response,
      (error: AxiosError) => {
        handleApiError(error);
        return Promise.reject(error);
      }
    );
  }
}
```

# Error Handling Strategy
```tsx
// Centralized error handling
export class ApiError extends Error {
  constructor(
    message: string,
    public statusCode: number,
    public code?: string
  ) {
    super(message);
    this.name = 'ApiError';
  }
}

export function handleApiError(error: unknown): ApiError {
  if (axios.isAxiosError(error)) {
    const status = error.response?.status ?? 500;
    const message = error.response?.data?.message ?? 'Network error';
    const code = error.response?.data?.code;
    
    return new ApiError(message, status, code);
  }
  
  return new ApiError('Unknown error occurred', 500);
}
```

# Stripe Integration
- Use official Stripe libraries only
- Implement webhook verification
- Handle payment intents properly
- Secure API key management

```tsx
import { Stripe } from 'stripe';

export class StripeService {
  private stripe: Stripe;
  
  constructor() {
    this.stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
      apiVersion: '2024-12-18.acacia',
    });
  }
  
  async createPaymentIntent(amount: number, currency = 'usd') {
    return await this.stripe.paymentIntents.create({
      amount: Math.round(amount * 100), // Convert to cents
      currency,
    });
  }
}
```

# Supabase Integration
- Use typed clients
- Implement RLS policies
- Handle real-time subscriptions
- Proper error handling

```tsx
import { createClient, SupabaseClient } from '@supabase/supabase-js';
import { Database } from '@/types/database';

export const supabase: SupabaseClient<Database> = createClient(
  import.meta.env.VITE_SUPABASE_URL,
  import.meta.env.VITE_SUPABASE_ANON_KEY
);

// Typed query helper
export async function fetchUser(id: string) {
  const { data, error } = await supabase
    .from('users')
    .select('*')
    .eq('id', id)
    .single();
    
  if (error) throw new ApiError(error.message, 400);
  return data;
}
```

# Real-time Subscriptions
```tsx
export class RealtimeService {
  private subscriptions = new Map<string, RealtimeChannel>();
  
  subscribeToTable<T>(
    table: string,
    callback: (payload: RealtimePostgresChangesPayload<T>) => void
  ) {
    const channel = supabase
      .channel(`${table}-changes`)
      .on('postgres_changes', 
        { event: '*', schema: 'public', table },
        callback
      )
      .subscribe();
      
    this.subscriptions.set(table, channel);
    return channel;
  }
  
  unsubscribe(table: string) {
    const channel = this.subscriptions.get(table);
    if (channel) {
      supabase.removeChannel(channel);
      this.subscriptions.delete(table);
    }
  }
}
```

# Webhook Handling
```tsx
// Webhook verification
export function verifyWebhookSignature(
  payload: string,
  signature: string,
  secret: string
): boolean {
  // Use crypto.timingSafeEqual for security
  const expectedSignature = createHmac('sha256', secret)
    .update(payload)
    .digest('hex');
    
  return crypto.timingSafeEqual(
    Buffer.from(signature),
    Buffer.from(expectedSignature)
  );
}
```

# Secret Management
- ALL secrets in environment variables
- Different secrets for dev/staging/prod
- NO secrets in code or version control
- Use proper key rotation practices

```tsx
// Environment validation
const requiredEnvVars = [
  'VITE_SUPABASE_URL',
  'VITE_SUPABASE_ANON_KEY',
  'VITE_STRIPE_PUBLIC_KEY',
] as const;

export function validateEnvironment() {
  for (const envVar of requiredEnvVars) {
    if (!import.meta.env[envVar]) {
      throw new Error(`Missing required environment variable: ${envVar}`);
    }
  }
}
```

# Rate Limiting & Retry Logic
```tsx
import { retry } from '@/lib/retry';

export async function apiCallWithRetry<T>(
  fn: () => Promise<T>,
  maxRetries = 3
): Promise<T> {
  return retry(fn, {
    retries: maxRetries,
    retryDelay: (attempt) => Math.min(1000 * Math.pow(2, attempt), 30000),
    retryIf: (error) => {
      // Retry on network errors and 5xx responses
      return axios.isAxiosError(error) && 
             (!error.response || error.response.status >= 500);
    },
  });
}
```

# Type Safety for APIs
- Generate types from OpenAPI specs where possible
- Create proper TypeScript interfaces for all responses
- Use Zod for runtime validation of external API responses

# Testing Integrations
- Mock external services in tests
- Use test-specific API keys/endpoints
- Test error scenarios explicitly
- Integration tests with real services in CI

# DCE-Specific Integrations
- Call tracking APIs
- Fraud detection services
- Campaign management APIs
- Real-time analytics
- Billing and payout systems

# CRITICAL RULES
- NO regex in integration code
- NO any types in API responses
- ALWAYS validate external API responses
- ALWAYS handle network errors gracefully
- NEVER commit secrets or API keys
- ALWAYS use proper authentication
- ALWAYS implement proper error boundaries
- ALWAYS log integration failures for monitoring
</file>

<file path="src/lib/CLAUDE.md">
# Utility Functions & Libraries

# File Organization
```
lib/
├── supabase.ts        # Supabase client config
├── validators.ts      # Zod validation schemas
├── formatters.ts      # Data formatting utilities
├── constants.ts       # App-wide constants
├── api.ts            # API helpers
├── auth.ts           # Auth utilities
├── utils.ts          # General utilities
└── types.ts          # Shared utility types
```

# Validation Patterns
- ALWAYS use Zod for validation
- NO regex patterns - use Zod string validators
- Create reusable schemas

```tsx
import { z } from 'zod';

export const phoneSchema = z.string()
  .min(10, 'Phone number must be at least 10 digits')
  .transform(val => val.replace(/\D/g, '')); // Remove non-digits

export const emailSchema = z.string().email('Invalid email format');
```

# External Library Usage
- Check if library exists before adding new ones
- Use existing project dependencies:
  - axios for HTTP requests
  - zod for validation
  - date-fns for date manipulation
  - lodash for utility functions (if needed)

# API Helpers
```tsx
// Use axios instance with proper typing
export const api = axios.create({
  baseURL: import.meta.env.VITE_API_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Typed API functions
export async function fetchUser(id: string): Promise<User> {
  const response = await api.get<User>(`/users/${id}`);
  return response.data;
}
```

# Error Handling Patterns
```tsx
// Custom error types
export class ValidationError extends Error {
  constructor(message: string, public field: string) {
    super(message);
    this.name = 'ValidationError';
  }
}

// Error handling utilities
export function handleApiError(error: unknown): string {
  if (error instanceof ValidationError) {
    return `Validation error: ${error.message}`;
  }
  if (axios.isAxiosError(error)) {
    return error.response?.data?.message ?? 'Network error';
  }
  return 'An unexpected error occurred';
}
```

# Data Formatting
```tsx
// Currency formatting
export function formatCurrency(
  amount: number, 
  currency = 'USD'
): string {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency,
  }).format(amount);
}

// Date formatting
export function formatDate(date: Date | string): string {
  return new Intl.DateTimeFormat('en-US').format(new Date(date));
}
```

# Secret Management
- Use environment variables for all secrets
- NO hardcoded API keys or passwords
- Use proper typing for env vars

```tsx
// Environment variable typing
interface ImportMetaEnv {
  readonly VITE_SUPABASE_URL: string;
  readonly VITE_SUPABASE_ANON_KEY: string;
  readonly VITE_STRIPE_PUBLIC_KEY: string;
}
```

# Performance Utilities
```tsx
// Debounce for search inputs
export function debounce<T extends unknown[]>(
  fn: (...args: T) => void,
  delay: number
): (...args: T) => void {
  let timeoutId: NodeJS.Timeout;
  return (...args: T) => {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => fn(...args), delay);
  };
}
```

# DCE-Specific Utilities
- Call duration calculation
- Commission rate calculations
- Traffic quality scoring
- Fraud detection helpers
- Real-time connection utilities

# Type Safety Requirements
- ALL functions must have proper TypeScript types
- Use generics for flexible utilities
- Export types alongside functions
- NO any types allowed

# Testing Utilities
- Create test helpers in lib/__tests__/
- Mock external dependencies
- Use fixtures for test data

# CRITICAL RULES
- NO regex patterns anywhere
- NO any types in utility functions
- ALWAYS validate inputs with Zod
- ALWAYS handle errors explicitly
- ALWAYS use proper TypeScript typing
- NO direct external API calls - use abstractions
</file>

<file path="src/lib/supabase.ts">
import { createClient } from '@supabase/supabase-js'
import type { Database } from '../types/database'

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error('Missing Supabase environment variables')
}

export const supabase = createClient<Database>(supabaseUrl, supabaseAnonKey, {
  auth: {
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: true,
  },
})
</file>

<file path="src/pages/billing/BillingPage.tsx">
export default function BillingPage() {
  return (
    <div className="py-6">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <h1 className="text-2xl font-semibold text-gray-900">Billing</h1>
        <p className="mt-1 text-sm text-gray-600">
          Manage your billing and payment methods.
        </p>
        
        <div className="mt-8">
          <div className="bg-white shadow overflow-hidden sm:rounded-md p-6">
            <p className="text-gray-500">Billing interface coming soon...</p>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/pages/calls/CallsPage.tsx">
export default function CallsPage() {
  return (
    <div className="py-6">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <h1 className="text-2xl font-semibold text-gray-900">Calls</h1>
        <p className="mt-1 text-sm text-gray-600">
          View and manage your call history.
        </p>
        
        <div className="mt-8">
          <div className="bg-white shadow overflow-hidden sm:rounded-md p-6">
            <p className="text-gray-500">Call tracking interface coming soon...</p>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/pages/campaigns/CampaignsPage.tsx">
export default function CampaignsPage() {
  return (
    <div className="py-6">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <h1 className="text-2xl font-semibold text-gray-900">Campaigns</h1>
        <p className="mt-1 text-sm text-gray-600">
          Manage your campaigns and tracking numbers.
        </p>
        
        <div className="mt-8">
          <div className="bg-white shadow overflow-hidden sm:rounded-md p-6">
            <p className="text-gray-500">Campaign management interface coming soon...</p>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/pages/dashboard/DashboardPage.tsx">
import { useAuthStore } from '../../store/authStore'
import { 
  CurrencyDollarIcon, 
  PhoneIcon, 
  ChartBarIcon,
  ArrowTrendingUpIcon,
} from '@heroicons/react/24/outline'

const stats = [
  { name: 'Total Revenue', stat: '$24,563', icon: CurrencyDollarIcon, change: '+12%', changeType: 'increase' },
  { name: 'Total Calls', stat: '1,234', icon: PhoneIcon, change: '+8%', changeType: 'increase' },
  { name: 'Active Campaigns', stat: '12', icon: ChartBarIcon, change: '+2', changeType: 'increase' },
  { name: 'Conversion Rate', stat: '24.5%', icon: ArrowTrendingUpIcon, change: '-2%', changeType: 'decrease' },
]

function classNames(...classes: string[]) {
  return classes.filter(Boolean).join(' ')
}

export default function DashboardPage() {
  const { user, userType } = useAuthStore()

  return (
    <div className="py-6">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <h1 className="text-2xl font-semibold text-gray-900">Dashboard</h1>
        <p className="mt-1 text-sm text-gray-600">
          Welcome back, {user?.email}
        </p>
      </div>

      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        {/* Stats */}
        <div className="mt-8">
          <h2 className="text-lg leading-6 font-medium text-gray-900">
            {userType === 'supplier' ? 'Campaign Performance' : 'Lead Overview'}
          </h2>
          <dl className="mt-5 grid grid-cols-1 gap-5 sm:grid-cols-2 lg:grid-cols-4">
            {stats.map((item) => (
              <div
                key={item.name}
                className="relative bg-white pt-5 px-4 pb-12 sm:pt-6 sm:px-6 shadow rounded-lg overflow-hidden"
              >
                <dt>
                  <div className="absolute bg-primary-500 rounded-md p-3">
                    <item.icon className="h-6 w-6 text-white" aria-hidden="true" />
                  </div>
                  <p className="ml-16 text-sm font-medium text-gray-500 truncate">{item.name}</p>
                </dt>
                <dd className="ml-16 pb-6 flex items-baseline sm:pb-7">
                  <p className="text-2xl font-semibold text-gray-900">{item.stat}</p>
                  <p
                    className={classNames(
                      item.changeType === 'increase' ? 'text-green-600' : 'text-red-600',
                      'ml-2 flex items-baseline text-sm font-semibold'
                    )}
                  >
                    {item.change}
                  </p>
                  <div className="absolute bottom-0 inset-x-0 bg-gray-50 px-4 py-4 sm:px-6">
                    <div className="text-sm">
                      <a href="#" className="font-medium text-primary-600 hover:text-primary-500">
                        View all<span className="sr-only"> {item.name} stats</span>
                      </a>
                    </div>
                  </div>
                </dd>
              </div>
            ))}
          </dl>
        </div>

        {/* Recent Activity */}
        <div className="mt-8">
          <h2 className="text-lg leading-6 font-medium text-gray-900">Recent Activity</h2>
          <div className="mt-5 bg-white shadow overflow-hidden sm:rounded-md">
            <ul className="divide-y divide-gray-200">
              <li className="px-6 py-4">
                <div className="flex items-center justify-between">
                  <div className="flex items-center">
                    <div className="flex-shrink-0">
                      <PhoneIcon className="h-8 w-8 text-gray-400" />
                    </div>
                    <div className="ml-4">
                      <p className="text-sm font-medium text-gray-900">New call received</p>
                      <p className="text-sm text-gray-500">Campaign: Home Services</p>
                    </div>
                  </div>
                  <div className="text-sm text-gray-500">2 minutes ago</div>
                </div>
              </li>
              <li className="px-6 py-4">
                <div className="flex items-center justify-between">
                  <div className="flex items-center">
                    <div className="flex-shrink-0">
                      <CurrencyDollarIcon className="h-8 w-8 text-gray-400" />
                    </div>
                    <div className="ml-4">
                      <p className="text-sm font-medium text-gray-900">Payment processed</p>
                      <p className="text-sm text-gray-500">Amount: $125.00</p>
                    </div>
                  </div>
                  <div className="text-sm text-gray-500">1 hour ago</div>
                </div>
              </li>
              <li className="px-6 py-4">
                <div className="flex items-center justify-between">
                  <div className="flex items-center">
                    <div className="flex-shrink-0">
                      <ChartBarIcon className="h-8 w-8 text-gray-400" />
                    </div>
                    <div className="ml-4">
                      <p className="text-sm font-medium text-gray-900">Campaign activated</p>
                      <p className="text-sm text-gray-500">Campaign: Insurance Leads</p>
                    </div>
                  </div>
                  <div className="text-sm text-gray-500">3 hours ago</div>
                </div>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/pages/public/HomePage.tsx">
import { Link } from 'react-router-dom'
import { 
  PhoneIcon, 
  ChartBarIcon, 
  ShieldCheckIcon, 
  CurrencyDollarIcon,
  BoltIcon,
  GlobeAltIcon,
} from '@heroicons/react/24/outline'

const features = [
  {
    name: 'Real-Time Call Tracking',
    description: 'Monitor your calls as they happen with our advanced real-time dashboard and analytics.',
    icon: PhoneIcon,
  },
  {
    name: 'Fraud Prevention',
    description: 'Industry-leading fraud detection powered by machine learning protects your campaigns.',
    icon: ShieldCheckIcon,
  },
  {
    name: 'Quality Scoring',
    description: 'Automatic call quality scoring ensures you only pay for high-intent, qualified leads.',
    icon: ChartBarIcon,
  },
  {
    name: 'Flexible Payouts',
    description: 'Choose from daily, weekly, or monthly payouts with multiple payment methods.',
    icon: CurrencyDollarIcon,
  },
  {
    name: 'Instant Routing',
    description: 'Calls are routed to the best buyer in milliseconds based on your criteria.',
    icon: BoltIcon,
  },
  {
    name: 'Global Coverage',
    description: 'Accept calls from anywhere with support for international numbers and routing.',
    icon: GlobeAltIcon,
  },
]

const stats = [
  { label: 'Active Campaigns', value: '10,000+' },
  { label: 'Calls Per Month', value: '2.5M+' },
  { label: 'Average Quality Score', value: '94%' },
  { label: 'Uptime SLA', value: '99.9%' },
]

export default function HomePage() {
  return (
    <div>
      {/* Hero Section */}
      <div className="relative bg-white overflow-hidden">
        <div className="max-w-7xl mx-auto">
          <div className="relative z-10 pb-8 bg-white sm:pb-16 md:pb-20 lg:max-w-2xl lg:w-full lg:pb-28 xl:pb-32">
            <main className="mt-10 mx-auto max-w-7xl px-4 sm:mt-12 sm:px-6 md:mt-16 lg:mt-20 lg:px-8 xl:mt-28">
              <div className="sm:text-center lg:text-left">
                <h1 className="text-4xl tracking-tight font-extrabold text-gray-900 sm:text-5xl md:text-6xl">
                  <span className="block">The Most Trusted</span>
                  <span className="block text-primary-600">Pay-Per-Call Network</span>
                </h1>
                <p className="mt-3 text-base text-gray-500 sm:mt-5 sm:text-lg sm:max-w-xl sm:mx-auto md:mt-5 md:text-xl lg:mx-0">
                  Connect quality callers with businesses that need them. Real-time tracking, fraud prevention, and instant payouts make DependableCalls the platform of choice for performance marketers.
                </p>
                <div className="mt-5 sm:mt-8 sm:flex sm:justify-center lg:justify-start">
                  <div className="rounded-md shadow">
                    <Link
                      to="/register"
                      className="w-full flex items-center justify-center px-8 py-3 border border-transparent text-base font-medium rounded-md text-white bg-primary-600 hover:bg-primary-700 md:py-4 md:text-lg md:px-10"
                    >
                      Get Started
                    </Link>
                  </div>
                  <div className="mt-3 sm:mt-0 sm:ml-3">
                    <Link
                      to="/login"
                      className="w-full flex items-center justify-center px-8 py-3 border border-transparent text-base font-medium rounded-md text-primary-700 bg-primary-100 hover:bg-primary-200 md:py-4 md:text-lg md:px-10"
                    >
                      Login
                    </Link>
                  </div>
                </div>
              </div>
            </main>
          </div>
        </div>
        <div className="lg:absolute lg:inset-y-0 lg:right-0 lg:w-1/2">
          <div className="h-56 w-full bg-gradient-to-br from-primary-500 to-primary-700 sm:h-72 md:h-96 lg:w-full lg:h-full" />
        </div>
      </div>

      {/* Stats Section */}
      <div className="bg-primary-700">
        <div className="max-w-7xl mx-auto py-12 px-4 sm:py-16 sm:px-6 lg:px-8 lg:py-20">
          <div className="max-w-4xl mx-auto text-center">
            <h2 className="text-3xl font-extrabold text-white sm:text-4xl">
              Trusted by thousands of performance marketers
            </h2>
          </div>
          <dl className="mt-10 text-center sm:max-w-3xl sm:mx-auto sm:grid sm:grid-cols-2 sm:gap-8 lg:max-w-none lg:grid-cols-4">
            {stats.map((stat) => (
              <div key={stat.label} className="flex flex-col mt-10 sm:mt-0">
                <dt className="order-2 mt-2 text-lg leading-6 font-medium text-primary-200">
                  {stat.label}
                </dt>
                <dd className="order-1 text-5xl font-extrabold text-white">
                  {stat.value}
                </dd>
              </div>
            ))}
          </dl>
        </div>
      </div>

      {/* Features Section */}
      <div id="features" className="py-12 bg-white">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="lg:text-center">
            <h2 className="text-base text-primary-600 font-semibold tracking-wide uppercase">Features</h2>
            <p className="mt-2 text-3xl leading-8 font-extrabold tracking-tight text-gray-900 sm:text-4xl">
              Everything you need to succeed
            </p>
            <p className="mt-4 max-w-2xl text-xl text-gray-500 lg:mx-auto">
              Our platform provides all the tools and features you need to run successful pay-per-call campaigns.
            </p>
          </div>

          <div className="mt-10">
            <dl className="space-y-10 md:space-y-0 md:grid md:grid-cols-2 lg:grid-cols-3 md:gap-x-8 md:gap-y-10">
              {features.map((feature) => (
                <div key={feature.name} className="relative">
                  <dt>
                    <div className="absolute flex items-center justify-center h-12 w-12 rounded-md bg-primary-500 text-white">
                      <feature.icon className="h-6 w-6" aria-hidden="true" />
                    </div>
                    <p className="ml-16 text-lg leading-6 font-medium text-gray-900">
                      {feature.name}
                    </p>
                  </dt>
                  <dd className="mt-2 ml-16 text-base text-gray-500">
                    {feature.description}
                  </dd>
                </div>
              ))}
            </dl>
          </div>
        </div>
      </div>

      {/* CTA Section */}
      <div className="bg-gray-50">
        <div className="max-w-7xl mx-auto py-12 px-4 sm:px-6 lg:py-16 lg:px-8 lg:flex lg:items-center lg:justify-between">
          <h2 className="text-3xl font-extrabold tracking-tight text-gray-900 sm:text-4xl">
            <span className="block">Ready to get started?</span>
            <span className="block text-primary-600">Start your free trial today.</span>
          </h2>
          <div className="mt-8 flex lg:mt-0 lg:flex-shrink-0">
            <div className="inline-flex rounded-md shadow">
              <Link
                to="/register"
                className="inline-flex items-center justify-center px-5 py-3 border border-transparent text-base font-medium rounded-md text-white bg-primary-600 hover:bg-primary-700"
              >
                Get started
              </Link>
            </div>
            <div className="ml-3 inline-flex rounded-md shadow">
              <Link
                to="/contact"
                className="inline-flex items-center justify-center px-5 py-3 border border-transparent text-base font-medium rounded-md text-primary-600 bg-white hover:bg-primary-50"
              >
                Contact sales
              </Link>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/pages/reports/ReportsPage.tsx">
export default function ReportsPage() {
  return (
    <div className="py-6">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <h1 className="text-2xl font-semibold text-gray-900">Reports</h1>
        <p className="mt-1 text-sm text-gray-600">
          Generate and view analytics reports.
        </p>
        
        <div className="mt-8">
          <div className="bg-white shadow overflow-hidden sm:rounded-md p-6">
            <p className="text-gray-500">Reporting interface coming soon...</p>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/pages/settings/SettingsPage.tsx">
export default function SettingsPage() {
  return (
    <div className="py-6">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <h1 className="text-2xl font-semibold text-gray-900">Settings</h1>
        <p className="mt-1 text-sm text-gray-600">
          Manage your account settings and preferences.
        </p>
        
        <div className="mt-8">
          <div className="bg-white shadow overflow-hidden sm:rounded-md p-6">
            <p className="text-gray-500">Settings interface coming soon...</p>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/pages/CLAUDE.md">
# Page Structure Patterns

# File Naming
- PascalCase with "Page" suffix: `DashboardPage.tsx`
- Group by feature: `/auth/LoginPage.tsx`
- One page component per file

# Page Component Template
```tsx
import { useEffect } from 'react';
import { useAuth } from '@/hooks/useAuth';

interface PageNamePageProps {
  // Props if needed
}

export function PageNamePage({ }: PageNamePageProps) {
  // Page-specific logic
  
  return (
    <div className="page-container">
      {/* Page content */}
    </div>
  );
}
```

# Data Fetching Patterns
- React Query for server state
- Zustand for global client state
- Local useState for page-only state
- Supabase real-time subscriptions for live data

# Route Organization
```
/auth/           # Authentication pages
/dashboard/      # User dashboards
/campaigns/      # Campaign management
/calls/          # Call tracking
/reports/        # Analytics/reporting
/billing/        # Payment/billing
/settings/       # User settings
/public/         # Public landing pages
```

# Page Layout Structure
```tsx
<PageLayout>
  <PageHeader title="Page Title" />
  <PageContent>
    {/* Main content */}
  </PageContent>
  <PageFooter />
</PageLayout>
```

# SEO Considerations
- Document title updates with `useEffect`
- Meta descriptions for public pages
- OpenGraph tags for social sharing
- Structured data where applicable

# Error Handling
- Error boundaries for page-level errors
- Loading states during data fetching
- Empty states for no data
- User-friendly error messages

# Authentication Patterns
- Protected routes with auth checks
- Role-based access control (Supplier/Buyer/Admin)
- Redirect to login for unauthenticated users
- Session management with Supabase Auth

# Performance Optimization
- Lazy load pages with React.lazy
- Preload critical data on route enter
- Optimize images with proper sizing
- Minimize bundle size per route

# DCE-Specific Pages
- Supplier Dashboard: Traffic overview, campaign selection
- Buyer Dashboard: Campaign management, lead quality
- Call Tracking: Real-time call monitoring
- Billing: Payment processing, payout management
- Reports: Analytics and performance metrics

# Form Pages
- React Hook Form for all forms
- Zod validation schemas
- Optimistic updates where appropriate
- Proper error handling and user feedback

# Real-time Features
- Supabase subscriptions for live updates
- Call status indicators
- Campaign performance metrics
- Fraud detection alerts

# CRITICAL RULES
- NO regex in page components
- NO any types in page props
- ALWAYS handle auth states
- ALWAYS implement loading/error states
- ALWAYS optimize for mobile-first design
</file>

<file path="src/services/CLAUDE.md">
# Service Layer Patterns

# Service Structure

```
services/
├── api/           # External API services
├── auth/          # Authentication services
├── billing/       # Payment processing
├── campaigns/     # Campaign management
├── calls/         # Call tracking
├── analytics/     # Analytics and reporting
└── fraud/         # Fraud detection
```

# Service Class Pattern

```tsx
export class CampaignService {
  constructor(
    private supabase: SupabaseClient,
    private stripe: Stripe
  ) {}

  async createCampaign(data: CreateCampaignDTO): Promise<Campaign> {
    // Validate input
    const validated = campaignSchema.parse(data)

    // Business logic
    const campaign = await this.supabase.from('campaigns').insert(validated).select().single()

    if (campaign.error) throw new ServiceError(campaign.error.message)

    // Side effects (analytics, notifications)
    await this.trackCampaignCreation(campaign.data)

    return campaign.data
  }
}
```

# Error Handling

```tsx
export class ServiceError extends Error {
  constructor(
    message: string,
    public code: string,
    public statusCode = 400
  ) {
    super(message)
    this.name = 'ServiceError'
  }
}

export function handleServiceError(error: unknown): ServiceError {
  if (error instanceof ServiceError) return error

  if (error instanceof Error) {
    return new ServiceError(error.message, 'UNKNOWN_ERROR', 500)
  }

  return new ServiceError('Unknown error', 'UNKNOWN_ERROR', 500)
}
```

# Authentication Service

```tsx
export class AuthService {
  async login(email: string, password: string): Promise<AuthResponse> {
    const { data, error } = await supabase.auth.signInWithPassword({
      email,
      password,
    })

    if (error) throw new ServiceError(error.message, 'AUTH_FAILED', 401)

    // Additional business logic (logging, analytics)
    await this.logUserActivity('login', data.user.id)

    return data
  }

  async validateSession(): Promise<User | null> {
    const {
      data: { user },
    } = await supabase.auth.getUser()
    return user
  }
}
```

# Billing Service

```tsx
export class BillingService {
  async processPayment(
    amount: number,
    paymentMethodId: string,
    userId: string
  ): Promise<PaymentResult> {
    // Create payment intent
    const intent = await this.stripe.paymentIntents.create({
      amount: Math.round(amount * 100),
      currency: 'usd',
      payment_method: paymentMethodId,
      confirm: true,
      metadata: { userId },
    })

    // Record transaction
    await this.recordTransaction(intent, userId)

    return {
      success: intent.status === 'succeeded',
      transactionId: intent.id,
    }
  }
}
```

# Call Tracking Service

```tsx
export class CallTrackingService {
  async startCall(campaignId: string, supplierId: string, callerNumber: string): Promise<Call> {
    // Generate tracking number
    const trackingNumber = await this.generateTrackingNumber()

    // Create call record
    const call = await this.supabase
      .from('calls')
      .insert({
        campaign_id: campaignId,
        supplier_id: supplierId,
        caller_number: callerNumber,
        tracking_number: trackingNumber,
        status: 'active',
      })
      .select()
      .single()

    // Set up real-time monitoring
    await this.initializeCallMonitoring(call.data.id)

    return call.data
  }

  private async generateTrackingNumber(): Promise<string> {
    // Implementation for unique tracking number
    return `1800${Date.now().toString().slice(-7)}`
  }
}
```

# Analytics Service

```tsx
export class AnalyticsService {
  async getCampaignMetrics(campaignId: string, dateRange: DateRange): Promise<CampaignMetrics> {
    const [calls, conversions, revenue] = await Promise.all([
      this.getCallVolume(campaignId, dateRange),
      this.getConversions(campaignId, dateRange),
      this.getRevenue(campaignId, dateRange),
    ])

    return {
      totalCalls: calls.count,
      conversionRate: (conversions / calls.count) * 100,
      revenue,
      costPerAcquisition: revenue / conversions,
    }
  }
}
```

# Fraud Detection Service

```tsx
export class FraudDetectionService {
  async analyzeCall(callId: string): Promise<FraudScore> {
    const call = await this.getCallDetails(callId)

    const checks = await Promise.all([
      this.checkDuplicateCaller(call.caller_number),
      this.checkCallPattern(call),
      this.checkGeographicAnomaly(call),
      this.checkCallDuration(call.duration),
    ])

    const score = this.calculateFraudScore(checks)

    if (score > FRAUD_THRESHOLD) {
      await this.flagCall(callId, score)
    }

    return score
  }
}
```

# Service Registration Pattern

```tsx
// services/index.ts
export class ServiceRegistry {
  private static instance: ServiceRegistry

  authService: AuthService
  billingService: BillingService
  campaignService: CampaignService
  callService: CallTrackingService
  analyticsService: AnalyticsService
  fraudService: FraudDetectionService

  private constructor() {
    this.authService = new AuthService()
    this.billingService = new BillingService(stripe)
    this.campaignService = new CampaignService(supabase, stripe)
    this.callService = new CallTrackingService()
    this.analyticsService = new AnalyticsService()
    this.fraudService = new FraudDetectionService()
  }

  static getInstance(): ServiceRegistry {
    if (!ServiceRegistry.instance) {
      ServiceRegistry.instance = new ServiceRegistry()
    }
    return ServiceRegistry.instance
  }
}
```

# Service Testing

```tsx
describe('CampaignService', () => {
  let service: CampaignService

  beforeEach(() => {
    service = new CampaignService(mockSupabase, mockStripe)
  })

  it('should create campaign successfully', async () => {
    const campaign = await service.createCampaign({
      name: 'Test Campaign',
      vertical: 'insurance',
      target_cpa: 50,
    })

    expect(campaign).toBeDefined()
    expect(campaign.name).toBe('Test Campaign')
  })
})
```

# Caching Strategy

```tsx
export class CachedService {
  private cache = new Map<string, CacheEntry>()

  async getCachedData<T>(
    key: string,
    fetcher: () => Promise<T>,
    ttl = 300000 // 5 minutes
  ): Promise<T> {
    const cached = this.cache.get(key)

    if (cached && Date.now() - cached.timestamp < ttl) {
      return cached.data as T
    }

    const data = await fetcher()
    this.cache.set(key, { data, timestamp: Date.now() })

    return data
  }
}
```

# Transaction Management

```tsx
export async function withTransaction<T>(operation: () => Promise<T>): Promise<T> {
  const client = await supabase.rpc('begin_transaction')

  try {
    const result = await operation()
    await supabase.rpc('commit_transaction')
    return result
  } catch (error) {
    await supabase.rpc('rollback_transaction')
    throw error
  }
}
```

# DCE-Specific Services

- Real-time call quality monitoring
- Dynamic campaign routing
- Supplier performance scoring
- Automated payout calculations
- Lead quality validation
- Commission rate optimization

# CRITICAL RULES

- NO regex in service logic
- NO any types in service methods
- ALWAYS validate inputs with Zod
- ALWAYS handle errors explicitly
- ALWAYS use transactions for multi-step operations
- ALWAYS log service operations
- NEVER expose internal errors to clients
- USE dependency injection for testing
- IMPLEMENT proper retry logic
- CACHE expensive operations appropriately
</file>

<file path="src/store/authStore.ts">
import { create } from 'zustand'
import { persist } from 'zustand/middleware'
import type { User, Session } from '@supabase/supabase-js'
import { supabase } from '../lib/supabase'

interface AuthState {
  user: User | null
  session: Session | null
  userType: 'supplier' | 'buyer' | 'admin' | null
  loading: boolean
  setUser: (user: User | null) => void
  setSession: (session: Session | null) => void
  setUserType: (userType: 'supplier' | 'buyer' | 'admin' | null) => void
  signIn: (email: string, password: string) => Promise<void>
  signUp: (email: string, password: string, userType: 'supplier' | 'buyer') => Promise<void>
  signOut: () => Promise<void>
  checkSession: () => Promise<void>
}

export const useAuthStore = create<AuthState>()(
  persist(
    (set) => ({
      user: null,
      session: null,
      userType: null,
      loading: true,

      setUser: (user) => set({ user }),
      setSession: (session) => set({ session }),
      setUserType: (userType) => set({ userType }),

      signIn: async (email, password) => {
        const { data, error } = await supabase.auth.signInWithPassword({
          email,
          password,
        })

        if (error) throw error

        if (data.user && data.session) {
          set({ user: data.user, session: data.session })
          
          // Fetch user type from users table
          const { data: userData } = await supabase
            .from('users')
            .select('user_type')
            .eq('id', data.user.id)
            .single()

          if (userData) {
            set({ userType: userData.user_type })
          }
        }
      },

      signUp: async (email, password, userType) => {
        const { data, error } = await supabase.auth.signUp({
          email,
          password,
          options: {
            data: { user_type: userType },
          },
        })

        if (error) throw error

        if (data.user && data.session) {
          set({ user: data.user, session: data.session, userType })
        }
      },

      signOut: async () => {
        await supabase.auth.signOut()
        set({ user: null, session: null, userType: null })
      },

      checkSession: async () => {
        set({ loading: true })
        
        const { data: { session } } = await supabase.auth.getSession()
        
        if (session) {
          set({ user: session.user, session })
          
          // Fetch user type
          const { data: userData } = await supabase
            .from('users')
            .select('user_type')
            .eq('id', session.user.id)
            .single()

          if (userData) {
            set({ userType: userData.user_type })
          }
        }
        
        set({ loading: false })
      },
    }),
    {
      name: 'auth-storage',
      partialize: (state) => ({ 
        user: state.user,
        session: state.session,
        userType: state.userType,
      }),
    }
  )
)
</file>

<file path="src/store/CLAUDE.md">
# Zustand State Management Patterns

# Store File Structure
```
store/
├── authStore.ts        # Authentication state
├── campaignStore.ts    # Campaign management
├── callStore.ts        # Call tracking state
├── billingStore.ts     # Billing/payment state
├── uiStore.ts          # UI state (modals, etc.)
└── index.ts            # Store exports
```

# Basic Store Pattern
```tsx
import { create } from 'zustand';
import { subscribeWithSelector } from 'zustand/middleware';

interface StoreState {
  // State properties
  data: DataType[];
  isLoading: boolean;
  error: string | null;
  
  // Actions
  setData: (data: DataType[]) => void;
  setLoading: (loading: boolean) => void;
  setError: (error: string | null) => void;
  reset: () => void;
}

export const useStore = create<StoreState>()(
  subscribeWithSelector((set, get) => ({
    // Initial state
    data: [],
    isLoading: false,
    error: null,
    
    // Actions
    setData: (data) => set({ data }),
    setLoading: (isLoading) => set({ isLoading }),
    setError: (error) => set({ error }),
    reset: () => set({ data: [], isLoading: false, error: null }),
  }))
);
```

# TypeScript Requirements
- ALL stores must have proper interfaces
- NO any types in state or actions
- Use proper generic types for flexible stores
- Export store types for component usage

# Async Actions Pattern
```tsx
// Async actions with proper error handling
const useDataStore = create<DataStore>((set, get) => ({
  data: [],
  isLoading: false,
  error: null,
  
  fetchData: async () => {
    set({ isLoading: true, error: null });
    try {
      const data = await api.getData();
      set({ data, isLoading: false });
    } catch (error) {
      set({ 
        error: handleApiError(error), 
        isLoading: false 
      });
    }
  },
}));
```

# Computed Values
```tsx
// Use selectors for computed values
export const useUserStats = () => {
  return useAuthStore((state) => ({
    totalCalls: state.calls.length,
    activeCallsCount: state.calls.filter(c => c.status === 'active').length,
    conversionRate: state.calls.length > 0 
      ? (state.conversions / state.calls.length) * 100 
      : 0,
  }));
};
```

# Persistence Patterns
```tsx
import { persist } from 'zustand/middleware';

// Persist auth state
export const useAuthStore = create<AuthState>()(
  persist(
    (set, get) => ({
      user: null,
      token: null,
      // ... other state and actions
    }),
    {
      name: 'auth-storage',
      partialize: (state) => ({
        user: state.user,
        token: state.token,
      }),
    }
  )
);
```

# Subscriptions for Real-time
```tsx
// Subscribe to Supabase real-time changes
export const useCallStore = create<CallState>((set, get) => ({
  calls: [],
  
  subscribeToRealTimeUpdates: () => {
    return supabase
      .channel('calls')
      .on('postgres_changes', 
        { event: '*', schema: 'public', table: 'calls' },
        (payload) => {
          // Update store based on real-time changes
          set((state) => ({
            calls: updateCallsArray(state.calls, payload)
          }));
        }
      )
      .subscribe();
  },
}));
```

# Performance Optimization
```tsx
// Use shallow equality for object selections
import { shallow } from 'zustand/shallow';

const Component = () => {
  const { user, isLoading } = useAuthStore(
    (state) => ({ user: state.user, isLoading: state.isLoading }),
    shallow
  );
};

// Or use specific selectors
const user = useAuthStore(state => state.user);
const isLoading = useAuthStore(state => state.isLoading);
```

# DCE-Specific Stores

## Auth Store
- User authentication state
- Role-based permissions (Supplier/Buyer/Admin)
- Session management

## Campaign Store
- Campaign CRUD operations
- Real-time campaign status
- Performance metrics

## Call Store
- Live call tracking
- Call history and analytics
- Real-time status updates

## Billing Store
- Payment processing state
- Payout calculations
- Transaction history

# Store Testing
```tsx
// Test stores in isolation
describe('AuthStore', () => {
  beforeEach(() => {
    useAuthStore.getState().reset();
  });
  
  it('should login user correctly', async () => {
    const { login } = useAuthStore.getState();
    await login('user@test.com', 'password');
    
    expect(useAuthStore.getState().user).toBeDefined();
    expect(useAuthStore.getState().isAuthenticated).toBe(true);
  });
});
```

# CRITICAL RULES
- NO regex in store logic
- NO any types in store interfaces
- ALWAYS handle async errors properly
- ALWAYS reset state when needed
- ALWAYS use TypeScript strictly
- ALWAYS test store actions
- NO direct state mutations (use set function)
</file>

<file path="src/test/providers.tsx">
import React from 'react'
import { BrowserRouter } from 'react-router-dom'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'

interface ProvidersProps {
  children: React.ReactNode
  queryClient?: QueryClient
}

export function AllTheProviders({
  children,
  queryClient = new QueryClient({
    defaultOptions: {
      queries: { retry: false },
      mutations: { retry: false },
    },
  }),
}: ProvidersProps) {
  return (
    <QueryClientProvider client={queryClient}>
      <BrowserRouter>{children}</BrowserRouter>
    </QueryClientProvider>
  )
}
</file>

<file path="src/types/CLAUDE.md">
# TypeScript Conventions

# File Organization
```
types/
├── database.ts       # Supabase generated types
├── api.ts           # API request/response types
├── auth.ts          # Authentication types
├── billing.ts       # Payment/billing types
├── campaign.ts      # Campaign management types
├── call.ts          # Call tracking types
├── common.ts        # Shared/utility types
└── index.ts         # Export all types
```

# Database Type Generation
- Use Supabase CLI to generate types
- NEVER manually write database types
- Regenerate after schema changes

```bash
# Generate database types
npx supabase gen types typescript --project-id=your-project > src/types/database.ts
```

# Type Definition Patterns
```tsx
// Base entity interface
interface BaseEntity {
  id: string;
  created_at: string;
  updated_at: string;
}

// Extend base for specific entities
interface User extends BaseEntity {
  email: string;
  role: UserRole;
  profile: UserProfile;
}

// Union types for enums
type UserRole = 'supplier' | 'buyer' | 'admin';
type CallStatus = 'pending' | 'active' | 'completed' | 'failed';
```

# API Response Types
```tsx
// Generic API response wrapper
interface ApiResponse<T> {
  data: T;
  message?: string;
  success: boolean;
}

// Paginated response
interface PaginatedResponse<T> {
  data: T[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  };
}

// Error response
interface ApiError {
  message: string;
  code?: string;
  field?: string;
}
```

# Form & Validation Types
```tsx
// Form data types
interface LoginFormData {
  email: string;
  password: string;
}

// Validation schemas with Zod
import { z } from 'zod';

export const loginSchema = z.object({
  email: z.string().email('Invalid email'),
  password: z.string().min(8, 'Password must be at least 8 characters'),
});

export type LoginFormData = z.infer<typeof loginSchema>;
```

# Utility Types
```tsx
// Make specific fields optional
type PartialUser = Partial<Pick<User, 'name' | 'phone'>>;

// Omit sensitive fields
type PublicUser = Omit<User, 'password' | 'apiKey'>;

// Extract enum values from const objects
const CALL_STATUSES = {
  PENDING: 'pending',
  ACTIVE: 'active',
  COMPLETED: 'completed',
} as const;

type CallStatus = typeof CALL_STATUSES[keyof typeof CALL_STATUSES];
```

# React Component Types
```tsx
// Props interface
interface ComponentProps {
  title: string;
  isVisible?: boolean;
  onClose: () => void;
  children: React.ReactNode;
}

// Event handlers
type ClickHandler = (event: React.MouseEvent<HTMLButtonElement>) => void;
type ChangeHandler = (event: React.ChangeEvent<HTMLInputElement>) => void;

// Ref types
type InputRef = React.RefObject<HTMLInputElement>;
```

# Hook Return Types
```tsx
// Custom hook return types
interface UseApiResult<T> {
  data: T | null;
  loading: boolean;
  error: string | null;
  refetch: () => Promise<void>;
}

// Generic hook type
type UseApiHook<T> = (endpoint: string) => UseApiResult<T>;
```

# DCE-Specific Types

## Campaign Types
```tsx
interface Campaign extends BaseEntity {
  name: string;
  buyer_id: string;
  status: CampaignStatus;
  target_cpa: number;
  daily_budget: number;
  filters: CampaignFilters;
}

interface CampaignFilters {
  states?: string[];
  age_range?: [number, number];
  time_restrictions?: TimeRestriction[];
}
```

## Call Types
```tsx
interface Call extends BaseEntity {
  campaign_id: string;
  supplier_id: string;
  phone_number: string;
  duration: number;
  status: CallStatus;
  quality_score: number;
  payout_amount: number;
}
```

## Billing Types
```tsx
interface Transaction extends BaseEntity {
  amount: number;
  currency: string;
  type: TransactionType;
  status: PaymentStatus;
  stripe_payment_intent_id?: string;
}

type TransactionType = 'payout' | 'charge' | 'refund';
type PaymentStatus = 'pending' | 'succeeded' | 'failed';
```

# Type Guards
```tsx
// Runtime type checking
export function isUser(obj: unknown): obj is User {
  return (
    typeof obj === 'object' &&
    obj !== null &&
    'id' in obj &&
    'email' in obj &&
    'role' in obj
  );
}

// API response type guards
export function isApiError(response: unknown): response is ApiError {
  return (
    typeof response === 'object' &&
    response !== null &&
    'message' in response
  );
}
```

# Environment Variable Types
```tsx
interface ImportMetaEnv {
  readonly VITE_SUPABASE_URL: string;
  readonly VITE_SUPABASE_ANON_KEY: string;
  readonly VITE_STRIPE_PUBLIC_KEY: string;
  readonly VITE_SENTRY_DSN: string;
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}
```

# Type Export Strategy
```tsx
// index.ts - Central type exports
export type { User, UserRole } from './auth';
export type { Campaign, CampaignFilters } from './campaign';
export type { Call, CallStatus } from './call';
export type { ApiResponse, PaginatedResponse } from './api';

// Re-export database types
export type { Database } from './database';
```

# CRITICAL RULES
- NO any types anywhere
- NO regex in type definitions
- ALWAYS use strict TypeScript settings
- ALWAYS generate database types
- NEVER use unknown without type guards
- ALWAYS export types for reuse
- ALWAYS use proper generic constraints
- STRICT null checks enabled
- NO implicit any allowed
- USE exact types, avoid loose objects
</file>

<file path="src/types/database.ts">
export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]

export interface Database {
  public: {
    Tables: {
      users: {
        Row: {
          id: string
          email: string
          full_name: string | null
          phone: string | null
          user_type: 'supplier' | 'buyer' | 'admin'
          status: 'active' | 'suspended' | 'pending'
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: string
          email: string
          full_name?: string | null
          phone?: string | null
          user_type: 'supplier' | 'buyer' | 'admin'
          status?: 'active' | 'suspended' | 'pending'
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: string
          email?: string
          full_name?: string | null
          phone?: string | null
          user_type?: 'supplier' | 'buyer' | 'admin'
          status?: 'active' | 'suspended' | 'pending'
          created_at?: string
          updated_at?: string
        }
      }
      suppliers: {
        Row: {
          id: string
          user_id: string
          company_name: string
          traffic_type: string[]
          payment_method: string
          tax_id: string | null
          billing_address: Json
          status: string
          created_at: string
        }
        Insert: {
          id?: string
          user_id: string
          company_name: string
          traffic_type: string[]
          payment_method: string
          tax_id?: string | null
          billing_address: Json
          status?: string
          created_at?: string
        }
        Update: {
          id?: string
          user_id?: string
          company_name?: string
          traffic_type?: string[]
          payment_method?: string
          tax_id?: string | null
          billing_address?: Json
          status?: string
          created_at?: string
        }
      }
      buyers: {
        Row: {
          id: string
          user_id: string
          company_name: string
          industry: string
          billing_type: 'prepaid' | 'postpaid'
          credit_limit: number | null
          stripe_customer_id: string | null
          billing_email: string
          status: string
          created_at: string
        }
        Insert: {
          id?: string
          user_id: string
          company_name: string
          industry: string
          billing_type: 'prepaid' | 'postpaid'
          credit_limit?: number | null
          stripe_customer_id?: string | null
          billing_email: string
          status?: string
          created_at?: string
        }
        Update: {
          id?: string
          user_id?: string
          company_name?: string
          industry?: string
          billing_type?: 'prepaid' | 'postpaid'
          credit_limit?: number | null
          stripe_customer_id?: string | null
          billing_email?: string
          status?: string
          created_at?: string
        }
      }
      campaigns: {
        Row: {
          id: string
          supplier_id: string
          name: string
          status: 'active' | 'paused' | 'ended'
          payout_per_call: number
          min_duration: number
          allowed_states: string[] | null
          blocked_states: string[] | null
          hours_of_operation: Json
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: string
          supplier_id: string
          name: string
          status?: 'active' | 'paused' | 'ended'
          payout_per_call: number
          min_duration?: number
          allowed_states?: string[] | null
          blocked_states?: string[] | null
          hours_of_operation?: Json
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: string
          supplier_id?: string
          name?: string
          status?: 'active' | 'paused' | 'ended'
          payout_per_call?: number
          min_duration?: number
          allowed_states?: string[] | null
          blocked_states?: string[] | null
          hours_of_operation?: Json
          created_at?: string
          updated_at?: string
        }
      }
      buyer_campaigns: {
        Row: {
          id: string
          buyer_id: string
          name: string
          status: 'active' | 'paused' | 'ended'
          bid_amount: number
          daily_cap: number | null
          monthly_cap: number | null
          concurrency_cap: number | null
          target_criteria: Json
          ivr_settings: Json | null
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: string
          buyer_id: string
          name: string
          status?: 'active' | 'paused' | 'ended'
          bid_amount: number
          daily_cap?: number | null
          monthly_cap?: number | null
          concurrency_cap?: number | null
          target_criteria: Json
          ivr_settings?: Json | null
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: string
          buyer_id?: string
          name?: string
          status?: 'active' | 'paused' | 'ended'
          bid_amount?: number
          daily_cap?: number | null
          monthly_cap?: number | null
          concurrency_cap?: number | null
          target_criteria?: Json
          ivr_settings?: Json | null
          created_at?: string
          updated_at?: string
        }
      }
      tracking_numbers: {
        Row: {
          id: string
          number: string
          campaign_id: string
          status: 'active' | 'inactive' | 'porting'
          created_at: string
        }
        Insert: {
          id?: string
          number: string
          campaign_id: string
          status?: 'active' | 'inactive' | 'porting'
          created_at?: string
        }
        Update: {
          id?: string
          number?: string
          campaign_id?: string
          status?: 'active' | 'inactive' | 'porting'
          created_at?: string
        }
      }
      calls: {
        Row: {
          id: string
          campaign_id: string
          buyer_campaign_id: string | null
          tracking_number: string
          caller_number: string
          destination_number: string | null
          started_at: string
          ended_at: string | null
          duration_seconds: number | null
          payout_amount: number | null
          charge_amount: number | null
          status: string
          metadata: Json | null
          recording_url: string | null
        }
        Insert: {
          id?: string
          campaign_id: string
          buyer_campaign_id?: string | null
          tracking_number: string
          caller_number: string
          destination_number?: string | null
          started_at?: string
          ended_at?: string | null
          duration_seconds?: number | null
          payout_amount?: number | null
          charge_amount?: number | null
          status: string
          metadata?: Json | null
          recording_url?: string | null
        }
        Update: {
          id?: string
          campaign_id?: string
          buyer_campaign_id?: string | null
          tracking_number?: string
          caller_number?: string
          destination_number?: string | null
          started_at?: string
          ended_at?: string | null
          duration_seconds?: number | null
          payout_amount?: number | null
          charge_amount?: number | null
          status?: string
          metadata?: Json | null
          recording_url?: string | null
        }
      }
      payouts: {
        Row: {
          id: string
          supplier_id: string
          amount: number
          status: string
          period_start: string
          period_end: string
          transaction_id: string | null
          paid_at: string | null
          created_at: string
        }
        Insert: {
          id?: string
          supplier_id: string
          amount: number
          status: string
          period_start: string
          period_end: string
          transaction_id?: string | null
          paid_at?: string | null
          created_at?: string
        }
        Update: {
          id?: string
          supplier_id?: string
          amount?: number
          status?: string
          period_start?: string
          period_end?: string
          transaction_id?: string | null
          paid_at?: string | null
          created_at?: string
        }
      }
      invoices: {
        Row: {
          id: string
          buyer_id: string
          amount: number
          status: string
          period_start: string
          period_end: string
          due_date: string
          paid_at: string | null
          stripe_invoice_id: string | null
          created_at: string
        }
        Insert: {
          id?: string
          buyer_id: string
          amount: number
          status: string
          period_start: string
          period_end: string
          due_date: string
          paid_at?: string | null
          stripe_invoice_id?: string | null
          created_at?: string
        }
        Update: {
          id?: string
          buyer_id?: string
          amount?: number
          status?: string
          period_start?: string
          period_end?: string
          due_date?: string
          paid_at?: string | null
          stripe_invoice_id?: string | null
          created_at?: string
        }
      }
    }
    Views: {
      [_ in never]: never
    }
    Functions: {
      [_ in never]: never
    }
    Enums: {
      [_ in never]: never
    }
  }
}
</file>

<file path="src/utils/CLAUDE.md">
# Utility Functions

# File Organization

```
utils/
├── format.ts       # Data formatting utilities
├── validate.ts     # Validation helpers
├── date.ts        # Date/time utilities
├── string.ts      # String manipulation
├── number.ts      # Number utilities
├── crypto.ts      # Encryption/hashing
├── storage.ts     # Local/session storage
└── index.ts       # Export all utilities
```

# Formatting Utilities

```tsx
// format.ts
export function formatPhoneNumber(phone: string): string {
  const cleaned = phone.replace(/\D/g, '')
  if (cleaned.length !== 10) return phone

  return `(${cleaned.slice(0, 3)}) ${cleaned.slice(3, 6)}-${cleaned.slice(6)}`
}

export function formatCurrency(amount: number, currency = 'USD', locale = 'en-US'): string {
  return new Intl.NumberFormat(locale, {
    style: 'currency',
    currency,
  }).format(amount)
}

export function formatPercentage(value: number, decimals = 2): string {
  return `${(value * 100).toFixed(decimals)}%`
}
```

# Validation Helpers

```tsx
// validate.ts - NO REGEX ALLOWED
import { z } from 'zod'

export const phoneValidator = z
  .string()
  .transform((val) => val.replace(/\D/g, ''))
  .refine((val) => val.length === 10, {
    message: 'Phone number must be 10 digits',
  })

export const emailValidator = z.string().email()

export const urlValidator = z.string().url()

export function isValidPhone(phone: string): boolean {
  return phoneValidator.safeParse(phone).success
}

export function isValidEmail(email: string): boolean {
  return emailValidator.safeParse(email).success
}
```

# Date Utilities

```tsx
// date.ts
export function formatDate(
  date: Date | string,
  format: 'short' | 'long' | 'iso' = 'short'
): string {
  const d = new Date(date)

  switch (format) {
    case 'short':
      return d.toLocaleDateString('en-US')
    case 'long':
      return d.toLocaleDateString('en-US', {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric',
      })
    case 'iso':
      return d.toISOString()
  }
}

export function addDays(date: Date, days: number): Date {
  const result = new Date(date)
  result.setDate(result.getDate() + days)
  return result
}

export function getDateRange(period: 'today' | 'week' | 'month' | 'year'): {
  start: Date
  end: Date
} {
  const end = new Date()
  const start = new Date()

  switch (period) {
    case 'today':
      start.setHours(0, 0, 0, 0)
      break
    case 'week':
      start.setDate(start.getDate() - 7)
      break
    case 'month':
      start.setMonth(start.getMonth() - 1)
      break
    case 'year':
      start.setFullYear(start.getFullYear() - 1)
      break
  }

  return { start, end }
}
```

# String Utilities

```tsx
// string.ts - NO REGEX ALLOWED
export function truncate(str: string, maxLength: number): string {
  if (str.length <= maxLength) return str
  return str.slice(0, maxLength - 3) + '...'
}

export function capitalize(str: string): string {
  if (!str) return ''
  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase()
}

export function slugify(str: string): string {
  return str
    .toLowerCase()
    .trim()
    .replace(/\s+/g, '-')
    .replace(/[^\w\-]+/g, '')
    .replace(/\-\-+/g, '-')
}

export function extractInitials(name: string): string {
  return name
    .split(' ')
    .map((part) => part.charAt(0))
    .join('')
    .toUpperCase()
    .slice(0, 2)
}
```

# Number Utilities

```tsx
// number.ts
export function clamp(value: number, min: number, max: number): number {
  return Math.min(Math.max(value, min), max)
}

export function roundTo(value: number, decimals: number): number {
  const factor = Math.pow(10, decimals)
  return Math.round(value * factor) / factor
}

export function randomBetween(min: number, max: number): number {
  return Math.floor(Math.random() * (max - min + 1)) + min
}

export function calculatePercentage(value: number, total: number): number {
  if (total === 0) return 0
  return (value / total) * 100
}
```

# Crypto Utilities

```tsx
// crypto.ts
export async function hashValue(value: string): Promise<string> {
  const encoder = new TextEncoder()
  const data = encoder.encode(value)
  const hash = await crypto.subtle.digest('SHA-256', data)

  return Array.from(new Uint8Array(hash))
    .map((b) => b.toString(16).padStart(2, '0'))
    .join('')
}

export function generateId(): string {
  return crypto.randomUUID()
}

export function generateSecureToken(length = 32): string {
  const array = new Uint8Array(length)
  crypto.getRandomValues(array)

  return Array.from(array)
    .map((b) => b.toString(16).padStart(2, '0'))
    .join('')
}
```

# Storage Utilities

```tsx
// storage.ts
export const storage = {
  get<T>(key: string, defaultValue?: T): T | null {
    try {
      const item = localStorage.getItem(key)
      return item ? JSON.parse(item) : (defaultValue ?? null)
    } catch {
      return defaultValue ?? null
    }
  },

  set<T>(key: string, value: T): void {
    try {
      localStorage.setItem(key, JSON.stringify(value))
    } catch (error) {
      console.error('Storage error:', error)
    }
  },

  remove(key: string): void {
    localStorage.removeItem(key)
  },

  clear(): void {
    localStorage.clear()
  },
}

export const sessionStorage = {
  get<T>(key: string): T | null {
    try {
      const item = window.sessionStorage.getItem(key)
      return item ? JSON.parse(item) : null
    } catch {
      return null
    }
  },

  set<T>(key: string, value: T): void {
    window.sessionStorage.setItem(key, JSON.stringify(value))
  },
}
```

# Array Utilities

```tsx
export function groupBy<T, K extends keyof any>(array: T[], key: (item: T) => K): Record<K, T[]> {
  return array.reduce(
    (groups, item) => {
      const group = key(item)
      if (!groups[group]) groups[group] = []
      groups[group].push(item)
      return groups
    },
    {} as Record<K, T[]>
  )
}

export function unique<T>(array: T[]): T[] {
  return [...new Set(array)]
}

export function chunk<T>(array: T[], size: number): T[][] {
  const chunks: T[][] = []
  for (let i = 0; i < array.length; i += size) {
    chunks.push(array.slice(i, i + size))
  }
  return chunks
}
```

# DCE-Specific Utilities

## Call Duration Formatting

```tsx
export function formatCallDuration(seconds: number): string {
  const hours = Math.floor(seconds / 3600)
  const minutes = Math.floor((seconds % 3600) / 60)
  const secs = seconds % 60

  if (hours > 0) {
    return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`
  }
  return `${minutes}:${secs.toString().padStart(2, '0')}`
}
```

## Commission Calculation

```tsx
export function calculateCommission(amount: number, rate: number, minCommission = 0): number {
  const commission = amount * (rate / 100)
  return Math.max(commission, minCommission)
}
```

## Quality Score Calculation

```tsx
export function calculateQualityScore(
  duration: number,
  converted: boolean,
  fraudScore: number
): number {
  let score = 50 // Base score

  // Duration bonus
  if (duration > 120) score += 20
  else if (duration > 60) score += 10

  // Conversion bonus
  if (converted) score += 30

  // Fraud penalty
  score -= fraudScore * 10

  return clamp(score, 0, 100)
}
```

# Error Utilities

```tsx
export function getErrorMessage(error: unknown): string {
  if (error instanceof Error) return error.message
  if (typeof error === 'string') return error
  return 'An unknown error occurred'
}

export function isNetworkError(error: unknown): boolean {
  return (
    error instanceof Error && (error.message.includes('network') || error.message.includes('fetch'))
  )
}
```

# Type Guards

```tsx
export function isNotNull<T>(value: T | null): value is T {
  return value !== null
}

export function isDefined<T>(value: T | undefined): value is T {
  return value !== undefined
}

export function isString(value: unknown): value is string {
  return typeof value === 'string'
}

export function isNumber(value: unknown): value is number {
  return typeof value === 'number' && !isNaN(value)
}
```

# CRITICAL RULES

- NO regex patterns anywhere
- NO any types in utility functions
- ALWAYS use Zod for validation
- ALWAYS handle edge cases
- ALWAYS provide TypeScript types
- ALWAYS document complex utilities
- TEST all utility functions
- USE native APIs when available
- OPTIMIZE for performance
- KEEP utilities pure and side-effect free
</file>

<file path="src/App.tsx">
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { useEffect } from 'react'
import { useAuthStore } from './store/authStore'

// Layouts
import PublicLayout from './components/layout/PublicLayout'
import AppLayout from './components/layout/AppLayout'

// Public Pages
import HomePage from './pages/public/HomePage'
import LoginPage from './pages/auth/LoginPage'
import RegisterPage from './pages/auth/RegisterPage'
import ForgotPasswordPage from './pages/auth/ForgotPasswordPage'

// Authenticated Pages
import DashboardPage from './pages/dashboard/DashboardPage'
import CampaignsPage from './pages/campaigns/CampaignsPage'
import CallsPage from './pages/calls/CallsPage'
import ReportsPage from './pages/reports/ReportsPage'
import BillingPage from './pages/billing/BillingPage'
import SettingsPage from './pages/settings/SettingsPage'

// Protected Route Component
function ProtectedRoute({ children }: { children: React.ReactNode }) {
  const { user, loading } = useAuthStore()
  
  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-center">
          <div className="inline-flex items-center justify-center w-16 h-16 border-4 border-primary-600 border-t-transparent rounded-full animate-spin"></div>
          <p className="mt-4 text-gray-600">Loading...</p>
        </div>
      </div>
    )
  }
  
  if (!user) {
    return <Navigate to="/login" replace />
  }
  
  return <>{children}</>
}

// Create QueryClient instance
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5 minutes
      retry: 1,
    },
  },
})

function App() {
  const { checkSession } = useAuthStore()
  
  useEffect(() => {
    checkSession()
  }, [checkSession])

  return (
    <QueryClientProvider client={queryClient}>
      <Router>
        <Routes>
          {/* Public routes */}
          <Route path="/" element={<PublicLayout />}>
            <Route index element={<HomePage />} />
            <Route path="login" element={<LoginPage />} />
            <Route path="register" element={<RegisterPage />} />
            <Route path="forgot-password" element={<ForgotPasswordPage />} />
          </Route>
          
          {/* Protected app routes */}
          <Route path="/app" element={
            <ProtectedRoute>
              <AppLayout />
            </ProtectedRoute>
          }>
            <Route index element={<Navigate to="/app/dashboard" replace />} />
            <Route path="dashboard" element={<DashboardPage />} />
            <Route path="campaigns" element={<CampaignsPage />} />
            <Route path="calls" element={<CallsPage />} />
            <Route path="reports" element={<ReportsPage />} />
            <Route path="billing" element={<BillingPage />} />
            <Route path="settings" element={<SettingsPage />} />
          </Route>
          
          {/* Catch all */}
          <Route path="*" element={<Navigate to="/" replace />} />
        </Routes>
      </Router>
    </QueryClientProvider>
  )
}

export default App
</file>

<file path="src/CLAUDE.md">
# CRITICAL RULES (NON-NEGOTIABLE)
- **NEVER** use regex (no /pattern/, no new RegExp) - use validator.js or zod
- **NEVER** use 'any' type - always specify proper types  
- **ALWAYS** use flat ESLint config (eslint.config.js)
- **ALWAYS** fix TypeScript/ESLint errors immediately
- **ALWAYS** commit work every 30 minutes

## Source Code Directory

This directory contains the main application source code for the DCE platform.

### Key Subdirectories
- `components/` - React components organized by feature
- `pages/` - Page components for routing
- `hooks/` - Custom React hooks
- `lib/` - Shared utilities and Supabase client
- `integrations/` - Third-party service integrations
- `store/` - Zustand state management
- `types/` - TypeScript type definitions
- `utils/` - Utility functions

### Code Standards
- Use TypeScript strict mode
- Follow existing patterns in each directory
- Implement proper error boundaries
- Use Zod for all validation (NO REGEX)
- Replace all 'any' with proper types or 'unknown'
</file>

<file path="src/index.css">
@tailwind base;
@tailwind components;
@tailwind utilities;
</file>

<file path="src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="supabase/migrations/001_initial_schema.sql">
-- DCE Platform Initial Schema Migration
-- Creates core tables for the pay-per-call network platform

-- Enable required extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- Create enum types for better data integrity
CREATE TYPE user_status AS ENUM ('pending', 'active', 'suspended', 'banned');
CREATE TYPE campaign_status AS ENUM ('draft', 'active', 'paused', 'completed', 'cancelled');
CREATE TYPE call_status AS ENUM ('initiated', 'ringing', 'connected', 'completed', 'failed', 'rejected');
CREATE TYPE payout_status AS ENUM ('pending', 'processing', 'completed', 'failed', 'cancelled');
CREATE TYPE invoice_status AS ENUM ('draft', 'open', 'paid', 'overdue', 'cancelled');
CREATE TYPE dispute_status AS ENUM ('open', 'investigating', 'resolved', 'closed');

-- Core users table (extends Supabase auth.users)
CREATE TABLE users (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email VARCHAR(255) UNIQUE NOT NULL,
    phone VARCHAR(20),
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    avatar_url TEXT,
    metadata JSONB DEFAULT '{}',
    status user_status DEFAULT 'pending',
    is_active BOOLEAN DEFAULT true,
    last_login TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Create admins table
CREATE TABLE admins (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    role VARCHAR(50) DEFAULT 'admin',
    permissions JSONB DEFAULT '{}',
    is_active BOOLEAN DEFAULT true,
    appointed_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(user_id)
);

-- Suppliers table - traffic providers
CREATE TABLE suppliers (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    company_name VARCHAR(255) NOT NULL,
    business_type VARCHAR(100),
    tax_id VARCHAR(50),
    website_url TEXT,
    credit_balance DECIMAL(12,2) DEFAULT 0.00,
    minimum_payout DECIMAL(10,2) DEFAULT 50.00,
    payout_frequency VARCHAR(20) DEFAULT 'weekly', -- weekly, biweekly, monthly
    verification_data JSONB DEFAULT '{}',
    status user_status DEFAULT 'pending',
    settings JSONB DEFAULT '{}',
    approved_at TIMESTAMP WITH TIME ZONE,
    approved_by UUID REFERENCES admins(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(user_id)
);

-- Buyers table - advertisers
CREATE TABLE buyers (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    company_name VARCHAR(255) NOT NULL,
    business_type VARCHAR(100),
    tax_id VARCHAR(50),
    website_url TEXT,
    credit_limit DECIMAL(12,2) DEFAULT 0.00,
    current_balance DECIMAL(12,2) DEFAULT 0.00,
    auto_recharge_enabled BOOLEAN DEFAULT false,
    auto_recharge_threshold DECIMAL(10,2) DEFAULT 100.00,
    auto_recharge_amount DECIMAL(10,2) DEFAULT 500.00,
    verification_data JSONB DEFAULT '{}',
    status user_status DEFAULT 'pending',
    settings JSONB DEFAULT '{}',
    approved_at TIMESTAMP WITH TIME ZONE,
    approved_by UUID REFERENCES admins(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(user_id)
);

-- Campaigns table - supplier traffic campaigns
CREATE TABLE campaigns (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    supplier_id UUID REFERENCES suppliers(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    category VARCHAR(100),
    vertical VARCHAR(100),
    targeting JSONB DEFAULT '{}', -- geographic, demographic, time-based targeting
    routing_rules JSONB DEFAULT '{}', -- call routing configuration
    bid_floor DECIMAL(8,2) NOT NULL DEFAULT 0.00,
    max_concurrent_calls INTEGER DEFAULT 10,
    daily_cap INTEGER,
    monthly_cap INTEGER,
    tracking_numbers JSONB DEFAULT '[]',
    schedule JSONB DEFAULT '{}', -- operating hours and days
    status campaign_status DEFAULT 'draft',
    quality_threshold INTEGER DEFAULT 70, -- minimum quality score (1-100)
    fraud_detection_enabled BOOLEAN DEFAULT true,
    recording_enabled BOOLEAN DEFAULT true,
    call_timeout_seconds INTEGER DEFAULT 30,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Buyer campaigns table - buyer's purchasing criteria
CREATE TABLE buyer_campaigns (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    buyer_id UUID REFERENCES buyers(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    targeting_criteria JSONB DEFAULT '{}', -- what they want to buy
    max_bid DECIMAL(8,2) NOT NULL,
    daily_budget DECIMAL(10,2),
    monthly_budget DECIMAL(10,2),
    daily_cap INTEGER,
    monthly_cap INTEGER,
    schedule JSONB DEFAULT '{}', -- when they want calls
    quality_requirements JSONB DEFAULT '{}', -- minimum quality standards
    exclude_suppliers UUID[] DEFAULT '{}', -- blacklisted suppliers
    preferred_suppliers UUID[] DEFAULT '{}', -- preferred suppliers
    status campaign_status DEFAULT 'draft',
    auto_approval_enabled BOOLEAN DEFAULT false,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Tracking numbers table
CREATE TABLE tracking_numbers (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    campaign_id UUID REFERENCES campaigns(id) ON DELETE CASCADE,
    number VARCHAR(20) NOT NULL UNIQUE,
    display_number VARCHAR(20), -- formatted display version
    country_code VARCHAR(5) DEFAULT 'US',
    area_code VARCHAR(5),
    is_active BOOLEAN DEFAULT true,
    assigned_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Calls table - core transaction records
CREATE TABLE calls (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    campaign_id UUID REFERENCES campaigns(id) ON DELETE SET NULL,
    buyer_campaign_id UUID REFERENCES buyer_campaigns(id) ON DELETE SET NULL,
    tracking_number VARCHAR(20) NOT NULL,
    caller_number VARCHAR(20) NOT NULL,
    destination_number VARCHAR(20),
    caller_location JSONB, -- geo data from caller
    started_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    answered_at TIMESTAMP WITH TIME ZONE,
    ended_at TIMESTAMP WITH TIME ZONE,
    duration_seconds INTEGER DEFAULT 0,
    billable_seconds INTEGER DEFAULT 0,
    payout_amount DECIMAL(8,2) DEFAULT 0.00,
    charge_amount DECIMAL(8,2) DEFAULT 0.00,
    margin_amount DECIMAL(8,2) DEFAULT 0.00,
    status call_status DEFAULT 'initiated',
    disposition VARCHAR(50), -- outcome classification
    quality_score INTEGER, -- 1-100 quality rating
    fraud_score INTEGER, -- 1-100 fraud risk rating
    metadata JSONB DEFAULT '{}', -- additional call data
    recording_url TEXT,
    recording_duration INTEGER,
    call_flow JSONB DEFAULT '[]', -- step-by-step call progression
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Call logs table - detailed call events
CREATE TABLE call_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    call_id UUID REFERENCES calls(id) ON DELETE CASCADE,
    event_type VARCHAR(50) NOT NULL, -- dial, ring, answer, hangup, etc.
    event_data JSONB DEFAULT '{}',
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Financial tables
CREATE TABLE payouts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    supplier_id UUID REFERENCES suppliers(id) ON DELETE CASCADE,
    amount DECIMAL(12,2) NOT NULL,
    fee_amount DECIMAL(10,2) DEFAULT 0.00,
    net_amount DECIMAL(12,2) NOT NULL,
    status payout_status DEFAULT 'pending',
    period_start DATE NOT NULL,
    period_end DATE NOT NULL,
    payment_method VARCHAR(50), -- bank_transfer, paypal, check
    payment_details JSONB DEFAULT '{}',
    transaction_id VARCHAR(255),
    reference_number VARCHAR(100),
    notes TEXT,
    processed_at TIMESTAMP WITH TIME ZONE,
    paid_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    created_by UUID REFERENCES users(id)
);

CREATE TABLE invoices (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    buyer_id UUID REFERENCES buyers(id) ON DELETE CASCADE,
    invoice_number VARCHAR(50) UNIQUE NOT NULL,
    amount DECIMAL(12,2) NOT NULL,
    tax_amount DECIMAL(10,2) DEFAULT 0.00,
    total_amount DECIMAL(12,2) NOT NULL,
    status invoice_status DEFAULT 'draft',
    period_start DATE NOT NULL,
    period_end DATE NOT NULL,
    due_date DATE NOT NULL,
    payment_terms INTEGER DEFAULT 30, -- days
    stripe_invoice_id VARCHAR(255),
    stripe_payment_intent_id VARCHAR(255),
    payment_method VARCHAR(50),
    paid_at TIMESTAMP WITH TIME ZONE,
    notes TEXT,
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Invoice line items
CREATE TABLE invoice_line_items (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    invoice_id UUID REFERENCES invoices(id) ON DELETE CASCADE,
    description TEXT NOT NULL,
    quantity INTEGER DEFAULT 1,
    unit_price DECIMAL(10,4) NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    call_id UUID REFERENCES calls(id), -- reference to source call if applicable
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Quality and compliance tables
CREATE TABLE call_quality_scores (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    call_id UUID REFERENCES calls(id) ON DELETE CASCADE,
    duration_score INTEGER, -- 1-100 based on call duration
    intent_score INTEGER, -- 1-100 based on intent detection
    content_score INTEGER, -- 1-100 based on conversation analysis
    technical_score INTEGER, -- 1-100 based on audio quality
    overall_score INTEGER, -- weighted average
    scoring_model VARCHAR(50) DEFAULT 'v1.0',
    flags JSONB DEFAULT '[]', -- quality issues detected
    notes TEXT,
    reviewed_by UUID REFERENCES users(id),
    reviewed_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE disputes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    call_id UUID REFERENCES calls(id) ON DELETE CASCADE,
    raised_by UUID REFERENCES users(id) ON DELETE SET NULL,
    dispute_type VARCHAR(50) NOT NULL, -- quality, fraud, billing, etc.
    reason VARCHAR(255) NOT NULL,
    description TEXT,
    evidence JSONB DEFAULT '[]', -- supporting documents/data
    amount_disputed DECIMAL(8,2),
    status dispute_status DEFAULT 'open',
    priority VARCHAR(20) DEFAULT 'normal', -- low, normal, high, urgent
    assigned_to UUID REFERENCES users(id),
    resolution TEXT,
    resolution_notes TEXT,
    resolved_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    resolved_at TIMESTAMP WITH TIME ZONE
);

-- Analytics and reporting tables
CREATE TABLE campaign_stats (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    campaign_id UUID REFERENCES campaigns(id) ON DELETE CASCADE,
    date DATE NOT NULL,
    hour INTEGER, -- 0-23, null for daily stats
    calls_count INTEGER DEFAULT 0,
    connected_calls INTEGER DEFAULT 0,
    completed_calls INTEGER DEFAULT 0,
    total_duration INTEGER DEFAULT 0, -- seconds
    avg_duration DECIMAL(8,2) DEFAULT 0.00,
    total_payout DECIMAL(10,2) DEFAULT 0.00,
    avg_payout DECIMAL(8,2) DEFAULT 0.00,
    quality_score_avg DECIMAL(5,2),
    conversion_rate DECIMAL(5,4), -- percentage as decimal
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(campaign_id, date, hour)
);

CREATE TABLE buyer_campaign_stats (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    buyer_campaign_id UUID REFERENCES buyer_campaigns(id) ON DELETE CASCADE,
    date DATE NOT NULL,
    hour INTEGER, -- 0-23, null for daily stats
    calls_received INTEGER DEFAULT 0,
    calls_accepted INTEGER DEFAULT 0,
    calls_completed INTEGER DEFAULT 0,
    total_cost DECIMAL(10,2) DEFAULT 0.00,
    avg_cost DECIMAL(8,2) DEFAULT 0.00,
    total_duration INTEGER DEFAULT 0, -- seconds
    avg_duration DECIMAL(8,2) DEFAULT 0.00,
    conversions INTEGER DEFAULT 0,
    conversion_rate DECIMAL(5,4), -- percentage as decimal
    quality_score_avg DECIMAL(5,2),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(buyer_campaign_id, date, hour)
);

-- System audit log
CREATE TABLE audit_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    table_name VARCHAR(100) NOT NULL,
    operation VARCHAR(20) NOT NULL, -- INSERT, UPDATE, DELETE
    user_id UUID REFERENCES users(id) ON DELETE SET NULL,
    record_id UUID,
    old_data JSONB,
    new_data JSONB,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Create updated_at trigger function
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Apply updated_at triggers to relevant tables
CREATE TRIGGER update_users_updated_at 
    BEFORE UPDATE ON users 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_suppliers_updated_at 
    BEFORE UPDATE ON suppliers 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_buyers_updated_at 
    BEFORE UPDATE ON buyers 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_campaigns_updated_at 
    BEFORE UPDATE ON campaigns 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_buyer_campaigns_updated_at 
    BEFORE UPDATE ON buyer_campaigns 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_calls_updated_at 
    BEFORE UPDATE ON calls 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_invoices_updated_at 
    BEFORE UPDATE ON invoices 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_disputes_updated_at 
    BEFORE UPDATE ON disputes 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_campaign_stats_updated_at 
    BEFORE UPDATE ON campaign_stats 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_buyer_campaign_stats_updated_at 
    BEFORE UPDATE ON buyer_campaign_stats 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Create invoice number generation function
CREATE OR REPLACE FUNCTION generate_invoice_number()
RETURNS TRIGGER AS $$
DECLARE
    year_part TEXT;
    sequence_part TEXT;
BEGIN
    IF NEW.invoice_number IS NULL THEN
        year_part := EXTRACT(YEAR FROM NOW())::TEXT;
        
        SELECT LPAD(
            (COALESCE(MAX(
                CAST(
                    REGEXP_REPLACE(
                        invoice_number, 
                        '^INV-' || year_part || '-(\d+)$', 
                        '\1'
                    ) AS INTEGER
                )
            ), 0) + 1)::TEXT, 
            6, 
            '0'
        ) INTO sequence_part
        FROM invoices 
        WHERE invoice_number LIKE 'INV-' || year_part || '-%';
        
        NEW.invoice_number := 'INV-' || year_part || '-' || sequence_part;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Apply invoice number generation trigger
CREATE TRIGGER generate_invoice_number_trigger
    BEFORE INSERT ON invoices
    FOR EACH ROW EXECUTE FUNCTION generate_invoice_number();

-- Comments for documentation
COMMENT ON TABLE users IS 'Core user accounts that extend Supabase auth.users';
COMMENT ON TABLE suppliers IS 'Traffic providers who generate calls';
COMMENT ON TABLE buyers IS 'Advertisers who purchase call leads';
COMMENT ON TABLE campaigns IS 'Supplier traffic campaigns with targeting and routing';
COMMENT ON TABLE buyer_campaigns IS 'Buyer purchasing criteria and budgets';
COMMENT ON TABLE calls IS 'Core call transaction records with billing data';
COMMENT ON TABLE payouts IS 'Supplier payment records';
COMMENT ON TABLE invoices IS 'Buyer billing records';
COMMENT ON TABLE call_quality_scores IS 'Quality assessment for each call';
COMMENT ON TABLE disputes IS 'Quality and billing disputes';
COMMENT ON TABLE campaign_stats IS 'Hourly and daily campaign performance metrics';
COMMENT ON TABLE buyer_campaign_stats IS 'Hourly and daily buyer campaign performance';
COMMENT ON TABLE audit_logs IS 'System audit trail for compliance';
</file>

<file path="supabase/migrations/002_security_policies.sql">
-- DCE Platform Row Level Security Policies
-- Implements comprehensive RLS policies for data security and privacy

-- Enable RLS on all tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE admins ENABLE ROW LEVEL SECURITY;
ALTER TABLE suppliers ENABLE ROW LEVEL SECURITY;
ALTER TABLE buyers ENABLE ROW LEVEL SECURITY;
ALTER TABLE campaigns ENABLE ROW LEVEL SECURITY;
ALTER TABLE buyer_campaigns ENABLE ROW LEVEL SECURITY;
ALTER TABLE tracking_numbers ENABLE ROW LEVEL SECURITY;
ALTER TABLE calls ENABLE ROW LEVEL SECURITY;
ALTER TABLE call_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE payouts ENABLE ROW LEVEL SECURITY;
ALTER TABLE invoices ENABLE ROW LEVEL SECURITY;
ALTER TABLE invoice_line_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE call_quality_scores ENABLE ROW LEVEL SECURITY;
ALTER TABLE disputes ENABLE ROW LEVEL SECURITY;
ALTER TABLE campaign_stats ENABLE ROW LEVEL SECURITY;
ALTER TABLE buyer_campaign_stats ENABLE ROW LEVEL SECURITY;
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;

-- Helper function to check if user is admin
CREATE OR REPLACE FUNCTION is_admin(user_uuid UUID DEFAULT auth.uid())
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM admins 
        WHERE user_id = user_uuid AND is_active = true
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Helper function to check if user is supplier
CREATE OR REPLACE FUNCTION is_supplier(user_uuid UUID DEFAULT auth.uid())
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM suppliers 
        WHERE user_id = user_uuid AND status = 'active'
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Helper function to check if user is buyer
CREATE OR REPLACE FUNCTION is_buyer(user_uuid UUID DEFAULT auth.uid())
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM buyers 
        WHERE user_id = user_uuid AND status = 'active'
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Helper function to get supplier ID for current user
CREATE OR REPLACE FUNCTION get_supplier_id(user_uuid UUID DEFAULT auth.uid())
RETURNS UUID AS $$
BEGIN
    RETURN (
        SELECT id FROM suppliers 
        WHERE user_id = user_uuid AND status = 'active'
        LIMIT 1
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Helper function to get buyer ID for current user
CREATE OR REPLACE FUNCTION get_buyer_id(user_uuid UUID DEFAULT auth.uid())
RETURNS UUID AS $$
BEGIN
    RETURN (
        SELECT id FROM buyers 
        WHERE user_id = user_uuid AND status = 'active'
        LIMIT 1
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ================================
-- USERS TABLE POLICIES
-- ================================

-- Users can view their own profile and basic info of others (for collaboration)
CREATE POLICY "users_select_policy" ON users
    FOR SELECT USING (
        auth.uid() = id OR -- Own profile
        is_admin() OR -- Admins can see all
        EXISTS ( -- Users involved in same calls can see basic info
            SELECT 1 FROM calls c
            JOIN campaigns camp ON c.campaign_id = camp.id
            JOIN suppliers s ON camp.supplier_id = s.id
            WHERE s.user_id = users.id OR c.buyer_campaign_id IN (
                SELECT bc.id FROM buyer_campaigns bc
                JOIN buyers b ON bc.buyer_id = b.id
                WHERE b.user_id = auth.uid()
            )
        )
    );

-- Users can only update their own profile
CREATE POLICY "users_update_policy" ON users
    FOR UPDATE USING (auth.uid() = id);

-- ================================
-- ADMIN TABLE POLICIES
-- ================================

-- Only admins can see admin records
CREATE POLICY "admins_select_policy" ON admins
    FOR SELECT USING (is_admin());

-- Only super admins can modify admin records
CREATE POLICY "admins_modify_policy" ON admins
    FOR ALL USING (
        is_admin() AND EXISTS (
            SELECT 1 FROM admins 
            WHERE user_id = auth.uid() 
            AND (permissions->>'super_admin')::boolean = true
        )
    );

-- ================================
-- SUPPLIERS TABLE POLICIES
-- ================================

-- Suppliers can see their own profile, buyers can see suppliers they work with
CREATE POLICY "suppliers_select_policy" ON suppliers
    FOR SELECT USING (
        user_id = auth.uid() OR -- Own profile
        is_admin() OR -- Admin access
        (is_buyer() AND EXISTS ( -- Buyers can see suppliers they've received calls from
            SELECT 1 FROM calls c
            JOIN campaigns camp ON c.campaign_id = camp.id
            WHERE camp.supplier_id = suppliers.id
            AND c.buyer_campaign_id IN (
                SELECT bc.id FROM buyer_campaigns bc
                WHERE bc.buyer_id = get_buyer_id()
            )
        ))
    );

-- Suppliers can update their own profile
CREATE POLICY "suppliers_update_policy" ON suppliers
    FOR UPDATE USING (user_id = auth.uid());

-- Admins can insert/delete suppliers
CREATE POLICY "suppliers_admin_policy" ON suppliers
    FOR ALL USING (is_admin());

-- ================================
-- BUYERS TABLE POLICIES
-- ================================

-- Buyers can see their own profile, suppliers can see buyers they work with
CREATE POLICY "buyers_select_policy" ON buyers
    FOR SELECT USING (
        user_id = auth.uid() OR -- Own profile
        is_admin() OR -- Admin access
        (is_supplier() AND EXISTS ( -- Suppliers can see buyers who've received their calls
            SELECT 1 FROM calls c
            JOIN buyer_campaigns bc ON c.buyer_campaign_id = bc.id
            WHERE bc.buyer_id = buyers.id
            AND c.campaign_id IN (
                SELECT camp.id FROM campaigns camp
                WHERE camp.supplier_id = get_supplier_id()
            )
        ))
    );

-- Buyers can update their own profile
CREATE POLICY "buyers_update_policy" ON buyers
    FOR UPDATE USING (user_id = auth.uid());

-- Admins can insert/delete buyers
CREATE POLICY "buyers_admin_policy" ON buyers
    FOR ALL USING (is_admin());

-- ================================
-- CAMPAIGNS TABLE POLICIES
-- ================================

-- Suppliers see their own campaigns, buyers see campaigns they can bid on or have worked with
CREATE POLICY "campaigns_select_policy" ON campaigns
    FOR SELECT USING (
        (is_supplier() AND supplier_id = get_supplier_id()) OR -- Own campaigns
        is_admin() OR -- Admin access
        (is_buyer() AND ( -- Buyers can see active campaigns or those they've worked with
            (status = 'active' AND EXISTS (
                SELECT 1 FROM buyer_campaigns bc
                WHERE bc.buyer_id = get_buyer_id()
                AND bc.status = 'active'
            )) OR
            EXISTS (
                SELECT 1 FROM calls c
                JOIN buyer_campaigns bc ON c.buyer_campaign_id = bc.id
                WHERE c.campaign_id = campaigns.id
                AND bc.buyer_id = get_buyer_id()
            )
        ))
    );

-- Suppliers can modify their own campaigns
CREATE POLICY "campaigns_modify_policy" ON campaigns
    FOR ALL USING (
        (is_supplier() AND supplier_id = get_supplier_id()) OR
        is_admin()
    );

-- ================================
-- BUYER CAMPAIGNS TABLE POLICIES
-- ================================

-- Buyers see their own campaigns, suppliers see campaigns that match their traffic
CREATE POLICY "buyer_campaigns_select_policy" ON buyer_campaigns
    FOR SELECT USING (
        (is_buyer() AND buyer_id = get_buyer_id()) OR -- Own campaigns
        is_admin() OR -- Admin access
        (is_supplier() AND ( -- Suppliers can see active buyer campaigns they could match
            status = 'active' OR
            EXISTS (
                SELECT 1 FROM calls c
                JOIN campaigns camp ON c.campaign_id = camp.id
                WHERE c.buyer_campaign_id = buyer_campaigns.id
                AND camp.supplier_id = get_supplier_id()
            )
        ))
    );

-- Buyers can modify their own campaigns
CREATE POLICY "buyer_campaigns_modify_policy" ON buyer_campaigns
    FOR ALL USING (
        (is_buyer() AND buyer_id = get_buyer_id()) OR
        is_admin()
    );

-- ================================
-- TRACKING NUMBERS TABLE POLICIES
-- ================================

-- Access tied to campaign ownership
CREATE POLICY "tracking_numbers_policy" ON tracking_numbers
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM campaigns c
            WHERE c.id = tracking_numbers.campaign_id
            AND ((is_supplier() AND c.supplier_id = get_supplier_id()) OR is_admin())
        )
    );

-- ================================
-- CALLS TABLE POLICIES
-- ================================

-- Most complex policy - suppliers see their calls, buyers see calls they received
CREATE POLICY "calls_select_policy" ON calls
    FOR SELECT USING (
        is_admin() OR -- Admin access
        EXISTS (
            SELECT 1 FROM campaigns camp
            WHERE camp.id = calls.campaign_id
            AND camp.supplier_id = get_supplier_id()
        ) OR -- Supplier's calls
        EXISTS (
            SELECT 1 FROM buyer_campaigns bc
            WHERE bc.id = calls.buyer_campaign_id
            AND bc.buyer_id = get_buyer_id()
        ) -- Buyer's calls
    );

-- System can insert calls, admins can modify
CREATE POLICY "calls_insert_policy" ON calls
    FOR INSERT WITH CHECK (true); -- Allow system inserts

CREATE POLICY "calls_update_policy" ON calls
    FOR UPDATE USING (
        is_admin() OR
        EXISTS (
            SELECT 1 FROM campaigns camp
            WHERE camp.id = calls.campaign_id
            AND camp.supplier_id = get_supplier_id()
        ) OR
        EXISTS (
            SELECT 1 FROM buyer_campaigns bc
            WHERE bc.id = calls.buyer_campaign_id
            AND bc.buyer_id = get_buyer_id()
        )
    );

-- ================================
-- CALL LOGS TABLE POLICIES
-- ================================

-- Access based on call ownership
CREATE POLICY "call_logs_policy" ON call_logs
    FOR ALL USING (
        is_admin() OR
        EXISTS (
            SELECT 1 FROM calls c
            JOIN campaigns camp ON c.campaign_id = camp.id
            WHERE c.id = call_logs.call_id
            AND camp.supplier_id = get_supplier_id()
        ) OR
        EXISTS (
            SELECT 1 FROM calls c
            JOIN buyer_campaigns bc ON c.buyer_campaign_id = bc.id
            WHERE c.id = call_logs.call_id
            AND bc.buyer_id = get_buyer_id()
        )
    );

-- ================================
-- FINANCIAL TABLE POLICIES
-- ================================

-- Payouts - suppliers see their own, admins see all
CREATE POLICY "payouts_select_policy" ON payouts
    FOR SELECT USING (
        (is_supplier() AND supplier_id = get_supplier_id()) OR
        is_admin()
    );

CREATE POLICY "payouts_admin_policy" ON payouts
    FOR ALL USING (is_admin());

-- Invoices - buyers see their own, admins see all
CREATE POLICY "invoices_select_policy" ON invoices
    FOR SELECT USING (
        (is_buyer() AND buyer_id = get_buyer_id()) OR
        is_admin()
    );

CREATE POLICY "invoices_admin_policy" ON invoices
    FOR ALL USING (is_admin());

-- Invoice line items - tied to invoice access
CREATE POLICY "invoice_line_items_policy" ON invoice_line_items
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM invoices i
            WHERE i.id = invoice_line_items.invoice_id
            AND ((is_buyer() AND i.buyer_id = get_buyer_id()) OR is_admin())
        )
    );

-- ================================
-- QUALITY & COMPLIANCE POLICIES
-- ================================

-- Quality scores - tied to call access
CREATE POLICY "call_quality_scores_select_policy" ON call_quality_scores
    FOR SELECT USING (
        is_admin() OR
        EXISTS (
            SELECT 1 FROM calls c
            JOIN campaigns camp ON c.campaign_id = camp.id
            WHERE c.id = call_quality_scores.call_id
            AND camp.supplier_id = get_supplier_id()
        ) OR
        EXISTS (
            SELECT 1 FROM calls c
            JOIN buyer_campaigns bc ON c.buyer_campaign_id = bc.id
            WHERE c.id = call_quality_scores.call_id
            AND bc.buyer_id = get_buyer_id()
        )
    );

-- Admin and system can modify quality scores
CREATE POLICY "call_quality_scores_modify_policy" ON call_quality_scores
    FOR ALL USING (is_admin());

-- Disputes - parties involved can see/create, admins manage
CREATE POLICY "disputes_select_policy" ON disputes
    FOR SELECT USING (
        raised_by = auth.uid() OR -- Dispute creator
        assigned_to = auth.uid() OR -- Assigned handler
        is_admin() OR -- Admin access
        EXISTS (
            SELECT 1 FROM calls c
            JOIN campaigns camp ON c.campaign_id = camp.id
            WHERE c.id = disputes.call_id
            AND camp.supplier_id = get_supplier_id()
        ) OR
        EXISTS (
            SELECT 1 FROM calls c
            JOIN buyer_campaigns bc ON c.buyer_campaign_id = bc.id
            WHERE c.id = disputes.call_id
            AND bc.buyer_id = get_buyer_id()
        )
    );

-- Users can create disputes for their calls
CREATE POLICY "disputes_insert_policy" ON disputes
    FOR INSERT WITH CHECK (
        raised_by = auth.uid() AND
        EXISTS (
            SELECT 1 FROM calls c
            WHERE c.id = call_id
            AND (
                EXISTS (
                    SELECT 1 FROM campaigns camp
                    WHERE camp.id = c.campaign_id
                    AND camp.supplier_id = get_supplier_id()
                ) OR
                EXISTS (
                    SELECT 1 FROM buyer_campaigns bc
                    WHERE bc.id = c.buyer_campaign_id
                    AND bc.buyer_id = get_buyer_id()
                )
            )
        )
    );

-- Admins can update disputes
CREATE POLICY "disputes_update_policy" ON disputes
    FOR UPDATE USING (is_admin());

-- ================================
-- ANALYTICS TABLE POLICIES
-- ================================

-- Campaign stats - tied to campaign ownership
CREATE POLICY "campaign_stats_policy" ON campaign_stats
    FOR ALL USING (
        is_admin() OR
        EXISTS (
            SELECT 1 FROM campaigns c
            WHERE c.id = campaign_stats.campaign_id
            AND c.supplier_id = get_supplier_id()
        )
    );

-- Buyer campaign stats - tied to buyer campaign ownership
CREATE POLICY "buyer_campaign_stats_policy" ON buyer_campaign_stats
    FOR ALL USING (
        is_admin() OR
        EXISTS (
            SELECT 1 FROM buyer_campaigns bc
            WHERE bc.id = buyer_campaign_stats.buyer_campaign_id
            AND bc.buyer_id = get_buyer_id()
        )
    );

-- ================================
-- AUDIT LOG POLICIES
-- ================================

-- Audit logs - users can see their own actions, admins see all
CREATE POLICY "audit_logs_select_policy" ON audit_logs
    FOR SELECT USING (
        user_id = auth.uid() OR
        is_admin()
    );

-- System can insert audit logs
CREATE POLICY "audit_logs_insert_policy" ON audit_logs
    FOR INSERT WITH CHECK (true);

-- Only admins can modify audit logs
CREATE POLICY "audit_logs_admin_policy" ON audit_logs
    FOR UPDATE USING (is_admin());

-- No deletion of audit logs
CREATE POLICY "audit_logs_no_delete" ON audit_logs
    FOR DELETE USING (false);

-- ================================
-- FUNCTION SECURITY
-- ================================

-- Grant execute permissions to authenticated users
GRANT EXECUTE ON FUNCTION is_admin(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION is_supplier(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION is_buyer(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION get_supplier_id(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION get_buyer_id(UUID) TO authenticated;

-- Comments for documentation
COMMENT ON FUNCTION is_admin IS 'Check if user has admin privileges';
COMMENT ON FUNCTION is_supplier IS 'Check if user is an active supplier';
COMMENT ON FUNCTION is_buyer IS 'Check if user is an active buyer';
COMMENT ON FUNCTION get_supplier_id IS 'Get supplier ID for user';
COMMENT ON FUNCTION get_buyer_id IS 'Get buyer ID for user';
</file>

<file path="supabase/migrations/003_functions.sql">
-- DCE Platform Database Functions
-- Business logic functions for calculations, validations, and data processing

-- ================================
-- BALANCE CALCULATION FUNCTIONS
-- ================================

-- Function to calculate supplier balance
CREATE OR REPLACE FUNCTION calculate_supplier_balance(supplier_uuid UUID)
RETURNS DECIMAL AS $$
DECLARE
    total_earnings DECIMAL;
    total_payouts DECIMAL;
BEGIN
    -- Sum all completed call payouts
    SELECT COALESCE(SUM(payout_amount), 0) INTO total_earnings
    FROM calls c
    JOIN campaigns camp ON c.campaign_id = camp.id
    WHERE camp.supplier_id = supplier_uuid 
    AND c.status = 'completed';
    
    -- Sum all completed payouts
    SELECT COALESCE(SUM(amount), 0) INTO total_payouts
    FROM payouts
    WHERE supplier_id = supplier_uuid 
    AND status = 'completed';
    
    RETURN total_earnings - total_payouts;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to calculate buyer balance (credit remaining)
CREATE OR REPLACE FUNCTION calculate_buyer_balance(buyer_uuid UUID)
RETURNS DECIMAL AS $$
DECLARE
    credit_limit DECIMAL;
    total_charges DECIMAL;
    total_payments DECIMAL;
BEGIN
    -- Get credit limit
    SELECT buyers.credit_limit INTO credit_limit
    FROM buyers
    WHERE id = buyer_uuid;
    
    -- Sum all completed call charges
    SELECT COALESCE(SUM(charge_amount), 0) INTO total_charges
    FROM calls c
    JOIN buyer_campaigns bc ON c.buyer_campaign_id = bc.id
    WHERE bc.buyer_id = buyer_uuid 
    AND c.status = 'completed';
    
    -- Sum all paid invoices
    SELECT COALESCE(SUM(total_amount), 0) INTO total_payments
    FROM invoices
    WHERE buyer_id = buyer_uuid 
    AND status = 'paid';
    
    RETURN credit_limit + total_payments - total_charges;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ================================
-- QUALITY SCORING FUNCTIONS
-- ================================

-- Function to calculate call quality score
CREATE OR REPLACE FUNCTION calculate_quality_score(
    call_duration INTEGER,
    call_metadata JSONB DEFAULT '{}'
)
RETURNS INTEGER AS $$
DECLARE
    duration_score INTEGER := 0;
    intent_score INTEGER := 70; -- default
    technical_score INTEGER := 85; -- default
    overall_score INTEGER;
BEGIN
    -- Duration scoring (0-100)
    CASE 
        WHEN call_duration >= 120 THEN duration_score := 100; -- 2+ minutes
        WHEN call_duration >= 60 THEN duration_score := 80;   -- 1-2 minutes
        WHEN call_duration >= 30 THEN duration_score := 60;   -- 30-60 seconds
        WHEN call_duration >= 15 THEN duration_score := 40;   -- 15-30 seconds
        ELSE duration_score := 20; -- under 15 seconds
    END CASE;
    
    -- Extract scores from metadata if available
    IF call_metadata ? 'intent_score' THEN
        intent_score := (call_metadata->>'intent_score')::INTEGER;
    END IF;
    
    IF call_metadata ? 'technical_score' THEN
        technical_score := (call_metadata->>'technical_score')::INTEGER;
    END IF;
    
    -- Weighted average: duration 40%, intent 40%, technical 20%
    overall_score := ROUND(
        (duration_score * 0.4 + intent_score * 0.4 + technical_score * 0.2)
    );
    
    -- Ensure score is within bounds
    overall_score := GREATEST(0, LEAST(100, overall_score));
    
    RETURN overall_score;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to detect fraud indicators
CREATE OR REPLACE FUNCTION detect_fraud_indicators(
    caller_number VARCHAR(20),
    call_duration INTEGER,
    caller_location JSONB DEFAULT '{}',
    call_metadata JSONB DEFAULT '{}'
)
RETURNS JSONB AS $$
DECLARE
    fraud_flags JSONB := '[]';
    fraud_score INTEGER := 0;
    recent_calls INTEGER;
BEGIN
    -- Check for rapid repeat calls from same number
    SELECT COUNT(*) INTO recent_calls
    FROM calls
    WHERE caller_number = detect_fraud_indicators.caller_number
    AND started_at > NOW() - INTERVAL '1 hour';
    
    IF recent_calls > 5 THEN
        fraud_flags := fraud_flags || '["rapid_repeat_calls"]'::jsonb;
        fraud_score := fraud_score + 30;
    END IF;
    
    -- Check for very short call duration
    IF call_duration < 10 THEN
        fraud_flags := fraud_flags || '["extremely_short_duration"]'::jsonb;
        fraud_score := fraud_score + 25;
    END IF;
    
    -- Check for suspicious geographic patterns
    IF caller_location ? 'country' AND (caller_location->>'country') != 'US' THEN
        fraud_flags := fraud_flags || '["international_caller"]'::jsonb;
        fraud_score := fraud_score + 20;
    END IF;
    
    -- Check for invalid phone number patterns
    IF caller_number ~ '^1?(000|111|222|333|444|555|666|777|888|999)' THEN
        fraud_flags := fraud_flags || '["suspicious_number_pattern"]'::jsonb;
        fraud_score := fraud_score + 40;
    END IF;
    
    -- Return fraud analysis
    RETURN jsonb_build_object(
        'fraud_score', LEAST(100, fraud_score),
        'flags', fraud_flags,
        'suspicious', fraud_score > 50
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ================================
-- CAMPAIGN MATCHING FUNCTIONS
-- ================================

-- Function to find matching buyer campaigns for a call
CREATE OR REPLACE FUNCTION find_matching_buyer_campaigns(
    supplier_campaign_id UUID,
    caller_location JSONB DEFAULT '{}',
    call_time TIMESTAMP WITH TIME ZONE DEFAULT NOW()
)
RETURNS TABLE(
    buyer_campaign_id UUID,
    buyer_id UUID,
    max_bid DECIMAL,
    match_score INTEGER
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        bc.id as buyer_campaign_id,
        bc.buyer_id,
        bc.max_bid,
        100 as match_score -- Simplified scoring, can be enhanced
    FROM buyer_campaigns bc
    JOIN buyers b ON bc.buyer_id = b.id
    JOIN campaigns c ON c.id = supplier_campaign_id
    WHERE bc.status = 'active'
    AND b.status = 'active'
    AND bc.max_bid >= c.bid_floor
    -- Add time-based matching
    AND (
        bc.schedule IS NULL OR
        (bc.schedule->>'enabled')::boolean = false OR
        (
            EXTRACT(hour FROM call_time) >= (bc.schedule->>'start_hour')::integer AND
            EXTRACT(hour FROM call_time) <= (bc.schedule->>'end_hour')::integer
        )
    )
    -- Add budget checks
    AND (
        bc.daily_budget IS NULL OR
        COALESCE((
            SELECT SUM(charge_amount)
            FROM calls calls_today
            WHERE calls_today.buyer_campaign_id = bc.id
            AND calls_today.started_at::date = call_time::date
        ), 0) + bc.max_bid <= bc.daily_budget
    )
    ORDER BY bc.max_bid DESC, match_score DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ================================
-- BILLING CALCULATION FUNCTIONS
-- ================================

-- Function to calculate call billing amounts
CREATE OR REPLACE FUNCTION calculate_call_billing(
    campaign_id UUID,
    buyer_campaign_id UUID,
    call_duration INTEGER,
    quality_score INTEGER
)
RETURNS JSONB AS $$
DECLARE
    bid_floor DECIMAL;
    max_bid DECIMAL;
    payout_amount DECIMAL;
    charge_amount DECIMAL;
    margin_amount DECIMAL;
    quality_multiplier DECIMAL := 1.0;
BEGIN
    -- Get campaign bid floor and buyer max bid
    SELECT c.bid_floor INTO bid_floor
    FROM campaigns c WHERE c.id = campaign_id;
    
    SELECT bc.max_bid INTO max_bid
    FROM buyer_campaigns bc WHERE bc.id = buyer_campaign_id;
    
    -- Apply quality score multiplier
    CASE 
        WHEN quality_score >= 90 THEN quality_multiplier := 1.1;  -- 10% bonus
        WHEN quality_score >= 80 THEN quality_multiplier := 1.0;  -- full amount
        WHEN quality_score >= 70 THEN quality_multiplier := 0.9;  -- 10% reduction
        WHEN quality_score >= 60 THEN quality_multiplier := 0.8;  -- 20% reduction
        ELSE quality_multiplier := 0.5; -- 50% reduction for poor quality
    END CASE;
    
    -- Calculate amounts
    payout_amount := bid_floor * quality_multiplier;
    charge_amount := max_bid * quality_multiplier;
    margin_amount := charge_amount - payout_amount;
    
    -- Ensure positive amounts
    payout_amount := GREATEST(0, payout_amount);
    charge_amount := GREATEST(payout_amount, charge_amount);
    margin_amount := charge_amount - payout_amount;
    
    RETURN jsonb_build_object(
        'payout_amount', payout_amount,
        'charge_amount', charge_amount,
        'margin_amount', margin_amount,
        'quality_multiplier', quality_multiplier
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ================================
-- STATS AGGREGATION FUNCTIONS
-- ================================

-- Function to process hourly campaign stats
CREATE OR REPLACE FUNCTION process_hourly_stats(target_hour TIMESTAMP WITH TIME ZONE DEFAULT DATE_TRUNC('hour', NOW() - INTERVAL '1 hour'))
RETURNS void AS $$
BEGIN
    -- Update campaign stats
    INSERT INTO campaign_stats (
        campaign_id, date, hour, calls_count, connected_calls, 
        completed_calls, total_duration, avg_duration, total_payout, avg_payout, quality_score_avg
    )
    SELECT 
        campaign_id,
        target_hour::date as date,
        EXTRACT(HOUR FROM target_hour)::integer as hour,
        COUNT(*) as calls_count,
        COUNT(CASE WHEN status IN ('connected', 'completed') THEN 1 END) as connected_calls,
        COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_calls,
        COALESCE(SUM(duration_seconds), 0) as total_duration,
        COALESCE(AVG(duration_seconds), 0) as avg_duration,
        COALESCE(SUM(payout_amount), 0) as total_payout,
        COALESCE(AVG(payout_amount), 0) as avg_payout,
        AVG(quality_score) as quality_score_avg
    FROM calls
    WHERE started_at >= target_hour 
    AND started_at < target_hour + INTERVAL '1 hour'
    AND campaign_id IS NOT NULL
    GROUP BY campaign_id
    ON CONFLICT (campaign_id, date, hour) 
    DO UPDATE SET
        calls_count = EXCLUDED.calls_count,
        connected_calls = EXCLUDED.connected_calls,
        completed_calls = EXCLUDED.completed_calls,
        total_duration = EXCLUDED.total_duration,
        avg_duration = EXCLUDED.avg_duration,
        total_payout = EXCLUDED.total_payout,
        avg_payout = EXCLUDED.avg_payout,
        quality_score_avg = EXCLUDED.quality_score_avg,
        updated_at = NOW();
    
    -- Update buyer campaign stats
    INSERT INTO buyer_campaign_stats (
        buyer_campaign_id, date, hour, calls_received, calls_accepted, 
        calls_completed, total_cost, avg_cost, total_duration, avg_duration, quality_score_avg
    )
    SELECT 
        buyer_campaign_id,
        target_hour::date as date,
        EXTRACT(HOUR FROM target_hour)::integer as hour,
        COUNT(*) as calls_received,
        COUNT(CASE WHEN status IN ('connected', 'completed') THEN 1 END) as calls_accepted,
        COUNT(CASE WHEN status = 'completed' THEN 1 END) as calls_completed,
        COALESCE(SUM(charge_amount), 0) as total_cost,
        COALESCE(AVG(charge_amount), 0) as avg_cost,
        COALESCE(SUM(duration_seconds), 0) as total_duration,
        COALESCE(AVG(duration_seconds), 0) as avg_duration,
        AVG(quality_score) as quality_score_avg
    FROM calls
    WHERE started_at >= target_hour 
    AND started_at < target_hour + INTERVAL '1 hour'
    AND buyer_campaign_id IS NOT NULL
    GROUP BY buyer_campaign_id
    ON CONFLICT (buyer_campaign_id, date, hour) 
    DO UPDATE SET
        calls_received = EXCLUDED.calls_received,
        calls_accepted = EXCLUDED.calls_accepted,
        calls_completed = EXCLUDED.calls_completed,
        total_cost = EXCLUDED.total_cost,
        avg_cost = EXCLUDED.avg_cost,
        total_duration = EXCLUDED.total_duration,
        avg_duration = EXCLUDED.avg_duration,
        quality_score_avg = EXCLUDED.quality_score_avg,
        updated_at = NOW();
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to get campaign performance summary
CREATE OR REPLACE FUNCTION get_campaign_performance(
    campaign_uuid UUID,
    start_date DATE DEFAULT CURRENT_DATE - INTERVAL '30 days',
    end_date DATE DEFAULT CURRENT_DATE
)
RETURNS JSONB AS $$
DECLARE
    result JSONB;
BEGIN
    SELECT jsonb_build_object(
        'total_calls', COALESCE(SUM(calls_count), 0),
        'connected_calls', COALESCE(SUM(connected_calls), 0),
        'completed_calls', COALESCE(SUM(completed_calls), 0),
        'total_duration', COALESCE(SUM(total_duration), 0),
        'total_payout', COALESCE(SUM(total_payout), 0),
        'avg_quality_score', COALESCE(AVG(quality_score_avg), 0),
        'connection_rate', CASE 
            WHEN SUM(calls_count) > 0 THEN 
                ROUND((SUM(connected_calls)::decimal / SUM(calls_count)) * 100, 2)
            ELSE 0 
        END,
        'completion_rate', CASE 
            WHEN SUM(calls_count) > 0 THEN 
                ROUND((SUM(completed_calls)::decimal / SUM(calls_count)) * 100, 2)
            ELSE 0 
        END
    ) INTO result
    FROM campaign_stats
    WHERE campaign_id = campaign_uuid
    AND date BETWEEN start_date AND end_date;
    
    RETURN COALESCE(result, '{}'::jsonb);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ================================
-- VALIDATION FUNCTIONS
-- ================================

-- Function to validate phone number format
CREATE OR REPLACE FUNCTION validate_phone_number(phone_number VARCHAR(20))
RETURNS BOOLEAN AS $$
BEGIN
    -- Basic US phone number validation (can be enhanced for international)
    RETURN phone_number ~ '^\+?1?[2-9][0-8][0-9][2-9][0-9]{2}[0-9]{4}$';
END;
$$ LANGUAGE plpgsql IMMUTABLE SECURITY DEFINER;

-- Function to validate campaign targeting
CREATE OR REPLACE FUNCTION validate_campaign_targeting(targeting JSONB)
RETURNS BOOLEAN AS $$
BEGIN
    -- Basic validation - ensure required fields exist
    IF NOT (targeting ? 'geographic' AND targeting ? 'schedule') THEN
        RETURN false;
    END IF;
    
    -- Validate geographic targeting
    IF NOT (targeting->'geographic' ? 'states' OR targeting->'geographic' ? 'regions') THEN
        RETURN false;
    END IF;
    
    RETURN true;
END;
$$ LANGUAGE plpgsql IMMUTABLE SECURITY DEFINER;

-- ================================
-- UTILITY FUNCTIONS
-- ================================

-- Function to generate unique tracking number
CREATE OR REPLACE FUNCTION generate_tracking_number(campaign_uuid UUID)
RETURNS VARCHAR(20) AS $$
DECLARE
    base_number VARCHAR(10);
    area_code VARCHAR(3) := '800'; -- Default toll-free area code
    sequence_num INTEGER;
    tracking_number VARCHAR(20);
BEGIN
    -- Get next sequence number for this campaign
    SELECT COALESCE(MAX(
        CAST(
            SUBSTRING(number FROM '[0-9]{4}$') AS INTEGER
        )
    ), 0) + 1 INTO sequence_num
    FROM tracking_numbers
    WHERE campaign_id = campaign_uuid;
    
    -- Generate the tracking number
    tracking_number := area_code || LPAD(
        (EXTRACT(epoch FROM NOW())::bigint % 1000)::text, 3, '0'
    ) || LPAD(sequence_num::text, 4, '0');
    
    RETURN tracking_number;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to clean up old audit logs (for maintenance)
CREATE OR REPLACE FUNCTION cleanup_audit_logs(retention_days INTEGER DEFAULT 90)
RETURNS INTEGER AS $$
DECLARE
    deleted_count INTEGER;
BEGIN
    DELETE FROM audit_logs
    WHERE created_at < NOW() - (retention_days || ' days')::INTERVAL;
    
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    
    RETURN deleted_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ================================
-- GRANT PERMISSIONS
-- ================================

-- Grant execute permissions to authenticated users for business functions
GRANT EXECUTE ON FUNCTION calculate_supplier_balance(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION calculate_buyer_balance(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION calculate_quality_score(INTEGER, JSONB) TO authenticated;
GRANT EXECUTE ON FUNCTION detect_fraud_indicators(VARCHAR, INTEGER, JSONB, JSONB) TO authenticated;
GRANT EXECUTE ON FUNCTION find_matching_buyer_campaigns(UUID, JSONB, TIMESTAMP WITH TIME ZONE) TO authenticated;
GRANT EXECUTE ON FUNCTION calculate_call_billing(UUID, UUID, INTEGER, INTEGER) TO authenticated;
GRANT EXECUTE ON FUNCTION get_campaign_performance(UUID, DATE, DATE) TO authenticated;
GRANT EXECUTE ON FUNCTION validate_phone_number(VARCHAR) TO authenticated;
GRANT EXECUTE ON FUNCTION validate_campaign_targeting(JSONB) TO authenticated;

-- Grant to service role for system functions
GRANT EXECUTE ON FUNCTION process_hourly_stats(TIMESTAMP WITH TIME ZONE) TO service_role;
GRANT EXECUTE ON FUNCTION generate_tracking_number(UUID) TO service_role;
GRANT EXECUTE ON FUNCTION cleanup_audit_logs(INTEGER) TO service_role;

-- Comments for documentation
COMMENT ON FUNCTION calculate_supplier_balance IS 'Calculate supplier available balance from completed calls minus payouts';
COMMENT ON FUNCTION calculate_buyer_balance IS 'Calculate buyer remaining credit balance';
COMMENT ON FUNCTION calculate_quality_score IS 'Calculate call quality score based on duration and metadata';
COMMENT ON FUNCTION detect_fraud_indicators IS 'Analyze call data for fraud indicators and return risk assessment';
COMMENT ON FUNCTION find_matching_buyer_campaigns IS 'Find active buyer campaigns that match supplier traffic';
COMMENT ON FUNCTION calculate_call_billing IS 'Calculate payout, charge, and margin amounts for a call';
COMMENT ON FUNCTION process_hourly_stats IS 'Process and aggregate hourly campaign statistics';
COMMENT ON FUNCTION get_campaign_performance IS 'Get performance summary for a campaign over date range';
COMMENT ON FUNCTION validate_phone_number IS 'Validate phone number format';
COMMENT ON FUNCTION validate_campaign_targeting IS 'Validate campaign targeting configuration';
COMMENT ON FUNCTION generate_tracking_number IS 'Generate unique tracking number for campaign';
COMMENT ON FUNCTION cleanup_audit_logs IS 'Clean up old audit log entries for maintenance';
</file>

<file path="supabase/migrations/004_triggers.sql">
-- DCE Platform Database Triggers
-- Automated processes, audit logging, and data validation triggers

-- ================================
-- AUDIT LOGGING TRIGGERS
-- ================================

-- Enhanced audit trigger function with more context
CREATE OR REPLACE FUNCTION audit_trigger()
RETURNS TRIGGER AS $$
DECLARE
    user_uuid UUID;
    user_ip INET;
    user_agent TEXT;
BEGIN
    -- Get current user info
    user_uuid := auth.uid();
    
    -- Try to get additional context (may not always be available)
    BEGIN
        user_ip := inet(current_setting('request.headers')::json->>'x-forwarded-for');
    EXCEPTION WHEN OTHERS THEN
        user_ip := NULL;
    END;
    
    BEGIN
        user_agent := current_setting('request.headers')::json->>'user-agent';
    EXCEPTION WHEN OTHERS THEN
        user_agent := NULL;
    END;
    
    INSERT INTO audit_logs (
        table_name,
        operation,
        user_id,
        record_id,
        old_data,
        new_data,
        ip_address,
        user_agent
    ) VALUES (
        TG_TABLE_NAME,
        TG_OP,
        user_uuid,
        CASE 
            WHEN TG_OP = 'DELETE' THEN (OLD.id)::UUID
            ELSE (NEW.id)::UUID
        END,
        CASE WHEN TG_OP = 'DELETE' OR TG_OP = 'UPDATE' THEN row_to_json(OLD) ELSE NULL END,
        CASE WHEN TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN row_to_json(NEW) ELSE NULL END,
        user_ip,
        user_agent
    );
    
    RETURN CASE WHEN TG_OP = 'DELETE' THEN OLD ELSE NEW END;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Apply audit triggers to sensitive tables
CREATE TRIGGER audit_users_trigger
    AFTER INSERT OR UPDATE OR DELETE ON users
    FOR EACH ROW EXECUTE FUNCTION audit_trigger();

CREATE TRIGGER audit_suppliers_trigger
    AFTER INSERT OR UPDATE OR DELETE ON suppliers
    FOR EACH ROW EXECUTE FUNCTION audit_trigger();

CREATE TRIGGER audit_buyers_trigger
    AFTER INSERT OR UPDATE OR DELETE ON buyers
    FOR EACH ROW EXECUTE FUNCTION audit_trigger();

CREATE TRIGGER audit_campaigns_trigger
    AFTER INSERT OR UPDATE OR DELETE ON campaigns
    FOR EACH ROW EXECUTE FUNCTION audit_trigger();

CREATE TRIGGER audit_buyer_campaigns_trigger
    AFTER INSERT OR UPDATE OR DELETE ON buyer_campaigns
    FOR EACH ROW EXECUTE FUNCTION audit_trigger();

CREATE TRIGGER audit_calls_trigger
    AFTER INSERT OR UPDATE OR DELETE ON calls
    FOR EACH ROW EXECUTE FUNCTION audit_trigger();

CREATE TRIGGER audit_payouts_trigger
    AFTER INSERT OR UPDATE OR DELETE ON payouts
    FOR EACH ROW EXECUTE FUNCTION audit_trigger();

CREATE TRIGGER audit_invoices_trigger
    AFTER INSERT OR UPDATE OR DELETE ON invoices
    FOR EACH ROW EXECUTE FUNCTION audit_trigger();

CREATE TRIGGER audit_disputes_trigger
    AFTER INSERT OR UPDATE OR DELETE ON disputes
    FOR EACH ROW EXECUTE FUNCTION audit_trigger();

-- ================================
-- BUSINESS LOGIC TRIGGERS
-- ================================

-- Trigger to automatically process call quality and billing
CREATE OR REPLACE FUNCTION process_call_completion()
RETURNS TRIGGER AS $$
DECLARE
    quality_result JSONB;
    fraud_result JSONB;
    billing_result JSONB;
    call_quality_score INTEGER;
BEGIN
    -- Only process when call status changes to completed
    IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN
        
        -- Calculate quality score
        call_quality_score := calculate_quality_score(NEW.duration_seconds, NEW.metadata);
        
        -- Detect fraud indicators
        fraud_result := detect_fraud_indicators(
            NEW.caller_number, 
            NEW.duration_seconds, 
            NEW.caller_location, 
            NEW.metadata
        );
        
        -- Calculate billing amounts if not already set
        IF NEW.payout_amount = 0 AND NEW.charge_amount = 0 AND NEW.campaign_id IS NOT NULL AND NEW.buyer_campaign_id IS NOT NULL THEN
            billing_result := calculate_call_billing(
                NEW.campaign_id, 
                NEW.buyer_campaign_id, 
                NEW.duration_seconds, 
                call_quality_score
            );
            
            NEW.payout_amount := (billing_result->>'payout_amount')::DECIMAL;
            NEW.charge_amount := (billing_result->>'charge_amount')::DECIMAL;
            NEW.margin_amount := (billing_result->>'margin_amount')::DECIMAL;
        END IF;
        
        -- Update quality and fraud scores
        NEW.quality_score := call_quality_score;
        NEW.fraud_score := (fraud_result->>'fraud_score')::INTEGER;
        
        -- Add fraud flags to metadata
        IF fraud_result->>'suspicious' = 'true' THEN
            NEW.metadata := NEW.metadata || jsonb_build_object('fraud_flags', fraud_result->'flags');
        END IF;
        
        -- Insert detailed quality score record
        INSERT INTO call_quality_scores (
            call_id,
            duration_score,
            overall_score,
            flags,
            scoring_model
        ) VALUES (
            NEW.id,
            CASE 
                WHEN NEW.duration_seconds >= 120 THEN 100
                WHEN NEW.duration_seconds >= 60 THEN 80
                WHEN NEW.duration_seconds >= 30 THEN 60
                WHEN NEW.duration_seconds >= 15 THEN 40
                ELSE 20
            END,
            call_quality_score,
            fraud_result->'flags',
            'v1.0'
        );
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Apply call completion trigger
CREATE TRIGGER process_call_completion_trigger
    BEFORE UPDATE ON calls
    FOR EACH ROW EXECUTE FUNCTION process_call_completion();

-- ================================
-- BALANCE MANAGEMENT TRIGGERS
-- ================================

-- Trigger to update supplier balance when calls are completed or payouts processed
CREATE OR REPLACE FUNCTION update_supplier_balance()
RETURNS TRIGGER AS $$
BEGIN
    -- Update supplier credit balance
    IF TG_TABLE_NAME = 'calls' AND NEW.status = 'completed' THEN
        UPDATE suppliers 
        SET credit_balance = calculate_supplier_balance(
            (SELECT supplier_id FROM campaigns WHERE id = NEW.campaign_id)
        )
        WHERE id = (SELECT supplier_id FROM campaigns WHERE id = NEW.campaign_id);
        
    ELSIF TG_TABLE_NAME = 'payouts' AND NEW.status = 'completed' THEN
        UPDATE suppliers 
        SET credit_balance = calculate_supplier_balance(NEW.supplier_id)
        WHERE id = NEW.supplier_id;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Apply balance update triggers
CREATE TRIGGER update_supplier_balance_calls_trigger
    AFTER UPDATE ON calls
    FOR EACH ROW EXECUTE FUNCTION update_supplier_balance();

CREATE TRIGGER update_supplier_balance_payouts_trigger
    AFTER UPDATE ON payouts
    FOR EACH ROW EXECUTE FUNCTION update_supplier_balance();

-- Trigger to update buyer balance when calls are charged or invoices are paid
CREATE OR REPLACE FUNCTION update_buyer_balance()
RETURNS TRIGGER AS $$
BEGIN
    -- Update buyer current balance
    IF TG_TABLE_NAME = 'calls' AND NEW.status = 'completed' THEN
        UPDATE buyers 
        SET current_balance = calculate_buyer_balance(
            (SELECT buyer_id FROM buyer_campaigns WHERE id = NEW.buyer_campaign_id)
        )
        WHERE id = (SELECT buyer_id FROM buyer_campaigns WHERE id = NEW.buyer_campaign_id);
        
    ELSIF TG_TABLE_NAME = 'invoices' AND NEW.status = 'paid' THEN
        UPDATE buyers 
        SET current_balance = calculate_buyer_balance(NEW.buyer_id)
        WHERE id = NEW.buyer_id;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Apply buyer balance update triggers
CREATE TRIGGER update_buyer_balance_calls_trigger
    AFTER UPDATE ON calls
    FOR EACH ROW EXECUTE FUNCTION update_buyer_balance();

CREATE TRIGGER update_buyer_balance_invoices_trigger
    AFTER UPDATE ON invoices
    FOR EACH ROW EXECUTE FUNCTION update_buyer_balance();

-- ================================
-- VALIDATION TRIGGERS
-- ================================

-- Trigger to validate campaign data before insert/update
CREATE OR REPLACE FUNCTION validate_campaign_data()
RETURNS TRIGGER AS $$
BEGIN
    -- Validate bid floor is positive
    IF NEW.bid_floor < 0 THEN
        RAISE EXCEPTION 'Bid floor must be positive';
    END IF;
    
    -- Validate targeting configuration
    IF NOT validate_campaign_targeting(NEW.targeting) THEN
        RAISE EXCEPTION 'Invalid campaign targeting configuration';
    END IF;
    
    -- Validate tracking numbers if provided
    IF NEW.tracking_numbers IS NOT NULL THEN
        DECLARE
            number_item JSONB;
        BEGIN
            FOR number_item IN SELECT jsonb_array_elements(NEW.tracking_numbers)
            LOOP
                IF NOT validate_phone_number(number_item->>'number') THEN
                    RAISE EXCEPTION 'Invalid tracking number format: %', number_item->>'number';
                END IF;
            END LOOP;
        END;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Apply campaign validation trigger
CREATE TRIGGER validate_campaign_data_trigger
    BEFORE INSERT OR UPDATE ON campaigns
    FOR EACH ROW EXECUTE FUNCTION validate_campaign_data();

-- Trigger to validate buyer campaign data
CREATE OR REPLACE FUNCTION validate_buyer_campaign_data()
RETURNS TRIGGER AS $$
BEGIN
    -- Validate max bid is positive
    IF NEW.max_bid <= 0 THEN
        RAISE EXCEPTION 'Max bid must be positive';
    END IF;
    
    -- Validate budget constraints
    IF NEW.daily_budget IS NOT NULL AND NEW.daily_budget <= 0 THEN
        RAISE EXCEPTION 'Daily budget must be positive';
    END IF;
    
    IF NEW.monthly_budget IS NOT NULL AND NEW.monthly_budget <= 0 THEN
        RAISE EXCEPTION 'Monthly budget must be positive';
    END IF;
    
    -- Ensure daily budget doesn't exceed monthly budget
    IF NEW.daily_budget IS NOT NULL AND NEW.monthly_budget IS NOT NULL THEN
        IF NEW.daily_budget * 31 > NEW.monthly_budget THEN
            RAISE EXCEPTION 'Daily budget would exceed monthly budget';
        END IF;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Apply buyer campaign validation trigger
CREATE TRIGGER validate_buyer_campaign_data_trigger
    BEFORE INSERT OR UPDATE ON buyer_campaigns
    FOR EACH ROW EXECUTE FUNCTION validate_buyer_campaign_data();

-- ================================
-- NOTIFICATION TRIGGERS
-- ================================

-- Trigger to send real-time notifications for important events
CREATE OR REPLACE FUNCTION send_realtime_notifications()
RETURNS TRIGGER AS $$
BEGIN
    -- Send notifications for different events
    CASE TG_TABLE_NAME
        WHEN 'calls' THEN
            IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN
                PERFORM pg_notify(
                    'call_completed',
                    json_build_object(
                        'call_id', NEW.id,
                        'campaign_id', NEW.campaign_id,
                        'buyer_campaign_id', NEW.buyer_campaign_id,
                        'payout_amount', NEW.payout_amount,
                        'charge_amount', NEW.charge_amount,
                        'quality_score', NEW.quality_score
                    )::text
                );
            END IF;
            
        WHEN 'disputes' THEN
            IF TG_OP = 'INSERT' THEN
                PERFORM pg_notify(
                    'dispute_created',
                    json_build_object(
                        'dispute_id', NEW.id,
                        'call_id', NEW.call_id,
                        'raised_by', NEW.raised_by,
                        'dispute_type', NEW.dispute_type,
                        'reason', NEW.reason
                    )::text
                );
            END IF;
            
        WHEN 'payouts' THEN
            IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN
                PERFORM pg_notify(
                    'payout_completed',
                    json_build_object(
                        'payout_id', NEW.id,
                        'supplier_id', NEW.supplier_id,
                        'amount', NEW.amount,
                        'transaction_id', NEW.transaction_id
                    )::text
                );
            END IF;
    END CASE;
    
    RETURN CASE WHEN TG_OP = 'DELETE' THEN OLD ELSE NEW END;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Apply notification triggers
CREATE TRIGGER send_call_notifications_trigger
    AFTER INSERT OR UPDATE ON calls
    FOR EACH ROW EXECUTE FUNCTION send_realtime_notifications();

CREATE TRIGGER send_dispute_notifications_trigger
    AFTER INSERT OR UPDATE ON disputes
    FOR EACH ROW EXECUTE FUNCTION send_realtime_notifications();

CREATE TRIGGER send_payout_notifications_trigger
    AFTER INSERT OR UPDATE ON payouts
    FOR EACH ROW EXECUTE FUNCTION send_realtime_notifications();

-- ================================
-- DATA INTEGRITY TRIGGERS
-- ================================

-- Trigger to ensure tracking numbers are unique and properly formatted
CREATE OR REPLACE FUNCTION manage_tracking_numbers()
RETURNS TRIGGER AS $$
BEGIN
    -- Auto-generate tracking number if not provided
    IF NEW.number IS NULL OR NEW.number = '' THEN
        NEW.number := generate_tracking_number(NEW.campaign_id);
    END IF;
    
    -- Validate number format
    IF NOT validate_phone_number(NEW.number) THEN
        RAISE EXCEPTION 'Invalid tracking number format: %', NEW.number;
    END IF;
    
    -- Set display number (formatted version)
    NEW.display_number := CASE 
        WHEN LENGTH(NEW.number) = 11 AND LEFT(NEW.number, 1) = '1' THEN
            '(' || SUBSTRING(NEW.number, 2, 3) || ') ' || 
            SUBSTRING(NEW.number, 5, 3) || '-' || 
            SUBSTRING(NEW.number, 8, 4)
        WHEN LENGTH(NEW.number) = 10 THEN
            '(' || LEFT(NEW.number, 3) || ') ' || 
            SUBSTRING(NEW.number, 4, 3) || '-' || 
            RIGHT(NEW.number, 4)
        ELSE NEW.number
    END;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Apply tracking number management trigger
CREATE TRIGGER manage_tracking_numbers_trigger
    BEFORE INSERT OR UPDATE ON tracking_numbers
    FOR EACH ROW EXECUTE FUNCTION manage_tracking_numbers();

-- ================================
-- AUTOMATIC STATS PROCESSING
-- ================================

-- Schedule hourly stats processing (requires pg_cron extension)
-- This would typically be set up separately in production
-- SELECT cron.schedule('process-hourly-stats', '0 * * * *', 'SELECT process_hourly_stats();');

-- Alternative: Trigger-based stats processing for real-time updates
CREATE OR REPLACE FUNCTION update_campaign_stats_realtime()
RETURNS TRIGGER AS $$
BEGIN
    -- Update daily stats when call is completed
    IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN
        
        -- Update campaign stats
        INSERT INTO campaign_stats (
            campaign_id, date, calls_count, connected_calls, 
            completed_calls, total_duration, total_payout
        )
        SELECT 
            NEW.campaign_id,
            NEW.started_at::date,
            1, 1, 1,
            NEW.duration_seconds,
            NEW.payout_amount
        WHERE NEW.campaign_id IS NOT NULL
        ON CONFLICT (campaign_id, date, hour)
        WHERE hour IS NULL
        DO UPDATE SET
            calls_count = campaign_stats.calls_count + 1,
            connected_calls = campaign_stats.connected_calls + 1,
            completed_calls = campaign_stats.completed_calls + 1,
            total_duration = campaign_stats.total_duration + NEW.duration_seconds,
            total_payout = campaign_stats.total_payout + NEW.payout_amount,
            updated_at = NOW();
        
        -- Update buyer campaign stats
        INSERT INTO buyer_campaign_stats (
            buyer_campaign_id, date, calls_received, calls_accepted,
            calls_completed, total_cost, total_duration
        )
        SELECT 
            NEW.buyer_campaign_id,
            NEW.started_at::date,
            1, 1, 1,
            NEW.charge_amount,
            NEW.duration_seconds
        WHERE NEW.buyer_campaign_id IS NOT NULL
        ON CONFLICT (buyer_campaign_id, date, hour)
        WHERE hour IS NULL
        DO UPDATE SET
            calls_received = buyer_campaign_stats.calls_received + 1,
            calls_accepted = buyer_campaign_stats.calls_accepted + 1,
            calls_completed = buyer_campaign_stats.calls_completed + 1,
            total_cost = buyer_campaign_stats.total_cost + NEW.charge_amount,
            total_duration = buyer_campaign_stats.total_duration + NEW.duration_seconds,
            updated_at = NOW();
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Apply real-time stats trigger
CREATE TRIGGER update_campaign_stats_realtime_trigger
    AFTER UPDATE ON calls
    FOR EACH ROW EXECUTE FUNCTION update_campaign_stats_realtime();

-- Comments for documentation
COMMENT ON FUNCTION audit_trigger IS 'Comprehensive audit logging for sensitive table changes';
COMMENT ON FUNCTION process_call_completion IS 'Automated quality scoring and billing calculation for completed calls';
COMMENT ON FUNCTION update_supplier_balance IS 'Maintain accurate supplier balance based on calls and payouts';
COMMENT ON FUNCTION update_buyer_balance IS 'Maintain accurate buyer balance based on charges and payments';
COMMENT ON FUNCTION validate_campaign_data IS 'Validate campaign configuration before save';
COMMENT ON FUNCTION validate_buyer_campaign_data IS 'Validate buyer campaign configuration before save';
COMMENT ON FUNCTION send_realtime_notifications IS 'Send real-time notifications for important events';
COMMENT ON FUNCTION manage_tracking_numbers IS 'Auto-generate and format tracking numbers';
COMMENT ON FUNCTION update_campaign_stats_realtime IS 'Real-time campaign statistics updates';
</file>

<file path="supabase/migrations/005_indexes.sql">
-- DCE Platform Performance Indexes
-- Optimized indexes for frequent queries and performance critical operations

-- ================================
-- PRIMARY LOOKUP INDEXES
-- ================================

-- Users table indexes
CREATE INDEX CONCURRENTLY idx_users_email ON users (email);
CREATE INDEX CONCURRENTLY idx_users_status ON users (status) WHERE status = 'active';
CREATE INDEX CONCURRENTLY idx_users_last_login ON users (last_login DESC) WHERE last_login IS NOT NULL;

-- Suppliers table indexes
CREATE INDEX CONCURRENTLY idx_suppliers_user_id ON suppliers (user_id);
CREATE INDEX CONCURRENTLY idx_suppliers_status ON suppliers (status) WHERE status = 'active';
CREATE INDEX CONCURRENTLY idx_suppliers_company_name ON suppliers (company_name);
CREATE INDEX CONCURRENTLY idx_suppliers_credit_balance ON suppliers (credit_balance DESC) WHERE credit_balance > 0;
CREATE INDEX CONCURRENTLY idx_suppliers_created_at ON suppliers (created_at DESC);

-- Buyers table indexes
CREATE INDEX CONCURRENTLY idx_buyers_user_id ON buyers (user_id);
CREATE INDEX CONCURRENTLY idx_buyers_status ON buyers (status) WHERE status = 'active';
CREATE INDEX CONCURRENTLY idx_buyers_company_name ON buyers (company_name);
CREATE INDEX CONCURRENTLY idx_buyers_credit_limit ON buyers (credit_limit DESC);
CREATE INDEX CONCURRENTLY idx_buyers_current_balance ON buyers (current_balance DESC);
CREATE INDEX CONCURRENTLY idx_buyers_created_at ON buyers (created_at DESC);

-- ================================
-- CAMPAIGN INDEXES
-- ================================

-- Campaigns table indexes
CREATE INDEX CONCURRENTLY idx_campaigns_supplier_id ON campaigns (supplier_id);
CREATE INDEX CONCURRENTLY idx_campaigns_status ON campaigns (status);
CREATE INDEX CONCURRENTLY idx_campaigns_status_active ON campaigns (status, created_at DESC) WHERE status = 'active';
CREATE INDEX CONCURRENTLY idx_campaigns_bid_floor ON campaigns (bid_floor DESC);
CREATE INDEX CONCURRENTLY idx_campaigns_category ON campaigns (category) WHERE category IS NOT NULL;
CREATE INDEX CONCURRENTLY idx_campaigns_vertical ON campaigns (vertical) WHERE vertical IS NOT NULL;
CREATE INDEX CONCURRENTLY idx_campaigns_created_at ON campaigns (created_at DESC);
CREATE INDEX CONCURRENTLY idx_campaigns_updated_at ON campaigns (updated_at DESC);

-- JSONB indexes for campaign targeting and routing
CREATE INDEX CONCURRENTLY idx_campaigns_targeting_geo ON campaigns USING GIN ((targeting->'geographic'));
CREATE INDEX CONCURRENTLY idx_campaigns_targeting_schedule ON campaigns USING GIN ((targeting->'schedule'));
CREATE INDEX CONCURRENTLY idx_campaigns_routing_rules ON campaigns USING GIN (routing_rules);

-- Buyer campaigns table indexes
CREATE INDEX CONCURRENTLY idx_buyer_campaigns_buyer_id ON buyer_campaigns (buyer_id);
CREATE INDEX CONCURRENTLY idx_buyer_campaigns_status ON buyer_campaigns (status);
CREATE INDEX CONCURRENTLY idx_buyer_campaigns_status_active ON buyer_campaigns (status, created_at DESC) WHERE status = 'active';
CREATE INDEX CONCURRENTLY idx_buyer_campaigns_max_bid ON buyer_campaigns (max_bid DESC);
CREATE INDEX CONCURRENTLY idx_buyer_campaigns_daily_budget ON buyer_campaigns (daily_budget DESC) WHERE daily_budget IS NOT NULL;
CREATE INDEX CONCURRENTLY idx_buyer_campaigns_created_at ON buyer_campaigns (created_at DESC);

-- JSONB indexes for buyer campaign criteria
CREATE INDEX CONCURRENTLY idx_buyer_campaigns_targeting ON buyer_campaigns USING GIN (targeting_criteria);
CREATE INDEX CONCURRENTLY idx_buyer_campaigns_schedule ON buyer_campaigns USING GIN (schedule);
CREATE INDEX CONCURRENTLY idx_buyer_campaigns_quality ON buyer_campaigns USING GIN (quality_requirements);

-- ================================
-- CALL TRACKING INDEXES
-- ================================

-- Tracking numbers table indexes
CREATE INDEX CONCURRENTLY idx_tracking_numbers_campaign_id ON tracking_numbers (campaign_id);
CREATE INDEX CONCURRENTLY idx_tracking_numbers_number ON tracking_numbers (number);
CREATE INDEX CONCURRENTLY idx_tracking_numbers_active ON tracking_numbers (campaign_id, is_active) WHERE is_active = true;
CREATE INDEX CONCURRENTLY idx_tracking_numbers_area_code ON tracking_numbers (area_code) WHERE area_code IS NOT NULL;

-- ================================
-- CALLS PERFORMANCE INDEXES
-- ================================

-- Core call lookup indexes
CREATE INDEX CONCURRENTLY idx_calls_campaign_id ON calls (campaign_id);
CREATE INDEX CONCURRENTLY idx_calls_buyer_campaign_id ON calls (buyer_campaign_id);
CREATE INDEX CONCURRENTLY idx_calls_tracking_number ON calls (tracking_number);
CREATE INDEX CONCURRENTLY idx_calls_caller_number ON calls (caller_number);
CREATE INDEX CONCURRENTLY idx_calls_status ON calls (status);
CREATE INDEX CONCURRENTLY idx_calls_started_at ON calls (started_at DESC);
CREATE INDEX CONCURRENTLY idx_calls_ended_at ON calls (ended_at DESC) WHERE ended_at IS NOT NULL;

-- Performance indexes for call queries
CREATE INDEX CONCURRENTLY idx_calls_campaign_started ON calls (campaign_id, started_at DESC);
CREATE INDEX CONCURRENTLY idx_calls_buyer_campaign_started ON calls (buyer_campaign_id, started_at DESC);
CREATE INDEX CONCURRENTLY idx_calls_status_started ON calls (status, started_at DESC);
CREATE INDEX CONCURRENTLY idx_calls_completed ON calls (status, started_at DESC) WHERE status = 'completed';

-- Billing and quality indexes
CREATE INDEX CONCURRENTLY idx_calls_payout_amount ON calls (payout_amount DESC) WHERE payout_amount > 0;
CREATE INDEX CONCURRENTLY idx_calls_charge_amount ON calls (charge_amount DESC) WHERE charge_amount > 0;
CREATE INDEX CONCURRENTLY idx_calls_quality_score ON calls (quality_score DESC) WHERE quality_score IS NOT NULL;
CREATE INDEX CONCURRENTLY idx_calls_fraud_score ON calls (fraud_score DESC) WHERE fraud_score IS NOT NULL;
CREATE INDEX CONCURRENTLY idx_calls_duration ON calls (duration_seconds DESC) WHERE duration_seconds > 0;

-- Composite indexes for complex queries
CREATE INDEX CONCURRENTLY idx_calls_campaign_status_date ON calls (campaign_id, status, started_at::date);
CREATE INDEX CONCURRENTLY idx_calls_buyer_campaign_status_date ON calls (buyer_campaign_id, status, started_at::date);
CREATE INDEX CONCURRENTLY idx_calls_quality_billing ON calls (quality_score DESC, payout_amount DESC) WHERE quality_score IS NOT NULL AND payout_amount > 0;

-- JSONB indexes for call metadata and location
CREATE INDEX CONCURRENTLY idx_calls_metadata ON calls USING GIN (metadata);
CREATE INDEX CONCURRENTLY idx_calls_caller_location ON calls USING GIN (caller_location);

-- ================================
-- CALL LOGS INDEXES
-- ================================

CREATE INDEX CONCURRENTLY idx_call_logs_call_id ON call_logs (call_id);
CREATE INDEX CONCURRENTLY idx_call_logs_event_type ON call_logs (event_type);
CREATE INDEX CONCURRENTLY idx_call_logs_timestamp ON call_logs (timestamp DESC);
CREATE INDEX CONCURRENTLY idx_call_logs_call_event_time ON call_logs (call_id, event_type, timestamp);

-- JSONB index for event data
CREATE INDEX CONCURRENTLY idx_call_logs_event_data ON call_logs USING GIN (event_data);

-- ================================
-- FINANCIAL INDEXES
-- ================================

-- Payouts table indexes
CREATE INDEX CONCURRENTLY idx_payouts_supplier_id ON payouts (supplier_id);
CREATE INDEX CONCURRENTLY idx_payouts_status ON payouts (status);
CREATE INDEX CONCURRENTLY idx_payouts_period ON payouts (period_start, period_end);
CREATE INDEX CONCURRENTLY idx_payouts_created_at ON payouts (created_at DESC);
CREATE INDEX CONCURRENTLY idx_payouts_paid_at ON payouts (paid_at DESC) WHERE paid_at IS NOT NULL;
CREATE INDEX CONCURRENTLY idx_payouts_amount ON payouts (amount DESC);
CREATE INDEX CONCURRENTLY idx_payouts_transaction_id ON payouts (transaction_id) WHERE transaction_id IS NOT NULL;

-- Composite indexes for payout queries
CREATE INDEX CONCURRENTLY idx_payouts_supplier_status_period ON payouts (supplier_id, status, period_end DESC);
CREATE INDEX CONCURRENTLY idx_payouts_status_period ON payouts (status, period_start, period_end);

-- Invoices table indexes
CREATE INDEX CONCURRENTLY idx_invoices_buyer_id ON invoices (buyer_id);
CREATE INDEX CONCURRENTLY idx_invoices_status ON invoices (status);
CREATE INDEX CONCURRENTLY idx_invoices_invoice_number ON invoices (invoice_number);
CREATE INDEX CONCURRENTLY idx_invoices_period ON invoices (period_start, period_end);
CREATE INDEX CONCURRENTLY idx_invoices_due_date ON invoices (due_date) WHERE status != 'paid';
CREATE INDEX CONCURRENTLY idx_invoices_created_at ON invoices (created_at DESC);
CREATE INDEX CONCURRENTLY idx_invoices_paid_at ON invoices (paid_at DESC) WHERE paid_at IS NOT NULL;
CREATE INDEX CONCURRENTLY idx_invoices_amount ON invoices (total_amount DESC);
CREATE INDEX CONCURRENTLY idx_invoices_stripe ON invoices (stripe_invoice_id) WHERE stripe_invoice_id IS NOT NULL;

-- Composite indexes for invoice queries
CREATE INDEX CONCURRENTLY idx_invoices_buyer_status_due ON invoices (buyer_id, status, due_date);
CREATE INDEX CONCURRENTLY idx_invoices_status_due ON invoices (status, due_date) WHERE status IN ('open', 'overdue');

-- Invoice line items indexes
CREATE INDEX CONCURRENTLY idx_invoice_line_items_invoice_id ON invoice_line_items (invoice_id);
CREATE INDEX CONCURRENTLY idx_invoice_line_items_call_id ON invoice_line_items (call_id) WHERE call_id IS NOT NULL;
CREATE INDEX CONCURRENTLY idx_invoice_line_items_amount ON invoice_line_items (total_amount DESC);

-- ================================
-- QUALITY AND COMPLIANCE INDEXES
-- ================================

-- Call quality scores indexes
CREATE INDEX CONCURRENTLY idx_call_quality_scores_call_id ON call_quality_scores (call_id);
CREATE INDEX CONCURRENTLY idx_call_quality_scores_overall ON call_quality_scores (overall_score DESC) WHERE overall_score IS NOT NULL;
CREATE INDEX CONCURRENTLY idx_call_quality_scores_duration ON call_quality_scores (duration_score DESC) WHERE duration_score IS NOT NULL;
CREATE INDEX CONCURRENTLY idx_call_quality_scores_intent ON call_quality_scores (intent_score DESC) WHERE intent_score IS NOT NULL;
CREATE INDEX CONCURRENTLY idx_call_quality_scores_created_at ON call_quality_scores (created_at DESC);
CREATE INDEX CONCURRENTLY idx_call_quality_scores_reviewed ON call_quality_scores (reviewed_at DESC) WHERE reviewed_at IS NOT NULL;

-- JSONB index for quality flags
CREATE INDEX CONCURRENTLY idx_call_quality_flags ON call_quality_scores USING GIN (flags);

-- Disputes table indexes
CREATE INDEX CONCURRENTLY idx_disputes_call_id ON disputes (call_id);
CREATE INDEX CONCURRENTLY idx_disputes_raised_by ON disputes (raised_by);
CREATE INDEX CONCURRENTLY idx_disputes_status ON disputes (status);
CREATE INDEX CONCURRENTLY idx_disputes_dispute_type ON disputes (dispute_type);
CREATE INDEX CONCURRENTLY idx_disputes_priority ON disputes (priority, created_at DESC);
CREATE INDEX CONCURRENTLY idx_disputes_assigned_to ON disputes (assigned_to) WHERE assigned_to IS NOT NULL;
CREATE INDEX CONCURRENTLY idx_disputes_created_at ON disputes (created_at DESC);
CREATE INDEX CONCURRENTLY idx_disputes_resolved_at ON disputes (resolved_at DESC) WHERE resolved_at IS NOT NULL;

-- Composite indexes for dispute queries
CREATE INDEX CONCURRENTLY idx_disputes_status_priority_created ON disputes (status, priority, created_at DESC);
CREATE INDEX CONCURRENTLY idx_disputes_assigned_status ON disputes (assigned_to, status, created_at DESC) WHERE assigned_to IS NOT NULL;

-- JSONB index for dispute evidence
CREATE INDEX CONCURRENTLY idx_disputes_evidence ON disputes USING GIN (evidence);

-- ================================
-- ANALYTICS AND REPORTING INDEXES
-- ================================

-- Campaign stats indexes
CREATE INDEX CONCURRENTLY idx_campaign_stats_campaign_id ON campaign_stats (campaign_id);
CREATE INDEX CONCURRENTLY idx_campaign_stats_date ON campaign_stats (date DESC);
CREATE INDEX CONCURRENTLY idx_campaign_stats_campaign_date ON campaign_stats (campaign_id, date DESC);
CREATE INDEX CONCURRENTLY idx_campaign_stats_campaign_date_hour ON campaign_stats (campaign_id, date DESC, hour) WHERE hour IS NOT NULL;
CREATE INDEX CONCURRENTLY idx_campaign_stats_calls_count ON campaign_stats (calls_count DESC) WHERE calls_count > 0;
CREATE INDEX CONCURRENTLY idx_campaign_stats_total_payout ON campaign_stats (total_payout DESC) WHERE total_payout > 0;
CREATE INDEX CONCURRENTLY idx_campaign_stats_created_at ON campaign_stats (created_at DESC);

-- Composite indexes for analytics queries
CREATE INDEX CONCURRENTLY idx_campaign_stats_performance ON campaign_stats (campaign_id, date DESC, calls_count DESC, total_payout DESC);
CREATE INDEX CONCURRENTLY idx_campaign_stats_daily ON campaign_stats (date DESC, hour) WHERE hour IS NULL;
CREATE INDEX CONCURRENTLY idx_campaign_stats_hourly ON campaign_stats (date DESC, hour) WHERE hour IS NOT NULL;

-- Buyer campaign stats indexes
CREATE INDEX CONCURRENTLY idx_buyer_campaign_stats_buyer_campaign_id ON buyer_campaign_stats (buyer_campaign_id);
CREATE INDEX CONCURRENTLY idx_buyer_campaign_stats_date ON buyer_campaign_stats (date DESC);
CREATE INDEX CONCURRENTLY idx_buyer_campaign_stats_buyer_date ON buyer_campaign_stats (buyer_campaign_id, date DESC);
CREATE INDEX CONCURRENTLY idx_buyer_campaign_stats_buyer_date_hour ON buyer_campaign_stats (buyer_campaign_id, date DESC, hour) WHERE hour IS NOT NULL;
CREATE INDEX CONCURRENTLY idx_buyer_campaign_stats_calls_received ON buyer_campaign_stats (calls_received DESC) WHERE calls_received > 0;
CREATE INDEX CONCURRENTLY idx_buyer_campaign_stats_total_cost ON buyer_campaign_stats (total_cost DESC) WHERE total_cost > 0;
CREATE INDEX CONCURRENTLY idx_buyer_campaign_stats_created_at ON buyer_campaign_stats (created_at DESC);

-- Composite indexes for buyer analytics
CREATE INDEX CONCURRENTLY idx_buyer_campaign_stats_performance ON buyer_campaign_stats (buyer_campaign_id, date DESC, calls_received DESC, total_cost DESC);
CREATE INDEX CONCURRENTLY idx_buyer_campaign_stats_daily ON buyer_campaign_stats (date DESC, hour) WHERE hour IS NULL;
CREATE INDEX CONCURRENTLY idx_buyer_campaign_stats_hourly ON buyer_campaign_stats (date DESC, hour) WHERE hour IS NOT NULL;

-- ================================
-- AUDIT AND SECURITY INDEXES
-- ================================

-- Audit logs indexes
CREATE INDEX CONCURRENTLY idx_audit_logs_table_name ON audit_logs (table_name);
CREATE INDEX CONCURRENTLY idx_audit_logs_operation ON audit_logs (operation);
CREATE INDEX CONCURRENTLY idx_audit_logs_user_id ON audit_logs (user_id) WHERE user_id IS NOT NULL;
CREATE INDEX CONCURRENTLY idx_audit_logs_record_id ON audit_logs (record_id) WHERE record_id IS NOT NULL;
CREATE INDEX CONCURRENTLY idx_audit_logs_created_at ON audit_logs (created_at DESC);
CREATE INDEX CONCURRENTLY idx_audit_logs_ip_address ON audit_logs (ip_address) WHERE ip_address IS NOT NULL;

-- Composite indexes for audit queries
CREATE INDEX CONCURRENTLY idx_audit_logs_table_user_time ON audit_logs (table_name, user_id, created_at DESC) WHERE user_id IS NOT NULL;
CREATE INDEX CONCURRENTLY idx_audit_logs_record_time ON audit_logs (table_name, record_id, created_at DESC) WHERE record_id IS NOT NULL;
CREATE INDEX CONCURRENTLY idx_audit_logs_user_time ON audit_logs (user_id, created_at DESC) WHERE user_id IS NOT NULL;

-- JSONB indexes for audit data
CREATE INDEX CONCURRENTLY idx_audit_logs_old_data ON audit_logs USING GIN (old_data) WHERE old_data IS NOT NULL;
CREATE INDEX CONCURRENTLY idx_audit_logs_new_data ON audit_logs USING GIN (new_data) WHERE new_data IS NOT NULL;

-- ================================
-- SPECIALIZED INDEXES FOR BUSINESS LOGIC
-- ================================

-- Index for fraud detection queries
CREATE INDEX CONCURRENTLY idx_calls_fraud_detection ON calls (caller_number, started_at DESC) WHERE started_at > NOW() - INTERVAL '24 hours';

-- Index for real-time call matching
CREATE INDEX CONCURRENTLY idx_buyer_campaigns_matching ON buyer_campaigns (status, max_bid DESC, daily_budget DESC) WHERE status = 'active';

-- Index for balance calculations
CREATE INDEX CONCURRENTLY idx_calls_balance_calc_supplier ON calls (campaign_id, status, payout_amount) WHERE status = 'completed' AND payout_amount > 0;
CREATE INDEX CONCURRENTLY idx_calls_balance_calc_buyer ON calls (buyer_campaign_id, status, charge_amount) WHERE status = 'completed' AND charge_amount > 0;

-- Index for recent activity queries
CREATE INDEX CONCURRENTLY idx_calls_recent_activity ON calls (started_at DESC) WHERE started_at > NOW() - INTERVAL '7 days';

-- Index for campaign performance optimization
CREATE INDEX CONCURRENTLY idx_campaigns_performance ON campaigns (status, bid_floor DESC, created_at DESC) WHERE status = 'active';

-- ================================
-- PARTIAL INDEXES FOR EFFICIENCY
-- ================================

-- Only index active records for most lookups
CREATE INDEX CONCURRENTLY idx_suppliers_active_only ON suppliers (user_id, created_at DESC) WHERE status = 'active';
CREATE INDEX CONCURRENTLY idx_buyers_active_only ON buyers (user_id, created_at DESC) WHERE status = 'active';
CREATE INDEX CONCURRENTLY idx_campaigns_active_only ON campaigns (supplier_id, bid_floor DESC) WHERE status = 'active';
CREATE INDEX CONCURRENTLY idx_buyer_campaigns_active_only ON buyer_campaigns (buyer_id, max_bid DESC) WHERE status = 'active';

-- Only index completed calls for financial calculations
CREATE INDEX CONCURRENTLY idx_calls_completed_billing ON calls (campaign_id, buyer_campaign_id, payout_amount, charge_amount) WHERE status = 'completed';

-- Only index pending payouts and open invoices
CREATE INDEX CONCURRENTLY idx_payouts_pending ON payouts (supplier_id, amount DESC, created_at DESC) WHERE status = 'pending';
CREATE INDEX CONCURRENTLY idx_invoices_open ON invoices (buyer_id, due_date, total_amount DESC) WHERE status IN ('open', 'overdue');

-- ================================
-- TEXT SEARCH INDEXES
-- ================================

-- Full-text search indexes for campaigns
CREATE INDEX CONCURRENTLY idx_campaigns_search ON campaigns USING GIN (to_tsvector('english', name || ' ' || COALESCE(description, '')));

-- Full-text search for companies
CREATE INDEX CONCURRENTLY idx_suppliers_search ON suppliers USING GIN (to_tsvector('english', company_name));
CREATE INDEX CONCURRENTLY idx_buyers_search ON buyers USING GIN (to_tsvector('english', company_name));

-- Search index for disputes
CREATE INDEX CONCURRENTLY idx_disputes_search ON disputes USING GIN (to_tsvector('english', reason || ' ' || COALESCE(description, '')));

-- Comments for documentation
COMMENT ON INDEX idx_calls_campaign_started IS 'Primary index for campaign call history queries';
COMMENT ON INDEX idx_calls_buyer_campaign_started IS 'Primary index for buyer call history queries';
COMMENT ON INDEX idx_calls_fraud_detection IS 'Optimized for fraud detection queries on recent calls';
COMMENT ON INDEX idx_buyer_campaigns_matching IS 'Optimized for real-time call matching algorithms';
COMMENT ON INDEX idx_campaigns_performance IS 'Performance index for active campaign discovery';
COMMENT ON INDEX idx_calls_completed_billing IS 'Optimized for billing calculations on completed calls';
COMMENT ON INDEX idx_campaign_stats_performance IS 'Comprehensive campaign analytics index';
COMMENT ON INDEX idx_audit_logs_table_user_time IS 'User activity tracking across all tables';
</file>

<file path="supabase/.gitignore">
# Supabase
.branches
.temp

# dotenvx
.env.keys
.env.local
.env.*.local
</file>

<file path="supabase/CLAUDE.md">
# Supabase Database Patterns

# Migration Structure
```
supabase/
├── migrations/           # SQL migration files
├── config.toml          # Local dev configuration
├── functions/           # Edge functions
└── seed.sql            # Development seed data
```

# Migration File Naming
- `001_initial_schema.sql` - Core database schema
- `002_security_policies.sql` - Row Level Security (RLS)
- `003_functions.sql` - Database functions and triggers
- `004_feature_specific.sql` - Feature additions

# Migration Best Practices
```sql
-- Always check if objects exist before creating
CREATE TABLE IF NOT EXISTS users (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Use proper foreign key constraints
ALTER TABLE campaigns
ADD CONSTRAINT fk_campaigns_buyer_id 
FOREIGN KEY (buyer_id) REFERENCES users(id) ON DELETE CASCADE;

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_calls_campaign_id ON calls(campaign_id);
CREATE INDEX IF NOT EXISTS idx_calls_status ON calls(status);
```

# Row Level Security (RLS) Patterns
```sql
-- Enable RLS on all tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE campaigns ENABLE ROW LEVEL SECURITY;
ALTER TABLE calls ENABLE ROW LEVEL SECURITY;

-- User can only access their own data
CREATE POLICY "Users can view own profile" ON users
  FOR SELECT USING (auth.uid() = id);

-- Role-based access for campaigns
CREATE POLICY "Buyers can manage their campaigns" ON campaigns
  FOR ALL USING (
    auth.uid() = buyer_id AND 
    (SELECT role FROM users WHERE id = auth.uid()) = 'buyer'
  );

-- Suppliers can view active campaigns
CREATE POLICY "Suppliers can view active campaigns" ON campaigns
  FOR SELECT USING (
    status = 'active' AND
    (SELECT role FROM users WHERE id = auth.uid()) = 'supplier'
  );
```

# Database Functions
```sql
-- Function to update timestamps
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger for auto-updating timestamps
CREATE TRIGGER update_users_updated_at
  BEFORE UPDATE ON users
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();
```

# Real-time Subscriptions Setup
```sql
-- Enable real-time for specific tables
ALTER PUBLICATION supabase_realtime 
ADD TABLE calls, campaigns, users;

-- Create real-time policies
CREATE POLICY "Real-time calls for campaign owners" ON calls
  FOR SELECT USING (
    campaign_id IN (
      SELECT id FROM campaigns 
      WHERE buyer_id = auth.uid()
    )
  );
```

# DCE-Specific Schema Patterns

## Users Table
```sql
CREATE TABLE users (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  email TEXT UNIQUE NOT NULL,
  role user_role NOT NULL DEFAULT 'supplier',
  profile JSONB DEFAULT '{}',
  is_verified BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TYPE user_role AS ENUM ('supplier', 'buyer', 'admin');
```

## Campaigns Table
```sql
CREATE TABLE campaigns (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  buyer_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  vertical campaign_vertical NOT NULL,
  status campaign_status DEFAULT 'draft',
  target_cpa DECIMAL(10,2),
  daily_budget DECIMAL(10,2),
  filters JSONB DEFAULT '{}',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TYPE campaign_status AS ENUM ('draft', 'active', 'paused', 'completed');
CREATE TYPE campaign_vertical AS ENUM ('insurance', 'home_services', 'legal', 'medical');
```

## Calls Table
```sql
CREATE TABLE calls (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  campaign_id UUID NOT NULL REFERENCES campaigns(id) ON DELETE CASCADE,
  supplier_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  tracking_number TEXT UNIQUE NOT NULL,
  caller_number TEXT,
  duration INTEGER DEFAULT 0,
  status call_status DEFAULT 'pending',
  quality_score INTEGER CHECK (quality_score >= 1 AND quality_score <= 10),
  payout_amount DECIMAL(10,2),
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TYPE call_status AS ENUM ('pending', 'active', 'completed', 'failed', 'fraud');
```

# Edge Functions Structure
```typescript
// supabase/functions/webhook-stripe/index.ts
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { corsHeaders } from '../_shared/cors.ts';

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    const signature = req.headers.get('stripe-signature')!;
    const body = await req.text();
    
    // Verify webhook signature
    // Process webhook data
    
    return new Response(
      JSON.stringify({ received: true }),
      { 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      },
    );
  } catch (error) {
    return new Response(
      JSON.stringify({ error: error.message }),
      { 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 400,
      },
    );
  }
});
```

# Local Development Setup
```toml
# config.toml
[api]
port = 54321
schemas = ["public", "auth", "storage", "realtime"]
extra_search_path = ["public", "extensions"]

[db]
port = 54322
major_version = 15

[studio]
port = 54323

[auth]
enable_signup = true
```

# Data Seeding
```sql
-- seed.sql
INSERT INTO users (id, email, role, is_verified) VALUES
  ('11111111-1111-1111-1111-111111111111', 'supplier@test.com', 'supplier', true),
  ('22222222-2222-2222-2222-222222222222', 'buyer@test.com', 'buyer', true);

INSERT INTO campaigns (buyer_id, name, vertical, status, target_cpa, daily_budget) VALUES
  ('22222222-2222-2222-2222-222222222222', 'Test Insurance Campaign', 'insurance', 'active', 50.00, 1000.00);
```

# Performance Optimization
```sql
-- Indexes for common queries
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_calls_created_at ON calls(created_at);
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_campaigns_buyer_id_status ON campaigns(buyer_id, status);

-- Partial indexes for active records
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_active_calls 
ON calls(campaign_id, created_at) WHERE status = 'active';
```

# Backup and Migrations
```bash
# Create migration
supabase migration new feature_name

# Apply migrations
supabase db push

# Reset local database
supabase db reset

# Generate TypeScript types
supabase gen types typescript --local > src/types/database.ts
```

# Testing Database
```sql
-- Create test-specific data
BEGIN;
  -- Insert test data
  INSERT INTO users ...;
  -- Run tests
ROLLBACK; -- Cleanup
```

# CRITICAL RULES
- NO regex in SQL queries or functions
- ALWAYS use RLS policies for data security
- ALWAYS create proper indexes for performance
- NEVER store sensitive data in JSONB fields
- ALWAYS use transactions for multi-table operations
- ENABLE real-time only for necessary tables
- TEST all migrations before deploying
- USE proper foreign key constraints
- IMPLEMENT audit trails for sensitive operations
- VALIDATE all user inputs at database level
</file>

<file path="supabase/config.toml">
# For detailed configuration reference documentation, visit:
# https://supabase.com/docs/guides/local-development/cli/config
# A string used to distinguish different Supabase projects on the same host. Defaults to the
# working directory name when running `supabase init`.
project_id = "dce-website"

[api]
enabled = true
# Port to use for the API URL.
port = 54321
# Schemas to expose in your API. Tables, views and stored procedures in this schema will get API
# endpoints. `public` and `graphql_public` schemas are included by default.
schemas = ["public", "graphql_public"]
# Extra schemas to add to the search_path of every request.
extra_search_path = ["public", "extensions"]
# The maximum number of rows returns from a view, table, or stored procedure. Limits payload size
# for accidental or malicious requests.
max_rows = 1000

[api.tls]
# Enable HTTPS endpoints locally using a self-signed certificate.
enabled = false

[db]
# Port to use for the local database URL.
port = 54322
# Port used by db diff command to initialize the shadow database.
shadow_port = 54320
# The database major version to use. This has to be the same as your remote database's. Run `SHOW
# server_version;` on the remote database to check.
major_version = 17

[db.pooler]
enabled = false
# Port to use for the local connection pooler.
port = 54329
# Specifies when a server connection can be reused by other clients.
# Configure one of the supported pooler modes: `transaction`, `session`.
pool_mode = "transaction"
# How many server connections to allow per user/database pair.
default_pool_size = 20
# Maximum number of client connections allowed.
max_client_conn = 100

# [db.vault]
# secret_key = "env(SECRET_VALUE)"

[db.migrations]
# If disabled, migrations will be skipped during a db push or reset.
enabled = true
# Specifies an ordered list of schema files that describe your database.
# Supports glob patterns relative to supabase directory: "./schemas/*.sql"
schema_paths = []

[db.seed]
# If enabled, seeds the database after migrations during a db reset.
enabled = true
# Specifies an ordered list of seed files to load during db reset.
# Supports glob patterns relative to supabase directory: "./seeds/*.sql"
sql_paths = ["./seed.sql"]

[db.network_restrictions]
# Enable management of network restrictions.
enabled = false
# List of IPv4 CIDR blocks allowed to connect to the database.
# Defaults to allow all IPv4 connections. Set empty array to block all IPs.
allowed_cidrs = ["0.0.0.0/0"]
# List of IPv6 CIDR blocks allowed to connect to the database.
# Defaults to allow all IPv6 connections. Set empty array to block all IPs.
allowed_cidrs_v6 = ["::/0"]

[realtime]
enabled = true
# Bind realtime via either IPv4 or IPv6. (default: IPv4)
# ip_version = "IPv6"
# The maximum length in bytes of HTTP request headers. (default: 4096)
# max_header_length = 4096

[studio]
enabled = true
# Port to use for Supabase Studio.
port = 54323
# External URL of the API server that frontend connects to.
api_url = "http://127.0.0.1"
# OpenAI API Key to use for Supabase AI in the Supabase Studio.
openai_api_key = "env(OPENAI_API_KEY)"

# Email testing server. Emails sent with the local dev setup are not actually sent - rather, they
# are monitored, and you can view the emails that would have been sent from the web interface.
[inbucket]
enabled = true
# Port to use for the email testing server web interface.
port = 54324
# Uncomment to expose additional ports for testing user applications that send emails.
# smtp_port = 54325
# pop3_port = 54326
# admin_email = "admin@email.com"
# sender_name = "Admin"

[storage]
enabled = true
# The maximum file size allowed (e.g. "5MB", "500KB").
file_size_limit = "50MiB"

# Image transformation API is available to Supabase Pro plan.
# [storage.image_transformation]
# enabled = true

# Uncomment to configure local storage buckets
# [storage.buckets.images]
# public = false
# file_size_limit = "50MiB"
# allowed_mime_types = ["image/png", "image/jpeg"]
# objects_path = "./images"

[auth]
enabled = true
# The base URL of your website. Used as an allow-list for redirects and for constructing URLs used
# in emails.
site_url = "http://localhost:5173"
# A list of *exact* URLs that auth providers are permitted to redirect to post authentication.
additional_redirect_urls = ["http://localhost:5173", "http://127.0.0.1:5173"]
# How long tokens are valid for, in seconds. Defaults to 3600 (1 hour), maximum 604,800 (1 week).
jwt_expiry = 3600
# If disabled, the refresh token will never expire.
enable_refresh_token_rotation = true
# Allows refresh tokens to be reused after expiry, up to the specified interval in seconds.
# Requires enable_refresh_token_rotation = true.
refresh_token_reuse_interval = 10
# Allow/disallow new user signups to your project.
enable_signup = true
# Allow/disallow anonymous sign-ins to your project.
enable_anonymous_sign_ins = false
# Allow/disallow testing manual linking of accounts
enable_manual_linking = false
# Passwords shorter than this value will be rejected as weak. Minimum 6, recommended 8 or more.
minimum_password_length = 8
# Passwords that do not meet the following requirements will be rejected as weak. Supported values
# are: `letters_digits`, `lower_upper_letters_digits`, `lower_upper_letters_digits_symbols`
password_requirements = "lower_upper_letters_digits"

[auth.rate_limit]
# Number of emails that can be sent per hour. Requires auth.email.smtp to be enabled.
email_sent = 2
# Number of SMS messages that can be sent per hour. Requires auth.sms to be enabled.
sms_sent = 30
# Number of anonymous sign-ins that can be made per hour per IP address. Requires enable_anonymous_sign_ins = true.
anonymous_users = 30
# Number of sessions that can be refreshed in a 5 minute interval per IP address.
token_refresh = 150
# Number of sign up and sign-in requests that can be made in a 5 minute interval per IP address (excludes anonymous users).
sign_in_sign_ups = 30
# Number of OTP / Magic link verifications that can be made in a 5 minute interval per IP address.
token_verifications = 30
# Number of Web3 logins that can be made in a 5 minute interval per IP address.
web3 = 30

# Configure one of the supported captcha providers: `hcaptcha`, `turnstile`.
# [auth.captcha]
# enabled = true
# provider = "hcaptcha"
# secret = ""

[auth.email]
# Allow/disallow new user signups via email to your project.
enable_signup = true
# If enabled, a user will be required to confirm any email change on both the old, and new email
# addresses. If disabled, only the new email is required to confirm.
double_confirm_changes = true
# If enabled, users need to confirm their email address before signing in.
enable_confirmations = true
# If enabled, users will need to reauthenticate or have logged in recently to change their password.
secure_password_change = false
# Controls the minimum amount of time that must pass before sending another signup confirmation or password reset email.
max_frequency = "1s"
# Number of characters used in the email OTP.
otp_length = 6
# Number of seconds before the email OTP expires (defaults to 1 hour).
otp_expiry = 3600

# Use a production-ready SMTP server
# [auth.email.smtp]
# enabled = true
# host = "smtp.sendgrid.net"
# port = 587
# user = "apikey"
# pass = "env(SENDGRID_API_KEY)"
# admin_email = "admin@email.com"
# sender_name = "Admin"

# Uncomment to customize email template
# [auth.email.template.invite]
# subject = "You have been invited"
# content_path = "./supabase/templates/invite.html"

[auth.sms]
# Allow/disallow new user signups via SMS to your project.
enable_signup = false
# If enabled, users need to confirm their phone number before signing in.
enable_confirmations = false
# Template for sending OTP to users
template = "Your code is {{ .Code }}"
# Controls the minimum amount of time that must pass before sending another sms otp.
max_frequency = "5s"

# Use pre-defined map of phone number to OTP for testing.
# [auth.sms.test_otp]
# 4152127777 = "123456"

# Configure logged in session timeouts.
# [auth.sessions]
# Force log out after the specified duration.
# timebox = "24h"
# Force log out if the user has been inactive longer than the specified duration.
# inactivity_timeout = "8h"

# This hook runs before a new user is created and allows developers to reject the request based on the incoming user object.
# [auth.hook.before_user_created]
# enabled = true
# uri = "pg-functions://postgres/auth/before-user-created-hook"

# This hook runs before a token is issued and allows you to add additional claims based on the authentication method used.
# [auth.hook.custom_access_token]
# enabled = true
# uri = "pg-functions://<database>/<schema>/<hook_name>"

# Configure one of the supported SMS providers: `twilio`, `twilio_verify`, `messagebird`, `textlocal`, `vonage`.
[auth.sms.twilio]
enabled = false
account_sid = ""
message_service_sid = ""
# DO NOT commit your Twilio auth token to git. Use environment variable substitution instead:
auth_token = "env(SUPABASE_AUTH_SMS_TWILIO_AUTH_TOKEN)"

# Multi-factor-authentication is available to Supabase Pro plan.
[auth.mfa]
# Control how many MFA factors can be enrolled at once per user.
max_enrolled_factors = 10

# Control MFA via App Authenticator (TOTP)
[auth.mfa.totp]
enroll_enabled = false
verify_enabled = false

# Configure MFA via Phone Messaging
[auth.mfa.phone]
enroll_enabled = false
verify_enabled = false
otp_length = 6
template = "Your code is {{ .Code }}"
max_frequency = "5s"

# Configure MFA via WebAuthn
# [auth.mfa.web_authn]
# enroll_enabled = true
# verify_enabled = true

# Use an external OAuth provider. The full list of providers are: `apple`, `azure`, `bitbucket`,
# `discord`, `facebook`, `github`, `gitlab`, `google`, `keycloak`, `linkedin_oidc`, `notion`, `twitch`,
# `twitter`, `slack`, `spotify`, `workos`, `zoom`.
[auth.external.apple]
enabled = false
client_id = ""
# DO NOT commit your OAuth provider secret to git. Use environment variable substitution instead:
secret = "env(SUPABASE_AUTH_EXTERNAL_APPLE_SECRET)"
# Overrides the default auth redirectUrl.
redirect_uri = ""
# Overrides the default auth provider URL. Used to support self-hosted gitlab, single-tenant Azure,
# or any other third-party OIDC providers.
url = ""
# If enabled, the nonce check will be skipped. Required for local sign in with Google auth.
skip_nonce_check = false

# Allow Solana wallet holders to sign in to your project via the Sign in with Solana (SIWS, EIP-4361) standard.
# You can configure "web3" rate limit in the [auth.rate_limit] section and set up [auth.captcha] if self-hosting.
[auth.web3.solana]
enabled = false

# Use Firebase Auth as a third-party provider alongside Supabase Auth.
[auth.third_party.firebase]
enabled = false
# project_id = "my-firebase-project"

# Use Auth0 as a third-party provider alongside Supabase Auth.
[auth.third_party.auth0]
enabled = false
# tenant = "my-auth0-tenant"
# tenant_region = "us"

# Use AWS Cognito (Amplify) as a third-party provider alongside Supabase Auth.
[auth.third_party.aws_cognito]
enabled = false
# user_pool_id = "my-user-pool-id"
# user_pool_region = "us-east-1"

# Use Clerk as a third-party provider alongside Supabase Auth.
[auth.third_party.clerk]
enabled = false
# Obtain from https://clerk.com/setup/supabase
# domain = "example.clerk.accounts.dev"

[edge_runtime]
enabled = true
# Configure one of the supported request policies: `oneshot`, `per_worker`.
# Use `oneshot` for hot reload, or `per_worker` for load testing.
policy = "oneshot"
# Port to attach the Chrome inspector for debugging edge functions.
inspector_port = 8083
# The Deno major version to use.
deno_version = 1

# [edge_runtime.secrets]
# secret_key = "env(SECRET_VALUE)"

[analytics]
enabled = true
port = 54327
# Configure one of the supported backends: `postgres`, `bigquery`.
backend = "postgres"

# Experimental features may be deprecated any time
[experimental]
# Configures Postgres storage engine to use OrioleDB (S3)
orioledb_version = ""
# Configures S3 bucket URL, eg. <bucket_name>.s3-<region>.amazonaws.com
s3_host = "env(S3_HOST)"
# Configures S3 bucket region, eg. us-east-1
s3_region = "env(S3_REGION)"
# Configures AWS_ACCESS_KEY_ID for S3 bucket
s3_access_key = "env(S3_ACCESS_KEY)"
# Configures AWS_SECRET_ACCESS_KEY for S3 bucket
s3_secret_key = "env(S3_SECRET_KEY)"
</file>

<file path="supabase/README.md">
# DCE Platform Supabase Backend Setup

This directory contains the complete Supabase backend implementation for the Dependable Call Exchange platform.

## 🏗️ Database Architecture

### Core Tables
- **users** - User accounts (extends auth.users)
- **suppliers** - Traffic providers
- **buyers** - Advertisers purchasing leads
- **campaigns** - Supplier traffic campaigns
- **buyer_campaigns** - Buyer purchasing criteria
- **calls** - Core call transaction records
- **tracking_numbers** - Phone numbers for call routing

### Supporting Tables
- **payouts** - Supplier payments
- **invoices** - Buyer billing
- **call_quality_scores** - Quality assessment
- **disputes** - Quality/billing disputes
- **campaign_stats** - Performance analytics
- **audit_logs** - System audit trail

## 🔐 Security Features

### Row Level Security (RLS)
- **Suppliers** can only access their own campaigns and calls
- **Buyers** can only access their campaigns and received calls
- **Admins** have broader access with role-based permissions
- **Audit logging** for all sensitive operations

### Data Protection
- All sensitive data encrypted at rest and in transit
- PII fields use field-level encryption where needed
- Comprehensive audit trail for compliance

## 📁 File Structure

```
supabase/
├── migrations/
│   ├── 001_initial_schema.sql      # Core database schema
│   ├── 002_security_policies.sql   # Row Level Security policies
│   ├── 003_functions.sql           # Business logic functions
│   ├── 004_triggers.sql            # Automated processes
│   └── 005_indexes.sql             # Performance indexes
├── functions/                      # Edge functions (to be added)
├── config.toml                     # Supabase configuration
├── seed.sql                        # Development test data
└── README.md                       # This file
```

## 🚀 Quick Start

### Prerequisites
- Docker Desktop installed and running
- Node.js 18+ 
- Supabase CLI installed (`npm i -g supabase`)

### Local Development Setup

1. **Start Supabase locally:**
   ```bash
   supabase start
   ```

2. **Apply migrations:**
   ```bash
   supabase db reset
   ```

3. **View local dashboard:**
   ```bash
   # API: http://localhost:54321
   # Studio: http://localhost:54323
   # Inbucket (emails): http://localhost:54324
   ```

4. **Generate TypeScript types:**
   ```bash
   supabase gen types typescript --local > ../src/types/database.ts
   ```

### Environment Setup

Copy `.env.local` values to your environment:

```bash
# For local development
VITE_SUPABASE_URL=http://127.0.0.1:54321
VITE_SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZS1kZW1vIiwicm9sZSI6ImFub24iLCJleHAiOjE5ODM4MTI5OTZ9.CRXP1A7WOeoJeXxjNni43kdQwgnWNReilDMblYTn_I0
```

## 📊 Database Functions

### Balance Calculations
- `calculate_supplier_balance(supplier_id)` - Get supplier available balance
- `calculate_buyer_balance(buyer_id)` - Get buyer remaining credit

### Quality Scoring
- `calculate_quality_score(duration, metadata)` - Score call quality (1-100)
- `detect_fraud_indicators(caller_data)` - Analyze fraud risk

### Campaign Matching  
- `find_matching_buyer_campaigns(campaign_id)` - Real-time call routing
- `calculate_call_billing(campaign_id, buyer_campaign_id)` - Billing amounts

### Analytics
- `process_hourly_stats()` - Aggregate campaign performance
- `get_campaign_performance(campaign_id, date_range)` - Performance summaries

## 🔧 Key Features

### Real-time Capabilities
- Live call updates via Supabase Realtime
- Campaign status changes
- Payment notifications
- System alerts

### Automated Processes
- Quality scoring on call completion
- Fraud detection and flagging
- Balance updates on transactions
- Hourly stats aggregation
- Audit logging for all changes

### Performance Optimizations
- Comprehensive indexing strategy
- Partial indexes for active records only
- JSONB indexes for metadata queries
- Full-text search capabilities

## 🧪 Test Data

The `seed.sql` file includes:
- Admin, supplier, and buyer test accounts
- Sample campaigns (insurance and legal verticals)
- Test calls with quality scores
- Invoice and payout examples
- Campaign performance statistics

### Test User Accounts
- **Admin**: admin@dce-platform.com
- **Supplier**: supplier@test.com (Test Traffic Co)
- **Buyer 1**: buyer@test.com (Insurance Plus LLC)
- **Buyer 2**: buyer2@test.com (Premium Legal Services)

## 🔍 Monitoring & Debugging

### Query Performance
```sql
-- Check slow queries
SELECT query, mean_time, calls 
FROM pg_stat_statements 
ORDER BY mean_time DESC 
LIMIT 10;

-- Check index usage
SELECT schemaname, tablename, attname, n_distinct, correlation
FROM pg_stats
WHERE schemaname = 'public'
ORDER BY n_distinct DESC;
```

### Audit Trail Queries
```sql
-- User activity tracking
SELECT table_name, operation, created_at, new_data
FROM audit_logs
WHERE user_id = 'user-uuid'
ORDER BY created_at DESC;

-- Table change history
SELECT operation, old_data, new_data, created_at
FROM audit_logs
WHERE table_name = 'campaigns' AND record_id = 'campaign-uuid'
ORDER BY created_at DESC;
```

## 🚢 Production Deployment

### Supabase Project Setup
1. Create new Supabase project
2. Configure custom domain (optional)
3. Set up database backups
4. Configure auth providers
5. Set environment variables

### Migration Deployment
```bash
# Link to remote project
supabase link --project-ref your-project-ref

# Push migrations
supabase db push

# Deploy edge functions
supabase functions deploy
```

### Environment Variables
```bash
# Production environment
VITE_SUPABASE_URL=https://your-project.supabase.co
VITE_SUPABASE_ANON_KEY=your-anon-key
```

## 🛡️ Security Checklist

- [ ] RLS enabled on all tables
- [ ] Proper role-based access policies
- [ ] Audit logging configured
- [ ] Rate limiting enabled
- [ ] API keys properly secured
- [ ] Database backups scheduled
- [ ] Monitoring alerts configured

## 🔧 Troubleshooting

### Common Issues

**Migration errors:**
```bash
# Reset local database
supabase db reset

# Check migration status
supabase migration list
```

**RLS policy issues:**
```sql
-- Test policy as specific user
SET ROLE authenticated;
SET request.jwt.claim.sub TO 'user-uuid';
SELECT * FROM campaigns; -- Should respect RLS
```

**Performance issues:**
```sql
-- Analyze query performance
EXPLAIN ANALYZE SELECT * FROM calls 
WHERE campaign_id = 'uuid' 
ORDER BY started_at DESC;
```

## 📚 Additional Resources

- [Supabase Documentation](https://supabase.com/docs)
- [PostgreSQL Documentation](https://www.postgresql.org/docs/)
- [Row Level Security Guide](https://supabase.com/docs/guides/auth/row-level-security)
- [Real-time Subscriptions](https://supabase.com/docs/guides/realtime)

## 🤝 Contributing

When adding new features:
1. Create a new migration file
2. Update RLS policies if needed
3. Add appropriate indexes
4. Update seed data for testing
5. Add audit logging for sensitive operations
6. Document any new functions or procedures
</file>

<file path="supabase/seed.sql">
-- DCE Platform Development Seed Data
-- Test data for local development and testing

-- Insert test users (these will need to be created via Supabase Auth first)
-- The UUIDs below are examples - replace with actual auth.users IDs after signup

-- Insert admin user profile
INSERT INTO users (id, email, first_name, last_name, status, is_active) VALUES
('00000000-0000-0000-0000-000000000001', 'admin@dce-platform.com', 'Admin', 'User', 'active', true)
ON CONFLICT (id) DO UPDATE SET
  email = EXCLUDED.email,
  first_name = EXCLUDED.first_name,
  last_name = EXCLUDED.last_name,
  status = EXCLUDED.status,
  is_active = EXCLUDED.is_active;

-- Insert test admin record
INSERT INTO admins (user_id, role, permissions, is_active) VALUES
('00000000-0000-0000-0000-000000000001', 'super_admin', '{"super_admin": true, "user_management": true, "financial_management": true}', true)
ON CONFLICT (user_id) DO UPDATE SET
  role = EXCLUDED.role,
  permissions = EXCLUDED.permissions,
  is_active = EXCLUDED.is_active;

-- Insert test supplier user
INSERT INTO users (id, email, first_name, last_name, status, is_active) VALUES
('11111111-1111-1111-1111-111111111111', 'supplier@test.com', 'Test', 'Supplier', 'active', true)
ON CONFLICT (id) DO UPDATE SET
  email = EXCLUDED.email,
  first_name = EXCLUDED.first_name,
  last_name = EXCLUDED.last_name,
  status = EXCLUDED.status,
  is_active = EXCLUDED.is_active;

-- Insert test supplier record
INSERT INTO suppliers (user_id, company_name, business_type, credit_balance, status, approved_at, approved_by) VALUES
('11111111-1111-1111-1111-111111111111', 'Test Traffic Co', 'Lead Generation', 1500.00, 'active', NOW(), (SELECT id FROM admins WHERE role = 'super_admin' LIMIT 1))
ON CONFLICT (user_id) DO UPDATE SET
  company_name = EXCLUDED.company_name,
  business_type = EXCLUDED.business_type,
  credit_balance = EXCLUDED.credit_balance,
  status = EXCLUDED.status;

-- Insert test buyer users
INSERT INTO users (id, email, first_name, last_name, status, is_active) VALUES
('22222222-2222-2222-2222-222222222222', 'buyer@test.com', 'Test', 'Buyer', 'active', true),
('33333333-3333-3333-3333-333333333333', 'buyer2@test.com', 'Premium', 'Buyer', 'active', true)
ON CONFLICT (id) DO UPDATE SET
  email = EXCLUDED.email,
  first_name = EXCLUDED.first_name,
  last_name = EXCLUDED.last_name,
  status = EXCLUDED.status,
  is_active = EXCLUDED.is_active;

-- Insert test buyer records
INSERT INTO buyers (user_id, company_name, business_type, credit_limit, current_balance, status, approved_at, approved_by) VALUES
('22222222-2222-2222-2222-222222222222', 'Insurance Plus LLC', 'Insurance', 10000.00, 8500.00, 'active', NOW(), (SELECT id FROM admins WHERE role = 'super_admin' LIMIT 1)),
('33333333-3333-3333-3333-333333333333', 'Premium Legal Services', 'Legal Services', 25000.00, 22000.00, 'active', NOW(), (SELECT id FROM admins WHERE role = 'super_admin' LIMIT 1))
ON CONFLICT (user_id) DO UPDATE SET
  company_name = EXCLUDED.company_name,
  business_type = EXCLUDED.business_type,
  credit_limit = EXCLUDED.credit_limit,
  current_balance = EXCLUDED.current_balance,
  status = EXCLUDED.status;

-- Insert test campaigns
INSERT INTO campaigns (
  id, supplier_id, name, description, category, vertical, 
  targeting, bid_floor, max_concurrent_calls, status,
  quality_threshold, recording_enabled
) VALUES
(
  'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa',
  (SELECT id FROM suppliers WHERE user_id = '11111111-1111-1111-1111-111111111111'),
  'Auto Insurance Leads - Florida',
  'High-quality auto insurance leads from Florida residents',
  'Insurance',
  'Auto Insurance',
  '{"geographic": {"states": ["FL"], "cities": ["Miami", "Orlando", "Tampa"]}, "demographic": {"age_range": "25-65", "income_level": "middle"}, "schedule": {"enabled": true, "timezone": "EST", "hours": {"monday": {"start": 9, "end": 18}, "tuesday": {"start": 9, "end": 18}, "wednesday": {"start": 9, "end": 18}, "thursday": {"start": 9, "end": 18}, "friday": {"start": 9, "end": 18}}}}',
  15.00,
  5,
  'active',
  75,
  true
),
(
  'bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb',
  (SELECT id FROM suppliers WHERE user_id = '11111111-1111-1111-1111-111111111111'),
  'Personal Injury Legal Leads',
  'Qualified personal injury leads for law firms',
  'Legal',
  'Personal Injury',
  '{"geographic": {"states": ["CA", "NY", "TX"], "metro_areas": ["Los Angeles", "New York", "Houston"]}, "demographic": {"age_range": "18-75"}, "schedule": {"enabled": true, "timezone": "PST", "hours": {"monday": {"start": 8, "end": 20}, "tuesday": {"start": 8, "end": 20}, "wednesday": {"start": 8, "end": 20}, "thursday": {"start": 8, "end": 20}, "friday": {"start": 8, "end": 20}}}}',
  85.00,
  10,
  'active',
  80,
  true
)
ON CONFLICT (id) DO UPDATE SET
  name = EXCLUDED.name,
  description = EXCLUDED.description,
  category = EXCLUDED.category,
  vertical = EXCLUDED.vertical,
  targeting = EXCLUDED.targeting,
  bid_floor = EXCLUDED.bid_floor,
  status = EXCLUDED.status;

-- Insert tracking numbers for campaigns
INSERT INTO tracking_numbers (campaign_id, number, display_number, area_code, is_active) VALUES
((SELECT id FROM campaigns WHERE name = 'Auto Insurance Leads - Florida'), '8005551234', '(800) 555-1234', '800', true),
((SELECT id FROM campaigns WHERE name = 'Auto Insurance Leads - Florida'), '8005551235', '(800) 555-1235', '800', true),
((SELECT id FROM campaigns WHERE name = 'Personal Injury Legal Leads'), '8005556789', '(800) 555-6789', '800', true),
((SELECT id FROM campaigns WHERE name = 'Personal Injury Legal Leads'), '8005556790', '(800) 555-6790', '800', true)
ON CONFLICT (number) DO UPDATE SET
  display_number = EXCLUDED.display_number,
  area_code = EXCLUDED.area_code,
  is_active = EXCLUDED.is_active;

-- Insert test buyer campaigns
INSERT INTO buyer_campaigns (
  id, buyer_id, name, description, targeting_criteria, 
  max_bid, daily_budget, monthly_budget, status,
  quality_requirements, auto_approval_enabled
) VALUES
(
  'cccccccc-cccc-cccc-cccc-cccccccccccc',
  (SELECT id FROM buyers WHERE user_id = '22222222-2222-2222-2222-222222222222'),
  'Florida Auto Insurance Campaign',
  'Buying auto insurance leads in Florida market',
  '{"geographic": {"states": ["FL"]}, "vertical": ["Auto Insurance"], "call_duration_min": 60, "quality_score_min": 70}',
  20.00,
  500.00,
  15000.00,
  'active',
  '{"minimum_duration": 45, "minimum_quality_score": 70, "required_fields": ["name", "phone", "email"]}',
  true
),
(
  'dddddddd-dddd-dddd-dddd-dddddddddddd',
  (SELECT id FROM buyers WHERE user_id = '33333333-3333-3333-3333-333333333333'),
  'Personal Injury Leads - Multi-State',
  'High-value personal injury leads across multiple states',
  '{"geographic": {"states": ["CA", "NY", "TX"]}, "vertical": ["Personal Injury"], "call_duration_min": 120, "quality_score_min": 80}',
  150.00,
  2000.00,
  60000.00,
  'active',
  '{"minimum_duration": 90, "minimum_quality_score": 80, "required_fields": ["name", "phone", "email", "injury_type"]}',
  false
)
ON CONFLICT (id) DO UPDATE SET
  name = EXCLUDED.name,
  description = EXCLUDED.description,
  targeting_criteria = EXCLUDED.targeting_criteria,
  max_bid = EXCLUDED.max_bid,
  daily_budget = EXCLUDED.daily_budget,
  monthly_budget = EXCLUDED.monthly_budget,
  status = EXCLUDED.status;

-- Insert sample calls data
INSERT INTO calls (
  id, campaign_id, buyer_campaign_id, tracking_number, 
  caller_number, destination_number, started_at, ended_at,
  duration_seconds, payout_amount, charge_amount, margin_amount,
  status, quality_score, caller_location, metadata
) VALUES
(
  'call1111-1111-1111-1111-111111111111',
  'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa',
  'cccccccc-cccc-cccc-cccc-cccccccccccc',
  '8005551234',
  '+13055551111',
  '+13055552222',
  NOW() - INTERVAL '2 hours',
  NOW() - INTERVAL '2 hours' + INTERVAL '185 seconds',
  185,
  18.50,
  20.00,
  1.50,
  'completed',
  85,
  '{"city": "Miami", "state": "FL", "country": "US", "zip": "33101"}',
  '{"intent_confirmed": true, "lead_quality": "high", "notes": "Interested in auto insurance quote"}'
),
(
  'call2222-2222-2222-2222-222222222222',
  'bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb',
  'dddddddd-dddd-dddd-dddd-dddddddddddd',
  '8005556789',
  '+12125553333',
  '+12125554444',
  NOW() - INTERVAL '1 hour',
  NOW() - INTERVAL '1 hour' + INTERVAL '320 seconds',
  320,
  127.50,
  150.00,
  22.50,
  'completed',
  92,
  '{"city": "New York", "state": "NY", "country": "US", "zip": "10001"}',
  '{"intent_confirmed": true, "injury_type": "car_accident", "lead_quality": "premium", "attorney_needed": true}'
),
(
  'call3333-3333-3333-3333-333333333333',
  'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa',
  'cccccccc-cccc-cccc-cccc-cccccccccccc',
  '8005551235',
  '+14075556666',
  '+14075557777',
  NOW() - INTERVAL '30 minutes',
  NOW() - INTERVAL '30 minutes' + INTERVAL '45 seconds',
  45,
  9.25,
  10.00,
  0.75,
  'completed',
  65,
  '{"city": "Orlando", "state": "FL", "country": "US", "zip": "32801"}',
  '{"intent_confirmed": false, "lead_quality": "low", "notes": "Short call, limited interest"}'
)
ON CONFLICT (id) DO UPDATE SET
  duration_seconds = EXCLUDED.duration_seconds,
  payout_amount = EXCLUDED.payout_amount,
  charge_amount = EXCLUDED.charge_amount,
  margin_amount = EXCLUDED.margin_amount,
  status = EXCLUDED.status,
  quality_score = EXCLUDED.quality_score;

-- Insert call quality scores for the sample calls
INSERT INTO call_quality_scores (
  call_id, duration_score, intent_score, content_score, 
  technical_score, overall_score, scoring_model, flags
) VALUES
(
  'call1111-1111-1111-1111-111111111111',
  90, 85, 80, 85, 85, 'v1.0', '[]'
),
(
  'call2222-2222-2222-2222-222222222222',
  95, 95, 90, 88, 92, 'v1.0', '[]'
),
(
  'call3333-3333-3333-3333-333333333333',
  45, 50, 65, 75, 65, 'v1.0', '["short_duration", "low_intent"]'
)
ON CONFLICT (call_id) DO UPDATE SET
  duration_score = EXCLUDED.duration_score,
  intent_score = EXCLUDED.intent_score,
  overall_score = EXCLUDED.overall_score;

-- Insert sample campaign stats
INSERT INTO campaign_stats (
  campaign_id, date, calls_count, connected_calls, completed_calls,
  total_duration, avg_duration, total_payout, avg_payout, quality_score_avg
) VALUES
(
  'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa',
  CURRENT_DATE,
  2, 2, 2, 230, 115.0, 27.75, 13.88, 75.0
),
(
  'bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb',
  CURRENT_DATE,
  1, 1, 1, 320, 320.0, 127.50, 127.50, 92.0
)
ON CONFLICT (campaign_id, date, hour) DO UPDATE SET
  calls_count = EXCLUDED.calls_count,
  connected_calls = EXCLUDED.connected_calls,
  completed_calls = EXCLUDED.completed_calls,
  total_duration = EXCLUDED.total_duration,
  avg_duration = EXCLUDED.avg_duration,
  total_payout = EXCLUDED.total_payout,
  avg_payout = EXCLUDED.avg_payout,
  quality_score_avg = EXCLUDED.quality_score_avg;

-- Insert sample buyer campaign stats
INSERT INTO buyer_campaign_stats (
  buyer_campaign_id, date, calls_received, calls_accepted, calls_completed,
  total_cost, avg_cost, total_duration, avg_duration, quality_score_avg
) VALUES
(
  'cccccccc-cccc-cccc-cccc-cccccccccccc',
  CURRENT_DATE,
  2, 2, 2, 30.00, 15.00, 230, 115.0, 75.0
),
(
  'dddddddd-dddd-dddd-dddd-dddddddddddd',
  CURRENT_DATE,
  1, 1, 1, 150.00, 150.00, 320, 320.0, 92.0
)
ON CONFLICT (buyer_campaign_id, date, hour) DO UPDATE SET
  calls_received = EXCLUDED.calls_received,
  calls_accepted = EXCLUDED.calls_accepted,
  calls_completed = EXCLUDED.calls_completed,
  total_cost = EXCLUDED.total_cost,
  avg_cost = EXCLUDED.avg_cost,
  total_duration = EXCLUDED.total_duration,
  avg_duration = EXCLUDED.avg_duration,
  quality_score_avg = EXCLUDED.quality_score_avg;

-- Insert sample invoice
INSERT INTO invoices (
  buyer_id, invoice_number, amount, tax_amount, total_amount,
  status, period_start, period_end, due_date, payment_terms
) VALUES
(
  (SELECT id FROM buyers WHERE user_id = '22222222-2222-2222-2222-222222222222'),
  'INV-2024-000001',
  30.00,
  2.40,
  32.40,
  'open',
  CURRENT_DATE - INTERVAL '7 days',
  CURRENT_DATE,
  CURRENT_DATE + INTERVAL '30 days',
  30
)
ON CONFLICT (invoice_number) DO UPDATE SET
  amount = EXCLUDED.amount,
  tax_amount = EXCLUDED.tax_amount,
  total_amount = EXCLUDED.total_amount;

-- Insert invoice line items
INSERT INTO invoice_line_items (
  invoice_id, description, quantity, unit_price, total_amount, call_id
) VALUES
(
  (SELECT id FROM invoices WHERE invoice_number = 'INV-2024-000001'),
  'Auto Insurance Call - Miami, FL (185s)',
  1,
  20.0000,
  20.00,
  'call1111-1111-1111-1111-111111111111'
),
(
  (SELECT id FROM invoices WHERE invoice_number = 'INV-2024-000001'),
  'Auto Insurance Call - Orlando, FL (45s)',
  1,
  10.0000,
  10.00,
  'call3333-3333-3333-3333-333333333333'
)
ON CONFLICT DO NOTHING;

-- Insert sample payout
INSERT INTO payouts (
  supplier_id, amount, fee_amount, net_amount, status,
  period_start, period_end, payment_method, reference_number
) VALUES
(
  (SELECT id FROM suppliers WHERE user_id = '11111111-1111-1111-1111-111111111111'),
  155.25,
  7.76,
  147.49,
  'pending',
  CURRENT_DATE - INTERVAL '7 days',
  CURRENT_DATE,
  'bank_transfer',
  'PAY-2024-000001'
)
ON CONFLICT DO NOTHING;

-- Update supplier balance based on completed calls
UPDATE suppliers 
SET credit_balance = calculate_supplier_balance(id)
WHERE user_id = '11111111-1111-1111-1111-111111111111';

-- Update buyer balance based on charges
UPDATE buyers 
SET current_balance = calculate_buyer_balance(id)
WHERE user_id IN ('22222222-2222-2222-2222-222222222222', '33333333-3333-3333-3333-333333333333');

-- Comments
COMMENT ON TABLE users IS 'Seed data includes admin, supplier, and buyer test accounts';
COMMENT ON TABLE campaigns IS 'Sample campaigns for auto insurance and legal verticals';
COMMENT ON TABLE calls IS 'Sample call data with varying quality scores and durations';
COMMENT ON TABLE invoices IS 'Sample billing data for testing payment flows';
</file>

<file path="tests/e2e/auth/example.spec.ts">
import { test, expect } from '@playwright/test'

// Example E2E test - remove this once real auth tests are implemented
test.describe('Authentication Example', () => {
  test('should display Vite React app homepage', async ({ page }) => {
    await page.goto('/')
    
    // This is just an example test to verify E2E setup
    // Replace with actual authentication tests once the auth system is implemented
    await expect(page).toHaveTitle(/Vite \+ React \+ TS/)
  })
  
  test('should load React app content', async ({ page }) => {
    await page.goto('/')
    
    // Example test to verify the basic Vite React app loads
    // Update with actual application content tests once implemented
    await expect(page).toHaveTitle(/Vite \+ React \+ TS/)
    await expect(page.locator('body')).toBeVisible()
  })
})
</file>

<file path="tests/e2e/CLAUDE.md">
# End-to-End Test Patterns

# Test File Organization
```
e2e/
├── auth/          # Authentication flows
├── campaigns/     # Campaign management
├── calls/         # Call tracking
├── billing/       # Payment processing
└── shared/        # Shared utilities and fixtures
```

# Playwright Configuration
- Multi-browser testing (Chromium, Firefox, Safari)
- Mobile viewport testing
- Network conditions simulation
- Video recording on failures
- Screenshot comparison

# Basic Test Template
```ts
import { test, expect } from '@playwright/test';

test.describe('Feature Name', () => {
  test.beforeEach(async ({ page }) => {
    // Setup before each test
    await page.goto('/');
  });

  test('should perform user action', async ({ page }) => {
    // Test implementation
    await page.click('[data-testid="button"]');
    await expect(page.locator('[data-testid="result"]')).toBeVisible();
  });
});
```

# Authentication Flow Tests
```ts
import { test, expect } from '@playwright/test';
import { loginAsSupplier, loginAsBuyer } from './helpers/auth';

test.describe('Authentication', () => {
  test('should login as supplier', async ({ page }) => {
    await page.goto('/login');
    
    await page.fill('[name="email"]', 'supplier@test.com');
    await page.fill('[name="password"]', 'password123');
    await page.click('[type="submit"]');
    
    await expect(page).toHaveURL('/dashboard');
    await expect(page.locator('[data-testid="supplier-dashboard"]')).toBeVisible();
  });

  test('should redirect to login for protected routes', async ({ page }) => {
    await page.goto('/dashboard');
    await expect(page).toHaveURL('/login');
  });
});
```

# Page Object Pattern
```ts
// pages/LoginPage.ts
export class LoginPage {
  constructor(private page: Page) {}

  async navigate() {
    await this.page.goto('/login');
  }

  async login(email: string, password: string) {
    await this.page.fill('[name="email"]', email);
    await this.page.fill('[name="password"]', password);
    await this.page.click('[type="submit"]');
  }

  async getErrorMessage() {
    return await this.page.textContent('[data-testid="error-message"]');
  }
}

// Usage in test
test('should show error for invalid credentials', async ({ page }) => {
  const loginPage = new LoginPage(page);
  await loginPage.navigate();
  await loginPage.login('invalid@test.com', 'wrongpassword');
  
  const error = await loginPage.getErrorMessage();
  expect(error).toBe('Invalid credentials');
});
```

# Data Attributes for Testing
```tsx
// Use data-testid for reliable element selection
<button data-testid="create-campaign-button">
  Create Campaign
</button>

// Access in tests
await page.click('[data-testid="create-campaign-button"]');
```

# API Mocking and Fixtures
```ts
import { test, expect } from '@playwright/test';

test('should handle API responses', async ({ page }) => {
  // Mock API response
  await page.route('/api/campaigns', (route) => {
    route.fulfill({
      status: 200,
      contentType: 'application/json',
      body: JSON.stringify({
        campaigns: [
          { id: '1', name: 'Test Campaign', status: 'active' }
        ]
      })
    });
  });

  await page.goto('/campaigns');
  await expect(page.locator('[data-testid="campaign-1"]')).toBeVisible();
});
```

# Real-time Feature Testing
```ts
test('should update call status in real-time', async ({ page, context }) => {
  await page.goto('/calls');
  
  // Simulate real-time update
  await page.evaluate(() => {
    window.dispatchEvent(new CustomEvent('callStatusUpdate', {
      detail: { callId: '123', status: 'completed' }
    }));
  });
  
  await expect(page.locator('[data-testid="call-123-status"]'))
    .toContainText('completed');
});
```

# Multi-User Testing
```ts
test('should handle multiple users simultaneously', async ({ browser }) => {
  const supplierContext = await browser.newContext();
  const buyerContext = await browser.newContext();
  
  const supplierPage = await supplierContext.newPage();
  const buyerPage = await buyerContext.newPage();
  
  // Login as different users
  await loginAsSupplier(supplierPage);
  await loginAsBuyer(buyerPage);
  
  // Test interactions between users
  await supplierPage.click('[data-testid="start-call"]');
  await expect(buyerPage.locator('[data-testid="incoming-call"]'))
    .toBeVisible({ timeout: 5000 });
});
```

# Form Testing
```ts
test('should validate form inputs', async ({ page }) => {
  await page.goto('/campaigns/create');
  
  // Test required field validation
  await page.click('[type="submit"]');
  await expect(page.locator('[data-testid="name-error"]'))
    .toContainText('Campaign name is required');
  
  // Test successful form submission
  await page.fill('[name="name"]', 'New Campaign');
  await page.selectOption('[name="category"]', 'insurance');
  await page.fill('[name="budget"]', '1000');
  
  await page.click('[type="submit"]');
  await expect(page).toHaveURL('/campaigns');
});
```

# Mobile Responsiveness Testing
```ts
test.describe('Mobile Tests', () => {
  test.use({ viewport: { width: 375, height: 667 } });

  test('should be mobile responsive', async ({ page }) => {
    await page.goto('/dashboard');
    
    // Check mobile navigation
    await page.click('[data-testid="mobile-menu-button"]');
    await expect(page.locator('[data-testid="mobile-nav"]')).toBeVisible();
  });
});
```

# Performance Testing
```ts
test('should load page within acceptable time', async ({ page }) => {
  const startTime = Date.now();
  
  await page.goto('/dashboard');
  await page.waitForLoadState('networkidle');
  
  const loadTime = Date.now() - startTime;
  expect(loadTime).toBeLessThan(3000); // 3 second threshold
});
```

# Visual Regression Testing
```ts
test('should match visual snapshot', async ({ page }) => {
  await page.goto('/dashboard');
  await page.waitForLoadState('networkidle');
  
  await expect(page).toHaveScreenshot('dashboard.png');
});
```

# Error Handling Tests
```ts
test('should handle network errors gracefully', async ({ page }) => {
  // Simulate network failure
  await page.route('/api/**', (route) => {
    route.abort('failed');
  });
  
  await page.goto('/dashboard');
  await expect(page.locator('[data-testid="error-message"]'))
    .toContainText('Unable to load data');
});
```

# DCE-Specific E2E Scenarios

## Supplier Journey
```ts
test('supplier complete journey', async ({ page }) => {
  await loginAsSupplier(page);
  
  // Browse available campaigns
  await page.goto('/campaigns');
  await page.click('[data-testid="campaign-1-select"]');
  
  // Generate tracking number
  await page.click('[data-testid="get-tracking-number"]');
  const trackingNumber = await page.textContent('[data-testid="tracking-number"]');
  
  // Simulate call completion
  await page.click('[data-testid="mark-call-complete"]');
  
  // Check payout calculation
  await expect(page.locator('[data-testid="payout-amount"]'))
    .toContainText('$');
});
```

## Buyer Journey
```ts
test('buyer complete journey', async ({ page }) => {
  await loginAsBuyer(page);
  
  // Create new campaign
  await page.goto('/campaigns/create');
  await page.fill('[name="name"]', 'Insurance Campaign');
  await page.selectOption('[name="vertical"]', 'insurance');
  await page.fill('[name="target_cpa"]', '50');
  await page.click('[type="submit"]');
  
  // Monitor campaign performance
  await page.goto('/campaigns');
  await page.click('[data-testid="campaign-analytics"]');
  
  await expect(page.locator('[data-testid="call-volume"]')).toBeVisible();
  await expect(page.locator('[data-testid="conversion-rate"]')).toBeVisible();
});
```

# Test Data Management
```ts
// fixtures/campaigns.ts
export const testCampaign = {
  name: 'Test Campaign',
  vertical: 'insurance',
  target_cpa: 50,
  daily_budget: 1000,
};

// Use in tests
import { testCampaign } from '../fixtures/campaigns';

test('should create campaign', async ({ page }) => {
  await fillCampaignForm(page, testCampaign);
});
```

# Accessibility Testing
```ts
import { injectAxe, checkA11y } from 'axe-playwright';

test('should be accessible', async ({ page }) => {
  await page.goto('/dashboard');
  await injectAxe(page);
  await checkA11y(page);
});
```

# CRITICAL RULES
- NO regex in E2E test code
- USE data-testid attributes for element selection
- ALWAYS wait for elements to be ready
- TEST real user scenarios end-to-end
- MOCK external APIs appropriately
- TEST across multiple browsers and devices
- VERIFY accessibility compliance
- CHECK performance thresholds
- CLEAN up test data after runs
- USE page object pattern for complex workflows
</file>

<file path="tests/fixtures/calls.ts">
export interface TestCall {
  id: string
  campaignId: string
  supplierId: string
  buyerId: string
  phoneNumber: string
  callerNumber: string
  status: 'ringing' | 'connected' | 'completed' | 'failed' | 'qualified' | 'rejected'
  duration: number
  startTime: string
  endTime?: string
  recordingUrl?: string
  transcription?: string
  qualificationNotes?: string
  payout?: number
  metadata: {
    userAgent?: string
    referrer?: string
    ip?: string
    location?: {
      city: string
      state: string
      country: string
    }
  }
  fraudScore: number
  createdAt: string
  updatedAt: string
}

export interface TestCallWithTracking extends TestCall {
  tracking: {
    events: Array<{
      type: 'dial' | 'ring' | 'connect' | 'disconnect' | 'qualify' | 'reject'
      timestamp: string
      data?: Record<string, unknown>
    }>
    qualityMetrics: {
      audioQuality: number
      connectionStability: number
      backgroundNoise: number
    }
  }
}

export const createTestCall = (overrides: Partial<TestCall> = {}): TestCall => ({
  id: `call_${Math.random().toString(36).substr(2, 9)}`,
  campaignId: `campaign_${Math.random().toString(36).substr(2, 9)}`,
  supplierId: `supplier_${Math.random().toString(36).substr(2, 9)}`,
  buyerId: `buyer_${Math.random().toString(36).substr(2, 9)}`,
  phoneNumber: '+1-555-CAMPAIGN',
  callerNumber: '+1-555-' + Math.floor(Math.random() * 10000).toString().padStart(4, '0'),
  status: 'completed',
  duration: 180,
  startTime: new Date(Date.now() - 300000).toISOString(),
  endTime: new Date().toISOString(),
  payout: 25.00,
  metadata: {
    userAgent: 'Mozilla/5.0 (compatible; TestBot/1.0)',
    referrer: 'https://example.com',
    ip: '192.168.1.100',
    location: {
      city: 'San Francisco',
      state: 'CA',
      country: 'US',
    },
  },
  fraudScore: 0.1,
  createdAt: new Date(Date.now() - 300000).toISOString(),
  updatedAt: new Date().toISOString(),
  ...overrides,
})

export const createTestCallWithTracking = (
  overrides: Partial<TestCallWithTracking> = {}
): TestCallWithTracking => ({
  ...createTestCall(),
  tracking: {
    events: [
      { type: 'dial', timestamp: new Date(Date.now() - 300000).toISOString() },
      { type: 'ring', timestamp: new Date(Date.now() - 295000).toISOString() },
      { type: 'connect', timestamp: new Date(Date.now() - 290000).toISOString() },
      { type: 'disconnect', timestamp: new Date().toISOString() },
    ],
    qualityMetrics: {
      audioQuality: 0.9,
      connectionStability: 0.95,
      backgroundNoise: 0.1,
    },
  },
  ...overrides,
})

export const testCalls = {
  qualifiedCall: createTestCall({
    status: 'qualified',
    duration: 240,
    payout: 35.00,
    qualificationNotes: 'Customer expressed strong interest, scheduled follow-up',
  }),
  rejectedCall: createTestCall({
    status: 'rejected',
    duration: 45,
    payout: 0,
    qualificationNotes: 'Not interested in service',
  }),
  fraudulentCall: createTestCall({
    status: 'rejected',
    duration: 15,
    payout: 0,
    fraudScore: 0.9,
    qualificationNotes: 'Suspected fraud - very short duration, high fraud score',
  }),
  longCall: createTestCall({
    status: 'qualified',
    duration: 600,
    payout: 50.00,
    qualificationNotes: 'Extended conversation, high purchase intent',
  }),
  failedCall: createTestCall({
    status: 'failed',
    duration: 0,
    payout: 0,
    endTime: undefined,
    qualificationNotes: 'Call failed to connect',
  }),
}
</file>

<file path="tests/fixtures/campaigns.ts">
export interface TestCampaign {
  id: string
  name: string
  buyerId: string
  status: 'active' | 'paused' | 'ended' | 'draft'
  payout: number
  category: string
  description: string
  requirements: {
    minCallDuration: number
    allowedStates: string[]
    workingHours: {
      start: string
      end: string
      timezone: string
    }
    blacklistedPhones: string[]
  }
  budget: {
    daily: number
    total: number
    spent: number
  }
  createdAt: string
  updatedAt: string
}

export interface TestCampaignWithMetrics extends TestCampaign {
  metrics: {
    totalCalls: number
    qualifiedCalls: number
    conversionRate: number
    avgCallDuration: number
    totalSpent: number
  }
}

export const createTestCampaign = (overrides: Partial<TestCampaign> = {}): TestCampaign => ({
  id: `campaign_${Math.random().toString(36).substr(2, 9)}`,
  name: `Test Campaign ${Math.random().toString(36).substr(2, 4).toUpperCase()}`,
  buyerId: `buyer_${Math.random().toString(36).substr(2, 9)}`,
  status: 'active',
  payout: 25.00,
  category: 'Home Services',
  description: 'High-quality leads for home improvement services',
  requirements: {
    minCallDuration: 60,
    allowedStates: ['CA', 'NY', 'TX', 'FL'],
    workingHours: {
      start: '08:00',
      end: '18:00',
      timezone: 'America/New_York',
    },
    blacklistedPhones: [],
  },
  budget: {
    daily: 1000,
    total: 10000,
    spent: 0,
  },
  createdAt: new Date().toISOString(),
  updatedAt: new Date().toISOString(),
  ...overrides,
})

export const createTestCampaignWithMetrics = (
  overrides: Partial<TestCampaignWithMetrics> = {}
): TestCampaignWithMetrics => ({
  ...createTestCampaign(),
  metrics: {
    totalCalls: 150,
    qualifiedCalls: 120,
    conversionRate: 0.8,
    avgCallDuration: 180,
    totalSpent: 3000,
  },
  ...overrides,
})

export const testCampaigns = {
  activeCampaign: createTestCampaign({
    name: 'Premium Home Services',
    payout: 35.00,
    status: 'active',
    category: 'Home Services',
  }),
  pausedCampaign: createTestCampaign({
    name: 'Auto Insurance Leads',
    payout: 45.00,
    status: 'paused',
    category: 'Insurance',
  }),
  draftCampaign: createTestCampaign({
    name: 'Solar Installation',
    payout: 75.00,
    status: 'draft',
    category: 'Energy',
  }),
  highPayoutCampaign: createTestCampaign({
    name: 'Legal Services',
    payout: 125.00,
    status: 'active',
    category: 'Legal',
  }),
}
</file>

<file path="tests/fixtures/CLAUDE.md">
# Test Fixtures & Data

# Fixture Organization

```
fixtures/
├── users.ts        # User test data
├── campaigns.ts    # Campaign fixtures
├── calls.ts        # Call tracking data
├── billing.ts      # Payment test data
├── auth.ts         # Authentication fixtures
└── index.ts        # Export all fixtures
```

# User Fixtures

```tsx
// users.ts
export const testUsers = {
  supplier: {
    id: '11111111-1111-1111-1111-111111111111',
    email: 'supplier@test.com',
    password: 'Test123!@#',
    role: 'supplier' as const,
    profile: {
      company: 'Test Traffic Co',
      phone: '5551234567',
    },
  },
  buyer: {
    id: '22222222-2222-2222-2222-222222222222',
    email: 'buyer@test.com',
    password: 'Test123!@#',
    role: 'buyer' as const,
    profile: {
      company: 'Test Buyer Inc',
      phone: '5559876543',
    },
  },
  admin: {
    id: '33333333-3333-3333-3333-333333333333',
    email: 'admin@test.com',
    password: 'Admin123!@#',
    role: 'admin' as const,
  },
}

export const invalidUsers = {
  noEmail: { password: 'Test123!@#' },
  noPassword: { email: 'test@example.com' },
  invalidEmail: { email: 'not-an-email', password: 'Test123!@#' },
  shortPassword: { email: 'test@example.com', password: '123' },
}
```

# Campaign Fixtures

```tsx
// campaigns.ts
export const testCampaigns = {
  active: {
    id: 'camp-001',
    buyer_id: testUsers.buyer.id,
    name: 'Insurance Leads - National',
    vertical: 'insurance' as const,
    status: 'active' as const,
    target_cpa: 50.0,
    daily_budget: 1000.0,
    filters: {
      states: ['CA', 'TX', 'FL'],
      age_range: [25, 65],
      time_restrictions: [
        {
          days: ['MON', 'TUE', 'WED', 'THU', 'FRI'],
          start_hour: 9,
          end_hour: 17,
        },
      ],
    },
  },
  paused: {
    id: 'camp-002',
    buyer_id: testUsers.buyer.id,
    name: 'Home Services - Regional',
    vertical: 'home_services' as const,
    status: 'paused' as const,
    target_cpa: 75.0,
    daily_budget: 500.0,
  },
  completed: {
    id: 'camp-003',
    buyer_id: testUsers.buyer.id,
    name: 'Legal Leads - Test',
    vertical: 'legal' as const,
    status: 'completed' as const,
    target_cpa: 100.0,
    daily_budget: 2000.0,
  },
}

export function createCampaign(overrides = {}) {
  return {
    ...testCampaigns.active,
    id: `camp-${Date.now()}`,
    ...overrides,
  }
}
```

# Call Fixtures

```tsx
// calls.ts
export const testCalls = {
  completed: {
    id: 'call-001',
    campaign_id: testCampaigns.active.id,
    supplier_id: testUsers.supplier.id,
    tracking_number: '18005551234',
    caller_number: '4155551234',
    duration: 180, // 3 minutes
    status: 'completed' as const,
    quality_score: 8,
    payout_amount: 45.0,
    created_at: new Date(Date.now() - 3600000).toISOString(),
  },
  active: {
    id: 'call-002',
    campaign_id: testCampaigns.active.id,
    supplier_id: testUsers.supplier.id,
    tracking_number: '18005551235',
    caller_number: '4155551235',
    duration: 0,
    status: 'active' as const,
    created_at: new Date().toISOString(),
  },
  failed: {
    id: 'call-003',
    campaign_id: testCampaigns.active.id,
    supplier_id: testUsers.supplier.id,
    tracking_number: '18005551236',
    caller_number: '4155551236',
    duration: 5,
    status: 'failed' as const,
    quality_score: 0,
    payout_amount: 0,
  },
}

export function generateCallBatch(count: number, status = 'completed') {
  return Array.from({ length: count }, (_, i) => ({
    ...testCalls.completed,
    id: `call-batch-${i}`,
    tracking_number: `1800555${(2000 + i).toString().padStart(4, '0')}`,
    status,
    created_at: new Date(Date.now() - i * 3600000).toISOString(),
  }))
}
```

# Billing Fixtures

```tsx
// billing.ts
export const testPaymentMethods = {
  card: {
    id: 'pm_test_card',
    type: 'card',
    card: {
      brand: 'visa',
      last4: '4242',
      exp_month: 12,
      exp_year: 2025,
    },
  },
  bank: {
    id: 'pm_test_bank',
    type: 'us_bank_account',
    us_bank_account: {
      bank_name: 'Test Bank',
      last4: '6789',
      account_type: 'checking',
    },
  },
}

export const testTransactions = {
  payout: {
    id: 'txn-001',
    amount: 1250.5,
    currency: 'usd',
    type: 'payout' as const,
    status: 'succeeded' as const,
    user_id: testUsers.supplier.id,
    stripe_payout_id: 'po_test_123',
    created_at: new Date(Date.now() - 86400000).toISOString(),
  },
  charge: {
    id: 'txn-002',
    amount: 500.0,
    currency: 'usd',
    type: 'charge' as const,
    status: 'succeeded' as const,
    user_id: testUsers.buyer.id,
    stripe_payment_intent_id: 'pi_test_456',
    created_at: new Date(Date.now() - 172800000).toISOString(),
  },
}
```

# Authentication Fixtures

```tsx
// auth.ts
export const authTokens = {
  valid: {
    access_token: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',
    refresh_token: 'refresh_token_123',
    expires_in: 3600,
    token_type: 'bearer',
  },
  expired: {
    access_token: 'expired_token',
    refresh_token: 'expired_refresh',
    expires_in: -1,
    token_type: 'bearer',
  },
}

export const authSessions = {
  supplier: {
    user: testUsers.supplier,
    session: authTokens.valid,
  },
  buyer: {
    user: testUsers.buyer,
    session: authTokens.valid,
  },
}
```

# Mock API Responses

```tsx
export const mockApiResponses = {
  success: <T>(data: T) => ({
    data,
    error: null,
    status: 200,
  }),
  error: (message: string, code = 400) => ({
    data: null,
    error: { message, code },
    status: code,
  }),
  paginated: <T>(data: T[], page = 1, limit = 10) => ({
    data,
    pagination: {
      page,
      limit,
      total: data.length,
      totalPages: Math.ceil(data.length / limit),
    },
    error: null,
    status: 200,
  }),
};
```

# Date/Time Fixtures

```tsx
export const testDates = {
  today: new Date(),
  yesterday: new Date(Date.now() - 86400000),
  lastWeek: new Date(Date.now() - 604800000),
  lastMonth: new Date(Date.now() - 2592000000),
  nextWeek: new Date(Date.now() + 604800000),
}

export const testTimeRanges = {
  today: {
    start: new Date(new Date().setHours(0, 0, 0, 0)),
    end: new Date(new Date().setHours(23, 59, 59, 999)),
  },
  thisWeek: {
    start: new Date(Date.now() - 604800000),
    end: new Date(),
  },
  thisMonth: {
    start: new Date(new Date().getFullYear(), new Date().getMonth(), 1),
    end: new Date(new Date().getFullYear(), new Date().getMonth() + 1, 0),
  },
}
```

# Form Data Fixtures

```tsx
export const testFormData = {
  validCampaign: {
    name: 'Test Campaign',
    vertical: 'insurance',
    target_cpa: '50',
    daily_budget: '1000',
    description: 'Test campaign description',
  },
  invalidCampaign: {
    name: '', // Required field
    vertical: 'invalid_vertical',
    target_cpa: '-10', // Negative value
    daily_budget: 'not a number',
  },
  validRegistration: {
    email: 'newuser@test.com',
    password: 'SecurePass123!',
    confirmPassword: 'SecurePass123!',
    company: 'Test Company',
    phone: '5551234567',
    role: 'supplier',
  },
}
```

# Analytics Fixtures

```tsx
export const testAnalytics = {
  campaignMetrics: {
    totalCalls: 1250,
    conversionRate: 12.5,
    averageCallDuration: 145,
    revenue: 15625.5,
    costPerAcquisition: 45.75,
    qualityScore: 7.8,
  },
  supplierStats: {
    totalCalls: 3450,
    acceptedCalls: 3105,
    rejectedCalls: 345,
    totalEarnings: 45678.9,
    averageQuality: 8.2,
    fraudScore: 0.02,
  },
}
```

# Error Fixtures

```tsx
export const testErrors = {
  networkError: new Error('Network request failed'),
  validationError: {
    field: 'email',
    message: 'Invalid email format',
  },
  authError: {
    code: 'auth/invalid-credentials',
    message: 'Invalid email or password',
  },
  serverError: {
    status: 500,
    message: 'Internal server error',
  },
}
```

# Fixture Utilities

```tsx
export function seedDatabase() {
  // Utility to seed test database
  return {
    users: Object.values(testUsers),
    campaigns: Object.values(testCampaigns),
    calls: generateCallBatch(100),
  }
}

export function resetFixtures() {
  // Reset all fixtures to original state
  Object.keys(testUsers).forEach((key) => {
    testUsers[key].id = testUsers[key].id
  })
}

export function generateMockData(type: string, count: number) {
  switch (type) {
    case 'calls':
      return generateCallBatch(count)
    case 'campaigns':
      return Array.from({ length: count }, () => createCampaign())
    default:
      throw new Error(`Unknown fixture type: ${type}`)
  }
}
```

# CRITICAL RULES

- NO production data in fixtures
- NO real API keys or secrets
- ALWAYS use consistent IDs
- ALWAYS provide edge case data
- ALWAYS include error scenarios
- USE factories for dynamic data
- KEEP fixtures maintainable
- UPDATE fixtures when schema changes
- TEST both valid and invalid data
- DOCUMENT complex fixture relationships
</file>

<file path="tests/fixtures/index.ts">
export * from './users'
export * from './campaigns'
export * from './calls'

// Factory helper to create multiple instances
export const createMany = <T>(factory: () => T, count: number): T[] => {
  return Array.from({ length: count }, factory)
}

// Utility to create test data with relationships
export const createTestScenario = () => {
  const supplier = createTestSupplier({ email: 'supplier@scenario.com' })
  const buyer = createTestBuyer({ email: 'buyer@scenario.com' })
  const campaign = createTestCampaign({ buyerId: buyer.id })
  const calls = createMany(() => createTestCall({ 
    campaignId: campaign.id,
    supplierId: supplier.id,
    buyerId: buyer.id 
  }), 5)
  
  return { supplier, buyer, campaign, calls }
}

// Re-export specific test data sets
export { testUsers } from './users'
export { testCampaigns } from './campaigns'  
export { testCalls } from './calls'
</file>

<file path="tests/fixtures/users.ts">
export interface TestUser {
  id: string
  email: string
  password: string
  firstName: string
  lastName: string
  userType: 'supplier' | 'buyer' | 'admin'
  isActive: boolean
  createdAt: string
}

export interface TestSupplier extends TestUser {
  userType: 'supplier'
  company: string
  trafficSources: string[]
  phoneNumbers: string[]
  payoutMethods: string[]
}

export interface TestBuyer extends TestUser {
  userType: 'buyer'
  company: string
  industry: string
  creditLimit: number
  paymentMethods: string[]
}

export interface TestAdmin extends TestUser {
  userType: 'admin'
  permissions: string[]
  lastLoginAt: string
}

export const createTestUser = (overrides: Partial<TestUser> = {}): TestUser => ({
  id: `user_${Math.random().toString(36).substr(2, 9)}`,
  email: `test${Math.random().toString(36).substr(2, 5)}@example.com`,
  password: 'TestPassword123!',
  firstName: 'Test',
  lastName: 'User',
  userType: 'supplier',
  isActive: true,
  createdAt: new Date().toISOString(),
  ...overrides,
})

export const createTestSupplier = (overrides: Partial<TestSupplier> = {}): TestSupplier => ({
  ...createTestUser({ userType: 'supplier' }),
  company: 'Test Traffic Co',
  trafficSources: ['Google Ads', 'Facebook', 'SEO'],
  phoneNumbers: ['+1-555-0123'],
  payoutMethods: ['ACH', 'PayPal'],
  ...overrides,
})

export const createTestBuyer = (overrides: Partial<TestBuyer> = {}): TestBuyer => ({
  ...createTestUser({ userType: 'buyer' }),
  company: 'Test Business Inc',
  industry: 'Home Services',
  creditLimit: 10000,
  paymentMethods: ['Credit Card', 'ACH'],
  ...overrides,
})

export const createTestAdmin = (overrides: Partial<TestAdmin> = {}): TestAdmin => ({
  ...createTestUser({ userType: 'admin' }),
  permissions: ['manage_users', 'manage_campaigns', 'view_reports'],
  lastLoginAt: new Date().toISOString(),
  ...overrides,
})

export const testUsers = {
  activeSupplier: createTestSupplier({
    email: 'supplier@test.com',
    firstName: 'Sarah',
    lastName: 'Supplier',
    company: 'Quality Leads LLC',
  }),
  activeBuyer: createTestBuyer({
    email: 'buyer@test.com',
    firstName: 'Bob',
    lastName: 'Buyer',
    company: 'Home Services Pro',
  }),
  admin: createTestAdmin({
    email: 'admin@test.com',
    firstName: 'Alice',
    lastName: 'Admin',
  }),
}
</file>

<file path="tests/integration/CLAUDE.md">
# Integration Test Patterns

# Test Structure

```
integration/
├── api/           # API endpoint tests
├── database/      # Database operation tests
├── workflows/     # Multi-step process tests
├── webhooks/      # Webhook handler tests
└── services/      # Service integration tests
```

# API Integration Tests

```tsx
// api/campaigns.test.ts
import { describe, it, expect, beforeAll } from 'vitest'
import { createTestClient } from '../helpers/test-client'
import { testUsers, testCampaigns } from '@/tests/fixtures'

describe('Campaign API Integration', () => {
  let client: TestClient
  let authToken: string

  beforeAll(async () => {
    client = createTestClient()
    authToken = await client.authenticate(testUsers.buyer)
  })

  describe('POST /api/campaigns', () => {
    it('should create campaign with valid data', async () => {
      const response = await client.post('/api/campaigns', {
        headers: { Authorization: `Bearer ${authToken}` },
        body: testCampaigns.active,
      })

      expect(response.status).toBe(201)
      expect(response.data).toMatchObject({
        name: testCampaigns.active.name,
        status: 'draft', // New campaigns start as draft
      })
    })

    it('should validate required fields', async () => {
      const response = await client.post('/api/campaigns', {
        headers: { Authorization: `Bearer ${authToken}` },
        body: { name: '' }, // Missing required fields
      })

      expect(response.status).toBe(400)
      expect(response.error).toContain('validation')
    })
  })
})
```

# Database Integration Tests

```tsx
// database/user-operations.test.ts
import { describe, it, expect, beforeEach } from 'vitest'
import { supabase } from '@/lib/supabase'
import { testUsers } from '@/tests/fixtures'

describe('User Database Operations', () => {
  beforeEach(async () => {
    // Clean up test data
    await supabase.from('users').delete().eq('email', 'integration@test.com')
  })

  it('should create user with profile', async () => {
    const { data, error } = await supabase
      .from('users')
      .insert({
        email: 'integration@test.com',
        role: 'supplier',
        profile: {
          company: 'Integration Test Co',
          phone: '5551234567',
        },
      })
      .select()
      .single()

    expect(error).toBeNull()
    expect(data).toMatchObject({
      email: 'integration@test.com',
      role: 'supplier',
    })
  })

  it('should enforce unique email constraint', async () => {
    // Insert first user
    await supabase.from('users').insert({
      email: 'duplicate@test.com',
      role: 'buyer',
    })

    // Try to insert duplicate
    const { error } = await supabase.from('users').insert({
      email: 'duplicate@test.com',
      role: 'supplier',
    })

    expect(error).toBeDefined()
    expect(error?.code).toBe('23505') // Unique violation
  })
})
```

# Workflow Integration Tests

```tsx
// workflows/call-lifecycle.test.ts
describe('Call Lifecycle Workflow', () => {
  it('should complete full call workflow', async () => {
    // 1. Supplier logs in
    const supplier = await authService.login(testUsers.supplier.email, testUsers.supplier.password)

    // 2. Get tracking number
    const tracking = await callService.generateTrackingNumber(
      testCampaigns.active.id,
      supplier.user.id
    )

    // 3. Start call
    const call = await callService.startCall({
      tracking_number: tracking.number,
      caller_number: '4155551234',
    })

    // 4. Simulate call duration
    await new Promise((resolve) => setTimeout(resolve, 2000))

    // 5. End call
    const completed = await callService.endCall(call.id, {
      duration: 120,
      quality_score: 8,
    })

    // 6. Verify payout calculation
    expect(completed.payout_amount).toBeGreaterThan(0)
    expect(completed.status).toBe('completed')

    // 7. Check analytics update
    const analytics = await analyticsService.getCampaignMetrics(testCampaigns.active.id)
    expect(analytics.totalCalls).toBeGreaterThanOrEqual(1)
  })
})
```

# Service Integration Tests

```tsx
// services/stripe-integration.test.ts
import { describe, it, expect, vi } from 'vitest'
import { BillingService } from '@/services/billing'
import { stripe } from '@/integrations/stripe'

describe('Stripe Integration', () => {
  let billingService: BillingService

  beforeEach(() => {
    billingService = new BillingService(stripe)
  })

  it('should create payment intent', async () => {
    const result = await billingService.createPaymentIntent({
      amount: 100.0,
      currency: 'usd',
      customer_id: 'cus_test_123',
    })

    expect(result.id).toMatch(/^pi_/)
    expect(result.amount).toBe(10000) // Cents
    expect(result.currency).toBe('usd')
  })

  it('should handle payment failures', async () => {
    // Mock failed payment
    vi.spyOn(stripe.paymentIntents, 'create').mockRejectedValue(new Error('Card declined'))

    await expect(
      billingService.processPayment({
        amount: 100.0,
        payment_method: 'pm_card_declined',
      })
    ).rejects.toThrow('Card declined')
  })
})
```

# Webhook Integration Tests

```tsx
// webhooks/stripe-webhooks.test.ts
import { describe, it, expect } from 'vitest'
import { handleStripeWebhook } from '@/api/webhooks/stripe'
import { stripe } from '@/integrations/stripe'

describe('Stripe Webhook Integration', () => {
  it('should handle payment success webhook', async () => {
    const payload = {
      id: 'evt_test_123',
      type: 'payment_intent.succeeded',
      data: {
        object: {
          id: 'pi_test_123',
          amount: 5000,
          currency: 'usd',
          metadata: {
            user_id: testUsers.buyer.id,
            campaign_id: testCampaigns.active.id,
          },
        },
      },
    }

    const signature = stripe.webhooks.generateTestHeaderString({
      payload: JSON.stringify(payload),
      secret: process.env.STRIPE_WEBHOOK_SECRET!,
    })

    const response = await handleStripeWebhook(JSON.stringify(payload), signature)

    expect(response.success).toBe(true)

    // Verify transaction was recorded
    const { data: transaction } = await supabase
      .from('transactions')
      .select()
      .eq('stripe_payment_intent_id', 'pi_test_123')
      .single()

    expect(transaction).toBeDefined()
    expect(transaction.status).toBe('succeeded')
  })
})
```

# Real-time Integration Tests

```tsx
// integration/realtime-updates.test.ts
describe('Real-time Updates', () => {
  it('should receive call status updates', async () => {
    const updates: any[] = []

    // Subscribe to updates
    const channel = supabase
      .channel('test-calls')
      .on(
        'postgres_changes',
        {
          event: 'UPDATE',
          schema: 'public',
          table: 'calls',
        },
        (payload) => {
          updates.push(payload)
        }
      )
      .subscribe()

    // Wait for subscription
    await new Promise((resolve) => setTimeout(resolve, 1000))

    // Create and update call
    const { data: call } = await supabase
      .from('calls')
      .insert({
        campaign_id: testCampaigns.active.id,
        supplier_id: testUsers.supplier.id,
        tracking_number: '18005559999',
        status: 'active',
      })
      .select()
      .single()

    // Update call status
    await supabase.from('calls').update({ status: 'completed' }).eq('id', call.id)

    // Wait for update
    await new Promise((resolve) => setTimeout(resolve, 1000))

    // Verify update received
    expect(updates).toHaveLength(1)
    expect(updates[0].new.status).toBe('completed')

    // Cleanup
    supabase.removeChannel(channel)
  })
})
```

# Multi-Service Integration

```tsx
// integration/campaign-creation-flow.test.ts
describe('Campaign Creation Flow', () => {
  it('should create campaign with all integrations', async () => {
    // 1. Create campaign in database
    const campaign = await campaignService.create({
      name: 'Integration Test Campaign',
      buyer_id: testUsers.buyer.id,
      vertical: 'insurance',
      target_cpa: 50,
      daily_budget: 1000,
    })

    // 2. Set up Stripe billing
    const subscription = await billingService.createCampaignSubscription({
      campaign_id: campaign.id,
      plan: 'pro',
      payment_method: 'pm_test_123',
    })

    // 3. Initialize analytics
    await analyticsService.initializeCampaignMetrics(campaign.id)

    // 4. Configure fraud detection
    await fraudService.setupCampaignRules(campaign.id, {
      duplicate_threshold: 3,
      min_call_duration: 30,
    })

    // 5. Verify all integrations
    const fullCampaign = await campaignService.getWithIntegrations(campaign.id)

    expect(fullCampaign).toMatchObject({
      id: campaign.id,
      subscription: { status: 'active' },
      analytics: { totalCalls: 0 },
      fraud_rules: { duplicate_threshold: 3 },
    })
  })
})
```

# Error Handling Integration

```tsx
describe('Error Handling Across Services', () => {
  it('should rollback on partial failure', async () => {
    // Mock stripe failure
    vi.spyOn(stripe.subscriptions, 'create').mockRejectedValue(new Error('Payment failed'))

    await expect(
      campaignService.createWithBilling({
        campaign: testCampaigns.active,
        payment_method: 'pm_card_declined',
      })
    ).rejects.toThrow()

    // Verify campaign was not created
    const { data: campaigns } = await supabase
      .from('campaigns')
      .select()
      .eq('name', testCampaigns.active.name)

    expect(campaigns).toHaveLength(0)
  })
})
```

# Performance Integration Tests

```tsx
describe('Integration Performance', () => {
  it('should handle concurrent operations', async () => {
    const operations = Array.from({ length: 10 }, (_, i) =>
      callService.startCall({
        campaign_id: testCampaigns.active.id,
        supplier_id: testUsers.supplier.id,
        caller_number: `415555${i.toString().padStart(4, '0')}`,
      })
    )

    const start = performance.now()
    const results = await Promise.all(operations)
    const duration = performance.now() - start

    expect(results).toHaveLength(10)
    expect(duration).toBeLessThan(5000) // Should complete within 5s
  })
})
```

# Test Helpers

```tsx
// helpers/test-client.ts
export class TestClient {
  constructor(private baseURL = 'http://localhost:3000') {}

  async authenticate(user: TestUser): Promise<string> {
    const response = await fetch(`${this.baseURL}/api/auth/login`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        email: user.email,
        password: user.password,
      }),
    })

    const data = await response.json()
    return data.access_token
  }

  async post(endpoint: string, options: RequestOptions) {
    return this.request('POST', endpoint, options)
  }

  private async request(method: string, endpoint: string, options: RequestOptions) {
    const response = await fetch(`${this.baseURL}${endpoint}`, {
      method,
      headers: {
        'Content-Type': 'application/json',
        ...options.headers,
      },
      body: JSON.stringify(options.body),
    })

    const data = await response.json()
    return {
      status: response.status,
      data: response.ok ? data : null,
      error: !response.ok ? data : null,
    }
  }
}
```

# Environment Setup

```tsx
// setup.ts
import { beforeAll, afterAll } from 'vitest'

beforeAll(async () => {
  // Set up test database
  await setupTestDatabase()

  // Initialize test services
  await initializeServices()

  // Mock external APIs if needed
  mockExternalAPIs()
})

afterAll(async () => {
  // Clean up test data
  await cleanupTestData()

  // Close connections
  await closeConnections()
})
```

# CRITICAL RULES

- NO regex in integration tests
- NO any types in test code
- ALWAYS clean up test data
- ALWAYS use test database
- ALWAYS mock external services
- ALWAYS test error scenarios
- ALWAYS verify side effects
- TEST real integration points
- ISOLATE tests from each other
- MONITOR test execution time
</file>

<file path="tests/performance/CLAUDE.md">
# Performance Test Patterns

# Test Structure

```
performance/
├── load/          # Load testing scenarios
├── stress/        # Stress testing limits
├── benchmarks/    # Performance benchmarks
└── profiling/     # Performance profiling
```

# Load Testing Patterns

```tsx
// load/concurrent-users.test.ts
import { describe, it, expect } from 'vitest'
import { loadTest } from '../helpers/load-test'

describe('Concurrent User Load Tests', () => {
  it('should handle 100 concurrent users', async () => {
    const results = await loadTest({
      virtualUsers: 100,
      duration: '30s',
      scenario: async (userId) => {
        // Simulate user journey
        await login(`user${userId}@test.com`, 'password')
        await browseCampaigns()
        await viewCampaignDetails()
        await generateTrackingNumber()
      },
    })

    expect(results.successRate).toBeGreaterThan(0.95) // 95% success
    expect(results.avgResponseTime).toBeLessThan(1000) // Under 1s
    expect(results.p95ResponseTime).toBeLessThan(2000) // 95th percentile under 2s
  })
})
```

# API Performance Tests

```tsx
// load/api-endpoints.test.ts
describe('API Endpoint Performance', () => {
  const endpoints = [
    { path: '/api/campaigns', method: 'GET' },
    { path: '/api/calls', method: 'GET' },
    { path: '/api/analytics/dashboard', method: 'GET' },
  ]

  endpoints.forEach(({ path, method }) => {
    it(`should handle load on ${method} ${path}`, async () => {
      const results = await loadTest({
        virtualUsers: 50,
        duration: '1m',
        scenario: async () => {
          const start = performance.now()
          const response = await fetch(path, { method })
          const duration = performance.now() - start

          return {
            status: response.status,
            duration,
          }
        },
      })

      expect(results.errorRate).toBeLessThan(0.01) // Less than 1% errors
      expect(results.avgResponseTime).toBeLessThan(500) // Under 500ms avg
    })
  })
})
```

# Database Performance Tests

```tsx
// performance/database-queries.test.ts
describe('Database Query Performance', () => {
  it('should execute campaign queries efficiently', async () => {
    const queries = [
      // Complex join query
      async () => {
        const start = performance.now()
        const { data } = await supabase
          .from('campaigns')
          .select(
            `
            *,
            calls (count),
            transactions (sum(amount))
          `
          )
          .eq('status', 'active')
          .limit(50)
        return performance.now() - start
      },

      // Aggregation query
      async () => {
        const start = performance.now()
        const { data } = await supabase.rpc('get_campaign_analytics', {
          campaign_id: testCampaigns.active.id,
          date_from: '2024-01-01',
          date_to: '2024-12-31',
        })
        return performance.now() - start
      },
    ]

    const durations = await Promise.all(queries.map((q) => q()))

    durations.forEach((duration) => {
      expect(duration).toBeLessThan(100) // Each query under 100ms
    })
  })
})
```

# Real-time Performance Tests

```tsx
// performance/realtime-subscriptions.test.ts
describe('Real-time Subscription Performance', () => {
  it('should handle multiple simultaneous subscriptions', async () => {
    const subscriptionCount = 100
    const channels: RealtimeChannel[] = []
    const messageReceived: number[] = []

    // Create subscriptions
    const startSubscribe = performance.now()
    for (let i = 0; i < subscriptionCount; i++) {
      const channel = supabase
        .channel(`test-channel-${i}`)
        .on('broadcast', { event: 'test' }, () => {
          messageReceived.push(performance.now())
        })
        .subscribe()

      channels.push(channel)
    }
    const subscribeTime = performance.now() - startSubscribe

    // Wait for all subscriptions
    await new Promise((resolve) => setTimeout(resolve, 2000))

    // Broadcast message
    const broadcastStart = performance.now()
    await supabase.channel('test-broadcast').send({
      type: 'broadcast',
      event: 'test',
      payload: { message: 'test' },
    })

    // Wait for messages
    await new Promise((resolve) => setTimeout(resolve, 1000))

    // Calculate latencies
    const latencies = messageReceived.map((time) => time - broadcastStart)
    const avgLatency = latencies.reduce((a, b) => a + b, 0) / latencies.length

    expect(subscribeTime).toBeLessThan(5000) // Subscribe all within 5s
    expect(avgLatency).toBeLessThan(100) // Avg latency under 100ms
    expect(messageReceived.length).toBeGreaterThan(90) // 90% delivery

    // Cleanup
    channels.forEach((ch) => supabase.removeChannel(ch))
  })
})
```

# Frontend Performance Tests

```tsx
// performance/rendering.test.ts
import { render } from '@testing-library/react'
import { measureRender } from '../helpers/performance'

describe('Component Rendering Performance', () => {
  it('should render dashboard efficiently', async () => {
    const metrics = await measureRender(() => {
      render(<DashboardPage />)
    })

    expect(metrics.renderTime).toBeLessThan(50) // Initial render under 50ms
    expect(metrics.layoutTime).toBeLessThan(20) // Layout under 20ms
  })

  it('should handle large lists efficiently', async () => {
    const largeData = generateCallBatch(1000)

    const metrics = await measureRender(() => {
      render(<CallList calls={largeData} />)
    })

    expect(metrics.renderTime).toBeLessThan(200) // Under 200ms for 1000 items
    expect(metrics.memoryUsage).toBeLessThan(50 * 1024 * 1024) // Under 50MB
  })
})
```

# Memory Performance Tests

```tsx
// performance/memory-usage.test.ts
describe('Memory Usage Tests', () => {
  it('should not leak memory during operations', async () => {
    const initialMemory = performance.memory.usedJSHeapSize

    // Perform operations that might leak
    for (let i = 0; i < 100; i++) {
      const calls = generateCallBatch(100)
      const processed = calls.map((call) => ({
        ...call,
        formatted: formatCallDuration(call.duration),
        quality: calculateQualityScore(call),
      }))

      // Simulate component mounting/unmounting
      const { unmount } = render(<CallList calls={processed} />)
      unmount()
    }

    // Force garbage collection if available
    if (global.gc) global.gc()

    await new Promise((resolve) => setTimeout(resolve, 1000))

    const finalMemory = performance.memory.usedJSHeapSize
    const memoryIncrease = finalMemory - initialMemory

    // Allow for some memory increase but not excessive
    expect(memoryIncrease).toBeLessThan(10 * 1024 * 1024) // Less than 10MB increase
  })
})
```

# Stress Testing

```tsx
// stress/system-limits.test.ts
describe('System Stress Tests', () => {
  it('should handle burst traffic', async () => {
    const results = await stressTest({
      pattern: 'burst',
      peakUsers: 500,
      duration: '10s',
      rampUp: '1s',
    })

    expect(results.crashPoint).toBeUndefined() // System shouldn't crash
    expect(results.degradationPoint).toBeGreaterThan(300) // Handle 300+ users
  })

  it('should recover from overload', async () => {
    // Overload system
    await stressTest({
      virtualUsers: 1000,
      duration: '30s',
    })

    // Wait for recovery
    await new Promise((resolve) => setTimeout(resolve, 5000))

    // Test normal operation
    const recoveryTest = await loadTest({
      virtualUsers: 10,
      duration: '10s',
      scenario: async () => {
        const response = await fetch('/api/health')
        return response.status
      },
    })

    expect(recoveryTest.successRate).toBe(1) // Full recovery
  })
})
```

# Call Volume Performance

```tsx
// performance/call-volume.test.ts
describe('High Call Volume Performance', () => {
  it('should process high call volume', async () => {
    const callsPerSecond = 50
    const duration = 60 // 1 minute
    const totalCalls = callsPerSecond * duration

    const start = performance.now()
    const results = []

    for (let second = 0; second < duration; second++) {
      const batch = Array.from({ length: callsPerSecond }, () =>
        callService.startCall({
          campaign_id: testCampaigns.active.id,
          supplier_id: testUsers.supplier.id,
          caller_number: generatePhoneNumber(),
        })
      )

      const batchStart = performance.now()
      const batchResults = await Promise.allSettled(batch)
      const batchDuration = performance.now() - batchStart

      results.push({
        second,
        processed: batchResults.filter((r) => r.status === 'fulfilled').length,
        failed: batchResults.filter((r) => r.status === 'rejected').length,
        duration: batchDuration,
      })

      // Wait for next second
      const elapsed = performance.now() - start
      const waitTime = Math.max(0, (second + 1) * 1000 - elapsed)
      await new Promise((resolve) => setTimeout(resolve, waitTime))
    }

    const totalProcessed = results.reduce((sum, r) => sum + r.processed, 0)
    const avgDuration = results.reduce((sum, r) => sum + r.duration, 0) / results.length

    expect(totalProcessed / totalCalls).toBeGreaterThan(0.95) // 95% processed
    expect(avgDuration).toBeLessThan(1000) // Process batch within 1s
  })
})
```

# Performance Benchmarks

```tsx
// benchmarks/operations.bench.ts
import { bench, describe } from 'vitest'

describe('Operation Benchmarks', () => {
  bench('format phone number', () => {
    formatPhoneNumber('4155551234')
  })

  bench('calculate quality score', () => {
    calculateQualityScore(180, true, 0.1)
  })

  bench('validate campaign data', () => {
    campaignSchema.parse(testCampaigns.active)
  })

  bench('generate tracking number', () => {
    generateTrackingNumber()
  })
})
```

# Performance Monitoring

```tsx
// helpers/performance-monitor.ts
export class PerformanceMonitor {
  private metrics: Map<string, number[]> = new Map()

  measure<T>(name: string, fn: () => T): T {
    const start = performance.now()
    const result = fn()
    const duration = performance.now() - start

    if (!this.metrics.has(name)) {
      this.metrics.set(name, [])
    }
    this.metrics.get(name)!.push(duration)

    return result
  }

  getStats(name: string) {
    const measurements = this.metrics.get(name) || []
    if (measurements.length === 0) return null

    const sorted = [...measurements].sort((a, b) => a - b)
    return {
      min: sorted[0],
      max: sorted[sorted.length - 1],
      avg: sorted.reduce((a, b) => a + b, 0) / sorted.length,
      p50: sorted[Math.floor(sorted.length * 0.5)],
      p95: sorted[Math.floor(sorted.length * 0.95)],
      p99: sorted[Math.floor(sorted.length * 0.99)],
    }
  }
}
```

# Performance Test Configuration

```tsx
// performance.config.ts
export const performanceThresholds = {
  api: {
    avgResponseTime: 500, // ms
    p95ResponseTime: 1000,
    p99ResponseTime: 2000,
    errorRate: 0.01, // 1%
  },
  database: {
    queryTime: 100, // ms
    connectionPoolSize: 20,
  },
  frontend: {
    initialRender: 100, // ms
    reRender: 50,
    bundleSize: 500 * 1024, // 500KB
  },
  realtime: {
    subscriptionTime: 1000, // ms
    messageLatency: 100,
    deliveryRate: 0.99, // 99%
  },
}
```

# Performance Utilities

```tsx
// helpers/load-test.ts
export async function loadTest(options: LoadTestOptions) {
  const results = {
    totalRequests: 0,
    successfulRequests: 0,
    failedRequests: 0,
    durations: [] as number[],
  }

  const promises = []
  for (let i = 0; i < options.virtualUsers; i++) {
    promises.push(runScenario(options.scenario, i, results))
  }

  await Promise.all(promises)

  return calculateMetrics(results)
}

function calculateMetrics(results: TestResults) {
  const sorted = [...results.durations].sort((a, b) => a - b)
  return {
    successRate: results.successfulRequests / results.totalRequests,
    errorRate: results.failedRequests / results.totalRequests,
    avgResponseTime: sorted.reduce((a, b) => a + b, 0) / sorted.length,
    p95ResponseTime: sorted[Math.floor(sorted.length * 0.95)],
    p99ResponseTime: sorted[Math.floor(sorted.length * 0.99)],
  }
}
```

# CRITICAL RULES

- NO regex in performance tests
- NO any types in test code
- ALWAYS establish baselines first
- ALWAYS test under realistic conditions
- ALWAYS measure before optimizing
- ALWAYS clean up after tests
- TEST both average and worst cases
- MONITOR memory usage
- PROFILE hot code paths
- DOCUMENT performance requirements
</file>

<file path="tests/unit/components/example.test.tsx">
import { describe, it, expect } from 'vitest'
import { render, screen } from '@/test/test-utils'

// Example component test - remove this once real components are tested
const ExampleComponent = ({ title }: { title: string }) => (
  <div>
    <h1>{title}</h1>
    <p>This is an example component for testing setup verification.</p>
  </div>
)

describe('Example Component Test', () => {
  it('renders title correctly', () => {
    render(<ExampleComponent title="Test Title" />)
    
    expect(screen.getByRole('heading', { name: 'Test Title' })).toBeInTheDocument()
  })

  it('renders description text', () => {
    render(<ExampleComponent title="Test" />)
    
    expect(screen.getByText('This is an example component for testing setup verification.')).toBeInTheDocument()
  })
})
</file>

<file path="tests/unit/integrations/stripe/billing.test.ts">
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import {
  createInvoice,
  createInvoiceItem,
  finalizeInvoice,
  sendInvoice,
  payInvoice,
  voidInvoice,
  updateInvoice,
  getInvoice,
  listCustomerInvoices,
  createCreditNote,
  createUsageBasedInvoice,
  CreateInvoiceParams,
  CreateInvoiceItemParams,
} from '@/integrations/stripe/billing'
import { stripeServerClient } from '@/integrations/stripe/client'
import type Stripe from 'stripe'

// Mock the stripe client
vi.mock('@/integrations/stripe/client', () => ({
  stripeServerClient: {
    invoices: {
      create: vi.fn(),
      finalizeInvoice: vi.fn(),
      sendInvoice: vi.fn(),
      pay: vi.fn(),
      voidInvoice: vi.fn(),
      update: vi.fn(),
      retrieve: vi.fn(),
      list: vi.fn(),
    },
    invoiceItems: {
      create: vi.fn(),
    },
    creditNotes: {
      create: vi.fn(),
    },
  },
}))

describe('Stripe Billing Module', () => {
  beforeEach(() => {
    vi.clearAllMocks()
    vi.spyOn(console, 'error').mockImplementation(() => {})
  })

  afterEach(() => {
    vi.restoreAllMocks()
  })

  describe('createInvoice', () => {
    const mockInvoice = {
      id: 'in_123',
      customer: 'cus_123',
      status: 'draft',
    } as Stripe.Invoice

    const invoiceParams: CreateInvoiceParams = {
      customerId: 'cus_123',
      description: 'Test invoice',
      metadata: {
        buyerId: 'buyer_123',
        billingPeriod: '2024-01',
        callCount: '50',
      },
    }

    it('should create an invoice successfully', async () => {
      vi.mocked(stripeServerClient.invoices.create).mockResolvedValue(mockInvoice)

      const result = await createInvoice(invoiceParams)

      expect(stripeServerClient.invoices.create).toHaveBeenCalledWith({
        customer: 'cus_123',
        description: 'Test invoice',
        metadata: {
          buyerId: 'buyer_123',
          billingPeriod: '2024-01',
          callCount: '50',
          platform: 'dependablecalls',
        },
        collection_method: 'charge_automatically',
        auto_advance: false,
      })
      expect(result).toEqual(mockInvoice)
    })

    it('should create an invoice with optional parameters', async () => {
      vi.mocked(stripeServerClient.invoices.create).mockResolvedValue(mockInvoice)

      const paramsWithOptionals: CreateInvoiceParams = {
        ...invoiceParams,
        dueDate: 1234567890,
        collectionMethod: 'send_invoice',
      }

      await createInvoice(paramsWithOptionals)

      expect(stripeServerClient.invoices.create).toHaveBeenCalledWith({
        customer: 'cus_123',
        description: 'Test invoice',
        metadata: {
          buyerId: 'buyer_123',
          billingPeriod: '2024-01',
          callCount: '50',
          platform: 'dependablecalls',
        },
        due_date: 1234567890,
        collection_method: 'send_invoice',
        auto_advance: false,
      })
    })

    it('should handle creation errors', async () => {
      vi.mocked(stripeServerClient.invoices.create).mockRejectedValue(new Error('Stripe API error'))

      await expect(createInvoice(invoiceParams)).rejects.toThrow(
        'Failed to create invoice: Stripe API error'
      )
      expect(console.error).toHaveBeenCalledWith('Error creating invoice:', expect.any(Error))
    })

    it('should handle non-Error exceptions', async () => {
      vi.mocked(stripeServerClient.invoices.create).mockRejectedValue('String error')

      await expect(createInvoice(invoiceParams)).rejects.toThrow(
        'Failed to create invoice: Unknown error'
      )
    })
  })

  describe('createInvoiceItem', () => {
    const mockInvoiceItem = {
      id: 'ii_123',
      customer: 'cus_123',
      amount: 5000,
    } as Stripe.InvoiceItem

    const invoiceItemParams: CreateInvoiceItemParams = {
      customerId: 'cus_123',
      amount: 5000,
      currency: 'usd',
      description: 'Call charges',
      metadata: {
        callId: 'call_123',
        campaignId: 'campaign_456',
        duration: '180',
      },
    }

    it('should create an invoice item successfully', async () => {
      vi.mocked(stripeServerClient.invoiceItems.create).mockResolvedValue(mockInvoiceItem)

      const result = await createInvoiceItem(invoiceItemParams)

      expect(stripeServerClient.invoiceItems.create).toHaveBeenCalledWith({
        customer: 'cus_123',
        amount: 5000,
        currency: 'usd',
        description: 'Call charges',
        metadata: {
          callId: 'call_123',
          campaignId: 'campaign_456',
          duration: '180',
          platform: 'dependablecalls',
        },
      })
      expect(result).toEqual(mockInvoiceItem)
    })

    it('should attach to existing invoice when invoiceId provided', async () => {
      vi.mocked(stripeServerClient.invoiceItems.create).mockResolvedValue(mockInvoiceItem)

      const paramsWithInvoice: CreateInvoiceItemParams = {
        ...invoiceItemParams,
        invoiceId: 'in_123',
      }

      await createInvoiceItem(paramsWithInvoice)

      expect(stripeServerClient.invoiceItems.create).toHaveBeenCalledWith({
        customer: 'cus_123',
        amount: 5000,
        currency: 'usd',
        description: 'Call charges',
        metadata: {
          callId: 'call_123',
          campaignId: 'campaign_456',
          duration: '180',
          platform: 'dependablecalls',
        },
        invoice: 'in_123',
      })
    })

    it('should handle creation errors', async () => {
      vi.mocked(stripeServerClient.invoiceItems.create).mockRejectedValue(
        new Error('Item creation failed')
      )

      await expect(createInvoiceItem(invoiceItemParams)).rejects.toThrow(
        'Failed to create invoice item: Item creation failed'
      )
    })
  })

  describe('finalizeInvoice', () => {
    const mockFinalizedInvoice = {
      id: 'in_123',
      status: 'open',
    } as Stripe.Invoice

    it('should finalize invoice with auto advance', async () => {
      vi.mocked(stripeServerClient.invoices.finalizeInvoice).mockResolvedValue(mockFinalizedInvoice)

      const result = await finalizeInvoice('in_123')

      expect(stripeServerClient.invoices.finalizeInvoice).toHaveBeenCalledWith('in_123', {
        auto_advance: true,
      })
      expect(result).toEqual(mockFinalizedInvoice)
    })

    it('should finalize invoice without auto advance', async () => {
      vi.mocked(stripeServerClient.invoices.finalizeInvoice).mockResolvedValue(mockFinalizedInvoice)

      await finalizeInvoice('in_123', false)

      expect(stripeServerClient.invoices.finalizeInvoice).toHaveBeenCalledWith('in_123', {
        auto_advance: false,
      })
    })

    it('should handle finalization errors', async () => {
      vi.mocked(stripeServerClient.invoices.finalizeInvoice).mockRejectedValue(
        new Error('Finalization failed')
      )

      await expect(finalizeInvoice('in_123')).rejects.toThrow(
        'Failed to finalize invoice: Finalization failed'
      )
    })
  })

  describe('sendInvoice', () => {
    const mockSentInvoice = {
      id: 'in_123',
      status: 'open',
    } as Stripe.Invoice

    it('should send invoice successfully', async () => {
      vi.mocked(stripeServerClient.invoices.sendInvoice).mockResolvedValue(mockSentInvoice)

      const result = await sendInvoice('in_123')

      expect(stripeServerClient.invoices.sendInvoice).toHaveBeenCalledWith('in_123')
      expect(result).toEqual(mockSentInvoice)
    })

    it('should handle send errors', async () => {
      vi.mocked(stripeServerClient.invoices.sendInvoice).mockRejectedValue(new Error('Send failed'))

      await expect(sendInvoice('in_123')).rejects.toThrow('Failed to send invoice: Send failed')
    })
  })

  describe('payInvoice', () => {
    const mockPaidInvoice = {
      id: 'in_123',
      status: 'paid',
    } as Stripe.Invoice

    it('should pay invoice with default payment method', async () => {
      vi.mocked(stripeServerClient.invoices.pay).mockResolvedValue(mockPaidInvoice)

      const result = await payInvoice('in_123')

      expect(stripeServerClient.invoices.pay).toHaveBeenCalledWith('in_123', {})
      expect(result).toEqual(mockPaidInvoice)
    })

    it('should pay invoice with specific payment method', async () => {
      vi.mocked(stripeServerClient.invoices.pay).mockResolvedValue(mockPaidInvoice)

      await payInvoice('in_123', 'pm_123')

      expect(stripeServerClient.invoices.pay).toHaveBeenCalledWith('in_123', {
        payment_method: 'pm_123',
      })
    })

    it('should handle payment errors', async () => {
      vi.mocked(stripeServerClient.invoices.pay).mockRejectedValue(new Error('Payment failed'))

      await expect(payInvoice('in_123')).rejects.toThrow('Failed to pay invoice: Payment failed')
    })
  })

  describe('voidInvoice', () => {
    const mockVoidedInvoice = {
      id: 'in_123',
      status: 'void',
    } as Stripe.Invoice

    it('should void invoice successfully', async () => {
      vi.mocked(stripeServerClient.invoices.voidInvoice).mockResolvedValue(mockVoidedInvoice)

      const result = await voidInvoice('in_123')

      expect(stripeServerClient.invoices.voidInvoice).toHaveBeenCalledWith('in_123')
      expect(result).toEqual(mockVoidedInvoice)
    })

    it('should handle void errors', async () => {
      vi.mocked(stripeServerClient.invoices.voidInvoice).mockRejectedValue(new Error('Void failed'))

      await expect(voidInvoice('in_123')).rejects.toThrow('Failed to void invoice: Void failed')
    })
  })

  describe('updateInvoice', () => {
    const mockUpdatedInvoice = {
      id: 'in_123',
      description: 'Updated description',
    } as Stripe.Invoice

    it('should update invoice successfully', async () => {
      vi.mocked(stripeServerClient.invoices.update).mockResolvedValue(mockUpdatedInvoice)

      const updates = { description: 'Updated description' }
      const result = await updateInvoice('in_123', updates)

      expect(stripeServerClient.invoices.update).toHaveBeenCalledWith('in_123', updates)
      expect(result).toEqual(mockUpdatedInvoice)
    })

    it('should handle update errors', async () => {
      vi.mocked(stripeServerClient.invoices.update).mockRejectedValue(new Error('Update failed'))

      await expect(updateInvoice('in_123', {})).rejects.toThrow(
        'Failed to update invoice: Update failed'
      )
    })
  })

  describe('getInvoice', () => {
    const mockInvoice = {
      id: 'in_123',
      customer: 'cus_123',
    } as Stripe.Invoice

    it('should retrieve invoice successfully', async () => {
      vi.mocked(stripeServerClient.invoices.retrieve).mockResolvedValue(mockInvoice)

      const result = await getInvoice('in_123')

      expect(stripeServerClient.invoices.retrieve).toHaveBeenCalledWith('in_123')
      expect(result).toEqual(mockInvoice)
    })

    it('should return null for missing invoice', async () => {
      const missingError = { code: 'resource_missing' }
      vi.mocked(stripeServerClient.invoices.retrieve).mockRejectedValue(missingError)

      const result = await getInvoice('in_123')

      expect(result).toBeNull()
    })

    it('should handle other errors', async () => {
      vi.mocked(stripeServerClient.invoices.retrieve).mockRejectedValue(
        new Error('Retrieve failed')
      )

      await expect(getInvoice('in_123')).rejects.toThrow(
        'Failed to retrieve invoice: Retrieve failed'
      )
    })
  })

  describe('listCustomerInvoices', () => {
    const mockInvoices = {
      data: [
        { id: 'in_1', status: 'paid' },
        { id: 'in_2', status: 'open' },
      ],
    } as Stripe.ApiList<Stripe.Invoice>

    it('should list customer invoices', async () => {
      vi.mocked(stripeServerClient.invoices.list).mockResolvedValue(mockInvoices)

      const result = await listCustomerInvoices('cus_123')

      expect(stripeServerClient.invoices.list).toHaveBeenCalledWith({
        customer: 'cus_123',
        status: undefined,
        limit: 100,
      })
      expect(result).toEqual(mockInvoices.data)
    })

    it('should filter by status', async () => {
      vi.mocked(stripeServerClient.invoices.list).mockResolvedValue(mockInvoices)

      await listCustomerInvoices('cus_123', 'open', 50)

      expect(stripeServerClient.invoices.list).toHaveBeenCalledWith({
        customer: 'cus_123',
        status: 'open',
        limit: 50,
      })
    })

    it('should handle listing errors', async () => {
      vi.mocked(stripeServerClient.invoices.list).mockRejectedValue(new Error('List failed'))

      await expect(listCustomerInvoices('cus_123')).rejects.toThrow(
        'Failed to list invoices: List failed'
      )
    })
  })

  describe('createCreditNote', () => {
    const mockCreditNote = {
      id: 'cn_123',
      invoice: 'in_123',
      amount: 1000,
    } as Stripe.CreditNote

    it('should create credit note successfully', async () => {
      vi.mocked(stripeServerClient.creditNotes.create).mockResolvedValue(mockCreditNote)

      const result = await createCreditNote('in_123', 1000, 'duplicate', 'Test memo')

      expect(stripeServerClient.creditNotes.create).toHaveBeenCalledWith({
        invoice: 'in_123',
        amount: 1000,
        reason: 'duplicate',
        memo: 'Test memo',
        metadata: {
          platform: 'dependablecalls',
        },
      })
      expect(result).toEqual(mockCreditNote)
    })

    it('should create credit note without memo', async () => {
      vi.mocked(stripeServerClient.creditNotes.create).mockResolvedValue(mockCreditNote)

      await createCreditNote('in_123', 1000, 'fraudulent')

      expect(stripeServerClient.creditNotes.create).toHaveBeenCalledWith({
        invoice: 'in_123',
        amount: 1000,
        reason: 'fraudulent',
        memo: undefined,
        metadata: {
          platform: 'dependablecalls',
        },
      })
    })

    it('should handle credit note errors', async () => {
      vi.mocked(stripeServerClient.creditNotes.create).mockRejectedValue(
        new Error('Credit note failed')
      )

      await expect(createCreditNote('in_123', 1000, 'duplicate')).rejects.toThrow(
        'Failed to create credit note: Credit note failed'
      )
    })
  })

  describe('createUsageBasedInvoice', () => {
    const mockInvoice = {
      id: 'in_123',
      customer: 'cus_123',
    } as Stripe.Invoice

    const mockFinalizedInvoice = {
      ...mockInvoice,
      status: 'open',
    } as Stripe.Invoice

    const billingPeriod = {
      start: new Date('2024-01-01'),
      end: new Date('2024-01-31'),
    }

    const usageRecords = [
      {
        amount: 2500,
        description: 'Call 1',
        metadata: { callId: 'call_1' },
      },
      {
        amount: 3500,
        description: 'Call 2',
        metadata: { callId: 'call_2' },
      },
    ]

    it('should create usage-based invoice with multiple items', async () => {
      vi.mocked(stripeServerClient.invoices.create).mockResolvedValue(mockInvoice)
      vi.mocked(stripeServerClient.invoiceItems.create).mockResolvedValue({} as Stripe.InvoiceItem)
      vi.mocked(stripeServerClient.invoices.finalizeInvoice).mockResolvedValue(mockFinalizedInvoice)

      const result = await createUsageBasedInvoice('cus_123', billingPeriod, usageRecords)

      // Check invoice creation
      expect(stripeServerClient.invoices.create).toHaveBeenCalledWith({
        customer: 'cus_123',
        description: 'Usage charges for 2024-01-01 to 2024-01-31',
        metadata: {
          buyerId: 'cus_123',
          billingPeriod: `${billingPeriod.start.toISOString()}_${billingPeriod.end.toISOString()}`,
          callCount: '2',
          platform: 'dependablecalls',
        },
        collection_method: 'charge_automatically',
        auto_advance: false,
      })

      // Check invoice items creation
      expect(stripeServerClient.invoiceItems.create).toHaveBeenCalledTimes(2)
      expect(stripeServerClient.invoiceItems.create).toHaveBeenNthCalledWith(1, {
        customer: 'cus_123',
        amount: 2500,
        currency: 'usd',
        description: 'Call 1',
        metadata: {
          callId: 'call_1',
          platform: 'dependablecalls',
        },
        invoice: 'in_123',
      })

      // Check finalization
      expect(stripeServerClient.invoices.finalizeInvoice).toHaveBeenCalledWith('in_123', {
        auto_advance: true,
      })

      expect(result).toEqual(mockFinalizedInvoice)
    })

    it('should handle errors in usage-based invoice creation', async () => {
      vi.mocked(stripeServerClient.invoices.create).mockRejectedValue(new Error('Creation failed'))

      await expect(createUsageBasedInvoice('cus_123', billingPeriod, usageRecords)).rejects.toThrow(
        'Failed to create usage-based invoice: Failed to create invoice: Creation failed'
      )
    })

    it('should handle errors in invoice item creation', async () => {
      vi.mocked(stripeServerClient.invoices.create).mockResolvedValue(mockInvoice)
      vi.mocked(stripeServerClient.invoiceItems.create).mockRejectedValue(new Error('Item failed'))

      await expect(createUsageBasedInvoice('cus_123', billingPeriod, usageRecords)).rejects.toThrow(
        'Failed to create usage-based invoice: Failed to create invoice item: Item failed'
      )
    })
  })
})
</file>

<file path="tests/unit/integrations/stripe/client.test.ts">
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import { getStripeClient, stripeConfig, isStripeConfigured } from '@/integrations/stripe/client'
import Stripe from 'stripe'
import { loadStripe } from '@stripe/stripe-js'

// Mock the Stripe modules
vi.mock('stripe')
vi.mock('@stripe/stripe-js')

// Mock environment variables
const mockEnv = {
  VITE_STRIPE_SECRET_KEY: 'sk_test_mock_secret_key',
  VITE_STRIPE_PUBLISHABLE_KEY: 'pk_test_mock_publishable_key',
  VITE_STRIPE_WEBHOOK_SECRET: 'whsec_test_mock_webhook_secret',
  VITE_STRIPE_CONNECT_CLIENT_ID: 'ca_test_mock_client_id',
}

describe('Stripe Client Module', () => {
  const originalEnv = import.meta.env

  beforeEach(() => {
    // Reset mocks
    vi.clearAllMocks()

    // Setup environment variables
    import.meta.env = { ...originalEnv, ...mockEnv }
  })

  afterEach(() => {
    // Restore original environment
    import.meta.env = originalEnv
  })

  describe('stripeServerClient', () => {
    it('should create a Stripe instance with correct configuration', () => {
      const MockedStripe = vi.mocked(Stripe)

      // Import module to trigger initialization
      vi.resetModules()

      expect(MockedStripe).toHaveBeenCalledWith(mockEnv.VITE_STRIPE_SECRET_KEY, {
        apiVersion: '2023-10-16',
        typescript: true,
      })
    })

    it('should handle missing secret key gracefully', () => {
      import.meta.env = { ...originalEnv, VITE_STRIPE_SECRET_KEY: '' }
      const MockedStripe = vi.mocked(Stripe)

      vi.resetModules()

      expect(MockedStripe).toHaveBeenCalledWith('', {
        apiVersion: '2023-10-16',
        typescript: true,
      })
    })
  })

  describe('getStripeClient', () => {
    it('should return the same promise instance on multiple calls', async () => {
      const mockStripeInstance = { id: 'mock-stripe' }
      vi.mocked(loadStripe).mockResolvedValue(
        mockStripeInstance as unknown as ReturnType<typeof loadStripe>
      )

      const firstCall = getStripeClient()
      const secondCall = getStripeClient()

      expect(firstCall).toBe(secondCall)
      expect(loadStripe).toHaveBeenCalledTimes(1)
      expect(loadStripe).toHaveBeenCalledWith(mockEnv.VITE_STRIPE_PUBLISHABLE_KEY)
    })

    it('should handle missing publishable key', async () => {
      import.meta.env = { ...originalEnv, VITE_STRIPE_PUBLISHABLE_KEY: '' }

      vi.resetModules()
      const { getStripeClient: getClient } = await import('@/integrations/stripe/client')

      getClient()

      expect(loadStripe).toHaveBeenCalledWith('')
    })

    it('should return null when loadStripe fails', async () => {
      vi.mocked(loadStripe).mockResolvedValue(null)

      vi.resetModules()
      const { getStripeClient: getClient } = await import('@/integrations/stripe/client')

      const result = await getClient()

      expect(result).toBeNull()
    })
  })

  describe('stripeConfig', () => {
    it('should contain all required configuration values', () => {
      expect(stripeConfig).toEqual({
        webhookSecret: mockEnv.VITE_STRIPE_WEBHOOK_SECRET,
        connectClientId: mockEnv.VITE_STRIPE_CONNECT_CLIENT_ID,
        apiVersion: '2023-10-16',
      })
    })

    it('should handle missing environment variables', () => {
      import.meta.env = { ...originalEnv }

      vi.resetModules()

      expect(stripeConfig).toEqual({
        webhookSecret: '',
        connectClientId: '',
        apiVersion: '2023-10-16',
      })
    })
  })

  describe('isStripeConfigured', () => {
    it('should return true when all required keys are present', () => {
      expect(isStripeConfigured()).toBe(true)
    })

    it('should return false when secret key is missing', () => {
      import.meta.env = {
        ...originalEnv,
        VITE_STRIPE_PUBLISHABLE_KEY: mockEnv.VITE_STRIPE_PUBLISHABLE_KEY,
      }

      expect(isStripeConfigured()).toBe(false)
    })

    it('should return false when publishable key is missing', () => {
      import.meta.env = {
        ...originalEnv,
        VITE_STRIPE_SECRET_KEY: mockEnv.VITE_STRIPE_SECRET_KEY,
      }

      expect(isStripeConfigured()).toBe(false)
    })

    it('should return false when both keys are missing', () => {
      import.meta.env = { ...originalEnv }

      expect(isStripeConfigured()).toBe(false)
    })

    it('should return false when keys are empty strings', () => {
      import.meta.env = {
        ...originalEnv,
        VITE_STRIPE_SECRET_KEY: '',
        VITE_STRIPE_PUBLISHABLE_KEY: '',
      }

      expect(isStripeConfigured()).toBe(false)
    })
  })
})
</file>

<file path="tests/unit/integrations/stripe/customers.test.ts">
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import {
  createStripeCustomer,
  updateStripeCustomer,
  getStripeCustomer,
  deleteStripeCustomer,
  listCustomerPaymentMethods,
  attachPaymentMethod,
  savePaymentMethod,
  detachPaymentMethod,
  setDefaultPaymentMethod,
  createSetupIntent,
} from '@/integrations/stripe/customers'
import { stripeServerClient } from '@/integrations/stripe/client'
import type Stripe from 'stripe'

// Mock uuid
vi.mock('uuid', () => ({
  v4: vi.fn(() => 'mock-uuid-123'),
}))

// Mock the stripe client
vi.mock('@/integrations/stripe/client', () => ({
  stripeServerClient: {
    customers: {
      create: vi.fn(),
      update: vi.fn(),
      retrieve: vi.fn(),
      del: vi.fn(),
    },
    paymentMethods: {
      list: vi.fn(),
      retrieve: vi.fn(),
      detach: vi.fn(),
    },
    setupIntents: {
      create: vi.fn(),
    },
    errors: {
      StripeError: class StripeError extends Error {
        constructor(
          public type: string,
          public code: string,
          public param?: string,
          public requestId?: string
        ) {
          super('Stripe error')
          this.name = 'StripeError'
        }
      },
    },
  },
}))

describe('Stripe Customers Module', () => {
  beforeEach(() => {
    vi.clearAllMocks()
    // Reset console mocks
    vi.spyOn(console, 'error').mockImplementation(() => {})
    vi.spyOn(console, 'warn').mockImplementation(() => {})
  })

  afterEach(() => {
    vi.restoreAllMocks()
  })

  describe('createStripeCustomer', () => {
    const mockCustomer = {
      id: 'cus_123',
      email: 'test@example.com',
      metadata: {
        userId: 'user_123',
        userType: 'buyer',
        platform: 'dependablecalls',
      },
    } as Stripe.Customer

    it('should create a customer with required fields', async () => {
      vi.mocked(stripeServerClient.customers.create).mockResolvedValue(mockCustomer)

      const result = await createStripeCustomer('test@example.com', {
        userId: 'user_123',
        userType: 'buyer',
      })

      expect(stripeServerClient.customers.create).toHaveBeenCalledWith(
        {
          email: 'test@example.com',
          metadata: {
            userId: 'user_123',
            userType: 'buyer',
            platform: 'dependablecalls',
          },
        },
        { idempotencyKey: 'mock-uuid-123' }
      )
      expect(result).toEqual(mockCustomer)
    })

    it('should create a customer with additional data', async () => {
      vi.mocked(stripeServerClient.customers.create).mockResolvedValue(mockCustomer)

      const additionalData = {
        name: 'John Doe',
        phone: '+1234567890',
        address: {
          line1: '123 Main St',
          city: 'San Francisco',
          state: 'CA',
          postal_code: '94105',
          country: 'US',
        } as Stripe.CustomerCreateParams.Address,
      }

      await createStripeCustomer(
        'test@example.com',
        {
          userId: 'user_123',
          userType: 'supplier',
          companyName: 'Test Company',
        },
        additionalData
      )

      expect(stripeServerClient.customers.create).toHaveBeenCalledWith(
        {
          email: 'test@example.com',
          name: 'John Doe',
          phone: '+1234567890',
          address: additionalData.address,
          metadata: {
            userId: 'user_123',
            userType: 'supplier',
            companyName: 'Test Company',
            platform: 'dependablecalls',
          },
        },
        { idempotencyKey: 'mock-uuid-123' }
      )
    })

    it('should handle Stripe errors properly', async () => {
      const stripeError = new stripeServerClient.errors.StripeError(
        'card_error',
        'card_declined',
        'payment_method',
        'req_123'
      )
      vi.mocked(stripeServerClient.customers.create).mockRejectedValue(stripeError)

      await expect(
        createStripeCustomer('test@example.com', {
          userId: 'user_123',
          userType: 'buyer',
        })
      ).rejects.toThrow('Customer service error. Please retry or contact support.')

      expect(console.error).toHaveBeenCalledWith('create Stripe customer failed', {
        type: 'card_error',
        code: 'card_declined',
        param: 'payment_method',
        requestId: 'req_123',
      })
    })

    it('should handle resource_missing errors with specific message', async () => {
      const stripeError = new stripeServerClient.errors.StripeError(
        'invalid_request_error',
        'resource_missing'
      )
      vi.mocked(stripeServerClient.customers.create).mockRejectedValue(stripeError)

      await expect(
        createStripeCustomer('test@example.com', {
          userId: 'user_123',
          userType: 'buyer',
        })
      ).rejects.toThrow('Resource not found. Please check your request and try again.')
    })

    it('should handle unexpected errors', async () => {
      vi.mocked(stripeServerClient.customers.create).mockRejectedValue(new Error('Network error'))

      await expect(
        createStripeCustomer('test@example.com', {
          userId: 'user_123',
          userType: 'buyer',
        })
      ).rejects.toThrow('Internal server error. Please try again later.')
    })
  })

  describe('updateStripeCustomer', () => {
    const mockUpdatedCustomer = {
      id: 'cus_123',
      email: 'updated@example.com',
    } as Stripe.Customer

    it('should update a customer successfully', async () => {
      vi.mocked(stripeServerClient.customers.update).mockResolvedValue(mockUpdatedCustomer)

      const updates = { email: 'updated@example.com' }
      const result = await updateStripeCustomer('cus_123', updates)

      expect(stripeServerClient.customers.update).toHaveBeenCalledWith('cus_123', updates, {
        idempotencyKey: 'mock-uuid-123',
      })
      expect(result).toEqual(mockUpdatedCustomer)
    })

    it('should handle update errors', async () => {
      vi.mocked(stripeServerClient.customers.update).mockRejectedValue(new Error('Update failed'))

      await expect(updateStripeCustomer('cus_123', { email: 'test@example.com' })).rejects.toThrow(
        'Internal server error. Please try again later.'
      )
    })
  })

  describe('getStripeCustomer', () => {
    it('should retrieve a customer successfully', async () => {
      const mockCustomer = {
        id: 'cus_123',
        deleted: false,
      } as Stripe.Customer
      vi.mocked(stripeServerClient.customers.retrieve).mockResolvedValue(mockCustomer)

      const result = await getStripeCustomer('cus_123')

      expect(stripeServerClient.customers.retrieve).toHaveBeenCalledWith('cus_123')
      expect(result).toEqual(mockCustomer)
    })

    it('should return null for deleted customers', async () => {
      const deletedCustomer = {
        id: 'cus_123',
        deleted: true,
      } as Stripe.DeletedCustomer
      vi.mocked(stripeServerClient.customers.retrieve).mockResolvedValue(deletedCustomer)

      const result = await getStripeCustomer('cus_123')

      expect(result).toBeNull()
    })

    it('should return null for resource_missing errors', async () => {
      const stripeError = new stripeServerClient.errors.StripeError(
        'invalid_request_error',
        'resource_missing'
      )
      vi.mocked(stripeServerClient.customers.retrieve).mockRejectedValue(stripeError)

      const result = await getStripeCustomer('cus_123')

      expect(result).toBeNull()
    })

    it('should handle other errors', async () => {
      vi.mocked(stripeServerClient.customers.retrieve).mockRejectedValue(new Error('Network error'))

      await expect(getStripeCustomer('cus_123')).rejects.toThrow(
        'Internal server error. Please try again later.'
      )
    })
  })

  describe('deleteStripeCustomer', () => {
    it('should delete a customer successfully', async () => {
      vi.mocked(stripeServerClient.customers.del).mockResolvedValue({
        id: 'cus_123',
        object: 'customer',
        deleted: true,
      })

      const result = await deleteStripeCustomer('cus_123')

      expect(stripeServerClient.customers.del).toHaveBeenCalledWith('cus_123')
      expect(result).toBe(true)
    })

    it('should handle deletion errors', async () => {
      vi.mocked(stripeServerClient.customers.del).mockRejectedValue(new Error('Delete failed'))

      await expect(deleteStripeCustomer('cus_123')).rejects.toThrow(
        'Internal server error. Please try again later.'
      )
    })
  })

  describe('listCustomerPaymentMethods', () => {
    it('should list payment methods with pagination', async () => {
      const mockPaymentMethods = [
        { id: 'pm_1', type: 'card' },
        { id: 'pm_2', type: 'card' },
      ] as Stripe.PaymentMethod[]

      // Mock async iterator
      const mockAsyncIterator = {
        [Symbol.asyncIterator]: async function* () {
          for (const pm of mockPaymentMethods) {
            yield pm
          }
        },
      }

      vi.mocked(stripeServerClient.paymentMethods.list).mockReturnValue(
        mockAsyncIterator as AsyncIterableIterator<Stripe.PaymentMethod>
      )

      const result = await listCustomerPaymentMethods('cus_123')

      expect(stripeServerClient.paymentMethods.list).toHaveBeenCalledWith({
        customer: 'cus_123',
        type: 'card',
        limit: 100,
      })
      expect(result).toEqual(mockPaymentMethods)
    })

    it('should list bank account payment methods', async () => {
      const mockAsyncIterator = {
        [Symbol.asyncIterator]: async function* () {
          yield { id: 'pm_bank', type: 'us_bank_account' }
        },
      }

      vi.mocked(stripeServerClient.paymentMethods.list).mockReturnValue(
        mockAsyncIterator as AsyncIterableIterator<Stripe.PaymentMethod>
      )

      const result = await listCustomerPaymentMethods('cus_123', 'us_bank_account', 50)

      expect(stripeServerClient.paymentMethods.list).toHaveBeenCalledWith({
        customer: 'cus_123',
        type: 'us_bank_account',
        limit: 50,
      })
      expect(result).toHaveLength(1)
    })

    it('should handle listing errors', async () => {
      vi.mocked(stripeServerClient.paymentMethods.list).mockImplementation(() => {
        throw new Error('List failed')
      })

      await expect(listCustomerPaymentMethods('cus_123')).rejects.toThrow(
        'Internal server error. Please try again later.'
      )
    })
  })

  describe('attachPaymentMethod', () => {
    it('should log deprecation warning and call savePaymentMethod', async () => {
      const mockPaymentMethod = { id: 'pm_123' } as Stripe.PaymentMethod
      const mockSetupIntent = {
        id: 'seti_123',
        status: 'succeeded',
      } as Stripe.SetupIntent

      vi.mocked(stripeServerClient.setupIntents.create).mockResolvedValue(mockSetupIntent)
      vi.mocked(stripeServerClient.paymentMethods.retrieve).mockResolvedValue(mockPaymentMethod)

      const result = await attachPaymentMethod('pm_123', 'cus_123')

      expect(console.warn).toHaveBeenCalledWith(
        'attachPaymentMethod is deprecated. Use savePaymentMethod for better SCA compliance.'
      )
      expect(result).toEqual(mockPaymentMethod)
    })
  })

  describe('savePaymentMethod', () => {
    it('should save payment method with SetupIntent', async () => {
      const mockSetupIntent = {
        id: 'seti_123',
        status: 'succeeded',
      } as Stripe.SetupIntent
      const mockPaymentMethod = { id: 'pm_123' } as Stripe.PaymentMethod

      vi.mocked(stripeServerClient.setupIntents.create).mockResolvedValue(mockSetupIntent)
      vi.mocked(stripeServerClient.paymentMethods.retrieve).mockResolvedValue(mockPaymentMethod)

      const result = await savePaymentMethod('cus_123', 'pm_123', { source: 'web' })

      expect(stripeServerClient.setupIntents.create).toHaveBeenCalledWith(
        {
          customer: 'cus_123',
          payment_method_types: ['card', 'us_bank_account'],
          payment_method: 'pm_123',
          confirm: true,
          usage: 'off_session',
          metadata: {
            source: 'web',
            platform: 'dependablecalls',
          },
        },
        { idempotencyKey: 'mock-uuid-123' }
      )
      expect(stripeServerClient.paymentMethods.retrieve).toHaveBeenCalledWith('pm_123')
      expect(result).toEqual(mockPaymentMethod)
    })

    it('should throw error if SetupIntent fails', async () => {
      const mockSetupIntent = {
        id: 'seti_123',
        status: 'requires_payment_method',
      } as Stripe.SetupIntent

      vi.mocked(stripeServerClient.setupIntents.create).mockResolvedValue(mockSetupIntent)

      await expect(savePaymentMethod('cus_123', 'pm_123')).rejects.toThrow(
        'SetupIntent failed with status: requires_payment_method'
      )
    })

    it('should handle setup errors', async () => {
      vi.mocked(stripeServerClient.setupIntents.create).mockRejectedValue(new Error('Setup failed'))

      await expect(savePaymentMethod('cus_123', 'pm_123')).rejects.toThrow(
        'Internal server error. Please try again later.'
      )
    })
  })

  describe('detachPaymentMethod', () => {
    it('should detach payment method successfully', async () => {
      const mockPaymentMethod = { id: 'pm_123', customer: null } as Stripe.PaymentMethod
      vi.mocked(stripeServerClient.paymentMethods.detach).mockResolvedValue(mockPaymentMethod)

      const result = await detachPaymentMethod('pm_123')

      expect(stripeServerClient.paymentMethods.detach).toHaveBeenCalledWith('pm_123')
      expect(result).toEqual(mockPaymentMethod)
    })

    it('should handle detach errors', async () => {
      vi.mocked(stripeServerClient.paymentMethods.detach).mockRejectedValue(
        new Error('Detach failed')
      )

      await expect(detachPaymentMethod('pm_123')).rejects.toThrow(
        'Internal server error. Please try again later.'
      )
    })
  })

  describe('setDefaultPaymentMethod', () => {
    it('should set default payment method successfully', async () => {
      const mockCustomer = {
        id: 'cus_123',
        invoice_settings: {
          default_payment_method: 'pm_123',
        },
      } as Stripe.Customer

      vi.mocked(stripeServerClient.customers.update).mockResolvedValue(mockCustomer)

      const result = await setDefaultPaymentMethod('cus_123', 'pm_123')

      expect(stripeServerClient.customers.update).toHaveBeenCalledWith(
        'cus_123',
        {
          invoice_settings: {
            default_payment_method: 'pm_123',
          },
        },
        { idempotencyKey: 'mock-uuid-123' }
      )
      expect(result).toEqual(mockCustomer)
    })
  })

  describe('createSetupIntent', () => {
    it('should create setup intent successfully', async () => {
      const mockSetupIntent = {
        id: 'seti_123',
        customer: 'cus_123',
      } as Stripe.SetupIntent

      vi.mocked(stripeServerClient.setupIntents.create).mockResolvedValue(mockSetupIntent)

      const result = await createSetupIntent('cus_123', { source: 'mobile' })

      expect(stripeServerClient.setupIntents.create).toHaveBeenCalledWith(
        {
          customer: 'cus_123',
          payment_method_types: ['card', 'us_bank_account'],
          usage: 'off_session',
          metadata: {
            source: 'mobile',
            platform: 'dependablecalls',
          },
        },
        { idempotencyKey: 'mock-uuid-123' }
      )
      expect(result).toEqual(mockSetupIntent)
    })

    it('should handle creation errors', async () => {
      vi.mocked(stripeServerClient.setupIntents.create).mockRejectedValue(
        new Error('Create failed')
      )

      await expect(createSetupIntent('cus_123')).rejects.toThrow(
        'Internal server error. Please try again later.'
      )
    })
  })
})
</file>

<file path="tests/unit/integrations/stripe/payments.test.ts">
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import {
  createPaymentIntent,
  confirmPaymentIntent,
  cancelPaymentIntent,
  getPaymentIntent,
  capturePaymentIntent,
  listPayments,
  createRefund,
  getPaymentStatus,
} from '@/integrations/stripe/payments'
import { stripeServerClient } from '@/integrations/stripe/client'
import type Stripe from 'stripe'
import type { CreatePaymentIntentParams } from '@/integrations/stripe/types'

// Mock uuid
vi.mock('uuid', () => ({
  v4: vi.fn(() => 'mock-uuid-123'),
}))

// Mock the stripe client
vi.mock('@/integrations/stripe/client', () => ({
  stripeServerClient: {
    paymentIntents: {
      create: vi.fn(),
      confirm: vi.fn(),
      cancel: vi.fn(),
      retrieve: vi.fn(),
      capture: vi.fn(),
      list: vi.fn(),
    },
    refunds: {
      create: vi.fn(),
    },
    errors: {
      StripeError: class StripeError extends Error {
        constructor(
          public type: string,
          public code: string,
          public param?: string,
          public requestId?: string
        ) {
          super('Stripe error')
          this.name = 'StripeError'
        }
      },
    },
  },
}))

describe('Stripe Payments Module', () => {
  beforeEach(() => {
    vi.clearAllMocks()
    vi.spyOn(console, 'error').mockImplementation(() => {})
  })

  afterEach(() => {
    vi.restoreAllMocks()
  })

  describe('createPaymentIntent', () => {
    const mockPaymentIntent = {
      id: 'pi_123',
      amount: 5000,
      status: 'requires_payment_method',
    } as Stripe.PaymentIntent

    const params: CreatePaymentIntentParams = {
      amount: 5000,
      currency: 'usd',
      customerId: 'cus_123',
      metadata: {
        campaignId: 'campaign_123',
        buyerId: 'buyer_123',
      },
    }

    it('should create payment intent with default payment method types', async () => {
      vi.mocked(stripeServerClient.paymentIntents.create).mockResolvedValue(mockPaymentIntent)

      const result = await createPaymentIntent(params)

      expect(stripeServerClient.paymentIntents.create).toHaveBeenCalledWith(
        {
          amount: 5000,
          currency: 'usd',
          customer: 'cus_123',
          payment_method_types: ['card', 'us_bank_account'],
          metadata: {
            campaignId: 'campaign_123',
            buyerId: 'buyer_123',
            platform: 'dependablecalls',
          },
          setup_future_usage: 'off_session',
          automatic_payment_methods: {
            enabled: true,
          },
        },
        { idempotencyKey: 'mock-uuid-123' }
      )
      expect(result).toEqual(mockPaymentIntent)
    })

    it('should create payment intent with custom payment method types', async () => {
      vi.mocked(stripeServerClient.paymentIntents.create).mockResolvedValue(mockPaymentIntent)

      const customParams: CreatePaymentIntentParams = {
        ...params,
        paymentMethodTypes: ['card'],
      }

      await createPaymentIntent(customParams)

      expect(stripeServerClient.paymentIntents.create).toHaveBeenCalledWith(
        expect.objectContaining({
          payment_method_types: ['card'],
        }),
        { idempotencyKey: 'mock-uuid-123' }
      )
    })

    it('should handle Stripe errors properly', async () => {
      const stripeError = new stripeServerClient.errors.StripeError(
        'card_error',
        'card_declined',
        'payment_method',
        'req_123'
      )
      vi.mocked(stripeServerClient.paymentIntents.create).mockRejectedValue(stripeError)

      await expect(createPaymentIntent(params)).rejects.toThrow(
        'Payment service error. Please retry or contact support.'
      )

      expect(console.error).toHaveBeenCalledWith('create payment intent failed', {
        type: 'card_error',
        code: 'card_declined',
        param: 'payment_method',
        requestId: 'req_123',
      })
    })

    it('should handle resource_missing errors with specific message', async () => {
      const stripeError = new stripeServerClient.errors.StripeError(
        'invalid_request_error',
        'resource_missing'
      )
      vi.mocked(stripeServerClient.paymentIntents.create).mockRejectedValue(stripeError)

      await expect(createPaymentIntent(params)).rejects.toThrow(
        'Resource not found. Please check your request and try again.'
      )
    })

    it('should handle unexpected errors', async () => {
      vi.mocked(stripeServerClient.paymentIntents.create).mockRejectedValue(
        new Error('Network error')
      )

      await expect(createPaymentIntent(params)).rejects.toThrow(
        'Internal server error. Please try again later.'
      )
    })
  })

  describe('confirmPaymentIntent', () => {
    const mockConfirmedIntent = {
      id: 'pi_123',
      status: 'processing',
    } as Stripe.PaymentIntent

    it('should confirm payment intent successfully', async () => {
      vi.mocked(stripeServerClient.paymentIntents.confirm).mockResolvedValue(mockConfirmedIntent)

      const result = await confirmPaymentIntent('pi_123', 'pm_123', 'https://example.com/return')

      expect(stripeServerClient.paymentIntents.confirm).toHaveBeenCalledWith(
        'pi_123',
        {
          payment_method: 'pm_123',
          return_url: 'https://example.com/return',
        },
        { idempotencyKey: 'mock-uuid-123' }
      )
      expect(result).toEqual(mockConfirmedIntent)
    })

    it('should handle confirmation errors', async () => {
      vi.mocked(stripeServerClient.paymentIntents.confirm).mockRejectedValue(
        new Error('Confirmation failed')
      )

      await expect(
        confirmPaymentIntent('pi_123', 'pm_123', 'https://example.com/return')
      ).rejects.toThrow('Internal server error. Please try again later.')
    })
  })

  describe('cancelPaymentIntent', () => {
    const mockCancelledIntent = {
      id: 'pi_123',
      status: 'canceled',
    } as Stripe.PaymentIntent

    it('should cancel payment intent with default reason', async () => {
      vi.mocked(stripeServerClient.paymentIntents.cancel).mockResolvedValue(mockCancelledIntent)

      const result = await cancelPaymentIntent('pi_123')

      expect(stripeServerClient.paymentIntents.cancel).toHaveBeenCalledWith(
        'pi_123',
        {
          cancellation_reason: 'requested_by_customer',
        },
        { idempotencyKey: 'mock-uuid-123' }
      )
      expect(result).toEqual(mockCancelledIntent)
    })

    it('should cancel payment intent with custom reason', async () => {
      vi.mocked(stripeServerClient.paymentIntents.cancel).mockResolvedValue(mockCancelledIntent)

      await cancelPaymentIntent('pi_123', 'duplicate')

      expect(stripeServerClient.paymentIntents.cancel).toHaveBeenCalledWith(
        'pi_123',
        {
          cancellation_reason: 'duplicate',
        },
        { idempotencyKey: 'mock-uuid-123' }
      )
    })

    it('should handle cancellation errors', async () => {
      vi.mocked(stripeServerClient.paymentIntents.cancel).mockRejectedValue(
        new Error('Cancellation failed')
      )

      await expect(cancelPaymentIntent('pi_123')).rejects.toThrow(
        'Internal server error. Please try again later.'
      )
    })
  })

  describe('getPaymentIntent', () => {
    const mockPaymentIntent = {
      id: 'pi_123',
      amount: 5000,
    } as Stripe.PaymentIntent

    it('should retrieve payment intent successfully', async () => {
      vi.mocked(stripeServerClient.paymentIntents.retrieve).mockResolvedValue(mockPaymentIntent)

      const result = await getPaymentIntent('pi_123')

      expect(stripeServerClient.paymentIntents.retrieve).toHaveBeenCalledWith('pi_123')
      expect(result).toEqual(mockPaymentIntent)
    })

    it('should return null for missing payment intent', async () => {
      const missingError = new stripeServerClient.errors.StripeError(
        'invalid_request_error',
        'resource_missing'
      )
      vi.mocked(stripeServerClient.paymentIntents.retrieve).mockRejectedValue(missingError)

      const result = await getPaymentIntent('pi_123')

      expect(result).toBeNull()
    })

    it('should handle other retrieval errors', async () => {
      vi.mocked(stripeServerClient.paymentIntents.retrieve).mockRejectedValue(
        new Error('Retrieval failed')
      )

      await expect(getPaymentIntent('pi_123')).rejects.toThrow(
        'Internal server error. Please try again later.'
      )
    })
  })

  describe('capturePaymentIntent', () => {
    const mockCapturedIntent = {
      id: 'pi_123',
      status: 'succeeded',
    } as Stripe.PaymentIntent

    it('should capture full amount by default', async () => {
      vi.mocked(stripeServerClient.paymentIntents.capture).mockResolvedValue(mockCapturedIntent)

      const result = await capturePaymentIntent('pi_123')

      expect(stripeServerClient.paymentIntents.capture).toHaveBeenCalledWith(
        'pi_123',
        {},
        { idempotencyKey: 'mock-uuid-123' }
      )
      expect(result).toEqual(mockCapturedIntent)
    })

    it('should capture partial amount when specified', async () => {
      vi.mocked(stripeServerClient.paymentIntents.capture).mockResolvedValue(mockCapturedIntent)

      await capturePaymentIntent('pi_123', 3000)

      expect(stripeServerClient.paymentIntents.capture).toHaveBeenCalledWith(
        'pi_123',
        { amount_to_capture: 3000 },
        { idempotencyKey: 'mock-uuid-123' }
      )
    })

    it('should handle capture errors', async () => {
      vi.mocked(stripeServerClient.paymentIntents.capture).mockRejectedValue(
        new Error('Capture failed')
      )

      await expect(capturePaymentIntent('pi_123')).rejects.toThrow(
        'Internal server error. Please try again later.'
      )
    })
  })

  describe('createRefund', () => {
    const mockRefund = {
      id: 'refund_123',
      amount: 2000,
      status: 'succeeded',
    } as Stripe.Refund

    it('should create full refund', async () => {
      vi.mocked(stripeServerClient.refunds.create).mockResolvedValue(mockRefund)

      const result = await createRefund('pi_123', undefined, 'requested_by_customer')

      expect(stripeServerClient.refunds.create).toHaveBeenCalledWith(
        {
          payment_intent: 'pi_123',
          reason: 'requested_by_customer',
          metadata: {
            platform: 'dependablecalls',
          },
        },
        { idempotencyKey: 'mock-uuid-123' }
      )
      expect(result).toEqual(mockRefund)
    })

    it('should create partial refund', async () => {
      vi.mocked(stripeServerClient.refunds.create).mockResolvedValue(mockRefund)

      await createRefund('pi_123', 2000, 'duplicate', { orderId: 'order_123' })

      expect(stripeServerClient.refunds.create).toHaveBeenCalledWith(
        {
          payment_intent: 'pi_123',
          amount: 2000,
          reason: 'duplicate',
          metadata: {
            orderId: 'order_123',
            platform: 'dependablecalls',
          },
        },
        { idempotencyKey: 'mock-uuid-123' }
      )
    })

    it('should handle refund errors', async () => {
      vi.mocked(stripeServerClient.refunds.create).mockRejectedValue(new Error('Refund failed'))

      await expect(createRefund('pi_123')).rejects.toThrow(
        'Internal server error. Please try again later.'
      )
    })
  })

  describe('listPayments', () => {
    const mockPayments = {
      data: [
        { id: 'pi_1', amount: 5000 },
        { id: 'pi_2', amount: 3000 },
      ],
    } as Stripe.ApiList<Stripe.PaymentIntent>

    it('should list customer payments', async () => {
      vi.mocked(stripeServerClient.paymentIntents.list).mockResolvedValue(mockPayments)

      const result = await listPayments({ customerId: 'cus_123' })

      expect(stripeServerClient.paymentIntents.list).toHaveBeenCalledWith({
        customer: 'cus_123',
        limit: 100,
      })
      expect(result).toEqual(mockPayments.data)
    })

    it('should list payments with filters', async () => {
      vi.mocked(stripeServerClient.paymentIntents.list).mockResolvedValue(mockPayments)

      await listPayments({
        customerId: 'cus_123',
        status: 'succeeded',
        limit: 50,
        startingAfter: 'pi_0',
      })

      expect(stripeServerClient.paymentIntents.list).toHaveBeenCalledWith({
        customer: 'cus_123',
        limit: 50,
        starting_after: 'pi_0',
      })
    })

    it('should handle listing errors', async () => {
      vi.mocked(stripeServerClient.paymentIntents.list).mockRejectedValue(new Error('List failed'))

      await expect(listPayments({ customerId: 'cus_123' })).rejects.toThrow(
        'Internal server error. Please try again later.'
      )
    })
  })

  describe('getPaymentStatus', () => {
    it('should map succeeded status', () => {
      const paymentIntent = {
        status: 'succeeded',
        last_payment_error: null,
      } as Stripe.PaymentIntent

      const status = getPaymentStatus(paymentIntent)

      expect(status).toEqual({
        status: 'succeeded',
        isTerminal: true,
        requiresAction: false,
        error: null,
      })
    })

    it('should map requires_action status', () => {
      const paymentIntent = {
        status: 'requires_action',
        last_payment_error: null,
      } as Stripe.PaymentIntent

      const status = getPaymentStatus(paymentIntent)

      expect(status).toEqual({
        status: 'requires_action',
        isTerminal: false,
        requiresAction: true,
        error: null,
      })
    })

    it('should include error information', () => {
      const paymentIntent = {
        status: 'requires_payment_method',
        last_payment_error: {
          code: 'card_declined',
          message: 'Your card was declined',
        },
      } as Stripe.PaymentIntent

      const status = getPaymentStatus(paymentIntent)

      expect(status).toEqual({
        status: 'requires_payment_method',
        isTerminal: false,
        requiresAction: false,
        error: {
          code: 'card_declined',
          message: 'Your card was declined',
        },
      })
    })
  })
})
</file>

<file path="tests/unit/integrations/stripe/webhooks.test.ts">
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import {
  verifyWebhookSignature,
  handleStripeWebhook,
  timingSafeEqual,
} from '@/integrations/stripe/webhooks'
import { stripeServerClient } from '@/integrations/stripe/client'
import type Stripe from 'stripe'
import type { Request, Response } from 'express'
import crypto from 'crypto'

// Mock crypto module
vi.mock('crypto', () => ({
  default: {
    timingSafeEqual: vi.fn((a: Buffer, b: Buffer) => {
      return a.toString() === b.toString()
    }),
  },
}))

// Mock the stripe client
vi.mock('@/integrations/stripe/client', () => ({
  stripeServerClient: {
    webhooks: {
      constructEvent: vi.fn(),
    },
  },
  stripeConfig: {
    webhookSecret: 'whsec_test_secret',
  },
}))

describe('Stripe Webhooks Module', () => {
  beforeEach(() => {
    vi.clearAllMocks()
    vi.spyOn(console, 'log').mockImplementation(() => {})
    vi.spyOn(console, 'error').mockImplementation(() => {})
    vi.spyOn(console, 'warn').mockImplementation(() => {})
  })

  afterEach(() => {
    vi.restoreAllMocks()
  })

  describe('verifyWebhookSignature', () => {
    it('should verify webhook signature successfully', () => {
      const mockEvent = {
        id: 'evt_123',
        type: 'payment_intent.succeeded',
        data: { object: { id: 'pi_123' } },
      } as Stripe.Event

      vi.mocked(stripeServerClient.webhooks.constructEvent).mockReturnValue(mockEvent)

      const result = verifyWebhookSignature('payload', 'signature')

      expect(stripeServerClient.webhooks.constructEvent).toHaveBeenCalledWith(
        'payload',
        'signature',
        'whsec_test_secret'
      )
      expect(result).toEqual(mockEvent)
    })

    it('should throw error when verification fails', () => {
      vi.mocked(stripeServerClient.webhooks.constructEvent).mockImplementation(() => {
        throw new Error('Invalid signature')
      })

      expect(() => verifyWebhookSignature('payload', 'signature')).toThrow(
        'Webhook signature verification failed: Invalid signature'
      )
    })

    it('should handle non-Error exceptions', () => {
      vi.mocked(stripeServerClient.webhooks.constructEvent).mockImplementation(() => {
        throw 'String error'
      })

      expect(() => verifyWebhookSignature('payload', 'signature')).toThrow(
        'Webhook signature verification failed: Unknown error'
      )
    })
  })

  describe('handleStripeWebhook', () => {
    let mockReq: Partial<Request>
    let mockRes: Partial<Response>

    beforeEach(() => {
      mockReq = {
        headers: {
          'stripe-signature': 'test-signature',
        },
        body: 'test-payload',
      }

      mockRes = {
        status: vi.fn().mockReturnThis(),
        send: vi.fn().mockReturnThis(),
        json: vi.fn().mockReturnThis(),
      }
    })

    it('should handle missing signature header', async () => {
      mockReq.headers = {}

      await handleStripeWebhook(mockReq as Request, mockRes as Response)

      expect(mockRes.status).toHaveBeenCalledWith(400)
      expect(mockRes.send).toHaveBeenCalledWith('Missing stripe-signature header')
    })

    it('should handle signature verification failure', async () => {
      vi.mocked(stripeServerClient.webhooks.constructEvent).mockImplementation(() => {
        throw new Error('Invalid signature')
      })

      await handleStripeWebhook(mockReq as Request, mockRes as Response)

      expect(mockRes.status).toHaveBeenCalledWith(400)
      expect(mockRes.send).toHaveBeenCalledWith('Webhook Error: Invalid signature')
      expect(console.error).toHaveBeenCalledWith(
        'Webhook signature verification failed:',
        expect.any(Error)
      )
    })

    it('should handle payment_intent.succeeded event', async () => {
      const mockEvent = {
        id: 'evt_123',
        type: 'payment_intent.succeeded',
        data: {
          object: {
            id: 'pi_123',
            amount: 5000,
            currency: 'usd',
          },
        },
      } as Stripe.Event

      vi.mocked(stripeServerClient.webhooks.constructEvent).mockReturnValue(mockEvent)

      await handleStripeWebhook(mockReq as Request, mockRes as Response)

      expect(console.log).toHaveBeenCalledWith('Payment succeeded:', 'pi_123')
      expect(mockRes.json).toHaveBeenCalledWith({ received: true })
    })

    it('should handle payment_intent.payment_failed event', async () => {
      const mockEvent = {
        id: 'evt_123',
        type: 'payment_intent.payment_failed',
        data: {
          object: {
            id: 'pi_123',
          },
        },
      } as Stripe.Event

      vi.mocked(stripeServerClient.webhooks.constructEvent).mockReturnValue(mockEvent)

      await handleStripeWebhook(mockReq as Request, mockRes as Response)

      expect(console.error).toHaveBeenCalledWith('Payment failed:', 'pi_123')
      expect(mockRes.json).toHaveBeenCalledWith({ received: true })
    })

    it('should handle charge.dispute.created event', async () => {
      const mockEvent = {
        id: 'evt_123',
        type: 'charge.dispute.created',
        data: {
          object: {
            id: 'dp_123',
          },
        },
      } as Stripe.Event

      vi.mocked(stripeServerClient.webhooks.constructEvent).mockReturnValue(mockEvent)

      await handleStripeWebhook(mockReq as Request, mockRes as Response)

      expect(console.warn).toHaveBeenCalledWith('Dispute created:', 'dp_123')
      expect(mockRes.json).toHaveBeenCalledWith({ received: true })
    })

    it('should handle account.updated event', async () => {
      const mockEvent = {
        id: 'evt_123',
        type: 'account.updated',
        data: {
          object: {
            id: 'acct_123',
          },
        },
      } as Stripe.Event

      vi.mocked(stripeServerClient.webhooks.constructEvent).mockReturnValue(mockEvent)

      await handleStripeWebhook(mockReq as Request, mockRes as Response)

      expect(console.log).toHaveBeenCalledWith('Connected account updated:', 'acct_123')
      expect(mockRes.json).toHaveBeenCalledWith({ received: true })
    })

    it('should handle payout events', async () => {
      const payoutEvents = [
        { type: 'payout.created', message: 'Payout created:' },
        { type: 'payout.paid', message: 'Payout completed:' },
        { type: 'payout.failed', message: 'Payout failed:' },
      ]

      for (const { type, message } of payoutEvents) {
        vi.clearAllMocks()

        const mockEvent = {
          id: 'evt_123',
          type,
          data: {
            object: {
              id: 'po_123',
            },
          },
        } as Stripe.Event

        vi.mocked(stripeServerClient.webhooks.constructEvent).mockReturnValue(mockEvent)

        await handleStripeWebhook(mockReq as Request, mockRes as Response)

        if (type === 'payout.failed') {
          expect(console.error).toHaveBeenCalledWith(message, 'po_123')
        } else {
          expect(console.log).toHaveBeenCalledWith(message, 'po_123')
        }
        expect(mockRes.json).toHaveBeenCalledWith({ received: true })
      }
    })

    it('should handle transfer events', async () => {
      const transferEvents = [
        { type: 'transfer.created', message: 'Transfer created:', logType: 'log' },
        { type: 'transfer.reversed', message: 'Transfer reversed:', logType: 'warn' },
      ]

      for (const { type, message, logType } of transferEvents) {
        vi.clearAllMocks()

        const mockEvent = {
          id: 'evt_123',
          type,
          data: {
            object: {
              id: 'tr_123',
            },
          },
        } as Stripe.Event

        vi.mocked(stripeServerClient.webhooks.constructEvent).mockReturnValue(mockEvent)

        await handleStripeWebhook(mockReq as Request, mockRes as Response)

        if (logType === 'warn') {
          expect(console.warn).toHaveBeenCalledWith(message, 'tr_123')
        } else {
          expect(console.log).toHaveBeenCalledWith(message, 'tr_123')
        }
        expect(mockRes.json).toHaveBeenCalledWith({ received: true })
      }
    })

    it('should handle account authorization events', async () => {
      const authEvents = [
        { type: 'account.application.authorized', message: 'Account authorized:' },
        { type: 'account.application.deauthorized', message: 'Account deauthorized:' },
      ]

      for (const { type, message } of authEvents) {
        vi.clearAllMocks()

        const mockEvent = {
          id: 'evt_123',
          type,
          data: {
            object: {
              id: 'acct_123',
            },
          },
        } as Stripe.Event

        vi.mocked(stripeServerClient.webhooks.constructEvent).mockReturnValue(mockEvent)

        await handleStripeWebhook(mockReq as Request, mockRes as Response)

        expect(console.log).toHaveBeenCalledWith(message, 'acct_123')
        expect(mockRes.json).toHaveBeenCalledWith({ received: true })
      }
    })

    it('should handle unhandled event types', async () => {
      const mockEvent = {
        id: 'evt_123',
        type: 'unknown.event',
        data: {
          object: {},
        },
      } as Stripe.Event

      vi.mocked(stripeServerClient.webhooks.constructEvent).mockReturnValue(mockEvent)

      await handleStripeWebhook(mockReq as Request, mockRes as Response)

      expect(console.log).toHaveBeenCalledWith('Unhandled webhook event type: unknown.event')
      expect(mockRes.json).toHaveBeenCalledWith({ received: true })
    })

    it('should handle webhook handler errors', async () => {
      const mockEvent = {
        id: 'evt_123',
        type: 'payment_intent.succeeded',
        data: {
          object: {
            id: 'pi_123',
          },
        },
      } as Stripe.Event

      vi.mocked(stripeServerClient.webhooks.constructEvent).mockReturnValue(mockEvent)

      // Mock console.log to throw an error when handler runs
      vi.mocked(console.log).mockImplementationOnce(() => {
        throw new Error('Handler error')
      })

      await handleStripeWebhook(mockReq as Request, mockRes as Response)

      expect(mockRes.status).toHaveBeenCalledWith(500)
      expect(mockRes.send).toHaveBeenCalledWith('Webhook handler error: Handler error')
    })
  })

  describe('timingSafeEqual', () => {
    it('should return true for equal strings', () => {
      const result = timingSafeEqual('test123', 'test123')
      expect(result).toBe(true)
    })

    it('should return false for different strings', () => {
      const result = timingSafeEqual('test123', 'test456')
      expect(result).toBe(false)
    })

    it('should return false for different length strings', () => {
      const result = timingSafeEqual('test', 'testing')
      expect(result).toBe(false)
    })

    it('should use crypto.timingSafeEqual for comparison', () => {
      const mockTimingSafeEqual = vi.mocked(crypto.timingSafeEqual)
      mockTimingSafeEqual.mockClear()

      timingSafeEqual('test', 'test')

      expect(mockTimingSafeEqual).toHaveBeenCalledWith(expect.any(Buffer), expect.any(Buffer))
    })
  })
})
</file>

<file path="tests/unit/pages/auth/ForgotPasswordPage.test.tsx">
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import { screen, fireEvent, waitFor } from '@testing-library/react'
import { render } from '@/test/test-utils'
import ForgotPasswordPage from '@/pages/auth/ForgotPasswordPage'

// Mock the router navigate function
const mockNavigate = vi.fn()
vi.mock('react-router-dom', async () => {
  const actual = await vi.importActual('react-router-dom')
  return {
    ...actual,
    useNavigate: () => mockNavigate,
    Link: ({ to, children, ...props }: { to: string; children: React.ReactNode }) => (
      <a href={to} {...props}>
        {children}
      </a>
    ),
  }
})

// Mock Supabase
vi.mock('@/lib/supabase', () => ({
  supabase: {
    auth: {
      resetPasswordForEmail: vi.fn(),
    },
  },
}))

// Import to get the mocked function reference
import { supabase } from '@/lib/supabase'
const mockResetPasswordForEmail = vi.mocked(supabase.auth.resetPasswordForEmail)

// Mock window.location
Object.defineProperty(window, 'location', {
  value: {
    origin: 'http://localhost:3000',
  },
  writable: true,
})

describe('ForgotPasswordPage', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  afterEach(() => {
    vi.restoreAllMocks()
  })

  it('should render forgot password form with all required elements', () => {
    render(<ForgotPasswordPage />)

    expect(screen.getByRole('heading', { name: /forgot your password/i })).toBeInTheDocument()
    expect(
      screen.getByText(/enter your email address and we'll send you a link/i)
    ).toBeInTheDocument()
    expect(screen.getByPlaceholderText(/enter your email/i)).toBeInTheDocument()
    expect(screen.getByRole('button', { name: /send reset link/i })).toBeInTheDocument()
    expect(screen.getByRole('link', { name: /back to login/i })).toHaveAttribute('href', '/login')
  })

  it('should validate email field', async () => {
    render(<ForgotPasswordPage />)

    const emailInput = screen.getByPlaceholderText(/enter your email/i)
    const submitButton = screen.getByRole('button', { name: /send reset link/i })

    // Test invalid email
    fireEvent.change(emailInput, { target: { value: 'invalid-email' } })
    fireEvent.blur(emailInput) // Trigger validation
    fireEvent.click(submitButton)

    await waitFor(() => {
      expect(screen.getByText(/invalid email address/i)).toBeInTheDocument()
    })
  })

  it('should handle successful password reset request', async () => {
    mockResetPasswordForEmail.mockResolvedValueOnce({ error: null })

    render(<ForgotPasswordPage />)

    const emailInput = screen.getByPlaceholderText(/enter your email/i)
    const submitButton = screen.getByRole('button', { name: /send reset link/i })

    // Fill in valid email
    fireEvent.change(emailInput, { target: { value: 'test@example.com' } })
    fireEvent.click(submitButton)

    // Check loading state
    await waitFor(() => {
      expect(screen.getByText(/sending.../i)).toBeInTheDocument()
    })

    // Check that resetPasswordForEmail was called with correct arguments
    await waitFor(() => {
      expect(mockResetPasswordForEmail).toHaveBeenCalledWith('test@example.com', {
        redirectTo: 'http://localhost:3000/reset-password',
      })
    })

    // Check success state is displayed
    await waitFor(() => {
      expect(screen.getByRole('heading', { name: /check your email/i })).toBeInTheDocument()
      expect(
        screen.getByText(/we've sent a password reset link to your email address/i)
      ).toBeInTheDocument()
      expect(screen.getByRole('link', { name: /back to login/i })).toHaveAttribute('href', '/login')
    })
  })

  it('should handle password reset error with Error instance', async () => {
    const errorMessage = 'User not found'
    mockResetPasswordForEmail.mockResolvedValueOnce({ error: new Error(errorMessage) })

    render(<ForgotPasswordPage />)

    const emailInput = screen.getByPlaceholderText(/enter your email/i)
    const submitButton = screen.getByRole('button', { name: /send reset link/i })

    // Fill in email
    fireEvent.change(emailInput, { target: { value: 'test@example.com' } })
    fireEvent.click(submitButton)

    // Wait for error to appear
    await waitFor(() => {
      expect(screen.getByText(errorMessage)).toBeInTheDocument()
    })

    // Check that loading state is cleared
    expect(screen.getByRole('button', { name: /send reset link/i })).toBeInTheDocument()
    expect(screen.queryByText(/sending.../i)).not.toBeInTheDocument()
  })

  it('should handle password reset error with non-Error instance', async () => {
    mockResetPasswordForEmail.mockRejectedValueOnce('String error')

    render(<ForgotPasswordPage />)

    const emailInput = screen.getByPlaceholderText(/enter your email/i)
    const submitButton = screen.getByRole('button', { name: /send reset link/i })

    // Fill in email
    fireEvent.change(emailInput, { target: { value: 'test@example.com' } })
    fireEvent.click(submitButton)

    // Wait for default error message to appear
    await waitFor(() => {
      expect(screen.getByText(/failed to send reset email/i)).toBeInTheDocument()
    })
  })

  it('should disable submit button while loading', async () => {
    // Mock a slow reset request to test loading state
    mockResetPasswordForEmail.mockImplementation(
      () => new Promise((resolve) => setTimeout(() => resolve({ error: null }), 1000))
    )

    render(<ForgotPasswordPage />)

    const emailInput = screen.getByPlaceholderText(/enter your email/i)
    const submitButton = screen.getByRole('button', { name: /send reset link/i })

    // Fill in email and submit
    fireEvent.change(emailInput, { target: { value: 'test@example.com' } })
    fireEvent.click(submitButton)

    // Check that button is disabled and shows loading text
    await waitFor(() => {
      const loadingButton = screen.getByRole('button', { name: /sending.../i })
      expect(loadingButton).toBeDisabled()
    })
  })

  it('should clear error when form is resubmitted', async () => {
    // First submission fails
    mockResetPasswordForEmail.mockResolvedValueOnce({ error: new Error('Network error') })

    render(<ForgotPasswordPage />)

    const emailInput = screen.getByPlaceholderText(/enter your email/i)
    const submitButton = screen.getByRole('button', { name: /send reset link/i })

    // First submission
    fireEvent.change(emailInput, { target: { value: 'test@example.com' } })
    fireEvent.click(submitButton)

    // Wait for error
    await waitFor(() => {
      expect(screen.getByText(/network error/i)).toBeInTheDocument()
    })

    // Second submission should succeed
    mockResetPasswordForEmail.mockResolvedValueOnce({ error: null })
    fireEvent.click(submitButton)

    // Error should be cleared during loading
    await waitFor(() => {
      expect(screen.queryByText(/network error/i)).not.toBeInTheDocument()
    })
  })

  it('should not submit form with missing email', async () => {
    render(<ForgotPasswordPage />)

    const emailInput = screen.getByPlaceholderText(/enter your email/i)
    const submitButton = screen.getByRole('button', { name: /send reset link/i })

    // Try to submit empty form
    fireEvent.blur(emailInput) // Trigger validation on empty field
    fireEvent.click(submitButton)

    // Should show validation error
    await waitFor(() => {
      expect(screen.getByText(/invalid email address/i)).toBeInTheDocument()
    })

    // Should not call resetPasswordForEmail
    expect(mockResetPasswordForEmail).not.toHaveBeenCalled()
  })

  it('should handle form submission with Enter key', async () => {
    mockResetPasswordForEmail.mockResolvedValueOnce({ error: null })

    render(<ForgotPasswordPage />)

    const emailInput = screen.getByPlaceholderText(/enter your email/i)

    // Fill in email
    fireEvent.change(emailInput, { target: { value: 'test@example.com' } })

    // Submit with Enter key
    fireEvent.keyDown(emailInput, { key: 'Enter', code: 'Enter' })

    await waitFor(() => {
      expect(mockResetPasswordForEmail).toHaveBeenCalledWith('test@example.com', {
        redirectTo: 'http://localhost:3000/reset-password',
      })
    })
  })

  it('should have proper accessibility attributes', () => {
    render(<ForgotPasswordPage />)

    const emailInput = screen.getByPlaceholderText(/enter your email/i)

    expect(emailInput).toHaveAttribute('type', 'email')
    expect(emailInput).toHaveAttribute('autoComplete', 'email')

    // Check that label exists for accessibility
    expect(screen.getByText(/email address/i)).toBeInTheDocument()
  })

  it('should render success state correctly', async () => {
    mockResetPasswordForEmail.mockResolvedValueOnce({ error: null })

    render(<ForgotPasswordPage />)

    const emailInput = screen.getByPlaceholderText(/enter your email/i)
    const submitButton = screen.getByRole('button', { name: /send reset link/i })

    // Submit form
    fireEvent.change(emailInput, { target: { value: 'test@example.com' } })
    fireEvent.click(submitButton)

    // Wait for success state
    await waitFor(() => {
      expect(screen.getByRole('heading', { name: /check your email/i })).toBeInTheDocument()
    })

    // Check that form is no longer visible
    expect(screen.queryByPlaceholderText(/enter your email/i)).not.toBeInTheDocument()
    expect(screen.queryByRole('button', { name: /send reset link/i })).not.toBeInTheDocument()

    // Check success message and back link
    expect(
      screen.getByText(/we've sent a password reset link to your email address/i)
    ).toBeInTheDocument()
    expect(screen.getByRole('link', { name: /back to login/i })).toHaveAttribute('href', '/login')
  })

  it('should set correct redirect URL based on current origin', async () => {
    // Mock different origin
    Object.defineProperty(window, 'location', {
      value: {
        origin: 'https://dependablecalls.com',
      },
      writable: true,
    })

    mockResetPasswordForEmail.mockResolvedValueOnce({ error: null })

    render(<ForgotPasswordPage />)

    const emailInput = screen.getByPlaceholderText(/enter your email/i)
    const submitButton = screen.getByRole('button', { name: /send reset link/i })

    fireEvent.change(emailInput, { target: { value: 'test@example.com' } })
    fireEvent.click(submitButton)

    await waitFor(() => {
      expect(mockResetPasswordForEmail).toHaveBeenCalledWith('test@example.com', {
        redirectTo: 'https://dependablecalls.com/reset-password',
      })
    })

    // Reset location for other tests
    Object.defineProperty(window, 'location', {
      value: {
        origin: 'http://localhost:3000',
      },
      writable: true,
    })
  })

  it('should maintain email input value after validation error', async () => {
    render(<ForgotPasswordPage />)

    const emailInput = screen.getByPlaceholderText(/enter your email/i)
    const submitButton = screen.getByRole('button', { name: /send reset link/i })

    // Enter invalid email
    fireEvent.change(emailInput, { target: { value: 'invalid-email' } })
    fireEvent.click(submitButton)

    // Wait for validation error
    await waitFor(() => {
      expect(screen.getByText(/invalid email address/i)).toBeInTheDocument()
    })

    // Check that input value is preserved
    expect(emailInput).toHaveValue('invalid-email')
  })

  it('should show error message styling correctly', async () => {
    mockResetPasswordForEmail.mockResolvedValueOnce({ error: new Error('Test error') })

    render(<ForgotPasswordPage />)

    const emailInput = screen.getByPlaceholderText(/enter your email/i)
    const submitButton = screen.getByRole('button', { name: /send reset link/i })

    fireEvent.change(emailInput, { target: { value: 'test@example.com' } })
    fireEvent.click(submitButton)

    await waitFor(() => {
      const errorElement = screen.getByText('Test error')
      expect(errorElement).toBeInTheDocument()
      // Find the error container div that has the styling classes
      const errorContainer = errorElement.closest('div[class*="bg-red-50"]')
      expect(errorContainer).toHaveClass('rounded-md', 'bg-red-50', 'p-4')
    })
  })
})
</file>

<file path="tests/unit/pages/auth/LoginPage.test.tsx">
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import { screen, fireEvent, waitFor } from '@testing-library/react'
import { render } from '@/test/test-utils'
import LoginPage from '@/pages/auth/LoginPage'

// Mock the router navigate function
const mockNavigate = vi.fn()
vi.mock('react-router-dom', async () => {
  const actual = await vi.importActual('react-router-dom')
  return {
    ...actual,
    useNavigate: () => mockNavigate,
    Link: ({ to, children, ...props }: { to: string; children: React.ReactNode }) => (
      <a href={to} {...props}>
        {children}
      </a>
    ),
  }
})

// Mock the auth store
const mockSignIn = vi.fn()
vi.mock('@/store/authStore', () => ({
  useAuthStore: vi.fn(() => ({
    signIn: mockSignIn,
  })),
}))

describe('LoginPage', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  afterEach(() => {
    vi.restoreAllMocks()
  })

  it('should render login form with all required fields', () => {
    render(<LoginPage />)

    expect(screen.getByRole('heading', { name: /sign in to your account/i })).toBeInTheDocument()
    expect(screen.getByPlaceholderText(/email address/i)).toBeInTheDocument()
    expect(screen.getByPlaceholderText(/password/i)).toBeInTheDocument()
    expect(screen.getByRole('button', { name: /sign in/i })).toBeInTheDocument()
    expect(screen.getByRole('checkbox', { name: /remember me/i })).toBeInTheDocument()
  })

  it('should display navigation links', () => {
    render(<LoginPage />)

    expect(screen.getByRole('link', { name: /create a new account/i })).toHaveAttribute(
      'href',
      '/register'
    )
    expect(screen.getByRole('link', { name: /forgot your password/i })).toHaveAttribute(
      'href',
      '/forgot-password'
    )
  })

  it('should validate email field', async () => {
    render(<LoginPage />)

    const emailInput = screen.getByPlaceholderText(/email address/i)
    const passwordInput = screen.getByPlaceholderText(/password/i)
    const submitButton = screen.getByRole('button', { name: /sign in/i })

    // Test invalid email - need valid password to trigger email validation
    fireEvent.change(emailInput, { target: { value: 'invalid-email' } })
    fireEvent.change(passwordInput, { target: { value: 'validpassword' } })
    fireEvent.click(submitButton)

    await waitFor(() => {
      expect(screen.getByText(/invalid email address/i)).toBeInTheDocument()
    })
  })

  it('should validate password field', async () => {
    render(<LoginPage />)

    const emailInput = screen.getByPlaceholderText(/email address/i)
    const passwordInput = screen.getByPlaceholderText(/password/i)
    const submitButton = screen.getByRole('button', { name: /sign in/i })

    // Test short password - need valid email to trigger password validation
    fireEvent.change(emailInput, { target: { value: 'test@example.com' } })
    fireEvent.change(passwordInput, { target: { value: '12345' } })
    fireEvent.click(submitButton)

    await waitFor(() => {
      expect(screen.getByText(/password must be at least 6 characters/i)).toBeInTheDocument()
    })
  })

  it('should handle successful login', async () => {
    mockSignIn.mockResolvedValueOnce(undefined)

    render(<LoginPage />)

    const emailInput = screen.getByPlaceholderText(/email address/i)
    const passwordInput = screen.getByPlaceholderText(/password/i)
    const submitButton = screen.getByRole('button', { name: /sign in/i })

    // Fill in valid credentials
    fireEvent.change(emailInput, { target: { value: 'test@example.com' } })
    fireEvent.change(passwordInput, { target: { value: 'password123' } })
    fireEvent.click(submitButton)

    // Check loading state
    await waitFor(() => {
      expect(screen.getByText(/signing in.../i)).toBeInTheDocument()
    })

    // Check that signIn was called with correct arguments
    await waitFor(() => {
      expect(mockSignIn).toHaveBeenCalledWith('test@example.com', 'password123')
    })

    // Check navigation after successful login
    await waitFor(() => {
      expect(mockNavigate).toHaveBeenCalledWith('/app/dashboard')
    })
  })

  it('should handle login error with Error instance', async () => {
    const errorMessage = 'Invalid credentials'
    mockSignIn.mockRejectedValueOnce(new Error(errorMessage))

    render(<LoginPage />)

    const emailInput = screen.getByPlaceholderText(/email address/i)
    const passwordInput = screen.getByPlaceholderText(/password/i)
    const submitButton = screen.getByRole('button', { name: /sign in/i })

    // Fill in credentials
    fireEvent.change(emailInput, { target: { value: 'test@example.com' } })
    fireEvent.change(passwordInput, { target: { value: 'wrongpassword' } })
    fireEvent.click(submitButton)

    // Wait for error to appear
    await waitFor(() => {
      expect(screen.getByText(errorMessage)).toBeInTheDocument()
    })

    // Check that loading state is cleared
    expect(screen.getByRole('button', { name: /sign in/i })).toBeInTheDocument()
    expect(screen.queryByText(/signing in.../i)).not.toBeInTheDocument()
  })

  it('should handle login error with non-Error instance', async () => {
    mockSignIn.mockRejectedValueOnce('String error')

    render(<LoginPage />)

    const emailInput = screen.getByPlaceholderText(/email address/i)
    const passwordInput = screen.getByPlaceholderText(/password/i)
    const submitButton = screen.getByRole('button', { name: /sign in/i })

    // Fill in credentials
    fireEvent.change(emailInput, { target: { value: 'test@example.com' } })
    fireEvent.change(passwordInput, { target: { value: 'wrongpassword' } })
    fireEvent.click(submitButton)

    // Wait for default error message to appear
    await waitFor(() => {
      expect(screen.getByText(/invalid email or password/i)).toBeInTheDocument()
    })
  })

  it('should disable submit button while loading', async () => {
    // Mock a slow sign in to test loading state
    mockSignIn.mockImplementation(() => new Promise((resolve) => setTimeout(resolve, 1000)))

    render(<LoginPage />)

    const emailInput = screen.getByPlaceholderText(/email address/i)
    const passwordInput = screen.getByPlaceholderText(/password/i)
    const submitButton = screen.getByRole('button', { name: /sign in/i })

    // Fill in credentials and submit
    fireEvent.change(emailInput, { target: { value: 'test@example.com' } })
    fireEvent.change(passwordInput, { target: { value: 'password123' } })
    fireEvent.click(submitButton)

    // Check that button is disabled and shows loading text
    await waitFor(() => {
      const loadingButton = screen.getByRole('button', { name: /signing in.../i })
      expect(loadingButton).toBeDisabled()
    })
  })

  it('should clear error when form is resubmitted', async () => {
    // First submission fails
    mockSignIn.mockRejectedValueOnce(new Error('Network error'))

    render(<LoginPage />)

    const emailInput = screen.getByPlaceholderText(/email address/i)
    const passwordInput = screen.getByPlaceholderText(/password/i)
    const submitButton = screen.getByRole('button', { name: /sign in/i })

    // First submission
    fireEvent.change(emailInput, { target: { value: 'test@example.com' } })
    fireEvent.change(passwordInput, { target: { value: 'password123' } })
    fireEvent.click(submitButton)

    // Wait for error
    await waitFor(() => {
      expect(screen.getByText(/network error/i)).toBeInTheDocument()
    })

    // Second submission should succeed
    mockSignIn.mockResolvedValueOnce(undefined)
    fireEvent.click(submitButton)

    // Error should be cleared
    await waitFor(() => {
      expect(screen.queryByText(/network error/i)).not.toBeInTheDocument()
    })
  })

  it('should not submit form with missing fields', async () => {
    render(<LoginPage />)

    const submitButton = screen.getByRole('button', { name: /sign in/i })

    // Submit empty form
    fireEvent.click(submitButton)

    // Should show validation errors
    await waitFor(() => {
      expect(screen.getByText(/invalid email address/i)).toBeInTheDocument()
      expect(screen.getByText(/password must be at least 6 characters/i)).toBeInTheDocument()
    })

    // Should not call signIn
    expect(mockSignIn).not.toHaveBeenCalled()
  })

  it('should allow checking remember me checkbox', () => {
    render(<LoginPage />)

    const rememberMeCheckbox = screen.getByRole('checkbox', { name: /remember me/i })

    expect(rememberMeCheckbox).not.toBeChecked()

    fireEvent.click(rememberMeCheckbox)

    expect(rememberMeCheckbox).toBeChecked()
  })

  it('should handle form submission with Enter key', async () => {
    mockSignIn.mockResolvedValueOnce(undefined)

    render(<LoginPage />)

    const emailInput = screen.getByPlaceholderText(/email address/i)
    const passwordInput = screen.getByPlaceholderText(/password/i)

    // Fill in credentials
    fireEvent.change(emailInput, { target: { value: 'test@example.com' } })
    fireEvent.change(passwordInput, { target: { value: 'password123' } })

    // Submit with Enter key on password field
    fireEvent.keyDown(passwordInput, { key: 'Enter', code: 'Enter' })

    await waitFor(() => {
      expect(mockSignIn).toHaveBeenCalledWith('test@example.com', 'password123')
    })
  })

  it('should have proper accessibility attributes', () => {
    render(<LoginPage />)

    const emailInput = screen.getByPlaceholderText(/email address/i)
    const passwordInput = screen.getByPlaceholderText(/password/i)

    expect(emailInput).toHaveAttribute('type', 'email')
    expect(emailInput).toHaveAttribute('autoComplete', 'email')
    expect(passwordInput).toHaveAttribute('type', 'password')
    expect(passwordInput).toHaveAttribute('autoComplete', 'current-password')

    // Check for label association
    expect(screen.getByLabelText(/email address/i)).toBe(emailInput)
    expect(screen.getByLabelText(/password/i)).toBe(passwordInput)
  })
})
</file>

<file path="tests/unit/pages/auth/RegisterPage.test.tsx">
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import { screen, fireEvent, waitFor } from '@testing-library/react'
import { render } from '@/test/test-utils'
import RegisterPage from '@/pages/auth/RegisterPage'

// Mock the router navigate function
const mockNavigate = vi.fn()
vi.mock('react-router-dom', async () => {
  const actual = await vi.importActual('react-router-dom')
  return {
    ...actual,
    useNavigate: () => mockNavigate,
    Link: ({ to, children, ...props }: { to: string; children: React.ReactNode }) => (
      <a href={to} {...props}>
        {children}
      </a>
    ),
  }
})

// Mock the auth store
const mockSignUp = vi.fn()
vi.mock('@/store/authStore', () => ({
  useAuthStore: vi.fn(() => ({
    signUp: mockSignUp,
  })),
}))

describe('RegisterPage', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  afterEach(() => {
    vi.restoreAllMocks()
  })

  it('should render registration form with all required fields', () => {
    render(<RegisterPage />)

    expect(screen.getByRole('heading', { name: /create your account/i })).toBeInTheDocument()
    expect(screen.getByText(/i am a.../i)).toBeInTheDocument()
    expect(screen.getByRole('radio', { name: /supplier/i })).toBeInTheDocument()
    expect(screen.getByRole('radio', { name: /buyer/i })).toBeInTheDocument()
    expect(screen.getByLabelText(/email address/i)).toBeInTheDocument()
    expect(screen.getByLabelText(/^password$/i)).toBeInTheDocument()
    expect(screen.getByLabelText(/confirm password/i)).toBeInTheDocument()
    expect(screen.getByRole('checkbox')).toBeInTheDocument()
    expect(screen.getByRole('button', { name: /create account/i })).toBeInTheDocument()
  })

  it('should display navigation link to login', () => {
    render(<RegisterPage />)

    expect(screen.getByRole('link', { name: /sign in to existing account/i })).toHaveAttribute(
      'href',
      '/login'
    )
  })

  it('should have supplier selected by default', () => {
    render(<RegisterPage />)

    const supplierRadio = screen.getByRole('radio', { name: /supplier/i })
    const buyerRadio = screen.getByRole('radio', { name: /buyer/i })

    expect(supplierRadio).toBeChecked()
    expect(buyerRadio).not.toBeChecked()
  })

  it('should allow switching between user types', () => {
    render(<RegisterPage />)

    const supplierRadio = screen.getByRole('radio', { name: /supplier/i })
    const buyerRadio = screen.getByRole('radio', { name: /buyer/i })

    // Initially supplier should be selected
    expect(supplierRadio).toBeChecked()
    expect(buyerRadio).not.toBeChecked()

    // Click buyer radio
    fireEvent.click(buyerRadio)

    expect(buyerRadio).toBeChecked()
    expect(supplierRadio).not.toBeChecked()

    // Click supplier radio again
    fireEvent.click(supplierRadio)

    expect(supplierRadio).toBeChecked()
    expect(buyerRadio).not.toBeChecked()
  })

  it('should validate email field', async () => {
    render(<RegisterPage />)

    const emailInput = screen.getByLabelText(/email address/i)
    const submitButton = screen.getByRole('button', { name: /create account/i })

    // Test invalid email
    fireEvent.change(emailInput, { target: { value: 'invalid-email' } })
    fireEvent.click(submitButton)

    await waitFor(() => {
      expect(screen.getByText(/invalid email address/i)).toBeInTheDocument()
    })
  })

  it('should validate password length', async () => {
    render(<RegisterPage />)

    const passwordInput = screen.getByLabelText(/^password$/i)
    const submitButton = screen.getByRole('button', { name: /create account/i })

    // Test short password
    fireEvent.change(passwordInput, { target: { value: '1234567' } })
    fireEvent.click(submitButton)

    await waitFor(() => {
      expect(screen.getByText(/password must be at least 8 characters/i)).toBeInTheDocument()
    })
  })

  it('should validate password confirmation', async () => {
    render(<RegisterPage />)

    const passwordInput = screen.getByLabelText(/^password$/i)
    const confirmPasswordInput = screen.getByLabelText(/confirm password/i)
    const submitButton = screen.getByRole('button', { name: /create account/i })

    // Enter different passwords
    fireEvent.change(passwordInput, { target: { value: 'password123' } })
    fireEvent.change(confirmPasswordInput, { target: { value: 'different123' } })
    fireEvent.click(submitButton)

    await waitFor(() => {
      expect(screen.getByText(/passwords don't match/i)).toBeInTheDocument()
    })
  })

  it('should validate terms acceptance', async () => {
    render(<RegisterPage />)

    const emailInput = screen.getByLabelText(/email address/i)
    const passwordInput = screen.getByLabelText(/^password$/i)
    const confirmPasswordInput = screen.getByLabelText(/confirm password/i)
    const submitButton = screen.getByRole('button', { name: /create account/i })

    // Fill valid data but don't accept terms
    fireEvent.change(emailInput, { target: { value: 'test@example.com' } })
    fireEvent.change(passwordInput, { target: { value: 'password123' } })
    fireEvent.change(confirmPasswordInput, { target: { value: 'password123' } })
    fireEvent.click(submitButton)

    await waitFor(() => {
      expect(screen.getByText(/you must accept the terms and conditions/i)).toBeInTheDocument()
    })
  })

  it('should handle successful registration', async () => {
    mockSignUp.mockResolvedValueOnce(undefined)

    render(<RegisterPage />)

    const emailInput = screen.getByLabelText(/email address/i)
    const passwordInput = screen.getByLabelText(/^password$/i)
    const confirmPasswordInput = screen.getByLabelText(/confirm password/i)
    const termsCheckbox = screen.getByRole('checkbox')
    const submitButton = screen.getByRole('button', { name: /create account/i })

    // Fill in valid data
    fireEvent.change(emailInput, { target: { value: 'test@example.com' } })
    fireEvent.change(passwordInput, { target: { value: 'password123' } })
    fireEvent.change(confirmPasswordInput, { target: { value: 'password123' } })
    fireEvent.click(termsCheckbox)
    fireEvent.click(submitButton)

    // Check loading state
    await waitFor(() => {
      expect(screen.getByText(/creating account.../i)).toBeInTheDocument()
    })

    // Check that signUp was called with correct arguments (default supplier)
    await waitFor(() => {
      expect(mockSignUp).toHaveBeenCalledWith('test@example.com', 'password123', 'supplier')
    })

    // Check navigation after successful registration
    await waitFor(() => {
      expect(mockNavigate).toHaveBeenCalledWith('/app/dashboard')
    })
  })

  it('should handle registration with buyer user type', async () => {
    mockSignUp.mockResolvedValueOnce(undefined)

    render(<RegisterPage />)

    const buyerRadio = screen.getByRole('radio', { name: /buyer/i })
    const emailInput = screen.getByLabelText(/email address/i)
    const passwordInput = screen.getByLabelText(/^password$/i)
    const confirmPasswordInput = screen.getByLabelText(/confirm password/i)
    const termsCheckbox = screen.getByRole('checkbox')
    const submitButton = screen.getByRole('button', { name: /create account/i })

    // Select buyer user type
    fireEvent.click(buyerRadio)

    // Fill in valid data
    fireEvent.change(emailInput, { target: { value: 'buyer@example.com' } })
    fireEvent.change(passwordInput, { target: { value: 'password123' } })
    fireEvent.change(confirmPasswordInput, { target: { value: 'password123' } })
    fireEvent.click(termsCheckbox)
    fireEvent.click(submitButton)

    // Check that signUp was called with buyer type
    await waitFor(() => {
      expect(mockSignUp).toHaveBeenCalledWith('buyer@example.com', 'password123', 'buyer')
    })
  })

  it('should handle registration error with Error instance', async () => {
    const errorMessage = 'Email already exists'
    mockSignUp.mockRejectedValueOnce(new Error(errorMessage))

    render(<RegisterPage />)

    const emailInput = screen.getByLabelText(/email address/i)
    const passwordInput = screen.getByLabelText(/^password$/i)
    const confirmPasswordInput = screen.getByLabelText(/confirm password/i)
    const termsCheckbox = screen.getByRole('checkbox')
    const submitButton = screen.getByRole('button', { name: /create account/i })

    // Fill in data
    fireEvent.change(emailInput, { target: { value: 'test@example.com' } })
    fireEvent.change(passwordInput, { target: { value: 'password123' } })
    fireEvent.change(confirmPasswordInput, { target: { value: 'password123' } })
    fireEvent.click(termsCheckbox)
    fireEvent.click(submitButton)

    // Wait for error to appear
    await waitFor(() => {
      expect(screen.getByText(errorMessage)).toBeInTheDocument()
    })

    // Check that loading state is cleared
    expect(screen.getByRole('button', { name: /create account/i })).toBeInTheDocument()
    expect(screen.queryByText(/creating account.../i)).not.toBeInTheDocument()
  })

  it('should handle registration error with non-Error instance', async () => {
    mockSignUp.mockRejectedValueOnce('String error')

    render(<RegisterPage />)

    const emailInput = screen.getByLabelText(/email address/i)
    const passwordInput = screen.getByLabelText(/^password$/i)
    const confirmPasswordInput = screen.getByLabelText(/confirm password/i)
    const termsCheckbox = screen.getByRole('checkbox')
    const submitButton = screen.getByRole('button', { name: /create account/i })

    // Fill in data
    fireEvent.change(emailInput, { target: { value: 'test@example.com' } })
    fireEvent.change(passwordInput, { target: { value: 'password123' } })
    fireEvent.change(confirmPasswordInput, { target: { value: 'password123' } })
    fireEvent.click(termsCheckbox)
    fireEvent.click(submitButton)

    // Wait for default error message to appear
    await waitFor(() => {
      expect(screen.getByText(/failed to create account/i)).toBeInTheDocument()
    })
  })

  it('should disable submit button while loading', async () => {
    // Mock a slow sign up to test loading state
    mockSignUp.mockImplementation(() => new Promise((resolve) => setTimeout(resolve, 1000)))

    render(<RegisterPage />)

    const emailInput = screen.getByLabelText(/email address/i)
    const passwordInput = screen.getByLabelText(/^password$/i)
    const confirmPasswordInput = screen.getByLabelText(/confirm password/i)
    const termsCheckbox = screen.getByRole('checkbox')
    const submitButton = screen.getByRole('button', { name: /create account/i })

    // Fill in data and submit
    fireEvent.change(emailInput, { target: { value: 'test@example.com' } })
    fireEvent.change(passwordInput, { target: { value: 'password123' } })
    fireEvent.change(confirmPasswordInput, { target: { value: 'password123' } })
    fireEvent.click(termsCheckbox)
    fireEvent.click(submitButton)

    // Check that button is disabled and shows loading text
    await waitFor(() => {
      const loadingButton = screen.getByRole('button', { name: /creating account.../i })
      expect(loadingButton).toBeDisabled()
    })
  })

  it('should clear error when form is resubmitted', async () => {
    // First submission fails
    mockSignUp.mockRejectedValueOnce(new Error('Network error'))

    render(<RegisterPage />)

    const emailInput = screen.getByLabelText(/email address/i)
    const passwordInput = screen.getByLabelText(/^password$/i)
    const confirmPasswordInput = screen.getByLabelText(/confirm password/i)
    const termsCheckbox = screen.getByRole('checkbox')
    const submitButton = screen.getByRole('button', { name: /create account/i })

    // First submission
    fireEvent.change(emailInput, { target: { value: 'test@example.com' } })
    fireEvent.change(passwordInput, { target: { value: 'password123' } })
    fireEvent.change(confirmPasswordInput, { target: { value: 'password123' } })
    fireEvent.click(termsCheckbox)
    fireEvent.click(submitButton)

    // Wait for error
    await waitFor(() => {
      expect(screen.getByText(/network error/i)).toBeInTheDocument()
    })

    // Second submission should succeed
    mockSignUp.mockResolvedValueOnce(undefined)
    fireEvent.click(submitButton)

    // Error should be cleared
    await waitFor(() => {
      expect(screen.queryByText(/network error/i)).not.toBeInTheDocument()
    })
  })

  it('should display terms and privacy policy links', () => {
    render(<RegisterPage />)

    expect(screen.getByRole('link', { name: /terms and conditions/i })).toHaveAttribute(
      'href',
      '/terms'
    )
    expect(screen.getByRole('link', { name: /privacy policy/i })).toHaveAttribute(
      'href',
      '/privacy'
    )
  })

  it('should have proper accessibility attributes', () => {
    render(<RegisterPage />)

    const emailInput = screen.getByLabelText(/email address/i)
    const passwordInput = screen.getByLabelText(/^password$/i)
    const confirmPasswordInput = screen.getByLabelText(/confirm password/i)

    expect(emailInput).toHaveAttribute('type', 'email')
    expect(emailInput).toHaveAttribute('autoComplete', 'email')
    expect(passwordInput).toHaveAttribute('type', 'password')
    expect(passwordInput).toHaveAttribute('autoComplete', 'new-password')
    expect(confirmPasswordInput).toHaveAttribute('type', 'password')
    expect(confirmPasswordInput).toHaveAttribute('autoComplete', 'new-password')
  })

  it('should show user type descriptions', () => {
    render(<RegisterPage />)

    expect(screen.getByText(/i have traffic to send/i)).toBeInTheDocument()
    expect(screen.getByText(/i need quality calls/i)).toBeInTheDocument()
  })

  it('should highlight selected user type visually', () => {
    render(<RegisterPage />)

    const supplierRadio = screen.getByRole('radio', { name: /supplier/i })
    const buyerRadio = screen.getByRole('radio', { name: /buyer/i })

    // Initially supplier should be highlighted
    expect(supplierRadio).toBeChecked()

    // Click buyer to switch
    fireEvent.click(buyerRadio)
    expect(buyerRadio).toBeChecked()
    expect(supplierRadio).not.toBeChecked()
  })

  it('should not submit form with missing required fields', async () => {
    render(<RegisterPage />)

    const submitButton = screen.getByRole('button', { name: /create account/i })

    // Submit empty form
    fireEvent.click(submitButton)

    // Should show validation errors
    await waitFor(() => {
      expect(screen.getByText(/invalid email address/i)).toBeInTheDocument()
      expect(screen.getByText(/password must be at least 8 characters/i)).toBeInTheDocument()
      expect(screen.getByText(/you must accept the terms and conditions/i)).toBeInTheDocument()
    })

    // Should not call signUp
    expect(mockSignUp).not.toHaveBeenCalled()
  })
})
</file>

<file path="tests/unit/CLAUDE.md">
# Unit Test Patterns

# Test File Organization
```
unit/
├── components/     # React component tests
├── hooks/         # Custom hook tests
├── stores/        # Zustand store tests
├── utils/         # Utility function tests
├── services/      # Service layer tests
└── lib/           # Library function tests
```

# Component Testing Template
```tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { expect, describe, it, vi } from 'vitest';
import { ComponentName } from './ComponentName';

describe('ComponentName', () => {
  const defaultProps = {
    title: 'Test Title',
    onAction: vi.fn(),
  };

  it('should render with correct title', () => {
    render(<ComponentName {...defaultProps} />);
    expect(screen.getByText('Test Title')).toBeInTheDocument();
  });

  it('should call onAction when button clicked', () => {
    render(<ComponentName {...defaultProps} />);
    fireEvent.click(screen.getByRole('button'));
    expect(defaultProps.onAction).toHaveBeenCalledTimes(1);
  });
});
```

# Hook Testing Pattern
```tsx
import { renderHook, act } from '@testing-library/react';
import { expect, describe, it } from 'vitest';
import { useCustomHook } from './useCustomHook';

describe('useCustomHook', () => {
  it('should return initial state', () => {
    const { result } = renderHook(() => useCustomHook());
    
    expect(result.current.data).toBe(null);
    expect(result.current.loading).toBe(false);
  });

  it('should handle state updates', () => {
    const { result } = renderHook(() => useCustomHook());
    
    act(() => {
      result.current.updateData('new data');
    });
    
    expect(result.current.data).toBe('new data');
  });
});
```

# Store Testing Pattern
```tsx
import { describe, it, beforeEach, expect } from 'vitest';
import { useAuthStore } from '@/store/authStore';

describe('AuthStore', () => {
  beforeEach(() => {
    // Reset store before each test
    useAuthStore.getState().reset();
  });

  it('should have initial state', () => {
    const state = useAuthStore.getState();
    
    expect(state.user).toBe(null);
    expect(state.isAuthenticated).toBe(false);
  });

  it('should login user correctly', async () => {
    const { login } = useAuthStore.getState();
    
    await login('test@example.com', 'password');
    
    const state = useAuthStore.getState();
    expect(state.isAuthenticated).toBe(true);
    expect(state.user?.email).toBe('test@example.com');
  });
});
```

# Utility Function Testing
```tsx
import { describe, it, expect } from 'vitest';
import { formatCurrency, validateEmail } from '@/lib/utils';

describe('formatCurrency', () => {
  it('should format USD correctly', () => {
    expect(formatCurrency(1234.56)).toBe('$1,234.56');
  });

  it('should handle zero amount', () => {
    expect(formatCurrency(0)).toBe('$0.00');
  });
});

describe('validateEmail', () => {
  it('should validate correct email', () => {
    expect(validateEmail('test@example.com')).toBe(true);
  });

  it('should reject invalid email', () => {
    expect(validateEmail('invalid-email')).toBe(false);
  });
});
```

# Async Function Testing
```tsx
import { describe, it, expect, vi } from 'vitest';
import { fetchUser } from '@/lib/api';

// Mock external dependencies
vi.mock('@/lib/supabase', () => ({
  supabase: {
    from: vi.fn(() => ({
      select: vi.fn(() => ({
        eq: vi.fn(() => ({
          single: vi.fn(() => Promise.resolve({
            data: { id: '1', email: 'test@example.com' },
            error: null,
          })),
        })),
      })),
    })),
  },
}));

describe('fetchUser', () => {
  it('should fetch user successfully', async () => {
    const user = await fetchUser('1');
    
    expect(user).toEqual({
      id: '1',
      email: 'test@example.com',
    });
  });
});
```

# Form Validation Testing
```tsx
import { describe, it, expect } from 'vitest';
import { loginSchema } from '@/types/auth';

describe('loginSchema', () => {
  it('should validate correct login data', () => {
    const validData = {
      email: 'test@example.com',
      password: 'password123',
    };
    
    const result = loginSchema.safeParse(validData);
    expect(result.success).toBe(true);
  });

  it('should reject invalid email', () => {
    const invalidData = {
      email: 'invalid-email',
      password: 'password123',
    };
    
    const result = loginSchema.safeParse(invalidData);
    expect(result.success).toBe(false);
    expect(result.error?.issues[0].path).toEqual(['email']);
  });
});
```

# Error Handling Tests
```tsx
describe('error handling', () => {
  it('should handle API errors gracefully', async () => {
    // Mock API to throw error
    vi.mocked(apiCall).mockRejectedValue(new Error('API Error'));
    
    const { result } = renderHook(() => useApiHook());
    
    await act(async () => {
      await result.current.fetchData();
    });
    
    expect(result.current.error).toBe('API Error');
    expect(result.current.loading).toBe(false);
  });
});
```

# Test Setup & Teardown
```tsx
import { beforeEach, afterEach } from 'vitest';

describe('Component with cleanup', () => {
  beforeEach(() => {
    // Setup before each test
    vi.clearAllMocks();
  });

  afterEach(() => {
    // Cleanup after each test
    vi.resetAllMocks();
  });
});
```

# Mocking External Dependencies
```tsx
// Mock Supabase
vi.mock('@/lib/supabase', () => ({
  supabase: {
    auth: {
      signIn: vi.fn(),
      signOut: vi.fn(),
      getUser: vi.fn(),
    },
    from: vi.fn(),
  },
}));

// Mock React Router
vi.mock('react-router-dom', () => ({
  useNavigate: () => vi.fn(),
  useLocation: () => ({ pathname: '/dashboard' }),
}));

// Mock environment variables
vi.mock('@/lib/env', () => ({
  env: {
    SUPABASE_URL: 'http://localhost:54321',
    STRIPE_PUBLIC_KEY: 'pk_test_123',
  },
}));
```

# DCE-Specific Unit Tests
- Campaign validation logic
- Call duration calculations
- Commission rate computations
- Fraud detection algorithms
- Real-time data transformations
- User permission checks

# Accessibility Testing
```tsx
import { axe, toHaveNoViolations } from 'jest-axe';

expect.extend(toHaveNoViolations);

describe('accessibility', () => {
  it('should not have accessibility violations', async () => {
    const { container } = render(<Component />);
    const results = await axe(container);
    expect(results).toHaveNoViolations();
  });
});
```

# Performance Testing
```tsx
import { performance } from 'perf_hooks';

describe('performance', () => {
  it('should render within acceptable time', () => {
    const start = performance.now();
    render(<ExpensiveComponent />);
    const end = performance.now();
    
    expect(end - start).toBeLessThan(100); // 100ms threshold
  });
});
```

# CRITICAL RULES
- NO regex in test code
- NO any types in assertions
- ALWAYS mock external dependencies
- ALWAYS test error conditions
- ALWAYS clean up after tests
- TEST accessibility compliance
- TEST performance requirements
- USE proper TypeScript typing
- WRITE descriptive test names
- COVER edge cases and error paths
</file>

<file path="tests/CLAUDE.md">
# Test Organization & Strategy

# Test Structure
```
tests/
├── unit/           # Component and utility tests
├── integration/    # API and workflow tests
├── e2e/           # End-to-end user flows
├── performance/   # Load and stress tests
└── fixtures/      # Shared test data
```

# Testing Tools
- Vitest: Unit and integration testing
- Testing Library: React component testing
- Playwright: End-to-end testing
- jsdom: DOM environment for Vitest

# Test Commands
- `npm test` - Run unit tests
- `npm run test:ci` - CI tests with coverage
- `npm run test:ui` - Visual test interface
- `npm run test:e2e` - Playwright E2E tests
- `npm run test:e2e:ui` - Playwright UI mode

# Coverage Requirements
- **90% minimum** code coverage
- Cover all critical business logic
- Test error conditions and edge cases
- Verify real-time functionality
- Test role-based access control

# Test File Naming
- Unit: `*.test.tsx` or `*.test.ts`
- Integration: `*.integration.test.ts`
- E2E: `*.spec.ts`
- Fixtures: descriptive names in `/fixtures/`

# Test Categories

## Unit Tests (`/unit/`)
- Component rendering and interaction
- Utility functions and helpers
- Store actions and state changes
- Custom hooks behavior
- Form validation logic

## Integration Tests (`/integration/`)
- API endpoint interactions
- Database operations
- Webhook processing
- Third-party service mocks
- Multi-component workflows

## E2E Tests (`/e2e/`)
- Complete user journeys
- Authentication flows
- Campaign creation/management
- Call tracking workflows
- Payment processing
- Cross-browser compatibility

## Performance Tests (`/performance/`)
- Real-time connection handling
- High-volume call processing
- Database query optimization
- Frontend rendering performance

# Test Data Management
- Use fixtures for consistent test data
- Mock external APIs in unit/integration tests
- Use test database for E2E tests
- Clean up test data after each test run

# DCE-Specific Test Scenarios
- Supplier registration and verification
- Buyer campaign setup and management
- Call routing and tracking accuracy
- Fraud detection algorithms
- Payment processing and payouts
- Real-time dashboard updates

# CI/CD Integration
- All tests must pass before deployment
- Generate coverage reports
- Run E2E tests in multiple browsers
- Performance regression detection
- Automated visual regression testing

# Test Environment Setup
- Separate test database instance
- Mock Stripe webhooks
- Test Supabase configuration
- Environment variable management
- Seed data for consistent testing

# Accessibility Testing
- Screen reader compatibility
- Keyboard navigation
- Color contrast validation
- ARIA label verification
- Focus management testing

# CRITICAL RULES
- NO regex in test code
- NO any types in test assertions
- ALWAYS clean up after tests
- ALWAYS test error conditions
- ALWAYS mock external dependencies
- MINIMUM 90% code coverage required
- TEST real-time features thoroughly
- VERIFY security and authorization
</file>

<file path=".prettierignore">
# Dependencies
node_modules/

# Build outputs
dist/
build/
coverage/
.next/
out/

# Test outputs
playwright-report/
test-results/

# Logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Environment files
.env
.env.local
.env.production.local
.env.development.local
.env.test.local

# Lock files
package-lock.json
yarn.lock
pnpm-lock.yaml

# Cache
.eslintcache
.cache/

# Misc
.DS_Store
.vscode/
.idea/

# Generated files
*.generated.*
tsconfig.tsbuildinfo
</file>

<file path=".prettierrc.json">
{
  "semi": false,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 100,
  "tabWidth": 2,
  "useTabs": false,
  "arrowParens": "always",
  "endOfLine": "lf",
  "bracketSpacing": true,
  "jsxBracketSameLine": false,
  "jsxSingleQuote": false,
  "quoteProps": "as-needed"
}
</file>

<file path="BACKEND_SETUP.md">
# DCE Platform Backend Setup Complete

## ✅ Database Schema Implementation

The complete Supabase database schema has been implemented according to the technical architecture specifications. The following migrations have been created:

### Migration Files Created:

1. **001_initial_schema.sql** - Core database schema
   - Users, suppliers, buyers, admins tables
   - Campaigns and buyer_campaigns tables
   - Calls and tracking_numbers tables
   - Financial tables (payouts, invoices, invoice_line_items)
   - Quality and compliance tables (call_quality_scores, disputes)
   - Analytics tables (campaign_stats, buyer_campaign_stats)
   - Audit logs table for compliance
   - All required ENUM types and constraints

2. **002_security_policies.sql** - Row Level Security
   - Comprehensive RLS policies for all tables
   - Role-based access control (suppliers, buyers, admins)
   - Helper functions for role checking
   - Data isolation and privacy protection

3. **003_functions.sql** - Business Logic Functions
   - Balance calculation functions (supplier/buyer balances)
   - Quality scoring and fraud detection
   - Campaign matching algorithms
   - Billing calculation functions
   - Analytics and reporting functions
   - Validation and utility functions

4. **004_triggers.sql** - Automated Processes
   - Audit logging triggers for all sensitive operations
   - Automatic call completion processing
   - Balance update triggers
   - Data validation triggers
   - Real-time notification triggers
   - Stats aggregation triggers

5. **005_indexes.sql** - Performance Optimization
   - 80+ optimized indexes for all query patterns
   - Composite indexes for complex queries
   - Partial indexes for active records
   - JSONB indexes for metadata queries
   - Full-text search indexes

### Configuration Files:

- **config.toml** - Supabase local development configuration
- **seed.sql** - Comprehensive test data including all user types
- **README.md** - Complete setup and deployment guide
- **.env.local** - Local development environment variables

## 🔐 Security Features Implemented:

- Row Level Security (RLS) enabled on all tables
- Role-based access control with proper data isolation
- Comprehensive audit logging for compliance
- Input validation at database level
- Fraud detection and quality scoring systems

## 🚀 Performance Features:

- Comprehensive indexing strategy for all query patterns
- Real-time data aggregation and statistics
- Optimized queries with proper joins and filters
- Connection pooling and query optimization

## 📊 Business Logic Features:

- Automated balance calculations
- Quality scoring algorithms (1-100 scale)
- Fraud detection with pattern analysis
- Real-time campaign matching
- Automated billing and payout calculations

## 🛠️ Development Environment:

- Local Supabase configuration ready
- Test data for all user types and scenarios
- Environment variables properly configured
- Documentation for setup and deployment

## 📋 Next Steps:

1. Start local Supabase instance: `npx supabase start`
2. Apply migrations: `npx supabase db reset`
3. Generate TypeScript types: `npx supabase gen types typescript --local > src/types/database.ts`
4. Test API endpoints and real-time subscriptions

The backend is now fully ready for frontend integration and supports all features required for the DCE pay-per-call platform including real-time call tracking, fraud prevention, automated billing, and comprehensive analytics.

## Files Location:

All Supabase files are located in the `supabase/` directory:

- `/supabase/migrations/` - Database migration files
- `/supabase/config.toml` - Supabase configuration
- `/supabase/seed.sql` - Development test data
- `/supabase/README.md` - Detailed setup guide
</file>

<file path="CLAUDE.md">
# Tech Stack
- Vite 7.0, React 19.1, TypeScript 5.8
- Tailwind CSS 4.1, Headless UI 2.2, Heroicons 2.2
- Supabase 2.52 (PostgreSQL + Auth + Realtime)
- Zustand 5.0, React Query 5.83, React Hook Form 7.60
- Stripe 18.3 (payments), Axios 1.10 (HTTP)
- Vitest 3.2, Playwright 1.54, Testing Library

# Commands
- `npm run dev` - Start dev server (localhost:5173)
- `npm run build` - Production build
- `npm run lint` - ESLint + TypeScript check
- `npm run preview` - Preview production build
- `npm test` - Run Vitest tests (if configured)

# Code Rules
- NO regex - use validator.js or zod
- NO any types - use unknown or proper types
- NO deprecated ESLint configs - use flat config only
- ALWAYS fix TS/ESLint errors immediately
- ALWAYS commit every 30 minutes

# Project Structure
- `/src/components/` - Reusable React components
- `/src/pages/` - Route-based page components
- `/src/lib/` - Utility functions and shared logic
- `/src/store/` - Zustand state management
- `/src/integrations/` - External service integrations
- `/src/types/` - TypeScript definitions
- `/src/hooks/` - Custom React hooks

# Testing
- Unit: Vitest + Testing Library
- E2E: Playwright for critical flows
- Coverage: 90% minimum requirement
- Run before commit: `npm run lint && npm test`

# DCE Platform Context
Pay-per-call network with suppliers (traffic) and buyers (advertisers).
Focus: Real-time call tracking, fraud prevention, billing automation.

## 🚨 Critical: Multi-Agent Orchestration via tmux

When being managed via tmux, remember that **tmux send-keys requires explicit Enter**:

```bash
# ❌ WRONG - Prompt appears but Claude never receives it:
tmux send-keys -t dce-impl:1 "You are the Frontend Lead..."

# ✅ CORRECT - Prompt is typed AND submitted to Claude:
tmux send-keys -t dce-impl:1 "You are the Frontend Lead..." Enter
```

If you appear stuck at the welcome screen with a typed prompt, the orchestrator forgot to send Enter. See `/Users/davidleathers/projects/dce-website-spec/ORCHESTRATION_BEST_PRACTICES.md` for full details.
</file>

<file path="eslint.config.js">
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import { globalIgnores } from 'eslint/config'

export default tseslint.config([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs['recommended-latest'],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
  },
])
</file>

<file path="index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React + TS</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="netlify.toml">
[build]
  publish = "dist"
  command = "npm run build"
  
[build.environment]
  NODE_VERSION = "22"
  NPM_FLAGS = "--prefix=/dev/null"

# Production settings
[context.production]
  command = "npm run build"
  
[context.production.environment]
  NODE_ENV = "production"

# Staging/develop branch settings
[context.develop]
  command = "npm run build"
  
[context.develop.environment]
  NODE_ENV = "staging"

# Branch deploy previews
[context.branch-deploy]
  command = "npm run build"

# Security headers
[[headers]]
  for = "/*"
  [headers.values]
    X-Frame-Options = "DENY"
    X-Content-Type-Options = "nosniff"
    X-XSS-Protection = "1; mode=block"
    Referrer-Policy = "strict-origin-when-cross-origin"
    Permissions-Policy = "camera=(), microphone=(), geolocation=(), payment=()"
    Strict-Transport-Security = "max-age=31536000; includeSubDomains; preload"
    Content-Security-Policy = """
      default-src 'self';
      script-src 'self' 'unsafe-inline' https://js.stripe.com https://cdn.jsdelivr.net;
      style-src 'self' 'unsafe-inline' https://fonts.googleapis.com;
      font-src 'self' https://fonts.gstatic.com;
      img-src 'self' data: https: blob:;
      connect-src 'self' https://*.supabase.co wss://*.supabase.co https://api.stripe.com https://*.sentry.io;
      frame-src https://js.stripe.com;
      object-src 'none';
      base-uri 'self';
      form-action 'self';
      upgrade-insecure-requests;
    """

# Cache static assets
[[headers]]
  for = "/assets/*"
  [headers.values]
    Cache-Control = "public, max-age=31536000, immutable"

[[headers]]
  for = "*.js"
  [headers.values]
    Cache-Control = "public, max-age=31536000, immutable"

[[headers]]
  for = "*.css"
  [headers.values]
    Cache-Control = "public, max-age=31536000, immutable"

[[headers]]
  for = "*.woff2"
  [headers.values]
    Cache-Control = "public, max-age=31536000, immutable"

# SPA routing - serve index.html for all routes
[[redirects]]
  from = "/*"
  to = "/index.html"
  status = 200
  conditions = {Role = ["admin", "user"], Country = ["US", "CA"]}

# Health check endpoint
[[redirects]]
  from = "/health"
  to = "/.netlify/functions/health"
  status = 200

# API redirects to edge functions
[[redirects]]
  from = "/api/*"
  to = "/.netlify/functions/:splat"
  status = 200

# Force HTTPS
[[redirects]]
  from = "http://dependablecalls.com/*"
  to = "https://dependablecalls.com/:splat"
  status = 301
  force = true

[[redirects]]
  from = "http://www.dependablecalls.com/*"
  to = "https://dependablecalls.com/:splat"
  status = 301
  force = true

# Redirect www to non-www
[[redirects]]
  from = "https://www.dependablecalls.com/*"
  to = "https://dependablecalls.com/:splat"
  status = 301
  force = true

# Edge Functions
[[edge_functions]]
  function = "auth-middleware"
  path = "/dashboard/*"

[[edge_functions]]
  function = "rate-limiter"
  path = "/api/*"

# Form handling
[plugins]
  [[plugins.inputs]]
    command = "npm run build"
</file>

<file path="playwright.config.ts">
import { defineConfig, devices } from '@playwright/test'

/**
 * @see https://playwright.dev/docs/test-configuration
 */
export default defineConfig({
  testDir: './tests/e2e',
  /* Run tests in files in parallel */
  fullyParallel: true,
  /* Fail the build on CI if you accidentally left test.only in the source code. */
  forbidOnly: !!process.env.CI,
  /* Retry on CI only */
  retries: process.env.CI ? 2 : 0,
  /* Opt out of parallel tests on CI. */
  workers: process.env.CI ? 1 : undefined,
  /* Reporter to use. See https://playwright.dev/docs/test-reporters */
  reporter: 'html',
  /* Shared settings for all the projects below. See https://playwright.dev/docs/api/class-testoptions. */
  use: {
    /* Base URL to use in actions like `await page.goto('/')`. */
    baseURL: 'http://localhost:5173',

    /* Collect trace when retrying the failed test. See https://playwright.dev/docs/trace-viewer */
    trace: 'on-first-retry',
  },

  /* Configure projects for major browsers */
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },

    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },

    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    },

    /* Test against mobile viewports. */
    {
      name: 'Mobile Chrome',
      use: { ...devices['Pixel 5'] },
    },
    {
      name: 'Mobile Safari',
      use: { ...devices['iPhone 12'] },
    },

    /* Test against branded browsers. */
    // {
    //   name: 'Microsoft Edge',
    //   use: { ...devices['Desktop Edge'], channel: 'msedge' },
    // },
    // {
    //   name: 'Google Chrome',
    //   use: { ...devices['Desktop Chrome'], channel: 'chrome' },
    // },
  ],

  /* Run your local dev server before starting the tests */
  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:5173',
    reuseExistingServer: !process.env.CI,
  },
})
</file>

<file path="tailwind.config.js">
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        primary: {
          50: '#eff6ff',
          100: '#dbeafe',
          200: '#bfdbfe',
          300: '#93bbfd',
          400: '#60a5fa',
          500: '#3b82f6',
          600: '#2563eb',
          700: '#1d4ed8',
          800: '#1e40af',
          900: '#1e3a8a',
        },
      },
    },
  },
  plugins: [],
}
</file>

<file path="tsconfig.app.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}
</file>

<file path="tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path=".husky/pre-commit">
# Run lint-staged for automatic formatting and linting
npx lint-staged

# Run type checking
echo "🔍 Running type check..."
npm run type-check || {
  echo "❌ Type check failed. Please fix TypeScript errors before committing."
  exit 1
}

echo "✅ Pre-commit checks passed!"
</file>

<file path="src/components/layout/AppLayout.tsx">
import { Outlet, Link, useLocation, useNavigate } from 'react-router-dom'
import { useState } from 'react'
import { useAuthStore } from '../../store/authStore'
import {
  HomeIcon,
  ChartBarIcon,
  PhoneIcon,
  DocumentTextIcon,
  CreditCardIcon,
  CogIcon,
  UserCircleIcon,
  Bars3Icon,
  XMarkIcon,
} from '@heroicons/react/24/outline'

const navigation = [
  { name: 'Dashboard', href: '/app/dashboard', icon: HomeIcon },
  { name: 'Campaigns', href: '/app/campaigns', icon: ChartBarIcon },
  { name: 'Calls', href: '/app/calls', icon: PhoneIcon },
  { name: 'Reports', href: '/app/reports', icon: DocumentTextIcon },
  { name: 'Billing', href: '/app/billing', icon: CreditCardIcon },
  { name: 'Settings', href: '/app/settings', icon: CogIcon },
]

function classNames(...classes: string[]) {
  return classes.filter(Boolean).join(' ')
}

export default function AppLayout() {
  const location = useLocation()
  const navigate = useNavigate()
  const { user, userType, signOut } = useAuthStore()
  const [sidebarOpen, setSidebarOpen] = useState(false)
  const [userMenuOpen, setUserMenuOpen] = useState(false)

  const handleSignOut = async () => {
    await signOut()
    navigate('/')
  }

  return (
    <div className="min-h-screen bg-gray-100">
      {/* Mobile sidebar */}
      <div className={classNames(
        'fixed inset-0 flex z-40 lg:hidden',
        sidebarOpen ? '' : 'pointer-events-none'
      )}>
        <div
          className={classNames(
            'fixed inset-0 bg-gray-600 bg-opacity-75 transition-opacity ease-linear duration-300',
            sidebarOpen ? 'opacity-100' : 'opacity-0'
          )}
          onClick={() => setSidebarOpen(false)}
        />
        
        <div className={classNames(
          'relative flex-1 flex flex-col max-w-xs w-full pt-5 pb-4 bg-white transition ease-in-out duration-300 transform',
          sidebarOpen ? 'translate-x-0' : '-translate-x-full'
        )}>
          <div className="absolute top-0 right-0 -mr-12 pt-2">
            <button
              className="ml-1 flex items-center justify-center h-10 w-10 rounded-full focus:outline-none focus:ring-2 focus:ring-inset focus:ring-white"
              onClick={() => setSidebarOpen(false)}
            >
              <XMarkIcon className="h-6 w-6 text-white" />
            </button>
          </div>
          
          <div className="flex-shrink-0 flex items-center px-4">
            <span className="text-2xl font-bold text-primary-600">DependableCalls</span>
          </div>
          
          <div className="mt-5 flex-1 h-0 overflow-y-auto">
            <nav className="px-2 space-y-1">
              {navigation.map((item) => (
                <Link
                  key={item.name}
                  to={item.href}
                  className={classNames(
                    location.pathname === item.href
                      ? 'bg-gray-100 text-gray-900'
                      : 'text-gray-600 hover:bg-gray-50 hover:text-gray-900',
                    'group flex items-center px-2 py-2 text-base font-medium rounded-md'
                  )}
                  onClick={() => setSidebarOpen(false)}
                >
                  <item.icon
                    className={classNames(
                      location.pathname === item.href
                        ? 'text-gray-500'
                        : 'text-gray-400 group-hover:text-gray-500',
                      'mr-4 flex-shrink-0 h-6 w-6'
                    )}
                  />
                  {item.name}
                </Link>
              ))}
            </nav>
          </div>
        </div>
      </div>

      {/* Desktop sidebar */}
      <div className="hidden lg:flex lg:w-64 lg:flex-col lg:fixed lg:inset-y-0">
        <div className="flex flex-col flex-1 min-h-0 bg-white border-r border-gray-200">
          <div className="flex items-center h-16 flex-shrink-0 px-4 bg-white border-b border-gray-200">
            <span className="text-2xl font-bold text-primary-600">DependableCalls</span>
          </div>
          
          <div className="flex-1 flex flex-col overflow-y-auto">
            <nav className="flex-1 px-2 py-4 space-y-1">
              {navigation.map((item) => (
                <Link
                  key={item.name}
                  to={item.href}
                  className={classNames(
                    location.pathname === item.href
                      ? 'bg-gray-100 text-gray-900'
                      : 'text-gray-600 hover:bg-gray-50 hover:text-gray-900',
                    'group flex items-center px-2 py-2 text-sm font-medium rounded-md'
                  )}
                >
                  <item.icon
                    className={classNames(
                      location.pathname === item.href
                        ? 'text-gray-500'
                        : 'text-gray-400 group-hover:text-gray-500',
                      'mr-3 flex-shrink-0 h-6 w-6'
                    )}
                  />
                  {item.name}
                </Link>
              ))}
            </nav>
          </div>
        </div>
      </div>

      {/* Main content */}
      <div className="lg:pl-64 flex flex-col flex-1">
        {/* Top navigation */}
        <div className="sticky top-0 z-10 flex-shrink-0 flex h-16 bg-white shadow">
          <button
            type="button"
            className="px-4 border-r border-gray-200 text-gray-500 focus:outline-none focus:ring-2 focus:ring-inset focus:ring-primary-500 lg:hidden"
            onClick={() => setSidebarOpen(true)}
          >
            <Bars3Icon className="h-6 w-6" />
          </button>
          
          <div className="flex-1 px-4 flex justify-between">
            <div className="flex-1 flex">
              {/* Search can go here */}
            </div>
            
            <div className="ml-4 flex items-center md:ml-6">
              {/* User menu */}
              <div className="ml-3 relative">
                <div>
                  <button
                    className="max-w-xs bg-white flex items-center text-sm rounded-full focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500"
                    onClick={() => setUserMenuOpen(!userMenuOpen)}
                  >
                    <UserCircleIcon className="h-8 w-8 text-gray-400" />
                    <span className="ml-3 text-gray-700 text-sm font-medium">
                      {user?.email}
                    </span>
                  </button>
                </div>
                
                {userMenuOpen && (
                  <div className="origin-top-right absolute right-0 mt-2 w-48 rounded-md shadow-lg py-1 bg-white ring-1 ring-black ring-opacity-5 focus:outline-none">
                    <div className="px-4 py-2 text-xs text-gray-500">
                      {userType && userType.charAt(0).toUpperCase() + userType.slice(1)} Account
                    </div>
                    <Link
                      to="/app/settings"
                      className="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100"
                      onClick={() => setUserMenuOpen(false)}
                    >
                      Account Settings
                    </Link>
                    <button
                      onClick={handleSignOut}
                      className="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100"
                    >
                      Sign out
                    </button>
                  </div>
                )}
              </div>
            </div>
          </div>
        </div>

        {/* Page content */}
        <main className="flex-1">
          <Outlet />
        </main>
      </div>
    </div>
  )
}
</file>

<file path="src/hooks/useStripe.ts">
import { useState, useEffect } from 'react'
import type { Stripe, StripeElements } from '@stripe/stripe-js'
import { getStripeClient } from '../integrations/stripe'

export const useStripe = () => {
  const [stripe, setStripe] = useState<Stripe | null>(null)
  const [isLoading, setIsLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    const initStripe = async () => {
      try {
        const stripeClient = await getStripeClient()
        setStripe(stripeClient)
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : 'Failed to initialize Stripe'
        setError(errorMessage)
      } finally {
        setIsLoading(false)
      }
    }

    initStripe()
  }, [])

  return { stripe, isLoading, error }
}

export const useStripeElements = () => {
  const { stripe } = useStripe()
  const [elements, setElements] = useState<StripeElements | null>(null)

  useEffect(() => {
    if (stripe) {
      setElements(stripe.elements())
    }
  }, [stripe])

  return { stripe, elements }
}
</file>

<file path="src/integrations/fraud/config.ts">
import type { FraudConfig } from './types'

export const fraudConfig: FraudConfig = {
  truecaller: {
    apiKey: import.meta.env.VITE_TRUECALLER_API_KEY || '',
    baseUrl: 'https://api.truecaller.com/v2',
    timeout: 5000,
  },
  ipquality: {
    apiKey: import.meta.env.VITE_IPQUALITY_API_KEY || '',
    baseUrl: 'https://ipqualityscore.com/api/json',
    timeout: 5000,
  },
  fraudlabs: {
    apiKey: import.meta.env.VITE_FRAUDLABS_API_KEY || '',
    baseUrl: 'https://api.fraudlabspro.com/v1',
    timeout: 5000,
  },
  sift: {
    apiKey: import.meta.env.VITE_SIFT_API_KEY || '',
    baseUrl: 'https://api.sift.com/v205',
    timeout: 10000,
  },
  maxmind: {
    apiKey: import.meta.env.VITE_MAXMIND_API_KEY || '',
    baseUrl: 'https://geoip.maxmind.com/geoip/v2.1',
    timeout: 5000,
  },
  thresholds: {
    autoReject: 85, // Fraud score >= 85: automatic rejection
    manualReview: 50, // Fraud score 50-84: manual review required
    autoApprove: 49, // Fraud score <= 49: automatic approval
  },
}

export const isFraudDetectionConfigured = (): boolean => {
  return !!(
    fraudConfig.truecaller.apiKey &&
    fraudConfig.ipquality.apiKey &&
    fraudConfig.fraudlabs.apiKey &&
    fraudConfig.sift.apiKey &&
    fraudConfig.maxmind.apiKey
  )
}

export const getFraudDecision = (score: number): 'approve' | 'review' | 'reject' => {
  if (score >= fraudConfig.thresholds.autoReject) {
    return 'reject'
  } else if (score >= fraudConfig.thresholds.manualReview) {
    return 'review'
  }
  return 'approve'
}
</file>

<file path="src/integrations/fraud/index.ts">
export * from './types'
export * from './config'
export { truecallerClient } from './truecaller'
export { ipQualityClient } from './ipquality'
export { fraudLabsClient } from './fraudlabs'
export { siftClient } from './sift'
export { maxMindClient } from './maxmind'
export { fraudScoringService } from './scoring'
export { autoBlockingService } from './blocking'

// Main fraud detection API
import { fraudScoringService } from './scoring'
import { autoBlockingService } from './blocking'
import type { FraudCheckRequest, UnifiedFraudScore } from './types'

export async function checkFraud(request: FraudCheckRequest): Promise<UnifiedFraudScore> {
  // Check if any values are already blocked
  const blockChecks = await Promise.all([
    request.phone ? autoBlockingService.checkBlocked('phone', request.phone) : null,
    request.ip ? autoBlockingService.checkBlocked('ip', request.ip) : null,
    request.email ? autoBlockingService.checkBlocked('email', request.email) : null,
  ])

  // If any value is blocked, return immediate rejection
  const blockedRule = blockChecks.find((rule) => rule !== null)
  if (blockedRule) {
    return {
      overallScore: 100,
      decision: 'reject',
      reasons: [`Blocked: ${blockedRule.reason}`],
      timestamp: new Date(),
    }
  }

  // Perform comprehensive fraud check
  const fraudScore = await fraudScoringService.performComprehensiveCheck(request)

  // Process auto-blocking if needed
  await autoBlockingService.processAutoBlocking(fraudScore, request)

  return fraudScore
}

// Utility function for call validation
export async function validateIncomingCall(
  phoneNumber: string,
  ipAddress: string,
  campaignId: string
): Promise<{ allowed: boolean; score: UnifiedFraudScore }> {
  const score = await checkFraud({
    phone: phoneNumber,
    ip: ipAddress,
    campaignId,
    metadata: { type: 'incoming_call' },
  })

  return {
    allowed: score.decision === 'approve',
    score,
  }
}

// Utility function for user registration validation
export async function validateRegistration(
  email: string,
  ipAddress: string,
  phone?: string
): Promise<{ allowed: boolean; score: UnifiedFraudScore }> {
  const score = await checkFraud({
    email,
    ip: ipAddress,
    phone,
    metadata: { type: 'user_registration' },
  })

  return {
    allowed: score.decision !== 'reject',
    score,
  }
}

// Cleanup function to be called periodically
export async function cleanupFraudData(): Promise<void> {
  const cleaned = await autoBlockingService.cleanupExpiredRules()
  console.log(`Cleaned up ${cleaned} expired blocking rules`)
}
</file>

<file path="src/integrations/fraud/scoring.ts">
import { truecallerClient } from './truecaller'
import { ipQualityClient } from './ipquality'
import { fraudLabsClient } from './fraudlabs'
import { siftClient } from './sift'
import { maxMindClient } from './maxmind'
import { getFraudDecision } from './config'
import type {
  FraudCheckRequest,
  UnifiedFraudScore,
  PhoneVerificationResult,
  IPReputationResult,
  TransactionScreeningResult,
  SiftFraudResult,
  MaxMindGeoResult,
} from './types'

export class FraudScoringService {
  async performComprehensiveCheck(request: FraudCheckRequest): Promise<UnifiedFraudScore> {
    const timestamp = new Date()
    const results = await Promise.allSettled([
      request.phone ? truecallerClient.verifyPhone(request.phone) : Promise.resolve(null),
      request.ip ? ipQualityClient.checkIPReputation(request.ip) : Promise.resolve(null),
      fraudLabsClient.screenTransaction(request),
      siftClient.screenTransaction(request),
      request.ip ? maxMindClient.checkIPLocation(request.ip) : Promise.resolve(null),
    ])

    // Extract results
    const phoneResult =
      results[0].status === 'fulfilled'
        ? (results[0].value as PhoneVerificationResult | null)
        : null
    const ipResult =
      results[1].status === 'fulfilled' ? (results[1].value as IPReputationResult | null) : null
    const transactionResult =
      results[2].status === 'fulfilled' ? (results[2].value as TransactionScreeningResult) : null
    const siftResult =
      results[3].status === 'fulfilled' ? (results[3].value as SiftFraudResult) : null
    const maxMindResult =
      results[4].status === 'fulfilled' ? (results[4].value as MaxMindGeoResult | null) : null

    // Calculate individual scores
    const phoneScore = this.calculatePhoneScore(phoneResult)
    const ipScore = ipResult?.fraudScore || 0
    const transactionScore = transactionResult?.fraudScore || 0
    const siftScore = siftResult?.fraudScore || 0
    const maxmindScore = maxMindResult?.fraudScore || 0

    // Calculate weighted overall score
    const overallScore = this.calculateOverallScore({
      phoneScore,
      ipScore,
      transactionScore,
      siftScore,
      maxmindScore,
    })

    // Collect reasons for the score
    const reasons = this.collectReasons({
      phoneResult,
      ipResult,
      transactionResult,
      siftResult,
      maxMindResult,
    })

    // Make final decision
    const decision = getFraudDecision(overallScore)

    return {
      overallScore,
      phoneScore,
      ipScore,
      transactionScore,
      siftScore,
      maxmindScore,
      decision,
      reasons,
      timestamp,
    }
  }

  private calculatePhoneScore(result: PhoneVerificationResult | null): number {
    if (!result) return 0

    let score = 0

    // Invalid phone number
    if (!result.valid) {
      score += 40
    }

    // High spam score
    if ((result.spamScore || 0) > 50) {
      score += 30
    }

    // VOIP numbers are higher risk
    if (result.lineType === 'voip') {
      score += 20
    }

    // Inactive numbers
    if (result.valid && !result.isActive) {
      score += 25
    }

    return Math.min(100, score)
  }

  private calculateOverallScore(scores: {
    phoneScore: number
    ipScore: number
    transactionScore: number
    siftScore: number
    maxmindScore: number
  }): number {
    // Weighted average with Sift and transaction screening having the highest weights
    const weights = {
      phone: 0.15,
      ip: 0.2,
      transaction: 0.25,
      sift: 0.25,
      maxmind: 0.15,
    }

    const weightedScore =
      scores.phoneScore * weights.phone +
      scores.ipScore * weights.ip +
      scores.transactionScore * weights.transaction +
      scores.siftScore * weights.sift +
      scores.maxmindScore * weights.maxmind

    return Math.round(weightedScore)
  }

  private collectReasons(data: {
    phoneResult: PhoneVerificationResult | null
    ipResult: IPReputationResult | null
    transactionResult: TransactionScreeningResult | null
    siftResult: SiftFraudResult | null
    maxMindResult: MaxMindGeoResult | null
  }): string[] {
    const reasons: string[] = []

    // Phone-related reasons
    if (data.phoneResult) {
      if (!data.phoneResult.valid) {
        reasons.push('Invalid phone number')
      }
      if ((data.phoneResult.spamScore || 0) > 50) {
        reasons.push('High spam score on phone number')
      }
      if (data.phoneResult.lineType === 'voip') {
        reasons.push('VOIP phone number detected')
      }
      if (data.phoneResult.valid && !data.phoneResult.isActive) {
        reasons.push('Inactive phone number')
      }
    }

    // IP-related reasons
    if (data.ipResult) {
      if (data.ipResult.proxy) {
        reasons.push('Proxy IP detected')
      }
      if (data.ipResult.vpn) {
        reasons.push('VPN connection detected')
      }
      if (data.ipResult.tor) {
        reasons.push('TOR network detected')
      }
      if (data.ipResult.recentAbuse) {
        reasons.push('Recent abuse from IP address')
      }
      if (data.ipResult.botStatus) {
        reasons.push('Bot activity detected')
      }
    }

    // Transaction-related reasons
    if (data.transactionResult) {
      reasons.push(...data.transactionResult.rules)
    }

    // Sift-related reasons
    if (data.siftResult) {
      reasons.push(...data.siftResult.reasons)
      if (data.siftResult.status === 'reject') {
        reasons.push('Sift AI flagged as high-risk transaction')
      }
    }

    // MaxMind-related reasons
    if (data.maxMindResult) {
      if (data.maxMindResult.isVpn) {
        reasons.push('VPN detected by MaxMind')
      }
      if (data.maxMindResult.isProxy) {
        reasons.push('Proxy detected by MaxMind')
      }
      if (data.maxMindResult.riskLevel === 'high') {
        reasons.push('High-risk location detected')
      }
    }

    return [...new Set(reasons)] // Remove duplicates
  }

  // Quick check methods for specific scenarios
  async quickPhoneCheck(phone: string): Promise<number> {
    const result = await truecallerClient.verifyPhone(phone)
    return this.calculatePhoneScore(result)
  }

  async quickIPCheck(ip: string): Promise<number> {
    const result = await ipQualityClient.checkIPReputation(ip)
    return result.fraudScore
  }

  async checkCallFraud(phone: string, ip: string, campaignId: string): Promise<UnifiedFraudScore> {
    return this.performComprehensiveCheck({
      phone,
      ip,
      campaignId,
      metadata: { checkType: 'incoming_call' },
    })
  }

  async checkRegistrationFraud(
    email: string,
    ip: string,
    phone?: string
  ): Promise<UnifiedFraudScore> {
    return this.performComprehensiveCheck({
      email,
      ip,
      phone,
      metadata: { checkType: 'user_registration' },
    })
  }

  async checkPaymentFraud(
    amount: number,
    currency: string,
    email: string,
    ip: string
  ): Promise<UnifiedFraudScore> {
    return this.performComprehensiveCheck({
      amount,
      currency,
      email,
      ip,
      metadata: { checkType: 'payment_transaction' },
    })
  }
}

// Export singleton instance
export const fraudScoringService = new FraudScoringService()
</file>

<file path="src/integrations/fraud/types.ts">
export interface PhoneVerificationResult {
  valid: boolean
  carrier?: string
  country?: string
  lineType?: 'mobile' | 'landline' | 'voip' | 'unknown'
  name?: string
  spamScore?: number
  isActive?: boolean
  error?: string
}

export interface IPReputationResult {
  fraudScore: number
  countryCode?: string
  region?: string
  city?: string
  isp?: string
  proxy?: boolean
  vpn?: boolean
  tor?: boolean
  recentAbuse?: boolean
  botStatus?: boolean
  error?: string
}

export interface TransactionScreeningResult {
  fraudScore: number
  status: 'approve' | 'review' | 'reject'
  rules: string[]
  riskFactors: {
    ip?: string
    email?: string
    phone?: string
    billing?: string
    shipping?: string
  }
  error?: string
}

export interface SiftFraudResult {
  fraudScore: number
  status: 'approve' | 'review' | 'reject'
  workflowStatus?: string
  reasons: string[]
  paymentAbuseScore?: number
  accountAbuseScore?: number
  error?: string
}

export interface MaxMindGeoResult {
  fraudScore: number
  countryCode?: string
  region?: string
  city?: string
  riskLevel: 'low' | 'medium' | 'high'
  isVpn?: boolean
  isProxy?: boolean
  isp?: string
  accuracyRadius?: number
  error?: string
}

export interface UnifiedFraudScore {
  overallScore: number
  phoneScore?: number
  ipScore?: number
  transactionScore?: number
  siftScore?: number
  maxmindScore?: number
  decision: 'approve' | 'review' | 'reject'
  reasons: string[]
  timestamp: Date
}

export interface FraudCheckRequest {
  phone?: string
  ip?: string
  email?: string
  amount?: number
  currency?: string
  userId?: string
  campaignId?: string
  metadata?: Record<string, unknown>
}

export interface BlockingRule {
  id: string
  type: 'phone' | 'ip' | 'email' | 'pattern'
  value: string
  reason: string
  createdAt: Date
  expiresAt?: Date
  autoBlocked: boolean
}

export interface FraudConfig {
  truecaller: {
    apiKey: string
    baseUrl: string
    timeout: number
  }
  ipquality: {
    apiKey: string
    baseUrl: string
    timeout: number
  }
  fraudlabs: {
    apiKey: string
    baseUrl: string
    timeout: number
  }
  sift: {
    apiKey: string
    baseUrl: string
    timeout: number
  }
  maxmind: {
    apiKey: string
    baseUrl: string
    timeout: number
  }
  thresholds: {
    autoReject: number
    manualReview: number
    autoApprove: number
  }
}
</file>

<file path="src/integrations/stripe/billing.ts">
import { stripeServerClient } from './client'
import type Stripe from 'stripe'

export interface CreateInvoiceParams {
  customerId: string
  description: string
  metadata: {
    buyerId: string
    billingPeriod: string
    callCount: string
  }
  dueDate?: number
  collectionMethod?: 'charge_automatically' | 'send_invoice'
}

export interface CreateInvoiceItemParams {
  customerId: string
  amount: number
  currency: string
  description: string
  metadata: {
    callId?: string
    campaignId?: string
    duration?: string
  }
  invoiceId?: string
}

export const createInvoice = async (params: CreateInvoiceParams): Promise<Stripe.Invoice> => {
  try {
    const invoice = await stripeServerClient.invoices.create({
      customer: params.customerId,
      description: params.description,
      metadata: {
        ...params.metadata,
        platform: 'dependablecalls',
      },
      due_date: params.dueDate,
      collection_method: params.collectionMethod || 'charge_automatically',
      auto_advance: false, // We'll finalize manually
    })

    return invoice
  } catch (error) {
    console.error('Error creating invoice:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    throw new Error(`Failed to create invoice: ${errorMessage}`)
  }
}

export const createInvoiceItem = async (
  params: CreateInvoiceItemParams
): Promise<Stripe.InvoiceItem> => {
  try {
    const invoiceItem = await stripeServerClient.invoiceItems.create({
      customer: params.customerId,
      amount: params.amount,
      currency: params.currency,
      description: params.description,
      metadata: {
        ...params.metadata,
        platform: 'dependablecalls',
      },
      ...(params.invoiceId && { invoice: params.invoiceId }),
    })

    return invoiceItem
  } catch (error) {
    console.error('Error creating invoice item:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    throw new Error(`Failed to create invoice item: ${errorMessage}`)
  }
}

export const finalizeInvoice = async (
  invoiceId: string,
  autoAdvance: boolean = true
): Promise<Stripe.Invoice> => {
  try {
    const invoice = await stripeServerClient.invoices.finalizeInvoice(invoiceId, {
      auto_advance: autoAdvance,
    })

    return invoice
  } catch (error) {
    console.error('Error finalizing invoice:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    throw new Error(`Failed to finalize invoice: ${errorMessage}`)
  }
}

export const sendInvoice = async (invoiceId: string): Promise<Stripe.Invoice> => {
  try {
    const invoice = await stripeServerClient.invoices.sendInvoice(invoiceId)
    return invoice
  } catch (error) {
    console.error('Error sending invoice:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    throw new Error(`Failed to send invoice: ${errorMessage}`)
  }
}

export const payInvoice = async (
  invoiceId: string,
  paymentMethodId?: string
): Promise<Stripe.Invoice> => {
  try {
    const invoice = await stripeServerClient.invoices.pay(invoiceId, {
      ...(paymentMethodId && { payment_method: paymentMethodId }),
    })

    return invoice
  } catch (error) {
    console.error('Error paying invoice:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    throw new Error(`Failed to pay invoice: ${errorMessage}`)
  }
}

export const voidInvoice = async (invoiceId: string): Promise<Stripe.Invoice> => {
  try {
    const invoice = await stripeServerClient.invoices.voidInvoice(invoiceId)
    return invoice
  } catch (error) {
    console.error('Error voiding invoice:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    throw new Error(`Failed to void invoice: ${errorMessage}`)
  }
}

export const updateInvoice = async (
  invoiceId: string,
  updates: Stripe.InvoiceUpdateParams
): Promise<Stripe.Invoice> => {
  try {
    const invoice = await stripeServerClient.invoices.update(invoiceId, updates)

    return invoice
  } catch (error) {
    console.error('Error updating invoice:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    throw new Error(`Failed to update invoice: ${errorMessage}`)
  }
}

export const getInvoice = async (invoiceId: string): Promise<Stripe.Invoice | null> => {
  try {
    const invoice = await stripeServerClient.invoices.retrieve(invoiceId)
    return invoice
  } catch (error) {
    if (
      error &&
      typeof error === 'object' &&
      'code' in error &&
      error.code === 'resource_missing'
    ) {
      return null
    }
    console.error('Error retrieving invoice:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    throw new Error(`Failed to retrieve invoice: ${errorMessage}`)
  }
}

export const listCustomerInvoices = async (
  customerId: string,
  status?: 'draft' | 'open' | 'paid' | 'uncollectible' | 'void',
  limit: number = 100
): Promise<Stripe.Invoice[]> => {
  try {
    const invoices = await stripeServerClient.invoices.list({
      customer: customerId,
      status,
      limit,
    })

    return invoices.data
  } catch (error) {
    console.error('Error listing invoices:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    throw new Error(`Failed to list invoices: ${errorMessage}`)
  }
}

export const createCreditNote = async (
  invoiceId: string,
  amount: number,
  reason: 'duplicate' | 'fraudulent' | 'order_change' | 'product_unsatisfactory',
  memo?: string
): Promise<Stripe.CreditNote> => {
  try {
    const creditNote = await stripeServerClient.creditNotes.create({
      invoice: invoiceId,
      amount,
      reason,
      memo,
      metadata: {
        platform: 'dependablecalls',
      },
    })

    return creditNote
  } catch (error) {
    console.error('Error creating credit note:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    throw new Error(`Failed to create credit note: ${errorMessage}`)
  }
}

export const createUsageBasedInvoice = async (
  customerId: string,
  billingPeriod: { start: Date; end: Date },
  usageRecords: Array<{
    amount: number
    description: string
    metadata: Record<string, string>
  }>
): Promise<Stripe.Invoice> => {
  try {
    // Create invoice for the billing period
    const invoice = await createInvoice({
      customerId,
      description: `Usage charges for ${billingPeriod.start.toISOString().split('T')[0]} to ${billingPeriod.end.toISOString().split('T')[0]}`,
      metadata: {
        buyerId: customerId,
        billingPeriod: `${billingPeriod.start.toISOString()}_${billingPeriod.end.toISOString()}`,
        callCount: usageRecords.length.toString(),
      },
    })

    // Add line items for each usage record
    for (const record of usageRecords) {
      await createInvoiceItem({
        customerId,
        amount: record.amount,
        currency: 'usd',
        description: record.description,
        metadata: record.metadata,
        invoiceId: invoice.id,
      })
    }

    // Finalize and send the invoice
    if (!invoice.id) {
      throw new Error('Invoice creation failed - no invoice ID returned')
    }
    const finalizedInvoice = await finalizeInvoice(invoice.id)

    return finalizedInvoice
  } catch (error) {
    console.error('Error creating usage-based invoice:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    throw new Error(`Failed to create usage-based invoice: ${errorMessage}`)
  }
}
</file>

<file path="src/integrations/stripe/connected-accounts.ts">
import { stripeServerClient } from './client';
import type { CreateConnectedAccountParams, ConnectedAccountStatus, PayoutSchedule } from './types';
import type Stripe from 'stripe';
import { v4 as uuid } from 'uuid';

/**
 * Centralized error handler for Stripe operations
 * Prevents leaking sensitive information and provides type-safe error handling
 */
function handleStripeError(err: unknown, context: string): never {
  if (err instanceof stripeServerClient.errors.StripeError) {
    console.error(`${context} failed`, { 
      type: err.type, 
      code: err.code, 
      param: err.param,
      requestId: err.requestId 
    });
    
    // Return generic error messages to prevent information leakage
    if (err.code === 'resource_missing') {
      throw new Error(`Resource not found. Please check your request and try again.`);
    }
    
    throw new Error(`Stripe ${context} failed. Please retry or contact support.`);
  }
  
  console.error(`${context} unexpected error`, err);
  throw new Error('Internal server error. Please try again later.');
}

export const createConnectedAccount = async (
  params: CreateConnectedAccountParams
): Promise<Stripe.Account> => {
  try {
    const account = await stripeServerClient.accounts.create({
      type: 'express',
      email: params.email,
      country: params.country ?? 'US',
      business_type: params.businessType ?? 'individual',
      capabilities: {
        card_payments: { requested: true },
        transfers: { requested: true },
      },
      settings: {
        payouts: {
          schedule: {
            delay_days: 7,
            interval: 'weekly',
            weekly_anchor: 'friday',
          },
        },
      },
      metadata: {
        ...params.metadata,
        platform: 'dependablecalls',
      },
    }, {
      idempotencyKey: uuid() // Prevent duplicate account creation
    });
    
    return account;
  } catch (error: unknown) {
    handleStripeError(error, 'create connected account');
  }
};

export const createAccountLink = async (
  accountId: string,
  refreshUrl: string,
  returnUrl: string,
  type: 'account_onboarding' | 'account_update' = 'account_onboarding'
): Promise<Stripe.AccountLink> => {
  try {
    const accountLink = await stripeServerClient.accountLinks.create({
      account: accountId,
      refresh_url: refreshUrl,
      return_url: returnUrl,
      type,
    }, {
      idempotencyKey: uuid() // Prevent duplicate link creation
    });
    
    return accountLink;
  } catch (error: unknown) {
    handleStripeError(error, 'create account link');
  }
};

export const getConnectedAccount = async (
  accountId: string
): Promise<Stripe.Account | null> => {
  try {
    const account = await stripeServerClient.accounts.retrieve(accountId);
    return account;
  } catch (error: unknown) {
    if (error instanceof stripeServerClient.errors.StripeError && 
        error.code === 'resource_missing') {
      return null;
    }
    handleStripeError(error, 'retrieve connected account');
  }
};

export const updateConnectedAccount = async (
  accountId: string,
  updates: Stripe.AccountUpdateParams
): Promise<Stripe.Account> => {
  try {
    const account = await stripeServerClient.accounts.update(
      accountId,
      updates
    );
    
    return account;
  } catch (error: unknown) {
    handleStripeError(error, 'update connected account');
  }
};

export const deleteConnectedAccount = async (
  accountId: string
): Promise<boolean> => {
  try {
    const result = await stripeServerClient.accounts.del(accountId);
    return result.deleted;
  } catch (error: unknown) {
    handleStripeError(error, 'delete connected account');
  }
};

export const getAccountStatus = async (
  accountId: string
): Promise<ConnectedAccountStatus> => {
  try {
    const account = await stripeServerClient.accounts.retrieve(accountId);
    
    return {
      id: account.id,
      chargesEnabled: account.charges_enabled ?? false,
      payoutsEnabled: account.payouts_enabled ?? false,
      detailsSubmitted: account.details_submitted ?? false,
      requirementsCurrentlyDue: account.requirements?.currently_due ?? [],
    };
  } catch (error: unknown) {
    handleStripeError(error, 'get account status');
  }
};

export const updatePayoutSchedule = async (
  accountId: string,
  schedule: PayoutSchedule
): Promise<Stripe.Account> => {
  try {
    const account = await stripeServerClient.accounts.update(accountId, {
      settings: {
        payouts: {
          schedule: {
            delay_days: schedule.delayDays,
            interval: schedule.interval,
            ...(schedule.weeklyAnchor && { weekly_anchor: schedule.weeklyAnchor }),
          },
        },
      },
    });
    
    return account;
  } catch (error: unknown) {
    handleStripeError(error, 'update payout schedule');
  }
};

export const createLoginLink = async (
  accountId: string
): Promise<Stripe.LoginLink> => {
  try {
    const loginLink = await stripeServerClient.accounts.createLoginLink(
      accountId
    );
    
    return loginLink;
  } catch (error: unknown) {
    handleStripeError(error, 'create login link');
  }
};

/**
 * List all transfers for an account with automatic pagination
 * This ensures we get ALL transfers, not just the first page
 */
export const listAccountTransfers = async (
  accountId: string,
  limit = 1000 // Increased from 100 for better performance
): Promise<Stripe.Transfer[]> => {
  try {
    const transfers: Stripe.Transfer[] = [];
    
    // Use auto-pagination to ensure we get all transfers
    for await (const transfer of stripeServerClient.transfers.list({
      destination: accountId,
      limit, // Page size
    })) {
      transfers.push(transfer);
    }
    
    return transfers;
  } catch (error: unknown) {
    handleStripeError(error, 'list account transfers');
  }
};

export const getAccountBalance = async (
  accountId: string
): Promise<Stripe.Balance> => {
  try {
    const balance = await stripeServerClient.balance.retrieve({
      stripeAccount: accountId,
    });
    
    return balance;
  } catch (error: unknown) {
    handleStripeError(error, 'retrieve account balance');
  }
};

/**
 * Create a transfer to a connected account with idempotency
 * Useful for payouts and platform fees
 */
export const createTransfer = async (
  accountId: string,
  amount: number,
  currency = 'usd',
  description?: string,
  metadata?: Record<string, string>
): Promise<Stripe.Transfer> => {
  try {
    const transfer = await stripeServerClient.transfers.create({
      amount: Math.round(amount * 100), // Convert to cents
      currency,
      destination: accountId,
      description,
      metadata: {
        ...metadata,
        platform: 'dependablecalls',
      },
    }, {
      idempotencyKey: uuid() // Prevent duplicate transfers
    });
    
    return transfer;
  } catch (error: unknown) {
    handleStripeError(error, 'create transfer');
  }
};

/**
 * Create a payout for a connected account with idempotency
 */
export const createPayout = async (
  accountId: string,
  amount: number,
  currency = 'usd',
  description?: string,
  metadata?: Record<string, string>
): Promise<Stripe.Payout> => {
  try {
    const payout = await stripeServerClient.payouts.create({
      amount: Math.round(amount * 100), // Convert to cents
      currency,
      description,
      metadata: {
        ...metadata,
        platform: 'dependablecalls',
      },
    }, {
      stripeAccount: accountId,
      idempotencyKey: uuid() // Prevent duplicate payouts
    });
    
    return payout;
  } catch (error: unknown) {
    handleStripeError(error, 'create payout');
  }
};
</file>

<file path="src/integrations/stripe/index.ts">
export * from './client'
export * from './types'
export * from './customers'
export * from './connected-accounts'
export * from './payments'
export * from './subscriptions'
export * from './billing'
export {
  toCents,
  toDollars,
  isValidCents,
  createCents,
  createTransfer as createPayoutTransfer,
  reverseTransfer,
  getTransfer,
  updateTransfer,
  getPayout,
  listAccountPayouts,
  createBulkPayout,
  calculatePayoutSummary,
  scheduleWeeklyPayouts,
} from './payouts'
export * from './webhooks'

// Re-export commonly used functions
export { stripeServerClient, getStripeClient, isStripeConfigured } from './client'

export { createStripeCustomer } from './customers'

export { createConnectedAccount, createTransfer } from './connected-accounts'

export { createPaymentIntent } from './payments'

export { createSubscription } from './subscriptions'

export { createInvoice } from './billing'

export { handleStripeWebhook } from './webhooks'

// Helper to check if all required Stripe environment variables are set
export const validateStripeEnvironment = (): { isValid: boolean; missing: string[] } => {
  const required = [
    'VITE_STRIPE_SECRET_KEY',
    'VITE_STRIPE_PUBLISHABLE_KEY',
    'VITE_STRIPE_WEBHOOK_SECRET',
  ]

  const missing = required.filter((key) => !import.meta.env[key])

  return {
    isValid: missing.length === 0,
    missing,
  }
}
</file>

<file path="src/integrations/stripe/payouts.ts">
import { stripeServerClient } from './client'
import type { CreateTransferParams } from './types'
import type Stripe from 'stripe'
import { v4 as uuid } from 'uuid'
import { z } from 'zod'

/**
 * Strongly typed cents to prevent decimal amount errors
 * Stripe requires amounts as positive integers in smallest currency unit
 */
export type Cents = number & { __brand: 'cents' }

/**
 * Convert dollars to cents with proper rounding
 */
export function toCents(dollars: number): Cents {
  return Math.round(dollars * 100) as Cents
}

/**
 * Convert cents to dollars
 */
export function toDollars(cents: Cents): number {
  return cents / 100
}

/**
 * Validate amount is valid cents (positive integer)
 */
export function isValidCents(amount: number): amount is Cents {
  return Number.isInteger(amount) && amount > 0
}

/**
 * Create Cents from a validated number
 */
export function createCents(amount: number): Cents {
  if (!isValidCents(amount)) {
    throw new Error('Amount must be a positive integer in cents')
  }
  return amount as Cents
}

/**
 * Validate statement descriptor according to Stripe requirements
 */
const statementDescriptorSchema = z
  .string()
  .max(22, 'Statement descriptor must be 22 chars or less')
  .transform((val) => val.replace(/[<>]/g, ''))

/**
 * Restricted update params for transfers (Stripe only allows metadata and description)
 */
export interface TransferUpdateParams {
  metadata?: Stripe.Metadata
  description?: string
}

/**
 * Centralized error handler for Stripe operations
 * Prevents leaking sensitive information and provides type-safe error handling
 */
function handleStripeError(err: unknown, context: string): never {
  if (err instanceof stripeServerClient.errors.StripeError) {
    console.error(`${context} failed`, {
      type: err.type,
      code: err.code,
      param: err.param,
      requestId: err.requestId,
    })

    // Handle idempotent request duplicates as success
    if (err.code === 'idempotency_key_in_use' || err.statusCode === 409) {
      // This is actually a success - the operation was already completed
      // The caller should handle this appropriately
      const duplicateError = new Error('Operation already completed') as Error & {
        isDuplicate: boolean
        originalRequest?: unknown
      }
      duplicateError.isDuplicate = true
      duplicateError.originalRequest = err.raw
      throw duplicateError
    }

    // Return generic error messages to prevent information leakage
    if (err.code === 'resource_missing') {
      throw new Error(`Resource not found. Please check your request and try again.`)
    }

    if (err.code === 'insufficient_funds') {
      throw new Error('Insufficient funds for payout. Please try again later.')
    }

    if (err.code === 'invalid_request_error' && err.param === 'amount') {
      throw new Error('Invalid amount. Amount must be a positive integer in cents.')
    }

    throw new Error(`Payout service error. Please retry or contact support.`)
  }

  console.error(`${context} unexpected error`, err)
  throw new Error('Internal server error. Please try again later.')
}

export interface CreatePayoutParams {
  accountId: string
  amount: Cents // Enforced as integer cents
  currency: string
  metadata: {
    supplierId: string
    payoutPeriod: string
    callCount: string
  }
  statementDescriptor?: string
}

export interface PayoutSummary {
  totalAmount: Cents // Enforced as integer cents
  currency: string
  transferCount: number
  period: {
    start: Date
    end: Date
  }
}

export const createTransfer = async (params: CreateTransferParams): Promise<Stripe.Transfer> => {
  try {
    // Validate amount is positive integer
    if (!Number.isInteger(params.amount) || params.amount <= 0) {
      throw new Error('Amount must be a positive integer in cents')
    }

    const transfer = await stripeServerClient.transfers.create(
      {
        amount: params.amount,
        currency: params.currency,
        destination: params.destination,
        transfer_group: `payout_${params.metadata.payoutId}`,
        metadata: {
          ...params.metadata,
          platform: 'dependablecalls',
        },
      },
      {
        idempotencyKey: uuid(), // Prevent duplicate transfers
      }
    )

    return transfer
  } catch (error: unknown) {
    // Check if this is a duplicate operation (409 response)
    if (error instanceof Error && 'isDuplicate' in error && error.isDuplicate) {
      console.log('Transfer already created, returning success')
      // In production, you'd retrieve and return the original transfer
      // For now, we re-throw to let caller handle
      throw error
    }
    handleStripeError(error, 'create transfer')
  }
}

export const reverseTransfer = async (
  transferId: string,
  amount?: Cents,
  reason?: string
): Promise<Stripe.TransferReversal> => {
  try {
    // Validate amount if provided
    if (amount !== undefined && (!Number.isInteger(amount) || amount <= 0)) {
      throw new Error('Amount must be a positive integer in cents')
    }

    const reversal = await stripeServerClient.transfers.createReversal(
      transferId,
      {
        amount,
        description: reason,
        metadata: {
          platform: 'dependablecalls',
          reason: reason || 'fraud_detected',
        },
      },
      {
        idempotencyKey: uuid(), // Prevent duplicate reversals
      }
    )

    return reversal
  } catch (error: unknown) {
    handleStripeError(error, 'reverse transfer')
  }
}

export const getTransfer = async (transferId: string): Promise<Stripe.Transfer | null> => {
  try {
    const transfer = await stripeServerClient.transfers.retrieve(transferId)
    return transfer
  } catch (error: unknown) {
    if (
      error instanceof stripeServerClient.errors.StripeError &&
      error.code === 'resource_missing'
    ) {
      return null
    }
    handleStripeError(error, 'retrieve transfer')
  }
}

export const updateTransfer = async (
  transferId: string,
  updates: TransferUpdateParams // Restricted to only metadata and description
): Promise<Stripe.Transfer> => {
  try {
    // Stripe only allows updating metadata and description on transfers
    const allowedUpdates: Stripe.TransferUpdateParams = {}
    if (updates.metadata !== undefined) {
      allowedUpdates.metadata = updates.metadata
    }
    if (updates.description !== undefined) {
      allowedUpdates.description = updates.description
    }

    const transfer = await stripeServerClient.transfers.update(transferId, allowedUpdates, {
      idempotencyKey: uuid(), // Prevent duplicate updates
    })

    return transfer
  } catch (error: unknown) {
    handleStripeError(error, 'update transfer')
  }
}

export const createPayout = async (params: CreatePayoutParams): Promise<Stripe.Payout> => {
  try {
    // Validate amount is positive integer
    if (!Number.isInteger(params.amount) || params.amount <= 0) {
      throw new Error('Amount must be a positive integer in cents')
    }

    // Validate and sanitize statement descriptor
    const statementDescriptor = params.statementDescriptor
      ? statementDescriptorSchema.parse(params.statementDescriptor)
      : 'DCE Payout'

    // First check if account can receive payouts
    const account = await stripeServerClient.accounts.retrieve(params.accountId)
    if (account.type === 'standard') {
      throw new Error('Cannot create payouts for Standard accounts. Use transfers instead.')
    }
    if (!account.payouts_enabled) {
      throw new Error('Account is not enabled for payouts. Please complete account verification.')
    }

    const payout = await stripeServerClient.payouts.create(
      {
        amount: params.amount,
        currency: params.currency,
        statement_descriptor: statementDescriptor,
        metadata: {
          ...params.metadata,
          platform: 'dependablecalls',
        },
      },
      {
        stripeAccount: params.accountId,
        idempotencyKey: uuid(), // Prevent duplicate payouts
      }
    )

    return payout
  } catch (error: unknown) {
    handleStripeError(error, 'create payout')
  }
}

export const cancelPayout = async (payoutId: string, accountId: string): Promise<Stripe.Payout> => {
  try {
    const payout = await stripeServerClient.payouts.cancel(
      payoutId,
      {},
      { stripeAccount: accountId }
    )

    return payout
  } catch (error) {
    console.error('Error canceling payout:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    throw new Error(`Failed to cancel payout: ${errorMessage}`)
  }
}

export const getPayout = async (
  payoutId: string,
  accountId: string
): Promise<Stripe.Payout | null> => {
  try {
    const payout = await stripeServerClient.payouts.retrieve(
      payoutId,
      {},
      { stripeAccount: accountId }
    )

    return payout
  } catch (error: unknown) {
    if (
      error instanceof stripeServerClient.errors.StripeError &&
      error.code === 'resource_missing'
    ) {
      return null
    }
    handleStripeError(error, 'retrieve payout')
  }
}

export const listAccountPayouts = async (
  accountId: string,
  status?: 'pending' | 'paid' | 'failed' | 'canceled',
  limit: number = 100
): Promise<Stripe.Payout[]> => {
  try {
    const payouts: Stripe.Payout[] = []

    // Use auto-pagination to ensure we get all payouts
    for await (const payout of stripeServerClient.payouts.list(
      {
        status,
        limit,
      },
      {
        stripeAccount: accountId,
      }
    )) {
      payouts.push(payout)
    }

    return payouts
  } catch (error: unknown) {
    handleStripeError(error, 'list payouts')
  }
}

export const createBulkPayout = async (
  payouts: Array<{
    accountId: string
    amount: Cents
    metadata: Record<string, string>
  }>,
  transferGroup: string,
  maxConcurrency: number = 5 // Limit concurrent requests
): Promise<Array<{ success: boolean; transfer?: Stripe.Transfer; error?: Error }>> => {
  try {
    // Create batches for concurrent processing
    const results: Array<{ success: boolean; transfer?: Stripe.Transfer; error?: Error }> = []

    // Process in batches to avoid rate limits
    for (let i = 0; i < payouts.length; i += maxConcurrency) {
      const batch = payouts.slice(i, i + maxConcurrency)

      const batchPromises = batch.map(async (payout) => {
        try {
          const transfer = await createTransfer({
            amount: payout.amount,
            currency: 'usd',
            destination: payout.accountId,
            metadata: {
              ...payout.metadata,
              transferGroup,
              payoutId: `${transferGroup}_${payout.accountId}_${Date.now()}`,
              supplierId: payout.metadata.supplierId || 'bulk',
              callCount: payout.metadata.callCount || '0',
              period: payout.metadata.period || transferGroup,
            },
          } as CreateTransferParams)

          return { success: true, transfer }
        } catch (error: unknown) {
          // Don't fail entire batch for individual errors
          const errorObj = error instanceof Error ? error : new Error(String(error))
          return { success: false, error: errorObj }
        }
      })

      const batchResults = await Promise.allSettled(batchPromises)

      batchResults.forEach((result) => {
        if (result.status === 'fulfilled') {
          results.push(result.value)
        } else {
          results.push({ success: false, error: result.reason })
        }
      })
    }

    return results
  } catch (error: unknown) {
    handleStripeError(error, 'create bulk payout')
  }
}

export const calculatePayoutSummary = async (
  accountId: string,
  period: { start: Date; end: Date }
): Promise<PayoutSummary> => {
  try {
    let totalAmount = 0
    let transferCount = 0

    // Use auto-pagination to ensure we get ALL transfers
    for await (const transfer of stripeServerClient.transfers.list({
      destination: accountId,
      created: {
        gte: Math.floor(period.start.getTime() / 1000),
        lt: Math.floor(period.end.getTime() / 1000),
      },
      limit: 100, // Page size
    })) {
      totalAmount += transfer.amount
      transferCount++
    }

    return {
      totalAmount: totalAmount as Cents,
      currency: 'usd',
      transferCount,
      period,
    }
  } catch (error: unknown) {
    handleStripeError(error, 'calculate payout summary')
  }
}

export const scheduleWeeklyPayouts = async (
  suppliers: Array<{
    accountId: string
    supplierId: string
    amount: Cents
    callCount: number
  }>,
  maxConcurrency: number = 5
): Promise<
  Array<{ supplierId: string; success: boolean; transfer?: Stripe.Transfer; error?: Error }>
> => {
  try {
    const now = new Date()
    const weekStart = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)
    const payoutPeriod = weekStart.toISOString().split('T')[0]
    const payoutGroup = `weekly_${payoutPeriod}`

    // Generate deterministic payout IDs to prevent duplicates
    const generatePayoutId = (supplierId: string) => {
      // Use supplier ID and period for idempotency
      return `payout_${supplierId}_${payoutPeriod}`
    }

    const results: Array<{
      supplierId: string
      success: boolean
      transfer?: Stripe.Transfer
      error?: Error
    }> = []

    // Filter eligible suppliers
    const eligibleSuppliers = suppliers.filter((s) => s.amount >= 10000) // $100 minimum

    // Process in batches for better performance
    for (let i = 0; i < eligibleSuppliers.length; i += maxConcurrency) {
      const batch = eligibleSuppliers.slice(i, i + maxConcurrency)

      const batchPromises = batch.map(async (supplier) => {
        try {
          const transfer = await createTransfer({
            amount: supplier.amount,
            currency: 'usd',
            destination: supplier.accountId,
            metadata: {
              payoutId: generatePayoutId(supplier.supplierId),
              supplierId: supplier.supplierId,
              callCount: supplier.callCount.toString(),
              period: payoutGroup,
            },
          } as CreateTransferParams)

          return { supplierId: supplier.supplierId, success: true, transfer }
        } catch (error: unknown) {
          // Check if it's a duplicate (already processed)
          if (
            error instanceof Error &&
            'isDuplicate' in error &&
            (error as Error & { isDuplicate: boolean }).isDuplicate
          ) {
            console.log(`Payout already processed for supplier ${supplier.supplierId}`)
            return { supplierId: supplier.supplierId, success: true, transfer: undefined }
          }

          console.error(`Failed to create payout for supplier ${supplier.supplierId}:`, error)
          return { supplierId: supplier.supplierId, success: false, error: error as Error }
        }
      })

      const batchResults = await Promise.allSettled(batchPromises)

      batchResults.forEach((result) => {
        if (result.status === 'fulfilled') {
          results.push(result.value)
        } else {
          results.push({
            supplierId: 'unknown',
            success: false,
            error: result.reason,
          })
        }
      })
    }

    // Log summary
    const successful = results.filter((r) => r.success).length
    const failed = results.filter((r) => !r.success).length
    console.log(`Weekly payouts completed: ${successful} successful, ${failed} failed`)

    return results
  } catch (error: unknown) {
    handleStripeError(error, 'schedule weekly payouts')
  }
}
</file>

<file path="src/integrations/stripe/subscriptions.ts">
import { stripeServerClient } from './client'
import type Stripe from 'stripe'

export interface CreateSubscriptionParams {
  customerId: string
  priceId: string
  metadata: {
    buyerId: string
    planType: 'starter' | 'professional' | 'enterprise'
  }
  trialDays?: number
  defaultPaymentMethod?: string
}

export interface UsageRecord {
  subscriptionItemId: string
  quantity: number
  timestamp?: number
  action?: 'set' | 'increment'
}

export const createSubscription = async (
  params: CreateSubscriptionParams
): Promise<Stripe.Subscription> => {
  try {
    const subscription = await stripeServerClient.subscriptions.create({
      customer: params.customerId,
      items: [{ price: params.priceId }],
      payment_behavior: 'default_incomplete',
      payment_settings: { save_default_payment_method: 'on_subscription' },
      expand: ['latest_invoice.payment_intent'],
      metadata: {
        ...params.metadata,
        platform: 'dependablecalls',
      },
      ...(params.trialDays && { trial_period_days: params.trialDays }),
      ...(params.defaultPaymentMethod && {
        default_payment_method: params.defaultPaymentMethod,
      }),
    })

    return subscription
  } catch (error) {
    console.error('Error creating subscription:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    throw new Error(`Failed to create subscription: ${errorMessage}`)
  }
}

export const updateSubscription = async (
  subscriptionId: string,
  updates: Stripe.SubscriptionUpdateParams
): Promise<Stripe.Subscription> => {
  try {
    const subscription = await stripeServerClient.subscriptions.update(subscriptionId, updates)

    return subscription
  } catch (error) {
    console.error('Error updating subscription:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    throw new Error(`Failed to update subscription: ${errorMessage}`)
  }
}

export const cancelSubscription = async (
  subscriptionId: string,
  immediately: boolean = false
): Promise<Stripe.Subscription> => {
  try {
    if (immediately) {
      return await stripeServerClient.subscriptions.cancel(subscriptionId)
    } else {
      return await stripeServerClient.subscriptions.update(subscriptionId, {
        cancel_at_period_end: true,
      })
    }
  } catch (error) {
    console.error('Error canceling subscription:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    throw new Error(`Failed to cancel subscription: ${errorMessage}`)
  }
}

export const reactivateSubscription = async (
  subscriptionId: string
): Promise<Stripe.Subscription> => {
  try {
    const subscription = await stripeServerClient.subscriptions.update(subscriptionId, {
      cancel_at_period_end: false,
    })

    return subscription
  } catch (error) {
    console.error('Error reactivating subscription:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    throw new Error(`Failed to reactivate subscription: ${errorMessage}`)
  }
}

export const getSubscription = async (
  subscriptionId: string
): Promise<Stripe.Subscription | null> => {
  try {
    const subscription = await stripeServerClient.subscriptions.retrieve(subscriptionId)

    return subscription
  } catch (error) {
    if (
      error &&
      typeof error === 'object' &&
      'code' in error &&
      error.code === 'resource_missing'
    ) {
      return null
    }
    console.error('Error retrieving subscription:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    throw new Error(`Failed to retrieve subscription: ${errorMessage}`)
  }
}

export const listCustomerSubscriptions = async (
  customerId: string,
  status?: 'active' | 'canceled' | 'past_due' | 'trialing'
): Promise<Stripe.Subscription[]> => {
  try {
    const subscriptions = await stripeServerClient.subscriptions.list({
      customer: customerId,
      status,
    })

    return subscriptions.data
  } catch (error) {
    console.error('Error listing subscriptions:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    throw new Error(`Failed to list subscriptions: ${errorMessage}`)
  }
}

export const createUsageRecord = async (record: UsageRecord): Promise<unknown> => {
  try {
    // Note: Usage records are created through billing, not directly
    // This is a placeholder implementation
    console.warn('Usage records should be created through billing system')
    return { success: true, record }
  } catch (error) {
    console.error('Error creating usage record:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    throw new Error(`Failed to create usage record: ${errorMessage}`)
  }
}

export const listUsageRecords = async (): Promise<unknown[]> => {
  try {
    // Note: Usage records are retrieved through billing, not directly
    // This is a placeholder implementation
    console.warn('Usage records should be retrieved through billing system')
    return []
  } catch (error) {
    console.error('Error listing usage records:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    throw new Error(`Failed to list usage records: ${errorMessage}`)
  }
}

export const updateSubscriptionItem = async (
  subscriptionId: string,
  itemId: string,
  newPriceId: string
): Promise<Stripe.Subscription> => {
  try {
    const subscription = await stripeServerClient.subscriptions.update(subscriptionId, {
      items: [
        {
          id: itemId,
          price: newPriceId,
        },
      ],
      proration_behavior: 'create_prorations',
    })

    return subscription
  } catch (error) {
    console.error('Error updating subscription item:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    throw new Error(`Failed to update subscription item: ${errorMessage}`)
  }
}

export const createSubscriptionSchedule = async (
  customerId: string,
  phases: Stripe.SubscriptionScheduleCreateParams.Phase[]
): Promise<Stripe.SubscriptionSchedule> => {
  try {
    const schedule = await stripeServerClient.subscriptionSchedules.create({
      customer: customerId,
      start_date: 'now',
      phases,
    })

    return schedule
  } catch (error) {
    console.error('Error creating subscription schedule:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    throw new Error(`Failed to create subscription schedule: ${errorMessage}`)
  }
}
</file>

<file path="src/integrations/stripe/types.ts">
import type Stripe from 'stripe';

export interface StripeCustomerData {
  id: string;
  email: string;
  name?: string;
  phone?: string;
  metadata: {
    userId: string;
    userType: 'buyer' | 'supplier';
    companyName?: string;
  };
}

export interface CreateConnectedAccountParams {
  email: string;
  country?: string;
  businessType?: 'individual' | 'company';
  metadata: {
    supplierId: string;
    companyName?: string;
  };
}

export interface CreatePaymentIntentParams {
  amount: number;
  currency: string;
  customerId: string;
  metadata: {
    invoiceId: string;
    buyerId: string;
    billingPeriod: string;
  };
  paymentMethodTypes?: string[];
}

import type { Cents } from './payouts';

export interface CreateTransferParams {
  amount: Cents;
  currency: string;
  destination: string;
  metadata: {
    payoutId: string;
    supplierId: string;
    callCount: string;
    period: string;
  };
}

export interface StripeWebhookEvent {
  id: string;
  type: string;
  data: {
    object: Stripe.Event.Data.Object;
  };
  created: number;
}

export interface PaymentStatus {
  id: string;
  status: 'pending' | 'processing' | 'succeeded' | 'failed';
  amount: number;
  currency: string;
  error?: string;
}

export interface ConnectedAccountStatus {
  id: string;
  chargesEnabled: boolean;
  payoutsEnabled: boolean;
  detailsSubmitted: boolean;
  requirementsCurrentlyDue: string[];
}

export interface PayoutSchedule {
  delayDays: number;
  interval: 'daily' | 'weekly' | 'monthly' | 'manual';
  weeklyAnchor?: 'monday' | 'tuesday' | 'wednesday' | 'thursday' | 'friday';
}

export type StripeEventType =
  | 'payment_intent.succeeded'
  | 'payment_intent.payment_failed'
  | 'charge.dispute.created'
  | 'account.updated'
  | 'account.application.authorized'
  | 'account.application.deauthorized'
  | 'payout.created'
  | 'payout.paid'
  | 'payout.failed'
  | 'transfer.created'
  | 'transfer.reversed';

export interface WebhookHandlerMap {
  [key: string]: (event: Stripe.Event) => Promise<void>;
}
</file>

<file path="src/lib/monitoring.ts">
import * as Sentry from '@sentry/react'
import { Routes, Route } from 'react-router-dom'

/**
 * Initialize Sentry monitoring for error tracking and performance monitoring
 */
export function initSentry(): void {
  const dsn = import.meta.env.VITE_SENTRY_DSN
  const environment = import.meta.env.MODE

  if (!dsn) {
    console.warn('Sentry DSN not configured, monitoring disabled')
    return
  }

  Sentry.init({
    dsn,
    environment,
    integrations: [
      Sentry.browserTracingIntegration({
        // Set up automatic route change tracking for React Router
        enableInp: true,
      }),
      Sentry.replayIntegration({
        // Mask sensitive data
        maskAllText: true,
        blockAllMedia: true,
      }),
    ],

    // Performance monitoring
    tracesSampleRate: environment === 'production' ? 0.1 : 1.0,

    // Session replay
    replaysSessionSampleRate: 0.1,
    replaysOnErrorSampleRate: 1.0,

    // Release tracking
    release: import.meta.env.VITE_APP_VERSION || 'unknown',

    // Error filtering
    beforeSend(event, hint) {
      // Filter out development errors
      if (environment === 'development') {
        console.error('Sentry event:', event, hint)
        return null
      }

      // Filter out network errors that are not actionable
      if (event.exception) {
        const error = hint.originalException
        if (error instanceof TypeError && error.message.includes('NetworkError')) {
          return null
        }
      }

      return event
    },

    // Additional context
    initialScope: {
      tags: {
        component: 'dce-website',
        platform: 'web',
      },
    },
  })
}

/**
 * Set user context for error tracking
 */
export function setSentryUser(user: { id: string; email?: string; role?: string }): void {
  Sentry.setUser({
    id: user.id,
    email: user.email,
    role: user.role,
  })
}

/**
 * Add breadcrumb for debugging
 */
export function addBreadcrumb(
  message: string,
  category: string = 'custom',
  level: Sentry.SeverityLevel = 'info',
  data?: Record<string, unknown>
): void {
  Sentry.addBreadcrumb({
    message,
    category,
    level,
    data,
    timestamp: Date.now() / 1000,
  })
}

/**
 * Capture exception manually
 */
export function captureError(error: Error, context?: Record<string, unknown>): void {
  Sentry.withScope((scope) => {
    if (context) {
      scope.setContext('error_context', context)
    }
    Sentry.captureException(error)
  })
}

/**
 * Capture custom message
 */
export function captureMessage(
  message: string,
  level: Sentry.SeverityLevel = 'info',
  context?: Record<string, unknown>
): void {
  Sentry.withScope((scope) => {
    if (context) {
      scope.setContext('message_context', context)
    }
    scope.setLevel(level)
    Sentry.captureMessage(message)
  })
}

/**
 * Performance monitoring for critical operations
 */
export function startTransaction(name: string, operation: string = 'navigation'): unknown {
  return Sentry.startSpan(
    {
      name,
      op: operation,
    },
    () => ({})
  )
}

/**
 * Track API call performance
 */
export function trackApiCall<T>(apiName: string, apiCall: () => Promise<T>): Promise<T> {
  const transaction = startTransaction(apiName, 'http.client')

  return apiCall()
    .then((result) => {
      ;(transaction as { setStatus?: (status: string) => void })?.setStatus?.('ok')
      return result
    })
    .catch((error) => {
      ;(transaction as { setStatus?: (status: string) => void })?.setStatus?.('internal_error')
      captureError(error, { apiName })
      throw error
    })
    .finally(() => {
      ;(transaction as { finish?: () => void })?.finish?.()
    })
}

// React integration components
export const SentryRoutes = Sentry.withSentryRouting(Routes)
export const SentryRoute = Sentry.withSentryRouting(Route)
export const SentryErrorBoundary = Sentry.ErrorBoundary
</file>

<file path="src/pages/auth/ForgotPasswordPage.tsx">
import { useState } from 'react'
import { Link } from 'react-router-dom'
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { z } from 'zod'
import { supabase } from '../../lib/supabase'

const forgotPasswordSchema = z.object({
  email: z.string().email('Invalid email address'),
})

type ForgotPasswordFormData = z.infer<typeof forgotPasswordSchema>

export default function ForgotPasswordPage() {
  const [success, setSuccess] = useState(false)
  const [error, setError] = useState('')
  const [loading, setLoading] = useState(false)

  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<ForgotPasswordFormData>({
    resolver: zodResolver(forgotPasswordSchema),
  })

  const onSubmit = async (data: ForgotPasswordFormData) => {
    setError('')
    setLoading(true)

    try {
      const { error } = await supabase.auth.resetPasswordForEmail(data.email, {
        redirectTo: `${window.location.origin}/reset-password`,
      })

      if (error) throw error

      setSuccess(true)
    } catch (err: unknown) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to send reset email'
      setError(errorMessage)
    } finally {
      setLoading(false)
    }
  }

  if (success) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
        <div className="max-w-md w-full space-y-8">
          <div className="text-center">
            <h2 className="mt-6 text-3xl font-extrabold text-gray-900">
              Check your email
            </h2>
            <p className="mt-2 text-sm text-gray-600">
              We've sent a password reset link to your email address.
            </p>
            <Link
              to="/login"
              className="mt-4 inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-primary-600 bg-primary-100 hover:bg-primary-200"
            >
              Back to login
            </Link>
          </div>
        </div>
      </div>
    )
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
      <div className="max-w-md w-full space-y-8">
        <div>
          <h2 className="mt-6 text-center text-3xl font-extrabold text-gray-900">
            Forgot your password?
          </h2>
          <p className="mt-2 text-center text-sm text-gray-600">
            Enter your email address and we'll send you a link to reset your password.
          </p>
        </div>

        <form className="mt-8 space-y-6" onSubmit={handleSubmit(onSubmit)}>
          <div>
            <label htmlFor="email" className="block text-sm font-medium text-gray-700">
              Email address
            </label>
            <input
              {...register('email')}
              type="email"
              autoComplete="email"
              className="mt-1 appearance-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-md focus:outline-none focus:ring-primary-500 focus:border-primary-500 focus:z-10 sm:text-sm"
              placeholder="Enter your email"
            />
            {errors.email && (
              <p className="mt-1 text-sm text-red-600">{errors.email.message}</p>
            )}
          </div>

          {error && (
            <div className="rounded-md bg-red-50 p-4">
              <div className="flex">
                <div className="ml-3">
                  <h3 className="text-sm font-medium text-red-800">{error}</h3>
                </div>
              </div>
            </div>
          )}

          <div>
            <button
              type="submit"
              disabled={loading}
              className="group relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-primary-600 hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {loading ? 'Sending...' : 'Send reset link'}
            </button>
          </div>

          <div className="text-center">
            <Link
              to="/login"
              className="font-medium text-primary-600 hover:text-primary-500"
            >
              Back to login
            </Link>
          </div>
        </form>
      </div>
    </div>
  )
}
</file>

<file path="src/pages/auth/LoginPage.tsx">
import { useState } from 'react'
import { Link, useNavigate } from 'react-router-dom'
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { z } from 'zod'
import { useAuthStore } from '../../store/authStore'

const loginSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z.string().min(6, 'Password must be at least 6 characters'),
})

type LoginFormData = z.infer<typeof loginSchema>

export default function LoginPage() {
  const navigate = useNavigate()
  const { signIn } = useAuthStore()
  const [error, setError] = useState('')
  const [loading, setLoading] = useState(false)

  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<LoginFormData>({
    resolver: zodResolver(loginSchema),
  })

  const onSubmit = async (data: LoginFormData) => {
    setError('')
    setLoading(true)

    try {
      await signIn(data.email, data.password)
      navigate('/app/dashboard')
    } catch (err: unknown) {
      const errorMessage = err instanceof Error ? err.message : 'Invalid email or password'
      setError(errorMessage)
    } finally {
      setLoading(false)
    }
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
      <div className="max-w-md w-full space-y-8">
        <div>
          <h2 className="mt-6 text-center text-3xl font-extrabold text-gray-900">
            Sign in to your account
          </h2>
          <p className="mt-2 text-center text-sm text-gray-600">
            Or{' '}
            <Link
              to="/register"
              className="font-medium text-primary-600 hover:text-primary-500"
            >
              create a new account
            </Link>
          </p>
        </div>

        <form className="mt-8 space-y-6" onSubmit={handleSubmit(onSubmit)}>
          <div className="rounded-md shadow-sm -space-y-px">
            <div>
              <label htmlFor="email" className="sr-only">
                Email address
              </label>
              <input
                {...register('email')}
                type="email"
                autoComplete="email"
                className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-t-md focus:outline-none focus:ring-primary-500 focus:border-primary-500 focus:z-10 sm:text-sm"
                placeholder="Email address"
              />
              {errors.email && (
                <p className="mt-1 text-sm text-red-600">{errors.email.message}</p>
              )}
            </div>
            <div>
              <label htmlFor="password" className="sr-only">
                Password
              </label>
              <input
                {...register('password')}
                type="password"
                autoComplete="current-password"
                className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-b-md focus:outline-none focus:ring-primary-500 focus:border-primary-500 focus:z-10 sm:text-sm"
                placeholder="Password"
              />
              {errors.password && (
                <p className="mt-1 text-sm text-red-600">{errors.password.message}</p>
              )}
            </div>
          </div>

          {error && (
            <div className="rounded-md bg-red-50 p-4">
              <div className="flex">
                <div className="ml-3">
                  <h3 className="text-sm font-medium text-red-800">{error}</h3>
                </div>
              </div>
            </div>
          )}

          <div className="flex items-center justify-between">
            <div className="flex items-center">
              <input
                id="remember-me"
                name="remember-me"
                type="checkbox"
                className="h-4 w-4 text-primary-600 focus:ring-primary-500 border-gray-300 rounded"
              />
              <label htmlFor="remember-me" className="ml-2 block text-sm text-gray-900">
                Remember me
              </label>
            </div>

            <div className="text-sm">
              <Link
                to="/forgot-password"
                className="font-medium text-primary-600 hover:text-primary-500"
              >
                Forgot your password?
              </Link>
            </div>
          </div>

          <div>
            <button
              type="submit"
              disabled={loading}
              className="group relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-primary-600 hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {loading ? 'Signing in...' : 'Sign in'}
            </button>
          </div>
        </form>
      </div>
    </div>
  )
}
</file>

<file path="src/pages/auth/RegisterPage.tsx">
import { useState } from 'react'
import { Link, useNavigate } from 'react-router-dom'
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { z } from 'zod'
import { useAuthStore } from '../../store/authStore'

const registerSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z.string().min(8, 'Password must be at least 8 characters'),
  confirmPassword: z.string(),
  userType: z.enum(['supplier', 'buyer']),
  acceptTerms: z.boolean().refine((val) => val === true, {
    message: 'You must accept the terms and conditions',
  }),
}).refine((data) => data.password === data.confirmPassword, {
  message: "Passwords don't match",
  path: ['confirmPassword'],
})

type RegisterFormData = z.infer<typeof registerSchema>

export default function RegisterPage() {
  const navigate = useNavigate()
  const { signUp } = useAuthStore()
  const [error, setError] = useState('')
  const [loading, setLoading] = useState(false)

  const {
    register,
    handleSubmit,
    formState: { errors },
    watch,
  } = useForm<RegisterFormData>({
    resolver: zodResolver(registerSchema),
    defaultValues: {
      userType: 'supplier',
    },
  })

  const userType = watch('userType')

  const onSubmit = async (data: RegisterFormData) => {
    setError('')
    setLoading(true)

    try {
      await signUp(data.email, data.password, data.userType)
      navigate('/app/dashboard')
    } catch (err: unknown) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to create account'
      setError(errorMessage)
    } finally {
      setLoading(false)
    }
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
      <div className="max-w-md w-full space-y-8">
        <div>
          <h2 className="mt-6 text-center text-3xl font-extrabold text-gray-900">
            Create your account
          </h2>
          <p className="mt-2 text-center text-sm text-gray-600">
            Or{' '}
            <Link
              to="/login"
              className="font-medium text-primary-600 hover:text-primary-500"
            >
              sign in to existing account
            </Link>
          </p>
        </div>

        <form className="mt-8 space-y-6" onSubmit={handleSubmit(onSubmit)}>
          {/* Account Type Selection */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              I am a...
            </label>
            <div className="grid grid-cols-2 gap-3">
              <label className="relative">
                <input
                  {...register('userType')}
                  type="radio"
                  value="supplier"
                  className="sr-only"
                />
                <div className={`border rounded-lg p-4 cursor-pointer text-center ${
                  userType === 'supplier' 
                    ? 'border-primary-500 bg-primary-50 text-primary-700' 
                    : 'border-gray-300'
                }`}>
                  <span className="block font-medium">Supplier</span>
                  <span className="block text-sm mt-1 text-gray-500">
                    I have traffic to send
                  </span>
                </div>
              </label>
              <label className="relative">
                <input
                  {...register('userType')}
                  type="radio"
                  value="buyer"
                  className="sr-only"
                />
                <div className={`border rounded-lg p-4 cursor-pointer text-center ${
                  userType === 'buyer' 
                    ? 'border-primary-500 bg-primary-50 text-primary-700' 
                    : 'border-gray-300'
                }`}>
                  <span className="block font-medium">Buyer</span>
                  <span className="block text-sm mt-1 text-gray-500">
                    I need quality calls
                  </span>
                </div>
              </label>
            </div>
          </div>

          <div className="space-y-4">
            <div>
              <label htmlFor="email" className="block text-sm font-medium text-gray-700">
                Email address
              </label>
              <input
                {...register('email')}
                type="email"
                autoComplete="email"
                className="mt-1 appearance-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-md focus:outline-none focus:ring-primary-500 focus:border-primary-500 focus:z-10 sm:text-sm"
                placeholder="Enter your email"
              />
              {errors.email && (
                <p className="mt-1 text-sm text-red-600">{errors.email.message}</p>
              )}
            </div>

            <div>
              <label htmlFor="password" className="block text-sm font-medium text-gray-700">
                Password
              </label>
              <input
                {...register('password')}
                type="password"
                autoComplete="new-password"
                className="mt-1 appearance-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-md focus:outline-none focus:ring-primary-500 focus:border-primary-500 focus:z-10 sm:text-sm"
                placeholder="Create a password"
              />
              {errors.password && (
                <p className="mt-1 text-sm text-red-600">{errors.password.message}</p>
              )}
            </div>

            <div>
              <label htmlFor="confirmPassword" className="block text-sm font-medium text-gray-700">
                Confirm Password
              </label>
              <input
                {...register('confirmPassword')}
                type="password"
                autoComplete="new-password"
                className="mt-1 appearance-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-md focus:outline-none focus:ring-primary-500 focus:border-primary-500 focus:z-10 sm:text-sm"
                placeholder="Confirm your password"
              />
              {errors.confirmPassword && (
                <p className="mt-1 text-sm text-red-600">{errors.confirmPassword.message}</p>
              )}
            </div>
          </div>

          <div className="flex items-start">
            <input
              {...register('acceptTerms')}
              type="checkbox"
              className="h-4 w-4 text-primary-600 focus:ring-primary-500 border-gray-300 rounded"
            />
            <label className="ml-2 block text-sm text-gray-900">
              I agree to the{' '}
              <Link to="/terms" className="text-primary-600 hover:text-primary-500">
                Terms and Conditions
              </Link>{' '}
              and{' '}
              <Link to="/privacy" className="text-primary-600 hover:text-primary-500">
                Privacy Policy
              </Link>
            </label>
          </div>
          {errors.acceptTerms && (
            <p className="mt-1 text-sm text-red-600">{errors.acceptTerms.message}</p>
          )}

          {error && (
            <div className="rounded-md bg-red-50 p-4">
              <div className="flex">
                <div className="ml-3">
                  <h3 className="text-sm font-medium text-red-800">{error}</h3>
                </div>
              </div>
            </div>
          )}

          <div>
            <button
              type="submit"
              disabled={loading}
              className="group relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-primary-600 hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {loading ? 'Creating account...' : 'Create account'}
            </button>
          </div>
        </form>
      </div>
    </div>
  )
}
</file>

<file path="src/test/setup.ts">
import '@testing-library/jest-dom'
import { cleanup } from '@testing-library/react'
import { afterEach } from 'vitest'

// Mock window.matchMedia
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: (query: string) => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: () => {},
    removeListener: () => {},
    addEventListener: () => {},
    removeEventListener: () => {},
    dispatchEvent: () => {},
  }),
})

// Mock IntersectionObserver
global.IntersectionObserver = class IntersectionObserver {
  root = null
  rootMargin = '0px'
  thresholds = [0]

  constructor() {}
  disconnect() {}
  observe() {}
  unobserve() {}
  takeRecords() {
    return []
  }
}

// Mock ResizeObserver
global.ResizeObserver = class ResizeObserver {
  constructor() {}
  disconnect() {}
  observe() {}
  unobserve() {}
}

// Clean up after each test
afterEach(() => {
  cleanup()
})
</file>

<file path="src/main.tsx">
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'
import { initSentry } from './lib/monitoring'

// Initialize Sentry monitoring
initSentry()

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

# Environment variables
.env
.env.local
.env.production

# Supabase
supabase/.branches
supabase/.temp

# Claude AI settings
.claude/

# Test outputs
coverage/
playwright-report/
test-results/
.nyc_output/

# Monitoring files
monitor.log
</file>

<file path="postcss.config.js">
import tailwindcss from '@tailwindcss/postcss'
import autoprefixer from 'autoprefixer'

export default {
  plugins: [tailwindcss, autoprefixer],
}
</file>

<file path="README.md">
# DCE Platform - Dependable Calls Exchange

A modern pay-per-call network platform connecting suppliers (traffic providers) with buyers (advertisers) for high-quality lead generation.

## 🚀 Overview

DCE Platform facilitates real-time call tracking, lead management, and automated billing for performance-based marketing campaigns. Built with cutting-edge technologies for reliability, scalability, and real-time performance.

### Key Features

- **Real-time Call Tracking** - Monitor calls as they happen with live status updates
- **Campaign Management** - Create and manage targeted campaigns with advanced filtering
- **Fraud Prevention** - Built-in fraud detection and quality scoring
- **Automated Billing** - Stripe integration for seamless payments and payouts
- **Role-based Access** - Separate interfaces for suppliers, buyers, and administrators
- **Analytics Dashboard** - Comprehensive reporting and performance metrics

## 🛠️ Technology Stack

- **Frontend**: Vite 7.0 + React 19.1 + TypeScript 5.8
- **Styling**: Tailwind CSS 4.1 + Headless UI 2.2
- **Backend**: Supabase (PostgreSQL + Auth + Realtime)
- **State Management**: Zustand 5.0 + React Query 5.83
- **Payments**: Stripe 18.3
- **Testing**: Vitest 3.2 + Playwright 1.54
- **Hosting**: Netlify with Edge Functions

## 📋 Prerequisites

- Node.js 22.15.0 or higher
- npm 10.x or higher
- Supabase CLI
- Stripe CLI (for webhook testing)

## 🚀 Quick Start

### 1. Clone the repository

```bash
git clone https://github.com/your-org/dce-website.git
cd dce-website
```

### 2. Install dependencies

```bash
npm install
```

### 3. Set up environment variables

```bash
cp .env.example .env.local
```

Edit `.env.local` with your credentials:

```env
# Supabase
VITE_SUPABASE_URL=your-supabase-url
VITE_SUPABASE_ANON_KEY=your-supabase-anon-key

# Stripe
VITE_STRIPE_PUBLIC_KEY=your-stripe-public-key
STRIPE_SECRET_KEY=your-stripe-secret-key
STRIPE_WEBHOOK_SECRET=your-webhook-secret

# Sentry (optional)
VITE_SENTRY_DSN=your-sentry-dsn
```

### 4. Set up the database

```bash
# Start Supabase locally
npx supabase start

# Run migrations
npx supabase db push

# Seed test data (optional)
npx supabase db seed
```

### 5. Start the development server

```bash
npm run dev
```

Visit [http://localhost:5173](http://localhost:5173)

## 🏗️ Project Structure

```
dce-website/
├── src/
│   ├── components/     # Reusable React components
│   ├── pages/         # Route-based page components
│   ├── hooks/         # Custom React hooks
│   ├── lib/           # Shared utilities
│   ├── store/         # Zustand state management
│   ├── services/      # Business logic layer
│   ├── integrations/  # Third-party integrations
│   ├── types/         # TypeScript definitions
│   └── utils/         # Helper functions
├── tests/
│   ├── unit/          # Unit tests
│   ├── integration/   # Integration tests
│   ├── e2e/          # End-to-end tests
│   └── fixtures/      # Test data
├── supabase/
│   ├── migrations/    # Database migrations
│   └── functions/     # Edge functions
└── .github/
    └── workflows/     # CI/CD pipelines
```

## 🧪 Testing

```bash
# Run unit tests
npm test

# Run tests with coverage
npm run test:ci

# Run E2E tests
npm run test:e2e

# Open test UI
npm run test:ui
```

## 📦 Building for Production

```bash
# Type check
npm run type-check

# Lint code
npm run lint

# Build production bundle
npm run build

# Preview production build
npm run preview
```

## 🚢 Deployment

The project is configured for automatic deployment to Netlify:

1. Push to `main` branch triggers production deployment
2. Pull requests create preview deployments
3. Environment variables are managed in Netlify dashboard

### Manual deployment

```bash
# Install Netlify CLI
npm install -g netlify-cli

# Deploy to production
netlify deploy --prod
```

## 🔧 Development Guidelines

### Code Quality Rules

- **NO regex patterns** - Use validator.js or zod for validation
- **NO any types** - Always use proper TypeScript types
- **Fix all TypeScript/ESLint errors** immediately
- **90% test coverage minimum** for all code
- **Commit every 30 minutes** during active development

### Available Scripts

- `npm run dev` - Start development server
- `npm run build` - Build for production
- `npm run lint` - Run ESLint
- `npm run lint:fix` - Fix ESLint issues
- `npm run type-check` - Check TypeScript types
- `npm test` - Run tests
- `npm run test:ci` - Run tests with coverage
- `npm run test:e2e` - Run E2E tests

## 🏛️ Architecture Overview

### Frontend Architecture

- **Pages**: Route-based components for each major section
- **Components**: Reusable UI components following atomic design
- **Hooks**: Custom hooks for data fetching and business logic
- **Store**: Centralized state management with Zustand
- **Services**: Abstraction layer for API calls and business logic

### Backend Architecture

- **Database**: PostgreSQL with Row Level Security (RLS)
- **Authentication**: Supabase Auth with JWT tokens
- **Real-time**: WebSocket connections for live updates
- **Edge Functions**: Serverless functions for complex operations
- **Webhooks**: Stripe integration for payment processing

### Security Features

- Row Level Security (RLS) for data access control
- Role-based permissions (Supplier/Buyer/Admin)
- Fraud detection algorithms
- Rate limiting on API endpoints
- Secure webhook verification

## 🤝 User Roles

### Suppliers (Traffic Providers)

- Browse active campaigns
- Generate tracking numbers
- Monitor call performance
- Track earnings and payouts

### Buyers (Advertisers)

- Create and manage campaigns
- Set targeting criteria
- Monitor lead quality
- Manage billing and budgets

### Administrators

- Platform oversight
- User management
- Fraud investigation
- System configuration

## 📊 Key Features

### Call Tracking

- Real-time call status updates
- Duration tracking
- Quality scoring
- Automatic payout calculation

### Campaign Management

- Geographic targeting
- Time-based restrictions
- Budget controls
- Performance optimization

### Billing & Payments

- Automated invoicing
- Scheduled payouts
- Multiple payment methods
- Transaction history

### Analytics & Reporting

- Real-time dashboards
- Historical reports
- Export functionality
- Custom metrics

## 🐛 Troubleshooting

### Common Issues

1. **Supabase connection errors**
   - Verify environment variables
   - Check Supabase service status
   - Ensure migrations are applied

2. **Stripe webhook failures**
   - Verify webhook secret
   - Use Stripe CLI for local testing
   - Check webhook logs in Stripe dashboard

3. **Build errors**
   - Clear node_modules and reinstall
   - Check TypeScript errors with `npm run type-check`
   - Ensure all environment variables are set

## 📚 Documentation

- See `/CLAUDE.md` files in each directory for detailed patterns
- API documentation available at `/api/docs`
- Component storybook (if configured) at `npm run storybook`

## 🤝 Contributing

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

### Commit Convention

Follow conventional commits:

- `feat:` New features
- `fix:` Bug fixes
- `docs:` Documentation changes
- `style:` Code style changes
- `refactor:` Code refactoring
- `test:` Test additions/changes
- `chore:` Build process updates

## 📄 License

This project is proprietary and confidential. All rights reserved.

## 🆘 Support

- Technical issues: tech-support@dependablecalls.com
- Business inquiries: info@dependablecalls.com
- Documentation: See `/docs` directory

---

Built with ❤️ by the DCE Team
</file>

<file path="vite.config.ts">
/// <reference types="vitest" />
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import { resolve } from 'path'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': resolve(__dirname, './src'),
    },
  },
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: ['./src/test/setup.ts'],
    include: ['tests/unit/**/*.{test,spec}.{js,mjs,cjs,ts,mts,cts,jsx,tsx}'],
    exclude: ['tests/e2e/**/*', 'tests/performance/**/*'],
    coverage: {
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/',
        'src/test/',
        'src/**/*.test.{ts,tsx}',
        'src/**/*.spec.{ts,tsx}',
        'src/vite-env.d.ts',
        'tests/**/*',
      ],
    },
  },
})
</file>

<file path="src/integrations/stripe/client.ts">
import Stripe from 'stripe'
import { loadStripe } from '@stripe/stripe-js'

const STRIPE_API_VERSION = '2025-06-30.basil' as const

export const stripeServerClient = new Stripe(import.meta.env.VITE_STRIPE_SECRET_KEY || '', {
  apiVersion: STRIPE_API_VERSION,
  typescript: true,
})

let stripePromise: Promise<import('@stripe/stripe-js').Stripe | null> | null = null

export const getStripeClient = () => {
  if (!stripePromise) {
    stripePromise = loadStripe(import.meta.env.VITE_STRIPE_PUBLISHABLE_KEY || '')
  }
  return stripePromise
}

export const stripeConfig = {
  webhookSecret: import.meta.env.VITE_STRIPE_WEBHOOK_SECRET || '',
  connectClientId: import.meta.env.VITE_STRIPE_CONNECT_CLIENT_ID || '',
  apiVersion: STRIPE_API_VERSION,
}

export const isStripeConfigured = () => {
  return !!(import.meta.env.VITE_STRIPE_SECRET_KEY && import.meta.env.VITE_STRIPE_PUBLISHABLE_KEY)
}
</file>

<file path="src/integrations/stripe/customers.ts">
import { stripeServerClient } from './client'
import type Stripe from 'stripe'
import { v4 as uuid } from 'uuid'

/**
 * Centralized error handler for Stripe operations
 * Prevents leaking sensitive information and provides type-safe error handling
 */
function handleStripeError(err: unknown, context: string): never {
  if (err instanceof stripeServerClient.errors.StripeError) {
    console.error(`${context} failed`, {
      type: err.type,
      code: err.code,
      param: err.param,
      requestId: err.requestId,
    })

    // Return generic error messages to prevent information leakage
    if (err.code === 'resource_missing') {
      throw new Error(`Resource not found. Please check your request and try again.`)
    }

    throw new Error(`Customer service error. Please retry or contact support.`)
  }

  console.error(`${context} unexpected error`, err)
  throw new Error('Internal server error. Please try again later.')
}

export const createStripeCustomer = async (
  email: string,
  metadata: {
    userId: string
    userType: 'buyer' | 'supplier'
    companyName?: string
  },
  additionalData?: {
    name?: string
    phone?: string
    address?: {
      line1?: string
      line2?: string
      city?: string
      state?: string
      postal_code?: string
      country?: string
    }
  }
): Promise<Stripe.Customer> => {
  try {
    const customer = await stripeServerClient.customers.create(
      {
        email,
        name: additionalData?.name,
        phone: additionalData?.phone,
        address: additionalData?.address,
        metadata: {
          ...metadata,
          platform: 'dependablecalls',
        },
      },
      {
        idempotencyKey: uuid(), // Prevent duplicate customer creation
      }
    )

    return customer
  } catch (error: unknown) {
    handleStripeError(error, 'create Stripe customer')
  }
}

export const updateStripeCustomer = async (
  customerId: string,
  updates: Stripe.CustomerUpdateParams
): Promise<Stripe.Customer> => {
  try {
    const customer = await stripeServerClient.customers.update(customerId, updates, {
      idempotencyKey: uuid(), // Prevent duplicate updates
    })

    return customer
  } catch (error: unknown) {
    handleStripeError(error, 'update Stripe customer')
  }
}

export const getStripeCustomer = async (customerId: string): Promise<Stripe.Customer | null> => {
  try {
    const customer = await stripeServerClient.customers.retrieve(customerId)

    if (customer.deleted) {
      return null
    }

    return customer as Stripe.Customer
  } catch (error: unknown) {
    if (
      error instanceof stripeServerClient.errors.StripeError &&
      error.code === 'resource_missing'
    ) {
      return null
    }
    handleStripeError(error, 'retrieve Stripe customer')
  }
}

export const deleteStripeCustomer = async (customerId: string): Promise<boolean> => {
  try {
    const result = await stripeServerClient.customers.del(customerId)
    return result.deleted
  } catch (error: unknown) {
    handleStripeError(error, 'delete Stripe customer')
  }
}

/**
 * List all payment methods for a customer with automatic pagination
 * Specifying type improves performance by 3-4x for large merchants
 */
export const listCustomerPaymentMethods = async (
  customerId: string,
  type: 'card' | 'us_bank_account' = 'card',
  limit = 100
): Promise<Stripe.PaymentMethod[]> => {
  try {
    const paymentMethods: Stripe.PaymentMethod[] = []

    // Use auto-pagination to ensure we get all payment methods
    for await (const paymentMethod of stripeServerClient.paymentMethods.list({
      customer: customerId,
      type, // Always specify type for better performance
      limit,
    })) {
      paymentMethods.push(paymentMethod)
    }

    return paymentMethods
  } catch (error: unknown) {
    handleStripeError(error, 'list payment methods')
  }
}

/**
 * Save a payment method using SetupIntent for SCA optimization
 * This replaces direct attachment and reduces decline rates by 10-20%
 * @deprecated Use savePaymentMethod instead of attachPaymentMethod
 */
export const attachPaymentMethod = async (
  paymentMethodId: string,
  customerId: string
): Promise<Stripe.PaymentMethod> => {
  console.warn(
    'attachPaymentMethod is deprecated. Use savePaymentMethod for better SCA compliance.'
  )
  return savePaymentMethod(customerId, paymentMethodId)
}

/**
 * Save a payment method using SetupIntent for proper SCA optimization
 * Reduces decline rates by 10-20% compared to direct attachment
 */
export const savePaymentMethod = async (
  customerId: string,
  paymentMethodId: string,
  metadata?: Record<string, string>
): Promise<Stripe.PaymentMethod> => {
  try {
    // Create a SetupIntent with the payment method
    const setupIntent = await stripeServerClient.setupIntents.create(
      {
        customer: customerId,
        payment_method_types: ['card', 'us_bank_account'],
        payment_method: paymentMethodId,
        confirm: true, // Immediately confirms and attaches
        usage: 'off_session',
        metadata: {
          ...metadata,
          platform: 'dependablecalls',
        },
      },
      { idempotencyKey: uuid() } // Prevents duplicate setup
    )

    if (setupIntent.status !== 'succeeded') {
      throw new Error(`SetupIntent failed with status: ${setupIntent.status}`)
    }

    // The PaymentMethod is now attached and 3DS optimized
    return stripeServerClient.paymentMethods.retrieve(paymentMethodId)
  } catch (error: unknown) {
    handleStripeError(error, 'save payment method')
  }
}

export const detachPaymentMethod = async (
  paymentMethodId: string
): Promise<Stripe.PaymentMethod> => {
  try {
    const paymentMethod = await stripeServerClient.paymentMethods.detach(paymentMethodId)

    return paymentMethod
  } catch (error: unknown) {
    handleStripeError(error, 'detach payment method')
  }
}

export const setDefaultPaymentMethod = async (
  customerId: string,
  paymentMethodId: string
): Promise<Stripe.Customer> => {
  try {
    const customer = await stripeServerClient.customers.update(
      customerId,
      {
        invoice_settings: {
          default_payment_method: paymentMethodId,
        },
      },
      {
        idempotencyKey: uuid(), // Prevent duplicate default method updates
      }
    )

    return customer
  } catch (error: unknown) {
    handleStripeError(error, 'set default payment method')
  }
}

export const createSetupIntent = async (
  customerId: string,
  metadata?: Record<string, string>
): Promise<Stripe.SetupIntent> => {
  try {
    const setupIntent = await stripeServerClient.setupIntents.create(
      {
        customer: customerId,
        payment_method_types: ['card', 'us_bank_account'],
        usage: 'off_session',
        metadata: {
          ...metadata,
          platform: 'dependablecalls',
        },
      },
      {
        idempotencyKey: uuid(), // Prevent duplicate setup intent creation
      }
    )

    return setupIntent
  } catch (error: unknown) {
    handleStripeError(error, 'create setup intent')
  }
}
</file>

<file path="src/integrations/stripe/payments.ts">
import { stripeServerClient } from './client'
import type { CreatePaymentIntentParams, PaymentStatus } from './types'
import type Stripe from 'stripe'
import { v4 as uuid } from 'uuid'

/**
 * Centralized error handler for Stripe operations
 * Prevents leaking sensitive information and provides type-safe error handling
 */
function handleStripeError(err: unknown, context: string): never {
  if (err instanceof stripeServerClient.errors.StripeError) {
    console.error(`${context} failed`, {
      type: err.type,
      code: err.code,
      param: err.param,
      requestId: err.requestId,
    })

    // Return generic error messages to prevent information leakage
    if (err.code === 'resource_missing') {
      throw new Error(`Resource not found. Please check your request and try again.`)
    }

    throw new Error(`Payment service error. Please retry or contact support.`)
  }

  console.error(`${context} unexpected error`, err)
  throw new Error('Internal server error. Please try again later.')
}

export const createPaymentIntent = async (
  params: CreatePaymentIntentParams
): Promise<Stripe.PaymentIntent> => {
  try {
    const paymentIntent = await stripeServerClient.paymentIntents.create(
      {
        amount: params.amount,
        currency: params.currency,
        customer: params.customerId,
        payment_method_types: params.paymentMethodTypes ?? ['card', 'us_bank_account'],
        metadata: {
          ...params.metadata,
          platform: 'dependablecalls',
        },
        setup_future_usage: 'off_session',
        automatic_payment_methods: {
          enabled: true, // Enable for better payment method management
        },
      },
      {
        idempotencyKey: uuid(), // Prevent duplicate payment intent creation
      }
    )

    return paymentIntent
  } catch (error: unknown) {
    handleStripeError(error, 'create payment intent')
  }
}

export const confirmPaymentIntent = async (
  paymentIntentId: string,
  paymentMethodId: string,
  returnUrl: string
): Promise<Stripe.PaymentIntent> => {
  try {
    const paymentIntent = await stripeServerClient.paymentIntents.confirm(
      paymentIntentId,
      {
        payment_method: paymentMethodId,
        return_url: returnUrl, // Required for payment methods that need redirect
      },
      {
        idempotencyKey: uuid(), // Prevent duplicate confirmation
      }
    )

    return paymentIntent
  } catch (error: unknown) {
    handleStripeError(error, 'confirm payment intent')
  }
}

export const cancelPaymentIntent = async (
  paymentIntentId: string
): Promise<Stripe.PaymentIntent> => {
  try {
    const paymentIntent = await stripeServerClient.paymentIntents.cancel(
      paymentIntentId,
      {},
      {
        idempotencyKey: uuid(), // Prevent duplicate cancellation
      }
    )

    return paymentIntent
  } catch (error: unknown) {
    handleStripeError(error, 'cancel payment intent')
  }
}

export const getPaymentIntent = async (
  paymentIntentId: string
): Promise<Stripe.PaymentIntent | null> => {
  try {
    const paymentIntent = await stripeServerClient.paymentIntents.retrieve(paymentIntentId)

    return paymentIntent
  } catch (error: unknown) {
    if (
      error instanceof stripeServerClient.errors.StripeError &&
      error.code === 'resource_missing'
    ) {
      return null
    }
    handleStripeError(error, 'retrieve payment intent')
  }
}

export const updatePaymentIntent = async (
  paymentIntentId: string,
  updates: Stripe.PaymentIntentUpdateParams
): Promise<Stripe.PaymentIntent> => {
  try {
    const paymentIntent = await stripeServerClient.paymentIntents.update(paymentIntentId, updates, {
      idempotencyKey: uuid(), // Prevent duplicate updates
    })

    return paymentIntent
  } catch (error: unknown) {
    handleStripeError(error, 'update payment intent')
  }
}

export const createRefund = async (
  paymentIntentId: string,
  amount?: number,
  reason?: 'duplicate' | 'fraudulent' | 'requested_by_customer',
  metadata?: Record<string, string>
): Promise<Stripe.Refund> => {
  try {
    const refund = await stripeServerClient.refunds.create(
      {
        payment_intent: paymentIntentId,
        amount,
        reason,
        metadata: {
          ...metadata,
          platform: 'dependablecalls',
        },
      },
      {
        idempotencyKey: uuid(), // Prevent duplicate refunds
      }
    )

    return refund
  } catch (error: unknown) {
    handleStripeError(error, 'create refund')
  }
}

export const getPaymentStatus = (paymentIntent: Stripe.PaymentIntent): PaymentStatus => {
  let status: PaymentStatus['status'] = 'pending'
  let error: string | undefined

  switch (paymentIntent.status) {
    case 'succeeded':
      status = 'succeeded'
      break
    case 'processing':
      status = 'processing'
      break
    case 'canceled':
    case 'requires_payment_method':
      status = 'failed'
      error = paymentIntent.last_payment_error?.message
      break
    default:
      status = 'pending'
  }

  return {
    id: paymentIntent.id,
    status,
    amount: paymentIntent.amount,
    currency: paymentIntent.currency,
    error,
  }
}

/**
 * List all payment intents for a customer with automatic pagination
 * This ensures we get ALL payments, not just the first page
 */
export const listCustomerPayments = async (
  customerId: string,
  limit = 1000 // Increased from 100 for better performance
): Promise<Stripe.PaymentIntent[]> => {
  try {
    const payments: Stripe.PaymentIntent[] = []

    // Use auto-pagination to ensure we get all payment intents
    for await (const paymentIntent of stripeServerClient.paymentIntents.list({
      customer: customerId,
      limit, // Page size
    })) {
      payments.push(paymentIntent)
    }

    return payments
  } catch (error: unknown) {
    handleStripeError(error, 'list customer payments')
  }
}

/**
 * Create and immediately capture a payment using PaymentIntents
 * This replaces the legacy charges.create API for SCA compliance
 * @deprecated Use createPaymentIntent with automatic capture instead
 */
export const createAndCapturePayment = async (
  amount: number,
  currency: string,
  paymentMethodId: string,
  customerId?: string,
  metadata?: Record<string, string>
): Promise<Stripe.PaymentIntent> => {
  try {
    // Create and confirm payment intent in one API call
    const paymentIntent = await stripeServerClient.paymentIntents.create(
      {
        amount,
        currency,
        payment_method: paymentMethodId,
        customer: customerId,
        confirm: true, // Immediately attempt to confirm
        capture_method: 'automatic', // Capture funds immediately on confirmation
        automatic_payment_methods: {
          enabled: true,
          allow_redirects: 'never', // For immediate capture, don't allow redirects
        },
        metadata: {
          ...metadata,
          platform: 'dependablecalls',
        },
      },
      {
        idempotencyKey: uuid(), // Prevent duplicate charges
      }
    )

    return paymentIntent
  } catch (error: unknown) {
    handleStripeError(error, 'create and capture payment')
  }
}

/**
 * Helper function to handle off-session payments (e.g., recurring charges)
 */
export const createOffSessionPayment = async (
  amount: number,
  currency: string,
  customerId: string,
  paymentMethodId: string,
  metadata?: Record<string, string>
): Promise<Stripe.PaymentIntent> => {
  try {
    const paymentIntent = await stripeServerClient.paymentIntents.create(
      {
        amount,
        currency,
        customer: customerId,
        payment_method: paymentMethodId,
        off_session: true,
        confirm: true,
        metadata: {
          ...metadata,
          platform: 'dependablecalls',
        },
      },
      {
        idempotencyKey: uuid(), // Prevent duplicate charges
      }
    )

    return paymentIntent
  } catch (error: unknown) {
    handleStripeError(error, 'create off-session payment')
  }
}
</file>

<file path="src/integrations/stripe/webhooks.ts">
import crypto from 'crypto'
interface Request {
  body: unknown
  headers: Record<string, string | string[] | undefined>
}

interface Response {
  status: (code: number) => Response
  json: (data: unknown) => Response
  send: (data: unknown) => Response
}
import Stripe from 'stripe'
import { stripeServerClient, stripeConfig } from './client'
import type { WebhookHandlerMap } from './types'

export const verifyWebhookSignature = (
  payload: string | Buffer,
  signature: string
): Stripe.Event => {
  try {
    return stripeServerClient.webhooks.constructEvent(
      payload,
      signature,
      stripeConfig.webhookSecret
    )
  } catch (err) {
    const errorMessage = err instanceof Error ? err.message : 'Unknown error'
    throw new Error(`Webhook signature verification failed: ${errorMessage}`)
  }
}

const webhookHandlers: WebhookHandlerMap = {
  'payment_intent.succeeded': async (event) => {
    const paymentIntent = event.data.object as Stripe.PaymentIntent
    console.log('Payment succeeded:', paymentIntent.id)

    // Update invoice status in database
    // Send confirmation email
    // Update buyer's balance
  },

  'payment_intent.payment_failed': async (event) => {
    const paymentIntent = event.data.object as Stripe.PaymentIntent
    console.error('Payment failed:', paymentIntent.id)

    // Mark invoice as failed
    // Send failure notification
    // Potentially pause campaigns if recurring failure
  },

  'charge.dispute.created': async (event) => {
    const dispute = event.data.object as Stripe.Dispute
    console.warn('Dispute created:', dispute.id)

    // Create dispute record
    // Notify admin team
    // Gather evidence automatically
  },

  'account.updated': async (event) => {
    const account = event.data.object as Stripe.Account
    console.log('Connected account updated:', account.id)

    // Update supplier's account status
    // Check if charges/payouts are enabled
    // Notify supplier of any required actions
  },

  'account.application.authorized': async (event) => {
    const account = event.data.object as Stripe.Account
    console.log('Account authorized:', account.id)

    // Mark supplier as active
    // Enable campaign creation
    // Send welcome email
  },

  'account.application.deauthorized': async (event) => {
    const account = event.data.object as Stripe.Account
    console.log('Account deauthorized:', account.id)

    // Pause all supplier campaigns
    // Notify admin team
    // Schedule final payout
  },

  'payout.created': async (event) => {
    const payout = event.data.object as Stripe.Payout
    console.log('Payout created:', payout.id)

    // Create payout record
    // Update supplier balance
    // Send notification
  },

  'payout.paid': async (event) => {
    const payout = event.data.object as Stripe.Payout
    console.log('Payout completed:', payout.id)

    // Mark payout as completed
    // Send confirmation
    // Update ledger
  },

  'payout.failed': async (event) => {
    const payout = event.data.object as Stripe.Payout
    console.error('Payout failed:', payout.id)

    // Mark payout as failed
    // Notify supplier and admin
    // Schedule retry or manual intervention
  },

  'transfer.created': async (event) => {
    const transfer = event.data.object as Stripe.Transfer
    console.log('Transfer created:', transfer.id)

    // Record transfer
    // Update internal ledger
  },

  'transfer.reversed': async (event) => {
    const transfer = event.data.object as Stripe.Transfer
    console.warn('Transfer reversed:', transfer.id)

    // Update ledger
    // Investigate reason
    // Notify affected parties
  },
}

export const handleStripeWebhook = async (req: Request, res: Response): Promise<void> => {
  const signature = req.headers['stripe-signature'] as string

  if (!signature) {
    res.status(400).send('Missing stripe-signature header')
    return
  }

  let event: Stripe.Event

  try {
    event = verifyWebhookSignature(req.body as string | Buffer, signature)
  } catch (err) {
    console.error('Webhook signature verification failed:', err)
    const errorMessage = err instanceof Error ? err.message : 'Unknown error'
    res.status(400).send(`Webhook Error: ${errorMessage}`)
    return
  }

  const handler = webhookHandlers[event.type]

  if (handler) {
    try {
      await handler(event)
      res.json({ received: true })
    } catch (err) {
      console.error(`Error handling webhook ${event.type}:`, err)
      const errorMessage = err instanceof Error ? err.message : 'Unknown error'
      res.status(500).send(`Webhook handler error: ${errorMessage}`)
    }
  } else {
    console.log(`Unhandled webhook event type: ${event.type}`)
    res.json({ received: true })
  }
}

export const timingSafeEqual = (a: string, b: string): boolean => {
  const bufferA = Buffer.from(a)
  const bufferB = Buffer.from(b)

  if (bufferA.length !== bufferB.length) {
    return false
  }

  return crypto.timingSafeEqual(bufferA, bufferB)
}
</file>

<file path="src/test/test-utils.tsx">
import React from 'react'
import { render } from '@testing-library/react'
import type { RenderOptions } from '@testing-library/react'
import { QueryClient } from '@tanstack/react-query'
import { AllTheProviders } from './providers'

interface CustomRenderOptions extends Omit<RenderOptions, 'wrapper'> {
  queryClient?: QueryClient
}

const customRender = (ui: React.ReactElement, options: CustomRenderOptions = {}) => {
  const { queryClient, ...renderOptions } = options

  return render(ui, {
    wrapper: ({ children }) => (
      <AllTheProviders queryClient={queryClient}>{children}</AllTheProviders>
    ),
    ...renderOptions,
  })
}

// Re-export specific exports instead of using export *
export {
  act,
  cleanup,
  fireEvent,
  screen,
  waitFor,
  waitForElementToBeRemoved,
  within,
  configure,
  prettyDOM,
  queries,
  queryHelpers,
  getDefaultNormalizer,
  getRoles,
  getQueriesForElement,
  getNodeText,
  findAllByDisplayValue,
  findByDisplayValue,
  getAllByDisplayValue,
  getByDisplayValue,
  queryAllByDisplayValue,
  queryByDisplayValue,
  findAllByRole,
  findByRole,
  getAllByRole,
  getByRole,
  queryAllByRole,
  queryByRole,
  findAllByTestId,
  findByTestId,
  getAllByTestId,
  getByTestId,
  queryAllByTestId,
  queryByTestId,
  findAllByText,
  findByText,
  getAllByText,
  getByText,
  queryAllByText,
  queryByText,
  findAllByTitle,
  findByTitle,
  getAllByTitle,
  getByTitle,
  queryAllByTitle,
  queryByTitle,
  findAllByLabelText,
  findByLabelText,
  getAllByLabelText,
  getByLabelText,
  queryAllByLabelText,
  queryByLabelText,
  findAllByPlaceholderText,
  findByPlaceholderText,
  getAllByPlaceholderText,
  getByPlaceholderText,
  queryAllByPlaceholderText,
  queryByPlaceholderText,
  findAllByAltText,
  findByAltText,
  getAllByAltText,
  getByAltText,
  queryAllByAltText,
  queryByAltText,
  buildQueries,
  createEvent,
  isInaccessible,
} from '@testing-library/react'

export { customRender as render }
</file>

<file path=".env.example">
# Supabase Configuration
VITE_SUPABASE_URL=your_supabase_project_url
VITE_SUPABASE_ANON_KEY=your_supabase_anon_key

# Stripe Configuration
VITE_STRIPE_PUBLISHABLE_KEY=pk_test_your_publishable_key_here
VITE_STRIPE_SECRET_KEY=sk_test_your_secret_key_here
VITE_STRIPE_WEBHOOK_SECRET=whsec_your_webhook_secret_here
VITE_STRIPE_CONNECT_CLIENT_ID=ca_your_connect_client_id_here

# App Configuration
VITE_APP_NAME=DependableCalls
VITE_APP_URL=http://localhost:5173
VITE_APP_VERSION=1.0.0

# Monitoring & Analytics
VITE_SENTRY_DSN=https://your_sentry_dsn_here@sentry.io/project_id

# Staging Environment (for staging deployments)
VITE_STAGING_SUPABASE_URL=your_staging_supabase_url
VITE_STAGING_SUPABASE_ANON_KEY=your_staging_supabase_anon_key
VITE_STAGING_STRIPE_PUBLISHABLE_KEY=pk_test_staging_key
VITE_STAGING_SENTRY_DSN=https://staging_sentry_dsn@sentry.io/project_id

# Fraud Detection Services
VITE_TRUECALLER_API_KEY=your_truecaller_api_key_here
VITE_IPQUALITY_API_KEY=your_ipquality_api_key_here
VITE_FRAUDLABS_API_KEY=your_fraudlabs_api_key_here
VITE_SIFT_API_KEY=your_sift_api_key_here
VITE_MAXMIND_API_KEY=your_maxmind_license_key_here

# Feature Flags
VITE_ENABLE_MFA=true
VITE_ENABLE_REAL_TIME=true
</file>

<file path="package.json">
{
  "name": "dce-website",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "lint:fix": "eslint . --fix",
    "type-check": "tsc --noEmit",
    "test": "vitest",
    "test:ci": "vitest run --coverage",
    "test:ui": "vitest --ui",
    "test:e2e": "playwright test",
    "test:e2e:ui": "playwright test --ui",
    "preview": "vite preview",
    "prepare": "husky"
  },
  "dependencies": {
    "@headlessui/react": "^2.2.4",
    "@heroicons/react": "^2.2.0",
    "@hookform/resolvers": "^5.1.1",
    "@sentry/react": "^8.52.0",
    "@sentry/tracing": "^7.117.0",
    "@stripe/react-stripe-js": "^3.7.0",
    "@stripe/stripe-js": "^7.6.1",
    "@supabase/supabase-js": "^2.52.0",
    "@tanstack/react-query": "^5.83.0",
    "@types/express": "^5.0.3",
    "@types/uuid": "^10.0.0",
    "axios": "^1.10.0",
    "express": "^5.1.0",
    "react": "^19.1.0",
    "react-dom": "^19.1.0",
    "react-hook-form": "^7.60.0",
    "react-router-dom": "^7.7.0",
    "stripe": "^18.3.0",
    "tailwindcss": "^4.1.11",
    "uuid": "^11.1.0",
    "zod": "^4.0.5",
    "zustand": "^5.0.6"
  },
  "devDependencies": {
    "@eslint/js": "^9.30.1",
    "@playwright/test": "^1.54.1",
    "@tailwindcss/postcss": "^4.1.11",
    "@testing-library/jest-dom": "^6.6.3",
    "@testing-library/react": "^16.3.0",
    "@testing-library/user-event": "^14.6.1",
    "@types/react": "^19.1.8",
    "@types/react-dom": "^19.1.6",
    "@types/react-router-dom": "^5.3.3",
    "@typescript-eslint/eslint-plugin": "^8.38.0",
    "@typescript-eslint/parser": "^8.38.0",
    "@vitejs/plugin-react": "^4.6.0",
    "@vitest/coverage-v8": "^3.2.4",
    "autoprefixer": "^10.4.21",
    "eslint": "^9.30.1",
    "eslint-config-prettier": "^10.1.8",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.20",
    "globals": "^16.3.0",
    "husky": "^9.1.7",
    "jsdom": "^26.1.0",
    "lint-staged": "^16.1.2",
    "postcss": "^8.5.6",
    "prettier": "^3.6.2",
    "typescript": "~5.8.3",
    "typescript-eslint": "^8.35.1",
    "vite": "^7.0.4",
    "vitest": "^3.2.4"
  },
  "lint-staged": {
    "*.{js,jsx,ts,tsx}": [
      "eslint --fix",
      "prettier --write"
    ],
    "*.{json,md,yml,yaml}": [
      "prettier --write"
    ]
  }
}
</file>

</files>
