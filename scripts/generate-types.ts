#!/usr/bin/env tsx

/**
 * Generate TypeScript types from Supabase database schema
 * 
 * This script uses the Supabase CLI to generate types and creates
 * additional utilities for type validation and mapping.
 * 
 * Usage: npm run generate:types or tsx scripts/generate-types.ts
 */

import { execSync } from 'child_process'
import { writeFileSync, existsSync, mkdirSync } from 'fs'
import { join, dirname } from 'path'
import { fileURLToPath } from 'url'

// Configuration
const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)
const PROJECT_ROOT = join(__dirname, '..')
const TYPES_DIR = join(PROJECT_ROOT, 'src', 'types')
const GENERATED_FILE = join(TYPES_DIR, 'database.generated.ts')
const GUARDS_FILE = join(TYPES_DIR, 'blog-guards.ts')
const MAPPINGS_FILE = join(TYPES_DIR, 'database-mappings.ts')

// Ensure types directory exists
if (!existsSync(TYPES_DIR)) {
  mkdirSync(TYPES_DIR, { recursive: true })
}

/**
 * Generate types using Supabase CLI
 */
function generateSupabaseTypes(): void {
  console.log('üîÑ Generating TypeScript types from Supabase...')
  
  try {
    // Check if supabase CLI is installed
    try {
      execSync('supabase --version', { stdio: 'ignore' })
    } catch {
      console.error('‚ùå Supabase CLI not found. Please install it first:')
      console.error('   npm install -g supabase')
      process.exit(1)
    }

    // Generate types from linked Supabase project
    const output = execSync('supabase gen types typescript', {
      cwd: PROJECT_ROOT,
      encoding: 'utf-8'
    })

    // Add header and save to file
    const header = `/**
 * Generated TypeScript types from Supabase database
 * 
 * DO NOT EDIT THIS FILE DIRECTLY
 * 
 * Generated at: ${new Date().toISOString()}
 * 
 * To regenerate: npm run generate:types
 */

`

    writeFileSync(GENERATED_FILE, header + output)
    console.log('‚úÖ Generated database types:', GENERATED_FILE)
  } catch (error) {
    console.error('‚ùå Failed to generate Supabase types:', error)
    
    // Fallback: create a minimal types file based on known schema
    console.log('‚ö†Ô∏è  Creating fallback types based on known schema...')
    createFallbackTypes()
  }
}

/**
 * Create fallback types if Supabase CLI fails
 */
function createFallbackTypes(): void {
  const fallbackTypes = `/**
 * Generated TypeScript types from Supabase database (Fallback)
 * 
 * DO NOT EDIT THIS FILE DIRECTLY
 * 
 * Generated at: ${new Date().toISOString()}
 * 
 * To regenerate: npm run generate:types
 */

export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]

export interface Database {
  public: {
    Tables: {
      blog_posts: {
        Row: {
          id: string
          title: string
          subtitle: string | null
          slug: string
          content: string
          excerpt: string | null
          featured_image_url: string | null
          author_id: string
          status: 'draft' | 'published' | 'archived'
          published_at: string | null
          metadata: Json | null
          seo_metadata: Json | null
          view_count: number
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: string
          title: string
          subtitle?: string | null
          slug: string
          content: string
          excerpt?: string | null
          featured_image_url?: string | null
          author_id: string
          status?: 'draft' | 'published' | 'archived'
          published_at?: string | null
          metadata?: Json | null
          seo_metadata?: Json | null
          view_count?: number
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: string
          title?: string
          subtitle?: string | null
          slug?: string
          content?: string
          excerpt?: string | null
          featured_image_url?: string | null
          author_id?: string
          status?: 'draft' | 'published' | 'archived'
          published_at?: string | null
          metadata?: Json | null
          seo_metadata?: Json | null
          view_count?: number
          created_at?: string
          updated_at?: string
        }
      }
      blog_authors: {
        Row: {
          id: string
          user_id: string
          bio: string | null
          avatar_url: string | null
          social_links: Json | null
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: string
          user_id: string
          bio?: string | null
          avatar_url?: string | null
          social_links?: Json | null
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: string
          user_id?: string
          bio?: string | null
          avatar_url?: string | null
          social_links?: Json | null
          created_at?: string
          updated_at?: string
        }
      }
      blog_categories: {
        Row: {
          id: string
          name: string
          slug: string
          description: string | null
          parent_id: string | null
          display_order: number
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: string
          name: string
          slug: string
          description?: string | null
          parent_id?: string | null
          display_order?: number
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: string
          name?: string
          slug?: string
          description?: string | null
          parent_id?: string | null
          display_order?: number
          created_at?: string
          updated_at?: string
        }
      }
      blog_tags: {
        Row: {
          id: string
          name: string
          slug: string
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: string
          name: string
          slug: string
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: string
          name?: string
          slug?: string
          created_at?: string
          updated_at?: string
        }
      }
      blog_post_tags: {
        Row: {
          post_id: string
          tag_id: string
          created_at: string
        }
        Insert: {
          post_id: string
          tag_id: string
          created_at?: string
        }
        Update: {
          post_id?: string
          tag_id?: string
          created_at?: string
        }
      }
      blog_comments: {
        Row: {
          id: string
          post_id: string
          user_id: string
          content: string
          status: 'pending' | 'approved' | 'spam' | 'deleted'
          parent_id: string | null
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: string
          post_id: string
          user_id: string
          content: string
          status?: 'pending' | 'approved' | 'spam' | 'deleted'
          parent_id?: string | null
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: string
          post_id?: string
          user_id?: string
          content?: string
          status?: 'pending' | 'approved' | 'spam' | 'deleted'
          parent_id?: string | null
          created_at?: string
          updated_at?: string
        }
      }
      blog_post_views: {
        Row: {
          id: string
          post_id: string
          user_id: string | null
          ip_address: string | null
          user_agent: string | null
          referrer: string | null
          session_id: string | null
          created_at: string
        }
        Insert: {
          id?: string
          post_id: string
          user_id?: string | null
          ip_address?: string | null
          user_agent?: string | null
          referrer?: string | null
          session_id?: string | null
          created_at?: string
        }
        Update: {
          id?: string
          post_id?: string
          user_id?: string | null
          ip_address?: string | null
          user_agent?: string | null
          referrer?: string | null
          session_id?: string | null
          created_at?: string
        }
      }
    }
    Views: Record<string, never>
    Functions: Record<string, never>
    Enums: {
      post_status: 'draft' | 'published' | 'archived'
      comment_status: 'pending' | 'approved' | 'spam' | 'deleted'
    }
  }
}
`

  writeFileSync(GENERATED_FILE, fallbackTypes)
  console.log('‚úÖ Created fallback database types:', GENERATED_FILE)
}

/**
 * Generate type guards for blog types
 */
function generateTypeGuards(): void {
  console.log('üîÑ Generating type guards...')

  const guardsContent = `/**
 * Type guards and validation functions for blog types
 * 
 * Generated at: ${new Date().toISOString()}
 * 
 * To regenerate: npm run generate:types
 */

import type { Database } from './database.generated'
import type {
  BlogPost,
  BlogAuthor,
  BlogCategory,
  BlogTag,
  BlogComment,
  PostStatus,
  CommentStatus,
  BlogSEOMetadata,
  AuthorSocialLinks
} from './blog'

// Type aliases for database rows
type BlogPostRow = Database['public']['Tables']['blog_posts']['Row']
type BlogAuthorRow = Database['public']['Tables']['blog_authors']['Row']
type BlogCategoryRow = Database['public']['Tables']['blog_categories']['Row']
type BlogTagRow = Database['public']['Tables']['blog_tags']['Row']
type BlogCommentRow = Database['public']['Tables']['blog_comments']['Row']

/**
 * Check if a value is a valid PostStatus
 */
export function isValidPostStatus(value: unknown): value is PostStatus {
  return typeof value === 'string' && 
    ['draft', 'published', 'archived'].includes(value)
}

/**
 * Check if a value is a valid CommentStatus
 */
export function isValidCommentStatus(value: unknown): value is CommentStatus {
  return typeof value === 'string' && 
    ['pending', 'approved', 'spam', 'deleted'].includes(value)
}

/**
 * Type guard for BlogPostRow
 */
export function isBlogPostRow(value: unknown): value is BlogPostRow {
  if (!value || typeof value !== 'object') return false
  
  const obj = value as Record<string, unknown>
  
  return (
    typeof obj.id === 'string' &&
    typeof obj.title === 'string' &&
    typeof obj.slug === 'string' &&
    typeof obj.content === 'string' &&
    typeof obj.author_id === 'string' &&
    isValidPostStatus(obj.status) &&
    typeof obj.view_count === 'number' &&
    typeof obj.created_at === 'string' &&
    typeof obj.updated_at === 'string'
  )
}

/**
 * Type guard for BlogAuthorRow
 */
export function isBlogAuthorRow(value: unknown): value is BlogAuthorRow {
  if (!value || typeof value !== 'object') return false
  
  const obj = value as Record<string, unknown>
  
  return (
    typeof obj.id === 'string' &&
    typeof obj.user_id === 'string' &&
    typeof obj.created_at === 'string' &&
    typeof obj.updated_at === 'string'
  )
}

/**
 * Type guard for BlogCategoryRow
 */
export function isBlogCategoryRow(value: unknown): value is BlogCategoryRow {
  if (!value || typeof value !== 'object') return false
  
  const obj = value as Record<string, unknown>
  
  return (
    typeof obj.id === 'string' &&
    typeof obj.name === 'string' &&
    typeof obj.slug === 'string' &&
    typeof obj.display_order === 'number' &&
    typeof obj.created_at === 'string' &&
    typeof obj.updated_at === 'string'
  )
}

/**
 * Type guard for BlogTagRow
 */
export function isBlogTagRow(value: unknown): value is BlogTagRow {
  if (!value || typeof value !== 'object') return false
  
  const obj = value as Record<string, unknown>
  
  return (
    typeof obj.id === 'string' &&
    typeof obj.name === 'string' &&
    typeof obj.slug === 'string' &&
    typeof obj.created_at === 'string' &&
    typeof obj.updated_at === 'string'
  )
}

/**
 * Type guard for BlogCommentRow
 */
export function isBlogCommentRow(value: unknown): value is BlogCommentRow {
  if (!value || typeof value !== 'object') return false
  
  const obj = value as Record<string, unknown>
  
  return (
    typeof obj.id === 'string' &&
    typeof obj.post_id === 'string' &&
    typeof obj.user_id === 'string' &&
    typeof obj.content === 'string' &&
    isValidCommentStatus(obj.status) &&
    typeof obj.created_at === 'string' &&
    typeof obj.updated_at === 'string'
  )
}

/**
 * Type guard for BlogSEOMetadata
 */
export function isBlogSEOMetadata(value: unknown): value is BlogSEOMetadata {
  if (!value || typeof value !== 'object') return false
  
  const obj = value as Record<string, unknown>
  
  // All fields are optional, so we just check the shape
  return (
    (obj.title === undefined || typeof obj.title === 'string') &&
    (obj.description === undefined || typeof obj.description === 'string') &&
    (obj.keywords === undefined || Array.isArray(obj.keywords)) &&
    (obj.ogImage === undefined || typeof obj.ogImage === 'string') &&
    (obj.ogTitle === undefined || typeof obj.ogTitle === 'string') &&
    (obj.ogDescription === undefined || typeof obj.ogDescription === 'string') &&
    (obj.canonicalUrl === undefined || typeof obj.canonicalUrl === 'string') &&
    (obj.noIndex === undefined || typeof obj.noIndex === 'boolean') &&
    (obj.noFollow === undefined || typeof obj.noFollow === 'boolean')
  )
}

/**
 * Type guard for AuthorSocialLinks
 */
export function isAuthorSocialLinks(value: unknown): value is AuthorSocialLinks {
  if (!value || typeof value !== 'object') return false
  
  const obj = value as Record<string, unknown>
  
  // All fields are optional, so we just check the shape
  return (
    (obj.twitter === undefined || typeof obj.twitter === 'string') &&
    (obj.linkedin === undefined || typeof obj.linkedin === 'string') &&
    (obj.github === undefined || typeof obj.github === 'string') &&
    (obj.website === undefined || typeof obj.website === 'string') &&
    (obj.facebook === undefined || typeof obj.facebook === 'string') &&
    (obj.instagram === undefined || typeof obj.instagram === 'string')
  )
}

/**
 * Validate and sanitize blog post data
 */
export function validateBlogPost(data: unknown): BlogPostRow | null {
  if (!isBlogPostRow(data)) return null
  
  // Additional validation
  if (data.title.length < 1 || data.title.length > 200) return null
  if (data.slug.length < 1 || data.slug.length > 200) return null
  if (data.content.length < 1) return null
  
  // Validate slug format (lowercase, alphanumeric with hyphens)
  if (!data.slug.match(/^[a-z0-9-]+$/)) return null
  
  // Validate dates
  if (data.published_at && isNaN(Date.parse(data.published_at))) return null
  if (isNaN(Date.parse(data.created_at))) return null
  if (isNaN(Date.parse(data.updated_at))) return null
  
  return data
}

/**
 * Validate and sanitize comment data
 */
export function validateComment(data: unknown): BlogCommentRow | null {
  if (!isBlogCommentRow(data)) return null
  
  // Additional validation
  if (data.content.length < 1 || data.content.length > 5000) return null
  
  // Validate dates
  if (isNaN(Date.parse(data.created_at))) return null
  if (isNaN(Date.parse(data.updated_at))) return null
  
  return data
}

/**
 * Create a type-safe blog post row
 */
export function createBlogPostRow(data: Partial<BlogPostRow>): BlogPostRow {
  const now = new Date().toISOString()
  
  return {
    id: data.id || crypto.randomUUID(),
    title: data.title || '',
    subtitle: data.subtitle ?? null,
    slug: data.slug || '',
    content: data.content || '',
    excerpt: data.excerpt ?? null,
    featured_image_url: data.featured_image_url ?? null,
    author_id: data.author_id || '',
    status: data.status || 'draft',
    published_at: data.published_at ?? null,
    metadata: data.metadata ?? null,
    seo_metadata: data.seo_metadata ?? null,
    view_count: data.view_count ?? 0,
    created_at: data.created_at || now,
    updated_at: data.updated_at || now
  }
}

/**
 * Array type guards
 */
export function isBlogPostRowArray(value: unknown): value is BlogPostRow[] {
  return Array.isArray(value) && value.every(isBlogPostRow)
}

export function isBlogAuthorRowArray(value: unknown): value is BlogAuthorRow[] {
  return Array.isArray(value) && value.every(isBlogAuthorRow)
}

export function isBlogCategoryRowArray(value: unknown): value is BlogCategoryRow[] {
  return Array.isArray(value) && value.every(isBlogCategoryRow)
}

export function isBlogTagRowArray(value: unknown): value is BlogTagRow[] {
  return Array.isArray(value) && value.every(isBlogTagRow)
}

export function isBlogCommentRowArray(value: unknown): value is BlogCommentRow[] {
  return Array.isArray(value) && value.every(isBlogCommentRow)
}
`

  writeFileSync(GUARDS_FILE, guardsContent)
  console.log('‚úÖ Generated type guards:', GUARDS_FILE)
}

/**
 * Generate database type mappings
 */
function generateMappings(): void {
  console.log('üîÑ Generating type mappings...')

  const mappingsContent = `/**
 * Database type mappings and converters
 * 
 * Utilities for converting between database rows and application types
 * 
 * Generated at: ${new Date().toISOString()}
 * 
 * To regenerate: npm run generate:types
 */

import type { Database } from './database.generated'
import type {
  BlogPost,
  BlogAuthor,
  BlogCategory,
  BlogTag,
  BlogComment,
  BlogSEOMetadata,
  AuthorSocialLinks
} from './blog'
import { isBlogSEOMetadata, isAuthorSocialLinks } from './blog-guards'

// Type aliases for database rows
type BlogPostRow = Database['public']['Tables']['blog_posts']['Row']
type BlogAuthorRow = Database['public']['Tables']['blog_authors']['Row']
type BlogCategoryRow = Database['public']['Tables']['blog_categories']['Row']
type BlogTagRow = Database['public']['Tables']['blog_tags']['Row']
type BlogCommentRow = Database['public']['Tables']['blog_comments']['Row']

/**
 * Parse JSON metadata safely
 */
function parseJsonSafely<T>(json: unknown, validator?: (value: unknown) => value is T): T | null {
  if (!json) return null
  
  try {
    const parsed = typeof json === 'string' ? JSON.parse(json) : json
    if (validator) {
      return validator(parsed) ? parsed : null
    }
    return parsed as T
  } catch {
    return null
  }
}

/**
 * Convert database blog post row to application type
 */
export function mapBlogPostRow(row: BlogPostRow): BlogPost {
  const seoMetadata = parseJsonSafely<BlogSEOMetadata>(
    row.seo_metadata,
    isBlogSEOMetadata
  )

  return {
    ...row,
    seo_metadata: seoMetadata
  }
}

/**
 * Convert database blog author row to application type
 */
export function mapBlogAuthorRow(row: BlogAuthorRow): BlogAuthor {
  const socialLinks = parseJsonSafely<AuthorSocialLinks>(
    row.social_links,
    isAuthorSocialLinks
  )

  return {
    ...row,
    social_links: socialLinks
  }
}

/**
 * Convert database blog category row to application type
 */
export function mapBlogCategoryRow(row: BlogCategoryRow): BlogCategory {
  return {
    ...row
  }
}

/**
 * Convert database blog tag row to application type
 */
export function mapBlogTagRow(row: BlogTagRow): BlogTag {
  return {
    ...row
  }
}

/**
 * Convert database blog comment row to application type
 */
export function mapBlogCommentRow(row: BlogCommentRow): BlogComment {
  return {
    ...row
  }
}

/**
 * Convert application blog post to database insert type
 */
export function mapBlogPostToInsert(
  post: Partial<BlogPost>
): Database['public']['Tables']['blog_posts']['Insert'] {
  const { seo_metadata, ...rest } = post
  
  return {
    ...rest,
    seo_metadata: seo_metadata ? JSON.stringify(seo_metadata) : null
  }
}

/**
 * Convert application blog post to database update type
 */
export function mapBlogPostToUpdate(
  post: Partial<BlogPost>
): Database['public']['Tables']['blog_posts']['Update'] {
  const { seo_metadata, ...rest } = post
  
  return {
    ...rest,
    seo_metadata: seo_metadata !== undefined 
      ? JSON.stringify(seo_metadata) 
      : undefined
  }
}

/**
 * Convert application blog author to database insert type
 */
export function mapBlogAuthorToInsert(
  author: Partial<BlogAuthor>
): Database['public']['Tables']['blog_authors']['Insert'] {
  const { social_links, ...rest } = author
  
  return {
    ...rest,
    social_links: social_links ? JSON.stringify(social_links) : null
  }
}

/**
 * Convert application blog author to database update type
 */
export function mapBlogAuthorToUpdate(
  author: Partial<BlogAuthor>
): Database['public']['Tables']['blog_authors']['Update'] {
  const { social_links, ...rest } = author
  
  return {
    ...rest,
    social_links: social_links !== undefined 
      ? JSON.stringify(social_links) 
      : undefined
  }
}

/**
 * Batch converters for arrays
 */
export function mapBlogPostRows(rows: BlogPostRow[]): BlogPost[] {
  return rows.map(mapBlogPostRow)
}

export function mapBlogAuthorRows(rows: BlogAuthorRow[]): BlogAuthor[] {
  return rows.map(mapBlogAuthorRow)
}

export function mapBlogCategoryRows(rows: BlogCategoryRow[]): BlogCategory[] {
  return rows.map(mapBlogCategoryRow)
}

export function mapBlogTagRows(rows: BlogTagRow[]): BlogTag[] {
  return rows.map(mapBlogTagRow)
}

export function mapBlogCommentRows(rows: BlogCommentRow[]): BlogComment[] {
  return rows.map(mapBlogCommentRow)
}

/**
 * Helper to extract IDs from relations
 */
export function extractCategoryIds(categories?: BlogCategory[]): string[] {
  return categories?.map(c => c.id) || []
}

export function extractTagIds(tags?: BlogTag[]): string[] {
  return tags?.map(t => t.id) || []
}

/**
 * Slug generation helper
 */
export function generateSlug(text: string): string {
  return text
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '')
    .substring(0, 200)
}

/**
 * Excerpt generation helper
 */
export function generateExcerpt(content: string, maxLength = 160): string {
  // Strip HTML tags if present
  const stripped = content.replace(/<[^>]*>/g, '')
  
  // Truncate at word boundary
  if (stripped.length <= maxLength) return stripped
  
  const truncated = stripped.substring(0, maxLength)
  const lastSpace = truncated.lastIndexOf(' ')
  
  return lastSpace > 0 
    ? truncated.substring(0, lastSpace) + '...'
    : truncated + '...'
}

/**
 * Reading time calculation
 */
export function calculateReadingTime(content: string, wordsPerMinute = 200): number {
  const text = content.replace(/<[^>]*>/g, '')
  const wordCount = text.split(/\\s+/).length
  return Math.ceil(wordCount / wordsPerMinute)
}
`

  writeFileSync(MAPPINGS_FILE, mappingsContent)
  console.log('‚úÖ Generated type mappings:', MAPPINGS_FILE)
}

/**
 * Main execution
 */
async function main() {
  console.log('üöÄ Starting type generation process...\n')

  // Step 1: Generate Supabase types
  generateSupabaseTypes()

  // Step 2: Generate type guards
  generateTypeGuards()

  // Step 3: Generate mappings
  generateMappings()

  console.log('\n‚úÖ Type generation complete!')
  console.log('\nüìÅ Generated files:')
  console.log(`   - ${GENERATED_FILE}`)
  console.log(`   - ${GUARDS_FILE}`)
  console.log(`   - ${MAPPINGS_FILE}`)
  
  console.log('\nüí° Next steps:')
  console.log('   1. Review the generated types')
  console.log('   2. Update imports in your application code')
  console.log('   3. Run TypeScript compiler to check for any issues')
}

// Run the script
main().catch(error => {
  console.error('‚ùå Script failed:', error)
  process.exit(1)
})